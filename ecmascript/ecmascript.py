import datetime
import dateutil.tz
import sys
from enum import Enum, unique, auto
from collections import namedtuple, deque, Counter
from functools import reduce, partial, cached_property, lru_cache
from itertools import chain
from typing import Union, Any, Tuple, Callable, Optional, List, Mapping, Deque
from copy import copy
import traceback
import math
import re
import regex
import types
import inspect
import random
import uuid
import struct
import operator

import snoop

from .lexer2 import LexerCore, utf_16_encode, utf_16_decode
from . import e262_regexp


@unique
class Empty(Enum):
    EMPTY = auto()


EMPTY = Empty.EMPTY


@unique
class ECMAScriptEnum(Enum):
    ENUMERATE = auto()
    ASSIGNMENT = auto()
    VARBINDING = auto()
    LEXICALBINDING = auto()
    ITERATE = auto()
    ASYNC_ITERATE = auto()
    SYNC = auto()
    ASYNC = auto()
    NON_GENERATOR = auto()
    SIMPLE = auto()
    STRICT = auto()
    INVALID = auto()
    DONE = auto()
    MISSING = auto()
    LEXICAL = auto()
    GLOBAL = auto()


ENUMERATE = ECMAScriptEnum.ENUMERATE
ASSIGNMENT = ECMAScriptEnum.ASSIGNMENT
VARBINDING = ECMAScriptEnum.VARBINDING
LEXICALBINDING = ECMAScriptEnum.LEXICALBINDING
ITERATE = ECMAScriptEnum.ITERATE
ASYNC_ITERATE = ECMAScriptEnum.ASYNC_ITERATE
SYNC = ECMAScriptEnum.SYNC
ASYNC = ECMAScriptEnum.ASYNC
NON_GENERATOR = ECMAScriptEnum.NON_GENERATOR
SIMPLE = ECMAScriptEnum.SIMPLE
STRICT = ECMAScriptEnum.STRICT
INVALID = ECMAScriptEnum.INVALID
DONE = ECMAScriptEnum.DONE
MISSING = ECMAScriptEnum.MISSING
LEXICAL = ECMAScriptEnum.LEXICAL
GLOBAL = ECMAScriptEnum.GLOBAL
FAILURE = e262_regexp.FAILURE

# 6.1 ECMAScript Language Types
##############################################################################################################################
#
#  .d8888b.       d888       8888888888  .d8888b.  888b     d888        d8888  .d8888b.                   d8b          888
# d88P  Y88b     d8888       888        d88P  Y88b 8888b   d8888       d88888 d88P  Y88b                  Y8P          888
# 888              888       888        888    888 88888b.d88888      d88P888 Y88b.                                    888
# 888d888b.        888       8888888    888        888Y88888P888     d88P 888  "Y888b.    .d8888b 888d888 888 88888b.  888888
# 888P "Y88b       888       888        888        888 Y888P 888    d88P  888     "Y88b. d88P"    888P"   888 888 "88b 888
# 888    888       888       888        888    888 888  Y8P  888   d88P   888       "888 888      888     888 888  888 888
# Y88b  d88P d8b   888       888        Y88b  d88P 888   "   888  d8888888888 Y88b  d88P Y88b.    888     888 888 d88P Y88b.
#  "Y8888P"  Y8P 8888888     8888888888  "Y8888P"  888       888 d88P     888  "Y8888P"   "Y8888P 888     888 88888P"   "Y888
#                                                                                                             888
#                                                                                                             888
#                                                                                                             888
# 888                                                                         88888888888
# 888                                                                             888
# 888                                                                             888
# 888       8888b.  88888b.   .d88b.  888  888  8888b.   .d88b.   .d88b.          888     888  888 88888b.   .d88b.  .d8888b
# 888          "88b 888 "88b d88P"88b 888  888     "88b d88P"88b d8P  Y8b         888     888  888 888 "88b d8P  Y8b 88K
# 888      .d888888 888  888 888  888 888  888 .d888888 888  888 88888888         888     888  888 888  888 88888888 "Y8888b.
# 888      888  888 888  888 Y88b 888 Y88b 888 888  888 Y88b 888 Y8b.             888     Y88b 888 888 d88P Y8b.          X88
# 88888888 "Y888888 888  888  "Y88888  "Y88888 "Y888888  "Y88888  "Y8888          888      "Y88888 88888P"   "Y8888   88888P'
#                                 888                        888                               888 888
#                            Y8b d88P                   Y8b d88P                          Y8b d88P 888
#                             "Y88P"                     "Y88P"                            "Y88P"  888
#
##############################################################################################################################


@unique
class JSType(Enum):
    UNDEFINED = auto()
    NULL = auto()
    BOOLEAN = auto()
    STRING = auto()
    SYMBOL = auto()
    NUMBER = auto()
    OBJECT = auto()


#    ILLEGAL = auto()  # Not actually a JS type.

T_UNDEFINED = JSType.UNDEFINED
T_NULL = JSType.NULL
T_BOOLEAN = JSType.BOOLEAN
T_STRING = JSType.STRING
T_SYMBOL = JSType.SYMBOL
T_NUMBER = JSType.NUMBER
T_OBJECT = JSType.OBJECT

# 6.1.1 The Undefined Type
# The Undefined type has exactly one value, called "undefined". Any variable that has not been assigned a value has the
# value "undefined".
# Implementation: we shall use the python value "None" to represent "undefined".

# 6.1.2 The Null Type
@unique
class JSNull(Enum):
    # The Null type has exactly one value, called "null".
    NULL = auto()


# 6.1.3 The Boolean Type
# The Boolean type represents a logical entity having two values, called "true" and "false".
# Implementation: we shall use the python bool type to be a ECMAScript Boolean.

# 6.1.4 The String Type
# The String type is the set of all ordered sequences of zero or more 16-bit unsigned integer values (“elements”) up
# to a maximum length of 2^53-1 elements. The String type is generally used to represent textual data in a running
# ECMAScript program, in which case each element in the String is treated as a UTF-16 code unit value. Each element is
# regarded as occupying a position within the sequence.
# Implementation: we shall use the python str type to be an ECMAScript String.

# 6.1.5 The Symbol Type
# The Symbol type is the set of all non-String values that may be used as the key of an Object property (6.1.7).
#
# Each possible Symbol value is unique and immutable.
#
# Each Symbol value immutably holds an associated value called [[Description]] that is either undefined or a String
# value.
#
# Implementation: A namedtuple seems appropriate, but fails uniqueness. It needs to be a real class.
class JSSymbol:
    __slots__ = ["description"]

    def __init__(self, desc: str):
        self.description = desc


# 6.1.5.1 Well-Known Symbols
#
# Well-known symbols are built-in Symbol values that are explicitly referenced by algorithms of this specification. They
# are typically used as the keys of properties whose values serve as extension points of a specification algorithm.
# Unless otherwise specified, well-known symbols values are shared by all realms (8.2).
#
# Within this specification a well-known symbol is referred to by using a notation of the form @@name, where �name� is
# one of the values listed in Table 1.
#
# Implementation Note: we don't do leading '@' for Python identifiers, so these are referred to in code as wks_name.
# ("wks" as an acronym for "well-known symbol"). We also snake-case them.
#
# Table 1: Well-known Symbols
# +----------------------+-----------------------------+---------------------------------------------------------------
# | Specification Name   | [[Description]]             | Value and Purpose
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@asyncIterator      | "Symbol.asyncIterator"      | A method that returns the default AsyncIterator for an object.
# |                      |                             | Called by the semantics of the for-await-of statement.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@hasInstance        | "Symbol.hasInstance"        | A method that determines if a constructor object recognizes an
# |                      |                             | object as one of the constructor's instances. Called by the
# |                      |                             | semantics of the instanceof operator.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@isConcatSpreadable | "Symbol.isConcatSpreadable" | A Boolean valued property that if true indicates that an
# |                      |                             | object should be flattened to its array elements by
# |                      |                             | Array.prototype.concat.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@iterator           | "Symbol.iterator"           | A method that returns the default Iterator for an object.
# |                      |                             | Called by the semantics of the for-of statement.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@match              | "Symbol.match"              | A regular expression method that matches the regular
# |                      |                             | expression against a string. Called by the
# |                      |                             | String.prototype.match method.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@replace            | "Symbol.replace"            | A regular expression method that replaces matched substrings
# |                      |                             | of a string. Called by the String.prototype.replace method.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@search             | "Symbol.search"             | A regular expression method that returns the index within a
# |                      |                             | string that matches the regular expression. Called by the
# |                      |                             | String.prototype.search method.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@species            | "Symbol.species"            | A function valued property that is the constructor function
# |                      |                             | that is used to create derived objects.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@split              | "Symbol.split"              | A regular expression method that splits a string at the
# |                      |                             | indices that match the regular expression. Called by the
# |                      |                             | String.prototype.split method.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@toPrimitive        | "Symbol.toPrimitive"        | A method that converts an object to a corresponding primitive
# |                      |                             | value. Called by the ToPrimitive abstract operation.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@toStringTag        | "Symbol.toStringTag"        | A String valued property that is used in the creation of the
# |                      |                             | default string description of an object. Accessed by the
# |                      |                             | built-in method  Object.prototype.toString.
# +----------------------+-----------------------------+---------------------------------------------------------------
# | @@unscopables        | "Symbol.unscopables"        | An object valued property whose own and inherited property
# |                      |                             | names are property names that are excluded from the with
# |                      |                             | environment bindings of the associated object.
# +----------------------+-----------------------------+---------------------------------------------------------------
wks_async_iterator = JSSymbol("Symbol.asyncIterator")
wks_has_instance = JSSymbol("Symbol.hasInstance")
wks_is_concat_spreadable = JSSymbol("Symbol.isConcatSpreadable")
wks_iterator = JSSymbol("Symbol.iterator")
wks_match = JSSymbol("Symbol.match")
wks_replace = JSSymbol("Symbol.replace")
wks_search = JSSymbol("Symbol.search")
wks_species = JSSymbol("Symbol.species")
wks_split = JSSymbol("Symbol.split")
wks_to_primitive = JSSymbol("Symbol.toPrimitive")
wks_to_string_tag = JSSymbol("Symbol.toStringTag")
wks_unscopables = JSSymbol("Symbol.unscopables")

# 6.1.6 The Number Type
# The Number type has exactly 18437736874454810627 (that is, 2^64-2^53+3) values, representing the double-precision
# 64-bit format IEEE 754-2008 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except
# that the 9007199254740990 (that is, 2^53-2) distinct “Not-a-Number” values of the IEEE Standard are represented in
# ECMAScript as a single special NaN value. (Note that the NaN value is produced by the program expression NaN.) In
# some implementations, external code might be able to detect a difference between various Not-a-Number values, but
# such behaviour is implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other.
#
# NOTE
# The bit pattern that might be observed in an ArrayBuffer (see 24.1) or a SharedArrayBuffer (see 24.2) after a Number
# value has been stored into it is not necessarily the same as the internal representation of that Number value used
# by the ECMAScript implementation.
#
# There are two other special values, called positive Infinity and negative Infinity. For brevity, these values are
# also referred to for expository purposes by the symbols +∞ and -∞, respectively. (Note that these two infinite
# Number values are produced by the program expressions +Infinity (or simply Infinity) and -Infinity.)
#
# The other 18437736874454810624 (that is, 2^64-2^53) values are called the finite numbers. Half of these are positive
# numbers and half are negative numbers; for every finite positive Number value there is a corresponding negative
# value having the same magnitude.
#
# Note that there is both a positive zero and a negative zero. For brevity, these values are also referred to for
# expository purposes by the symbols +0 and -0, respectively. (Note that these two different zero Number values are
# produced by the program expressions +0 (or simply 0) and -0.)
#
# The 18437736874454810622 (that is, 2^64-2^53-2) finite nonzero values are of two kinds:
#
# 18428729675200069632 (that is, 2^64-2^54) of them are normalized, having the form
#
# s × m × 2^e
#
# where s is +1 or -1, m is a positive integer less than 2^53 but not less than 2^52, and e is an integer ranging from
# -1074 to 971, inclusive.
#
# The remaining 9007199254740990 (that is, 2^53-2) values are denormalized, having the form
#
# s × m × 2^e
#
# where s is +1 or -1, m is a positive integer less than 2^52, and e is -1074.
#
# Note that all the positive and negative integers whose magnitude is no greater than 253 are representable in the
# Number type (indeed, the integer 0 has two representations, +0 and -0).
#
# A finite number has an odd significand if it is nonzero and the integer m used to express it (in one of the two
# forms shown above) is odd. Otherwise, it has an even significand.
#
# In this specification, the phrase “the Number value for x” where x represents an exact real mathematical quantity
# (which might even be an irrational number such as π) means a Number value chosen in the following manner. Consider
# the set of all finite values of the Number type, with -0 removed and with two additional values added to it that are
# not representable in the Number type, namely 2^1024 (which is +1 × 2^53 × 2^971) and -2^1024 (which is
# -1 × 2^53 × 2^971). Choose the member of this set that is closest in value to x. If two values of the set are equally
# close, then the one with an even significand is chosen; for this purpose, the two extra values 2^1024 and -2^1024 are
# considered to have even significands. Finally, if 2^1024 was chosen, replace it with +∞; if -2^1024 was chosen,
# replace it with -∞; if +0 was chosen, replace it with -0 if and only if x is less than zero; any other chosen value
# is used unchanged. The result is the Number value for x. (This procedure corresponds exactly to the behaviour of the
# IEEE 754-2008 “round to nearest, ties to even” mode.)
#
# Some ECMAScript operators deal only with integers in specific ranges such as -2^31 through 2^31-1, inclusive, or in
# the range 0 through 2^16-1, inclusive. These operators accept any value of the Number type but first convert each
# such value to an integer value in the expected range. See the descriptions of the numeric conversion operations in
# 7.1.
#

# Implementation: A Python float works fine. We also will take integers if they happen by.

# 6.1.7 The Object Type
#
# An Object is logically a collection of properties. Each property is either a data property, or an accessor property:
#
#   * A data property associates a key value with an ECMAScript language value and a set of Boolean attributes.
#   * An accessor property associates a key value with one or two accessor functions, and a set of Boolean attributes.
#     The accessor functions are used to store or retrieve an ECMAScript language value that is associated with the
#     property.
#
# Properties are identified using key values. A property key value is either an ECMAScript String value or a Symbol
# value. All String and Symbol values, including the empty string, are valid as property keys. A property name is a
# property key that is a String value.
#
# An integer index is a String-valued property key that is a canonical numeric String (see 7.1.16) and whose numeric
# value is either +0 or a positive integer ≤ 2^53-1. An array index is an integer index whose numeric value i is in
# the range +0 ≤ i < 2^32-1.
#
# Property keys are used to access properties and their values. There are two kinds of access for properties: get and
# set, corresponding to value retrieval and assignment, respectively. The properties accessible via get and set access
# includes both own properties that are a direct part of an object and inherited properties which are provided by
# another associated object via a property inheritance relationship. Inherited properties may be either own or
# inherited properties of the associated object. Each own property of an object must each have a key value that is
# distinct from the key values of the other own properties of that object.
#
# All objects are logically collections of properties, but there are multiple forms of objects that differ in their
# semantics for accessing and manipulating their properties. Ordinary objects are the most common form of objects and
# have the default object semantics. An exotic object is any form of object whose property semantics differ in any way
# from the default semantics.


class JSObject:
    class Property:
        def __init__(self, **kwargs):
            for key, val in kwargs.items():
                setattr(self, key, val)

        def __repr__(self):
            return (
                "Property("
                + ", ".join(
                    f"{name}={getattr(self,name)!r}"
                    for name in ["Get", "Set", "value", "writable", "enumerable", "configurable"]
                    if hasattr(self, name)
                )
                + ")"
            )

    def __init__(self):
        self.Prototype = JSNull.NULL
        self.Extensible = False
        self.properties = {}


JSValue = Union[None, bool, str, float, int, JSSymbol, JSObject]

# Type checkers
def isUndefined(arg: JSValue) -> bool:
    return arg is None


def isNumber(arg: JSValue) -> bool:
    return isinstance(arg, (int, float)) and not isinstance(arg, bool)


def isNull(arg: JSValue) -> bool:
    return isinstance(arg, JSNull)


def isBoolean(arg: JSValue) -> bool:
    return isinstance(arg, bool)


def isString(arg: JSValue) -> bool:
    return isinstance(arg, str)


def isSymbol(arg: JSValue) -> bool:
    return isinstance(arg, JSSymbol)


def isObject(arg: JSValue) -> bool:
    return isinstance(arg, JSObject)


def isEcmaValue(arg: Any) -> bool:
    """Returns True if 'arg' is a ECMAScript Value."""
    return isinstance(arg, (type(None), str, int, float, bool, JSSymbol, JSNull, JSObject))


_typeof_checks: Tuple[Callable[[JSValue], Optional[JSType]], ...]
_typeof_checks = (
    lambda v: T_UNDEFINED if isUndefined(v) else None,
    lambda v: T_NULL if isNull(v) else None,
    lambda v: T_STRING if isString(v) else None,
    lambda v: T_NUMBER if isNumber(v) else None,
    lambda v: T_BOOLEAN if isBoolean(v) else None,
    lambda v: T_SYMBOL if isSymbol(v) else None,
    lambda v: T_OBJECT if isObject(v) else None,
)


def TypeOf(arg: JSValue) -> JSType:
    rval: Optional[JSType]
    rval = reduce(lambda r, f: r or f(arg), _typeof_checks, None)
    assert rval is not None, f"TypeOf called with non-ecmascript-value {arg}"
    return rval


##############################################################################################################################################################
#
#  .d8888b.       .d8888b.      8888888888  .d8888b.  888b     d888        d8888  .d8888b.                   d8b          888
# d88P  Y88b     d88P  Y88b     888        d88P  Y88b 8888b   d8888       d88888 d88P  Y88b                  Y8P          888
# 888                   888     888        888    888 88888b.d88888      d88P888 Y88b.                                    888
# 888d888b.           .d88P     8888888    888        888Y88888P888     d88P 888  "Y888b.    .d8888b 888d888 888 88888b.  888888
# 888P "Y88b      .od888P"      888        888        888 Y888P 888    d88P  888     "Y88b. d88P"    888P"   888 888 "88b 888
# 888    888     d88P"          888        888    888 888  Y8P  888   d88P   888       "888 888      888     888 888  888 888
# Y88b  d88P d8b 888"           888        Y88b  d88P 888   "   888  d8888888888 Y88b  d88P Y88b.    888     888 888 d88P Y88b.
#  "Y8888P"  Y8P 888888888      8888888888  "Y8888P"  888       888 d88P     888  "Y8888P"   "Y8888P 888     888 88888P"   "Y888
#                                                                                                                888
#                                                                                                                888
#                                                                                                                888
#  .d8888b.                             d8b  .d888 d8b                   888    d8b                       88888888888
# d88P  Y88b                            Y8P d88P"  Y8P                   888    Y8P                           888
# Y88b.                                     888                          888                                  888
#  "Y888b.   88888b.   .d88b.   .d8888b 888 888888 888  .d8888b  8888b.  888888 888  .d88b.  88888b.          888     888  888 88888b.   .d88b.  .d8888b
#     "Y88b. 888 "88b d8P  Y8b d88P"    888 888    888 d88P"        "88b 888    888 d88""88b 888 "88b         888     888  888 888 "88b d8P  Y8b 88K
#       "888 888  888 88888888 888      888 888    888 888      .d888888 888    888 888  888 888  888         888     888  888 888  888 88888888 "Y8888b.
# Y88b  d88P 888 d88P Y8b.     Y88b.    888 888    888 Y88b.    888  888 Y88b.  888 Y88..88P 888  888         888     Y88b 888 888 d88P Y8b.          X88
#  "Y8888P"  88888P"   "Y8888   "Y8888P 888 888    888  "Y8888P "Y888888  "Y888 888  "Y88P"  888  888         888      "Y88888 88888P"   "Y8888   88888P'
#            888                                                                                                           888 888
#            888                                                                                                      Y8b d88P 888
#            888                                                                                                       "Y88P"  888
#
##############################################################################################################################################################
# 6.2 ECMAScript Specification Types

# 6.2.1 The List and Record Specification Types
#
# The List type is used to explain the evaluation of argument lists (see 12.3.6) in new expressions, in function calls,
# and in other algorithms where a simple ordered list of values is needed. Values of the List type are simply ordered
# sequences of list elements containing the individual values. These sequences may be of any length. The elements of a
# list may be randomly accessed using 0-origin indices. For notational convenience an array-like syntax can be used to
# access List elements. For example, arguments[2] is shorthand for saying the 3rd element of the List arguments.
#
# For notational convenience within this specification, a literal syntax can be used to express a new List value. For
# example, « 1, 2 » defines a List value that has two elements each of which is initialized to a specific value. A new
# empty List can be expressed as « ».
#
# The Record type is used to describe data aggregations within the algorithms of this specification. A Record type
# value consists of one or more named fields. The value of each field is either an ECMAScript value or an abstract
# value represented by a name associated with the Record type. Field names are always enclosed in double brackets, for
# example [[Value]].
#
# For notational convenience within this specification, an object literal-like syntax can be used to express a Record
# value. For example, { [[Field1]]: 42, [[Field2]]: false, [[Field3]]: empty } defines a Record value that has three
# fields, each of which is initialized to a specific value. Field name order is not significant. Any fields that are
# not explicitly listed are considered to be absent.
#
# In specification text and algorithms, dot notation may be used to refer to a specific field of a Record value. For
# example, if R is the record shown in the previous paragraph then R.[[Field2]] is shorthand for “the field of R named
# [[Field2]]”.
#
# Schema for commonly used Record field combinations may be named, and that name may be used as a prefix to a literal
# Record value to identify the specific kind of aggregations that is being described. For example: PropertyDescriptor
# { [[Value]]: 42, [[Writable]]: false, [[Configurable]]: true }.
class Record:
    def __init__(self, **kwargs):
        for key, val in kwargs.items():
            setattr(self, key, val)


# Section 6.2.3
#
# The Completion Record Specification Type
#
# The Completion type is a Record used to explain the runtime propagation of values and control flow such as the
# behaviour of statements (break, continue, return and throw) that perform nonlocal transfers of control.
# Values of the Completion type are Record values whose fields are defined as by Table 8. Such values are referred to as
# Completion Records.
#
# Table 8: Completion Record Fields
#
# | Field Name | Value                                            | Meaning  |
# | [[Type]]   | One of normal, break, continue, return, or throw | The type of completion that occurred.
# | [[Value]]  | any ECMAScript language value or empty           | The value that was produced.
# | [[Target]] | any ECMAScript string or empty                   | The target label for directed control transfers.

# The term "abrupt completion" refers to any completion with a [[Type]] value other than normal.


@unique
class CompletionType(Enum):
    NORMAL = auto()
    BREAK = auto()
    CONTINUE = auto()
    RETURN = auto()
    THROW = auto()


Completion = namedtuple("Completion", ["ctype", "value", "target"])


# 6.2.3.1 Await
def Await(value: JSValue) -> None:
    raise NotImplementedError("Await not yet ready")


# 6.2.3.4 UpdateEmpty
def UpdateEmpty(cr: Union[Empty, JSValue], value: Union[Empty, JSValue]) -> Union[Empty, JSValue]:
    # The abstract operation UpdateEmpty with arguments completionRecord and value performs the following steps:

    # 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
    # assert cr.value != EMPTY if cr.ctype in [CompletionType.RETURN, CompletionType.THROW] else True

    # 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
    # if cr.value != EMPTY:
    #    return Completion(cr.ctype, cr.value, cr.target)

    # 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value,
    #                        [[Target]]: completionRecord.[[Target]] }.
    # return Completion(cr.ctype, value, cr.target)
    if cr != EMPTY:
        return cr
    return value


# Section 6.2.4
#
# The Reference Specification Type
#
# NOTE  | The Reference type is used to explain the behaviour of such operators as delete, typeof, the assignment
#       | operators, the super keyword and other language features. For example, the left-hand operand of an assignment
#       | is expected to produce a reference.
#
# A Reference is a resolved name or property binding. A Reference consists of three components, the base value
# component, the referenced name component, and the Boolean-valued strict reference flag. The base value component is
# either undefined, an Object, a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value
# component of undefined indicates that the Reference could not be resolved to a binding. The referenced name component
# is a String or Symbol value.
#
# A Super Reference is a Reference that is used to represent a name binding that was expressed using the super keyword.
# A Super Reference has an additional thisValue component, and its base value component will never be an Environment
# Record.

ReferenceBase = Union[None, JSObject, bool, str, JSSymbol, float, int]  # (Need to add EnvironmentRecords)
SuperBase = Union[None, JSObject, bool, str, JSSymbol, float, int]


class Reference:
    def __init__(self, base: ReferenceBase, name: str, strict: bool) -> None:
        self.base = base
        self.name = name
        self.strict = strict

    def __repr__(self) -> str:
        return f'Reference({"S " if self.strict else ""}{self.name!r}, base={self.base!r})'


class SuperReference(Reference):
    def __init__(self, base: ReferenceBase, name: str, strict: bool, this_value: JSValue):
        super().__init__(base, name, strict)
        self.this_value = this_value

    def __repr__(self):
        return f'SuperReference({"S " if self.strict else ""}{self.name!r}, base={self.base!r}, thisValue={self.this_value!r})'


# 6.2.4.1 GetBase ( V )
def GetBase(value: Reference) -> ReferenceBase:
    # 1. Assert: Type(V) is Reference.
    assert isinstance(value, Reference)
    # 2. Return the base value component of V.
    return value.base


# 6.2.4.2 GetReferencedName ( V )
def GetReferencedName(value: Reference) -> str:
    # 1. Assert: Type(V) is Reference.
    assert isinstance(value, Reference)
    # 2. Return the referenced name component of V.
    return value.name


# 6.2.4.3 IsStrictReference ( V )
def IsStrictReference(value: Reference) -> bool:
    # 1. Assert: Type(V) is Reference.
    assert isinstance(value, Reference)
    # 2. Return the strict reference flag of V.
    return value.strict


# 6.2.4.4 HasPrimitiveBase ( V )
def HasPrimitiveBase(value: Reference) -> bool:
    # 1. Assert: Type(V) is Reference.
    assert isinstance(value, Reference)
    # 2. If Type(V's base value component) is Boolean, String, Symbol, or Number, return true; otherwise return false.
    return isBoolean(value.base) or isString(value.base) or isSymbol(value.base) or isNumber(value.base)


# 6.2.4.5 IsPropertyReference ( V )
def IsPropertyReference(value: Reference) -> bool:
    # 1. Assert: Type(V) is Reference.
    assert isinstance(value, Reference)
    # 2. If either the base value component of V is an Object or HasPrimitiveBase(V) is true, return true; otherwise
    #    return false.
    return isObject(value.base) or HasPrimitiveBase(value)


# 6.2.4.6 IsUnresolvableReference ( V )
def IsUnresolvableReference(value: Reference) -> bool:
    # 1. Assert: Type(V) is Reference.
    assert isinstance(value, Reference)
    # 2. If the base value component of V is undefined, return true; otherwise return false.
    return value.base is None


# 6.2.4.7 IsSuperReference ( V )
def IsSuperReference(value: Reference) -> bool:
    # 1. Assert: Type(V) is Reference.
    assert isinstance(value, Reference)
    # 2. If V has a thisValue component, return true; otherwise return false.
    return hasattr(value, "this_value")


# 6.2.4.8 GetValue ( V )
def GetValue(value):
    # 1. ReturnIfAbrupt(V).
    # 2. If Type(V) is not Reference, return V.
    if not isinstance(value, Reference):
        return value
    # 3. Let base be GetBase(V).
    base = GetBase(value)
    # 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.
    if IsUnresolvableReference(value):
        raise ESReferenceError(f"'{GetReferencedName(value)}': unknown")
    # 5. If IsPropertyReference(V) is true, then
    if IsPropertyReference(value):
        # a. If HasPrimitiveBase(V) is true, then
        if HasPrimitiveBase(value):
            # i. Assert: In this case, base will never be undefined or null.
            assert base is not None and not isNull(base)
            # ii. Set base to ! ToObject(base).
            base = ToObject(base)
        # b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).
        return base.Get(GetReferencedName(value), GetThisValue(value))
    # 6. Else base must be an Environment Record,
    # a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).
    return base.GetBindingValue(GetReferencedName(value), IsStrictReference(value))
    # NOTE
    # The object that may be created in step 5.a.ii is not accessible outside of the above abstract operation and the
    # ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the
    # object.


# 6.2.4.9 PutValue ( V, W )
def PutValue(ref, value):
    # 1. ReturnIfAbrupt(V).
    # 2. ReturnIfAbrupt(W).
    # 3. If Type(V) is not Reference, throw a ReferenceError exception.
    if not isinstance(ref, Reference):
        raise ESReferenceError(f"Bad Reference: {ref!r}")
    # 4. Let base be GetBase(V).
    base = GetBase(ref)
    # 5. If IsUnresolvableReference(V) is true, then
    if IsUnresolvableReference(ref):
        # a. If IsStrictReference(V) is true, then
        if IsStrictReference(ref):
            # i. Throw a ReferenceError exception.
            raise ESReferenceError(f"Cannot create {GetReferencedName(ref)} in strict context")
        # b. Let globalObj be GetGlobalObject().
        global_obj = GetGlobalObject()
        # c. Return ? Set(globalObj, GetReferencedName(V), W, false).
        return Set(global_obj, GetReferencedName(ref), value, False)
    # 6. Else if IsPropertyReference(V) is true, then
    elif IsPropertyReference(ref):
        # a. If HasPrimitiveBase(V) is true, then
        if HasPrimitiveBase(ref):
            # i. Assert: In this case, base will never be undefined or null.
            assert base is not None and not isNull(base)
            # ii. Set base to ! ToObject(base).
            base = ToObject(base)
        # b. Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).
        succeeded = base.Set(GetReferencedName(ref), value, GetThisValue(ref))
        # c. If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.
        if not succeeded and IsStrictReference(ref):
            raise ESTypeError(f"Unable to write to {GetReferencedName(ref)}")
        # d. Return.
        return None
    # 7. Else base must be an Environment Record,
    # a. Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).
    return base.SetMutableBinding(GetReferencedName(ref), value, IsStrictReference(ref))
    # NOTE
    # The object that may be created in step 6.a.ii is not accessible outside of the above algorithm and the ordinary
    # object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.


# 6.2.4.10 GetThisValue ( V )
def GetThisValue(ref):
    # 1. Assert: IsPropertyReference(V) is true.
    assert IsPropertyReference(ref)
    # 2. If IsSuperReference(V) is true, then
    if IsSuperReference(ref):
        # a. Return the value of the thisValue component of the reference V.
        return ref.this_value
    # 3. Return GetBase(V).
    return GetBase(ref)


# 6.2.4.11 InitializeReferencedBinding ( V, W )
def InitializeReferencedBinding(ref, value):
    # 1. ReturnIfAbrupt(V).
    # 2. ReturnIfAbrupt(W).
    # 3. Assert: Type(V) is Reference.
    assert isinstance(ref, Reference)
    # 4. Assert: IsUnresolvableReference(V) is false.
    assert not IsUnresolvableReference(ref)
    # 5. Let base be GetBase(V).
    base = GetBase(ref)
    # 6. Assert: base is an Environment Record.
    # 7. Return base.InitializeBinding(GetReferencedName(V), W).
    return base.InitializeBinding(GetReferencedName(ref), value)


# 6.2.5 The Property Descriptor Specification Type
#
# The Property Descriptor type is used to explain the manipulation and reification of Object property attributes. Values
# of the Property Descriptor type are Records. Each field's name is an attribute name and its value is a corresponding
# attribute value as specified in 6.1.7.1. In addition, any field may be present or absent. The schema name used within
# this specification to tag literal descriptions of Property Descriptor records is "PropertyDescriptor".
#
# Property Descriptor values may be further classified as data Property Descriptors and accessor Property Descriptors
# based upon the existence or use of certain fields. A data Property Descriptor is one that includes any fields named
# either [[Value]] or [[Writable]]. An accessor Property Descriptor is one that includes any fields named either [[Get]]
# or [[Set]]. Any Property Descriptor may have fields named [[Enumerable]] and [[Configurable]]. A Property Descriptor
# value may not be both a data Property Descriptor and an accessor Property Descriptor; however, it may be neither. A
# generic Property Descriptor is a Property Descriptor value that is neither a data Property Descriptor nor an accessor
# Property Descriptor. A fully populated Property Descriptor is one that is either an accessor Property Descriptor or a
# data Property Descriptor and that has all of the fields that correspond to the property attributes defined in either
# Table 2 or Table 3.


class PropertyDescriptor(Record):
    def __repr__(self):
        return (
            "Descriptor("
            + ", ".join(
                f"{name}={getattr(self,name)!r}"
                for name in ["Get", "Set", "value", "writable", "enumerable", "configurable"]
                if hasattr(self, name)
            )
            + ")"
        )

    def is_accessor_descriptor(self):
        "Returns True if this descriptor is an accessor style descriptor."
        # 2. If both Desc.[[Get]] and Desc.[[Set]] are absent, return false.
        # 3. Return true.
        return hasattr(self, "Get") or hasattr(self, "Set")

    def is_data_descriptor(self):
        "Returns True if this descriptor is a data style descriptor."
        # 2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.
        # 3. Return true.
        return hasattr(self, "value") or hasattr(self, "writable")

    def is_generic_descriptor(self):
        "Returns True if this descriptor cannot be described as either a accessor or data descriptor."
        # 2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, return true.
        # 3. Return false.
        return not (self.is_accessor_descriptor() or self.is_data_descriptor())

    def complete_property_descriptor(self):
        "Fills in missing fields for a property descriptor."
        # 2. Let like be Record { [[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined,
        #    [[Enumerable]]: false, [[Configurable]]: false }.
        # 3. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then
        if self.is_data_descriptor() or self.is_generic_descriptor():
            # a. If Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].
            if not hasattr(self, "value"):
                self.value = None
            # b. If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].
            if not hasattr(self, "writable"):
                self.writable = False
        # 4. Else,
        else:
            # a. If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].
            if not hasattr(self, "Get"):
                self.Get = None
            # b. If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].
            if not hasattr(self, "Set"):
                self.Set = None
        # 5. If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].
        if not hasattr(self, "enumerable"):
            self.enumerable = False
        # 6. If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].
        if not hasattr(self, "configurable"):
            self.configurable = False
        # 7. Return Desc.
        return self


# 6.2.5.1 IsAccessorDescriptor ( Desc )
def IsAccessorDescriptor(desc):
    # When the abstract operation IsAccessorDescriptor is called with Property Descriptor Desc, the following steps are
    # taken:
    #
    # 1. If Desc is undefined, return false.
    if desc is None:
        return False
    return desc.is_accessor_descriptor()


# 6.2.5.2 IsDataDescriptor ( Desc )
def IsDataDescriptor(desc):
    # When the abstract operation IsDataDescriptor is called with Property Descriptor Desc, the following steps are
    # taken:
    #
    # 1. If Desc is undefined, return false.
    if desc is None:
        return False
    return desc.is_data_descriptor()


# 6.2.5.3 IsGenericDescriptor ( Desc )
def IsGenericDescriptor(desc):
    # When the abstract operation IsGenericDescriptor is called with Property Descriptor Desc, the following steps are
    # taken:
    #
    # 1. If Desc is undefined, return false.
    if desc is None:
        return False
    return desc.is_generic_descriptor()


# 6.2.5.4 FromPropertyDescriptor ( Desc )
def FromPropertyDescriptor(desc):
    # When the abstract operation FromPropertyDescriptor is called with Property Descriptor Desc, the following steps
    # are taken:
    #
    # 1. If Desc is undefined, return undefined.
    if desc is None:
        return None
    # 2. Let obj be ObjectCreate(%ObjectPrototype%).
    obj = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
    # 3. Assert: obj is an extensible ordinary object with no own properties.
    # 4. If Desc has a [[Value]] field, then
    cr = True
    if hasattr(desc, "value"):
        # a. Perform CreateDataProperty(obj, "value", Desc.[[Value]]).
        cr = CreateDataProperty(obj, "value", desc.value) and cr
    # 5. If Desc has a [[Writable]] field, then
    if hasattr(desc, "writable"):
        # a. Perform CreateDataProperty(obj, "writable", Desc.[[Writable]]).
        cr = CreateDataProperty(obj, "writable", desc.writable) and cr
    # 6. If Desc has a [[Get]] field, then
    if hasattr(desc, "Get"):
        # a. Perform CreateDataProperty(obj, "get", Desc.[[Get]]).
        cr = CreateDataProperty(obj, "get", desc.Get) and cr
    # 7. If Desc has a [[Set]] field, then
    if hasattr(desc, "Set"):
        # a. Perform CreateDataProperty(obj, "set", Desc.[[Set]]).
        cr = CreateDataProperty(obj, "set", desc.Set) and cr
    # 8. If Desc has an [[Enumerable]] field, then
    if hasattr(desc, "enumerable"):
        # a. Perform CreateDataProperty(obj, "enumerable", Desc.[[Enumerable]]).
        cr = CreateDataProperty(obj, "enumerable", desc.enumerable) and cr
    # 9. If Desc has a [[Configurable]] field, then
    if hasattr(desc, "configurable"):
        # a. Perform CreateDataProperty(obj, "configurable", Desc.[[Configurable]]).
        cr = CreateDataProperty(obj, "configurable", desc.configurable) and cr
    # 10. Assert: All of the above CreateDataProperty operations return true.
    assert cr
    # 11. Return obj.
    return obj


# 6.2.5.5 ToPropertyDescriptor ( Obj )
def ToPropertyDescriptor(obj):
    # When the abstract operation ToPropertyDescriptor is called with object Obj, the following steps are taken:
    #
    # 1. If Type(Obj) is not Object, throw a TypeError exception.
    if not isObject(obj):
        raise ESTypeError("ToPropertyDescriptor called with non-object")
    # 2. Let desc be a new Property Descriptor that initially has no fields.
    desc = PropertyDescriptor()
    # 3. Let hasEnumerable be ? HasProperty(Obj, "enumerable").
    has_enumerable = HasProperty(obj, "enumerable")
    # 4. If hasEnumerable is true, then
    if has_enumerable:
        # a. Let enum be ToBoolean(? Get(Obj, "enumerable")).
        enumble = Get(obj, "enumerable")
        # b. Set desc.[[Enumerable]] to enum.
        desc.enumerable = ToBoolean(enumble)
    # 5. Let hasConfigurable be ? HasProperty(Obj, "configurable").
    has_configurable = HasProperty(obj, "configurable")
    # 6. If hasConfigurable is true, then
    if has_configurable:
        # a. Let conf be ToBoolean(? Get(Obj, "configurable")).
        conf = Get(obj, "configurable")
        # b. Set desc.[[Configurable]] to conf.
        desc.configurable = ToBoolean(conf)
    # 7. Let hasValue be ? HasProperty(Obj, "value").
    has_value = HasProperty(obj, "value")
    # 8. If hasValue is true, then
    if has_value:
        # a. Let value be ? Get(Obj, "value").
        value = Get(obj, "value")
        # b. Set desc.[[Value]] to value.
        desc.value = value
    # 9. Let hasWritable be ? HasProperty(Obj, "writable").
    has_writable = HasProperty(obj, "writable")
    # 10. If hasWritable is true, then
    if has_writable:
        # a. Let writable be ToBoolean(? Get(Obj, "writable")).
        writable = Get(obj, "writable")
        # b. Set desc.[[Writable]] to writable.
        desc.writable = ToBoolean(writable)
    # 11. Let hasGet be ? HasProperty(Obj, "get").
    has_get = HasProperty(obj, "get")
    # 12. If hasGet is true, then
    if has_get:
        # a. Let getter be ? Get(Obj, "get").
        getter = Get(obj, "get")
        # b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.
        if not IsCallable(getter) and getter is not None:
            raise ESTypeError("Getter Object not callable")
        # c. Set desc.[[Get]] to getter.
        desc.Get = getter
    # 13. Let hasSet be ? HasProperty(Obj, "set").
    has_set = HasProperty(obj, "set")
    # 14. If hasSet is true, then
    if has_set:
        # a. Let setter be ? Get(Obj, "set").
        setter = Get(obj, "set")
        # b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.
        if not IsCallable(setter) and setter is not None:
            raise ESTypeError("Setter object not callable")
        # c. Set desc.[[Set]] to setter.
        desc.Set = setter
    # 15. If desc.[[Get]] is present or desc.[[Set]] is present, then
    if hasattr(desc, "Get") or hasattr(desc, "Set"):
        # a. If desc.[[Value]] is present or desc.[[Writable]] is present, throw a TypeError exception.
        if hasattr(desc, "value") or hasattr(desc, "writable"):
            raise ESTypeError("ToPropertyDescriptor: Had a declarative vs accessor conflict")
    # 16. Return desc.
    return desc


# 6.2.5.6 CompletePropertyDescriptor ( Desc )
def CompletePropertyDescriptor(desc):
    # When the abstract operation CompletePropertyDescriptor is called with Property Descriptor Desc, the following
    # steps are taken:
    #
    # 1. Assert: Desc is a Property Descriptor.
    assert isinstance(desc, PropertyDescriptor)
    return desc.complete_property_descriptor()


######################################################################################################################
# 6.2.7 Data Blocks
######################################################################################################################
# The Data Block specification type is used to describe a distinct and mutable sequence of byte-sized (8 bit) numeric
# values. A Data Block value is created with a fixed number of bytes that each have the initial value 0.
#
# For notational convenience within this specification, an array-like syntax can be used to access the individual bytes
# of a Data Block value. This notation presents a Data Block value as a 0-origined integer-indexed sequence of bytes.
# For example, if db is a 5 byte Data Block value then db[2] can be used to access its 3rd byte.
#
# A data block that resides in memory that can be referenced from multiple agents concurrently is designated a Shared
# Data Block. A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that
# is address-free: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of
# locations in memory that the block represents. Two data blocks are equal only if the sets of the locations they
# contain are equal; otherwise, they are not equal and the intersection of the sets of locations they contain is empty.
# Finally, Shared Data Blocks can be distinguished from Data Blocks.
#
# The semantics of Shared Data Blocks is defined using Shared Data Block events by the memory model. Abstract
# operations below introduce Shared Data Block events and act as the interface between evaluation semantics and the
# event semantics of the memory model. The events form a candidate execution, on which the memory model acts as a
# filter. Please consult the memory model for full semantics.
#
# Shared Data Block events are modeled by Records, defined in the memory model.
#
# The following abstract operations are used in this specification to operate upon Data Block values:

# 6.2.7.1 CreateByteDataBlock ( size )
def CreateByteDataBlock(size):
    # When the abstract operation CreateByteDataBlock is called with integer argument size, the following steps are
    # taken:
    #
    #   1. Assert: size≥0.
    #   2. Let db be a new Data Block value consisting of size bytes. If it is impossible to create such a Data Block,
    #      throw a RangeError exception.
    #   3. Set all of the bytes of db to 0.
    #   4. Return db.
    assert size >= 0
    return memoryview(bytearray(size))


# 6.2.7.3 CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )
def CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count):
    # When the abstract operation CopyDataBlockBytes is called, the following steps are taken:
    #
    #   1. Assert: fromBlock and toBlock are distinct Data Block or Shared Data Block values.
    #   2. Assert: fromIndex, toIndex, and count are integer values ≥ 0.
    #   3. Let fromSize be the number of bytes in fromBlock.
    #   4. Assert: fromIndex+count ≤ fromSize.
    #   5. Let toSize be the number of bytes in toBlock.
    #   6. Assert: toIndex+count ≤ toSize.
    #   7. Repeat, while count>0
    #       a. If fromBlock is a Shared Data Block, then
    #           i. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
    #           ii. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
    #           iii. Let bytes be a List of length 1 that contains a nondeterministically chosen byte value.
    #           iv. NOTE: In implementations, bytes is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
    #           v. Let readEvent be ReadSharedMemory { [[Order]]: "Unordered", [[NoTear]]: true, [[Block]]: fromBlock, [[ByteIndex]]: fromIndex, [[ElementSize]]: 1 }.
    #           vi. Append readEvent to eventList.
    #           vii. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: bytes } to execution.[[ChosenValues]].
    #           viii. If toBlock is a Shared Data Block, then
    #               1. Append WriteSharedMemory { [[Order]]: "Unordered", [[NoTear]]: true, [[Block]]: toBlock, [[ByteIndex]]: toIndex, [[ElementSize]]: 1, [[Payload]]: bytes } to eventList.
    #           ix. Else,
    #               1. Set toBlock[toIndex] to bytes[0].
    #       b. Else,
    #           i. Assert: toBlock is not a Shared Data Block.
    #           ii. Set toBlock[toIndex] to fromBlock[fromIndex].
    #       c. Increment toIndex and fromIndex each by 1.
    #       d. Decrement count by 1.
    #   8. Return NormalCompletion(empty).
    assert isinstance(toBlock, memoryview) and isinstance(fromBlock, memoryview) and toBlock.obj is not fromBlock.obj
    assert all(IsInteger(x) and x >= 0 for x in (fromIndex, toIndex, count))
    assert fromIndex + count <= fromBlock.nbytes
    assert toIndex + count <= toBlock.nbytes
    toBlock[toIndex : toIndex + count] = fromBlock[fromIndex : fromIndex + count]
    return EMPTY


substitute_error = {
    "%ReferenceError%": ReferenceError,
    "%TypeError%": TypeError,
    "%SyntaxError%": SyntaxError,
    "%RangeError%": ArithmeticError,
}


def CreateErrorObject(msg, intrinsic):
    try:
        error_constructor = surrounding_agent.running_ec.realm.intrinsics[intrinsic]
        errobj = Construct(error_constructor, [msg])
        Set(errobj, "stack", "".join(traceback.format_stack()[:-2]), False)
    except (NameError, AttributeError):
        errobj = substitute_error[intrinsic](msg)
    return errobj


def CreateReferenceError(msg=""):
    return CreateErrorObject(msg, "%ReferenceError%")


def CreateTypeError(msg=""):
    return CreateErrorObject(msg, "%TypeError%")


def CreateSyntaxError(msg=""):
    return CreateErrorObject(msg, "%SyntaxError%")


def CreateRangeError(msg=""):
    return CreateErrorObject(msg, "%RangeError%")


class ESError(BaseException):
    def __init__(self, object):
        self.ecma_object = object

    def __str__(self):
        return ToString(self.ecma_object) if isObject(self.ecma_object) else str(self.ecma_object)

    def __repr__(self):
        return f"ESError({self.ecma_object!r})"


class ESReferenceError(ESError):
    def __init__(self, msg=""):
        obj = msg if isinstance(msg, JSObject) else CreateReferenceError(msg)
        super().__init__(obj)


class ESTypeError(ESError):
    def __init__(self, msg=""):
        obj = msg if isinstance(msg, JSObject) else CreateTypeError(msg)
        super().__init__(obj)


class ESSyntaxError(ESError):
    def __init__(self, msg=""):
        obj = msg if isinstance(msg, JSObject) else CreateSyntaxError(msg)
        super().__init__(obj)


class ESRangeError(ESError):
    def __init__(self, msg=""):
        obj = msg if isinstance(msg, JSObject) else CreateRangeError(msg)
        super().__init__(obj)


class ESAbrupt(BaseException):
    def __init__(self, ctype=None, value=EMPTY, target=EMPTY):
        self.completion = Completion(ctype, value, target)


class ESBreak(ESAbrupt):
    def __init__(self, value=EMPTY, target=EMPTY):
        super().__init__(ctype=CompletionType.BREAK, value=value, target=target)


class ESContinue(ESAbrupt):
    def __init__(self, value=EMPTY, target=EMPTY):
        super().__init__(ctype=CompletionType.CONTINUE, value=value, target=target)


class ESReturn(ESAbrupt):
    def __init__(self, value=EMPTY, target=EMPTY):
        super().__init__(ctype=CompletionType.RETURN, value=value, target=target)


# 7.1 Type Conversion
#
# The ECMAScript language implicitly performs automatic type conversion as needed. To clarify the semantics of certain
# constructs it is useful to define a set of conversion abstract operations. The conversion abstract operations are
# polymorphic; they can accept a value of any ECMAScript language type. But no other specification types are used with
# these operations.

# 7.1.1 ToPrimitive ( input [ , PreferredType ] )
def ToPrimitive(input, preferred_type="default"):
    """
    The abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract
    operation ToPrimitive converts its input argument to a non-Object type. If an object is capable of converting to
    more than one primitive type, it may use the optional hint PreferredType to favour that type.
    """
    # Conversion occurs according to the following algorithm:

    # 1. Assert: input is an ECMAScript language value.
    assert isEcmaValue(input), f"{input!r} is not an ECMAScript language value"
    assert preferred_type in ["default", "string", "number"]
    # 2. If Type(input) is Object, then
    if isObject(input):
        # a. If PreferredType is not present, let hint be "default".
        # b. Else if PreferredType is hint String, let hint be "string".
        # c. Else PreferredType is hint Number, let hint be "number".
        # d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).
        exotic_to_prim = GetMethod(input, wks_to_primitive)
        # e. If exoticToPrim is not undefined, then
        if exotic_to_prim is not None:
            # i. Let result be ? Call(exoticToPrim, input, � hint �).
            result = Call(exotic_to_prim, input, [preferred_type])
            # ii. If Type(result) is not Object, return result.
            if not isObject(result):
                return result
            # iii. Throw a TypeError exception.
            raise ESTypeError(f"Cannot convert to primitive: {input!r}")
        # f. If hint is "default", set hint to "number".
        if preferred_type == "default":
            preferred_type = "number"
        # g. Return ? OrdinaryToPrimitive(input, hint).
        return OrdinaryToPrimitive(input, preferred_type)
    # 3. Return input.
    return input

    # NOTE
    #
    # When ToPrimitive is called with no hint, then it generally behaves as if the hint were Number. However, objects
    # may over-ride this behaviour by defining a @@toPrimitive method. Of the objects defined in this specification only
    # Date objects (see 20.3.4.45) and Symbol objects (see 19.4.3.4) over-ride the default ToPrimitive behaviour. Date
    # objects treat no hint as if the hint were String.


# 7.1.1.1 OrdinaryToPrimitive ( O, hint )
def OrdinaryToPrimitive(obj, hint):
    # When the abstract operation OrdinaryToPrimitive is called with arguments O and hint, the following steps are
    # taken:

    # 1. Assert: Type(O) is Object.
    assert isObject(obj)
    # 2. Assert: Type(hint) is String and its value is either "string" or "number".
    assert hint in ["string", "number"]
    # 3. If hint is "string", then
    if hint == "string":
        # a. Let methodNames be [ "toString", "valueOf" ].
        method_names = ["toString", "valueOf"]
    # 4. Else,
    else:
        # a. Let methodNames be [ "valueOf", "toString" ].
        method_names = ["valueOf", "toString"]
    # 5. For each name in methodNames in List order, do
    for name in method_names:
        # a. Let method be ? Get(O, name).
        method = Get(obj, name)
        # b. If IsCallable(method) is true, then
        if IsCallable(method):
            # i. Let result be ? Call(method, O).
            result = Call(method, obj)
            # ii. If Type(result) is not Object, return result.
            if not isObject(result):
                return result
    # 6. Throw a TypeError exception.
    raise ESTypeError(f"Can't convert {obj!r} to {hint}")


# 7.1.2 ToBoolean ( argument )
# The abstract operation ToBoolean converts argument to a value of type Boolean according to Table 9:
#
# Table 9: ToBoolean Conversions
# +---------------+---------------------------------------------------------------------------------------------
# | Argument Type |  Result
# +---------------+---------------------------------------------------------------------------------------------
# | Undefined     | Return false.
# | Null          | Return false.
# | Boolean       | Return argument.
# | Number        | If argument is +0, -0, or NaN, return false; otherwise return true.
# | String        | If argument is the empty String (its length is zero), return false; otherwise return true.
# | Symbol        | Return true.
# | Object        | Return true.
# +---------------+---------------------------------------------------------------------------------------------
type_to_boolean = {
    T_UNDEFINED: lambda v: False,
    T_NULL: lambda v: False,
    T_BOOLEAN: lambda v: v,
    T_NUMBER: lambda v: v != 0.0 and not math.isnan(v),
    T_STRING: lambda v: len(v) > 0,
    T_SYMBOL: lambda v: True,
    T_OBJECT: lambda v: True,
}


def ToBoolean(arg):
    return type_to_boolean[TypeOf(arg)](arg)


# 7.1.3 ToNumber ( argument )
# The abstract operation ToNumber converts argument to a value of type Number according to Table 10:
#
# Table 10: ToNumber Conversions
# +---------------+--------------------------------------------------------------------------------------------------+
# | Argument Type | Result                                                                                           |
# +---------------+--------------------------------------------------------------------------------------------------+
# | Undefined     | Return NaN.                                                                                      |
# +---------------+--------------------------------------------------------------------------------------------------+
# | Null          | Return +0.                                                                                       |
# +---------------+--------------------------------------------------------------------------------------------------+
# | Boolean       | If argument is true, return 1. If argument is false, return +0.                                  |
# +---------------+--------------------------------------------------------------------------------------------------+
# | Number        | Return argument (no conversion).                                                                 |
# +---------------+--------------------------------------------------------------------------------------------------+
# | String        | See grammar and conversion algorithm below.                                                      |
# +---------------+--------------------------------------------------------------------------------------------------+
# | Symbol        | Throw a TypeError exception.                                                                     |
# +---------------+--------------------------------------------------------------------------------------------------+
# | Object        | Apply the following steps:                                                                       |
# |               |   1. Let primValue be ? ToPrimitive(argument, hint Number).                                      |
# |               |   2. Return ? ToNumber(primValue).                                                               |
# +---------------+--------------------------------------------------------------------------------------------------+
def raise_typeerror(msg):
    raise ESTypeError(msg)


digits_to_floats = (
    (regex.compile(r"0[bB](?P<numerals>[0-1]+)$"), lambda n: float(int(n, 2))),
    (regex.compile(r"0[oO](?P<numerals>[0-7]+)$"), lambda n: float(int(n, 8))),
    (regex.compile(r"0[xX](?P<numerals>[0-9a-fA-F]+)$"), lambda n: float(int(n, 16))),
    # StrUnsignedDecimalLiteral :::
    #   Infinity
    #   DecimalDigits . DecimalDigits ExponentPart
    #   DecimalDigits . DecimalDigits
    #   DecimalDigits . ExponentPart
    #   DecimalDigits .
    #   . DecimalDigits ExponentPart
    #   . DecimalDigits
    #   DecimalDigits ExponentPart
    #   DecimalDigits
    (
        regex.compile(
            r"(?P<numerals>[-+]?((Infinity)|([0-9]+\.([0-9]+)?([eE][-+]?[0-9]+)?)|(\.[0-9]+([eE][-+]?[0-9]+)?)|([0-9]+([eE][-+]?[0-9]+)?)))$"
        ),
        lambda n: float(n),
    ),
)


def string_to_number(arg):
    stripper = regex.compile(
        f"^({LexerCore.WhiteSpace}|{LexerCore.LineTerminator})*(?P<numstr>.*?)({LexerCore.WhiteSpace}|{LexerCore.LineTerminator})*$"
    )
    m = stripper.match(arg)
    assert m, "Failed to remove whitespace (should never happen)"
    digits = m.group("numstr")
    if digits == "":
        return 0
    for rx, cvt in digits_to_floats:
        nums = rx.match(digits)
        if nums:
            numerals = nums.group("numerals")
            try:
                return cvt(numerals)
            except OverflowError:
                return math.inf
    return math.nan


type_to_number = {
    T_UNDEFINED: lambda v: math.nan,
    T_NULL: lambda v: 0,
    T_BOOLEAN: lambda v: 1 if v else 0,
    T_NUMBER: lambda v: v,
    T_STRING: string_to_number,
    T_SYMBOL: lambda v: raise_typeerror("Cannot convert a Symbol value to a number"),
    T_OBJECT: lambda v: ToNumber(ToPrimitive(v, "number")),
}


def ToNumber(arg):
    return type_to_number[TypeOf(arg)](arg)


# 7.1.4 ToInteger ( argument )
# The abstract operation ToInteger converts argument to an integral numeric value. This abstract operation functions as follows:
#   1. Let number be ? ToNumber(argument).
#   2. If number is NaN, return +0.
#   3. If number is +0, -0, +∞, or -∞, return number.
#   4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).
def ToInteger(arg):
    number = ToNumber(arg)
    if math.isnan(number):
        result = 0
    elif number == 0.0 or abs(number) == math.inf:
        result = number
    else:
        result = math.floor(abs(number))
        if number < 0:
            result = -result
    return result


# 7.1.5 ToInt32 ( argument )
def ToInt32(arg):
    number = ToNumber(arg)
    if math.isnan(number) or number == 0 or abs(number) == math.inf:
        return 0
    this_int = math.floor(abs(number))
    if number < 0:
        this_int = -this_int
    int32bit = this_int % 2 ** 32
    if int32bit >= 2 ** 31:
        return int32bit - 2 ** 32
    return int32bit


# 7.1.6 ToUint32 ( argument )
def ToUint32(arg):
    number = ToNumber(arg)
    if math.isnan(number) or number == 0 or abs(number) == math.inf:
        return 0
    this_int = math.floor(abs(number))
    if number < 0:
        this_int = -this_int
    int32bit = this_int % 2 ** 32
    return int32bit


# 7.1.7 ToInt16 ( argument )
def ToInt16(arg):
    number = ToNumber(arg)
    if math.isnan(number) or number == 0 or abs(number) == math.inf:
        return 0
    this_int = math.floor(abs(number))
    if number < 0:
        this_int = -this_int
    int16bit = this_int % 2 ** 16
    if int16bit >= 2 ** 15:
        return int16bit - 2 ** 16
    return int16bit


# 7.1.8 ToUint16 ( argument )
def ToUint16(arg):
    number = ToNumber(arg)
    if math.isnan(number) or number == 0 or abs(number) == math.inf:
        return 0
    this_int = math.floor(abs(number))
    if number < 0:
        this_int = -this_int
    int16bit = this_int % 2 ** 16
    return int16bit


# 7.1.9 ToInt8 ( argument )
def ToInt8(arg):
    number = ToNumber(arg)
    if math.isnan(number) or number == 0 or abs(number) == math.inf:
        return 0
    this_int = math.floor(abs(number))
    if number < 0:
        this_int = -this_int
    int8bit = this_int % 2 ** 8
    if int8bit >= 2 ** 7:
        return int8bit - 2 ** 8
    return int8bit


# 7.1.10 ToUint8 ( argument )
def ToUint8(arg):
    number = ToNumber(arg)
    if math.isnan(number) or number == 0 or abs(number) == math.inf:
        return 0
    this_int = math.floor(abs(number))
    if number < 0:
        this_int = -this_int
    int8bit = this_int % 2 ** 8
    return int8bit


# 7.1.11 ToUint8Clamp ( argument )
def ToUint8Clamp(arg):
    number = ToNumber(arg)
    if math.isnan(number) or number <= 0:
        return 0
    if number >= 255:
        return 255
    f = math.floor(number)
    if f + 0.5 < number:
        return f + 1
    if number < f + 0.5 or f & 1 == 0:
        return f
    return f + 1


# 7.1.12 ToString ( argument )
def ToString(arg):
    if isUndefined(arg):
        return "undefined"
    if isNull(arg):
        return "null"
    if isBoolean(arg):
        return "true" if arg else "false"
    if isNumber(arg):
        return NumberToString(arg)
    if isString(arg):
        return arg
    if isSymbol(arg):
        raise ESTypeError("Symbol not convertable to string")
    # isObject
    prim_value = ToPrimitive(arg, "string")
    return ToString(prim_value)


# 7.1.12.1 NumberToString ( m )
def NumberToString(m):
    if math.isnan(m):
        return "NaN"
    if m == 0:
        return "0"
    if m < 0:
        return "-" + NumberToString(-m)
    if m == math.inf:
        return "Infinity"
    return "{:.21g}".format(m)


# 7.1.13 ToObject ( argument )
def ToObject(argument):
    intrinsics = surrounding_agent.running_ec.realm.intrinsics
    # The abstract operation ToObject converts argument to a value of type Object according to Table 12:
    #
    # Table 12: ToObject Conversions
    # +---------------+-------------------------------------------------------------------------------------------------
    # | Argument Type | Result
    # +---------------+-------------------------------------------------------------------------------------------------
    # | Undefined     | Throw a TypeError exception.
    # +---------------+-------------------------------------------------------------------------------------------------
    # | Null          | Throw a TypeError exception.
    # +---------------+-------------------------------------------------------------------------------------------------
    # | Boolean       | Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. See 19.3
    # |               | for a description of Boolean objects.
    # +---------------+-------------------------------------------------------------------------------------------------
    # | Number        | Return a new Number object whose [[NumberData]] internal slot is set to argument. See 20.1 for
    # |               | a description of Number objects.
    # +---------------+-------------------------------------------------------------------------------------------------
    # | String        | Return a new String object whose [[StringData]] internal slot is set to argument. See 21.1 for
    # |               | a description of String objects.
    # +---------------+-------------------------------------------------------------------------------------------------
    # | Symbol        | Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. See 19.4 for
    # |               | a description of Symbol objects.
    # +---------------+-------------------------------------------------------------------------------------------------
    # | Object        | Return argument.
    # +---------------+-------------------------------------------------------------------------------------------------
    if isBoolean(argument):
        return Construct(intrinsics["%Boolean%"], [argument])
    if isNumber(argument):
        return Construct(intrinsics["%Number%"], [argument])
    if isString(argument):
        return Construct(intrinsics["%String%"], [argument])
    if isSymbol(argument):
        symobj = ObjectCreate(intrinsics["%SymbolPrototype%"], ["SymbolData"])
        symobj.SymbolData = argument
        return symobj
    if isObject(argument):
        return argument
    raise ESTypeError("undefined and null cannot be converted to objects")


# 7.1.14 ToPropertyKey ( argument )
def ToPropertyKey(argument):
    # The abstract operation ToPropertyKey converts argument to a value that can be used as a property key by
    # performing the following steps:
    #
    # 1. Let key be ? ToPrimitive(argument, hint String).
    # 2. If Type(key) is Symbol, then
    #    a. Return key.
    # 3. Return ! ToString(key).
    key = ToPrimitive(argument, "string")
    if isSymbol(key):
        return key
    return ToString(key)


# 7.1.15 ToLength ( argument )
def ToLength(argument):
    # The abstract operation ToLength converts argument to an integer suitable for use as the length of an array-like
    # object. It performs the following steps:
    #
    #   1. Let len be ? ToInteger(argument).
    #   2. If len ≤ +0, return +0.
    #   3. Return min(len, 2^53-1).
    length = ToInteger(argument)
    if length <= 0:
        return 0
    return min(length, 2 ** 53 - 1)


# 7.1.16 CanonicalNumericIndexString ( argument )
def CanonicalNumericIndexString(arg):
    # The abstract operation CanonicalNumericIndexString returns argument converted to a numeric value if it is a
    # String representation of a Number that would be produced by ToString, or the string "-0". Otherwise, it returns
    # undefined. This abstract operation functions as follows:
    #
    # 1. Assert: Type(argument) is String.
    assert isString(arg)
    # 2. If argument is "-0", return -0.
    if arg == "-0":
        return -0.0
    # 3. Let n be ! ToNumber(argument).
    n = ToNumber(arg)
    # 4. If SameValue(! ToString(n), argument) is false, return undefined.
    if not SameValue(ToString(n), arg):
        return None
    # 5. Return n.
    return n
    # A canonical numeric string is any String value for which the CanonicalNumericIndexString abstract operation does
    # not return undefined.


# 7.1.17 ToIndex ( value )
def ToIndex(value):
    # The abstract operation ToIndex returns value argument converted to a numeric value if it is a valid integer index
    # value. This abstract operation functions as follows:
    #
    #   1. If value is undefined, then
    #       a. Let index be 0.
    #   2. Else,
    #       a. Let integerIndex be ? ToInteger(value).
    #       b. If integerIndex < 0, throw a RangeError exception.
    #       c. Let index be ! ToLength(integerIndex).
    #       d. If SameValueZero(integerIndex, index) is false, throw a RangeError exception.
    #   3. Return index.
    if value is None:
        index = 0
    else:
        integerIndex = ToInteger(value)
        if integerIndex < 0:
            raise ESRangeError("Index must be non-negative")
        index = ToLength(integerIndex)
        if not SameValueZero(integerIndex, index):
            raise ESRangeError("Index too large")
    return index


#################################################################################################################################################################################################################################################################################################################
#
# 8888888888      .d8888b.      88888888888                   888    d8b                                              888      .d8888b.                                                   d8b                                 .d88888b.                                     888    d8b
#       d88P     d88P  Y88b         888                       888    Y8P                                              888     d88P  Y88b                                                  Y8P                                d88P" "Y88b                                    888    Y8P
#      d88P             888         888                       888                                                     888     888    888                                                                                     888     888                                    888
#     d88P            .d88P         888      .d88b.  .d8888b  888888 888 88888b.   .d88b.       8888b.  88888b.   .d88888     888         .d88b.  88888b.d88b.  88888b.   8888b.  888d888 888 .d8888b   .d88b.  88888b.      888     888 88888b.   .d88b.  888d888  8888b.  888888 888  .d88b.  88888b.  .d8888b
#  88888888       .od888P"          888     d8P  Y8b 88K      888    888 888 "88b d88P"88b         "88b 888 "88b d88" 888     888        d88""88b 888 "888 "88b 888 "88b     "88b 888P"   888 88K      d88""88b 888 "88b     888     888 888 "88b d8P  Y8b 888P"       "88b 888    888 d88""88b 888 "88b 88K
#   d88P         d88P"              888     88888888 "Y8888b. 888    888 888  888 888  888     .d888888 888  888 888  888     888    888 888  888 888  888  888 888  888 .d888888 888     888 "Y8888b. 888  888 888  888     888     888 888  888 88888888 888     .d888888 888    888 888  888 888  888 "Y8888b.
#  d88P      d8b 888"               888     Y8b.          X88 Y88b.  888 888  888 Y88b 888     888  888 888  888 Y88b 888     Y88b  d88P Y88..88P 888  888  888 888 d88P 888  888 888     888      X88 Y88..88P 888  888     Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  888 Y88..88P 888  888      X88
# d88P       Y8P 888888888          888      "Y8888   88888P'  "Y888 888 888  888  "Y88888     "Y888888 888  888  "Y88888      "Y8888P"   "Y88P"  888  888  888 88888P"  "Y888888 888     888  88888P'  "Y88P"  888  888      "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888 888  "Y88P"  888  888  88888P'
#                                                                                      888                                                                      888                                                                      888
#                                                                                 Y8b d88P                                                                      888                                                                      888
#                                                                                  "Y88P"                                                                       888                                                                      888
#
#################################################################################################################################################################################################################################################################################################################
# 7.2.1 RequireObjectCoercible ( argument )
def RequireObjectCoercible(argument):
    # The abstract operation RequireObjectCoercible throws an error if argument is a value that cannot be converted to an Object using ToObject. It is defined by Table 13:
    #
    # Table 13: RequireObjectCoercible Results
    # +---------------+-----------------------------------+
    # | Argument Type | Result                            |
    # +---------------+-----------------------------------+
    # | Undefined     | Throw a TypeError exception.      |
    # +---------------+-----------------------------------+
    # | Null          | Throw a TypeError exception.      |
    # +---------------+-----------------------------------+
    # | Boolean       | Return argument.                  |
    # +---------------+-----------------------------------+
    # | Number        | Return argument.                  |
    # +---------------+-----------------------------------+
    # | String        | Return argument.                  |
    # +---------------+-----------------------------------+
    # | Symbol        | Return argument.                  |
    # +---------------+-----------------------------------+
    # | Object        | Return argument.                  |
    # +---------------+-----------------------------------+
    if isNull(argument) or isUndefined(argument):
        raise ESTypeError("Must be a coercible value")
    return argument


# 7.2.2 IsArray ( argument )
def IsArray(arg):
    # The abstract operation IsArray takes one argument argument, and performs the following steps:
    #
    # 1. If Type(argument) is not Object, return false.
    if not isObject(arg):
        return False
    # 2. If argument is an Array exotic object, return true.
    if isinstance(arg, ArrayObject):
        return True
    # 3. If argument is a Proxy exotic object, then
    if isinstance(arg, ProxyObject):
        # a. If argument.[[ProxyHandler]] is null, throw a TypeError exception.
        if isNull(arg.ProxyHandler):
            raise ESTypeError("IsArray: Proxy object is missing a handler")
        # b. Let target be argument.[[ProxyTarget]].
        target = arg.ProxyTarget
        # c. Return ? IsArray(target).
        return IsArray(target)
    # 4. Return false.
    return False


# 7.2.3 IsCallable ( argument )
def IsCallable(arg):
    # The abstract operation IsCallable determines if argument, which must be an ECMAScript language value, is a
    # callable function with a [[Call]] internal method.
    #
    # 1. If Type(argument) is not Object, return false.
    if not isObject(arg):
        return False
    # 2. If argument has a [[Call]] internal method, return true.
    # 3. Return false.
    return hasattr(arg, "Call")


# 7.2.4 IsConstructor ( argument )
def IsConstructor(arg):
    # The abstract operation IsConstructor determines if argument, which must be an ECMAScript language value, is a
    # function object with a [[Construct]] internal method.
    #
    # 1. If Type(argument) is not Object, return false.
    if not isObject(arg):
        return False
    # 2. If argument has a [[Construct]] internal method, return true.
    # 3. Return false.
    return hasattr(arg, "Construct")


# 7.2.5 IsExtensible ( O )
def IsExtensible(o_value):
    # The abstract operation IsExtensible is used to determine whether additional properties can be added to the object
    # that is O. A Boolean value is returned. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(o_value)
    # 2. Return ? O.[[IsExtensible]]().
    return o_value.IsExtensible()


# 7.2.6 IsInteger ( argument )
def IsInteger(argument):
    # The abstract operation IsInteger determines if argument is a finite integer numeric value.
    #
    # 1. If Type(argument) is not Number, return false.
    if not isNumber(argument):
        return False
    # 2. If argument is NaN, +∞, or -∞, return false.
    if math.isnan(argument) or abs(argument) == math.inf:
        return False
    # 3. If floor(abs(argument)) ≠ abs(argument), return false.
    # 4. Return true.
    return math.floor(abs(argument)) == abs(argument)


# 7.2.7 IsPropertyKey ( argument )
def IsPropertyKey(arg):
    # The abstract operation IsPropertyKey determines if argument, which must be an ECMAScript language value, is a
    # value that may be used as a property key.
    # 1. If Type(argument) is String, return true.
    # 2. If Type(argument) is Symbol, return true.
    # 3. Return false.
    return isString(arg) or isSymbol(arg)


# 7.2.8 IsRegExp ( argument )
def IsRegExp(arg):
    # The abstract operation IsRegExp with argument argument performs the following steps:
    #   1. If Type(argument) is not Object, return false.
    #   2. Let matcher be ? Get(argument, @@match).
    #   3. If matcher is not undefined, return ToBoolean(matcher).
    #   4. If argument has a [[RegExpMatcher]] internal slot, return true.
    #   5. Return false.
    if not isObject(arg):
        return False
    matcher = Get(arg, wks_match)
    if matcher is not None:
        return ToBoolean(matcher)
    return hasattr(arg, "RegExpMatcher")


# 7.2.10 SameValue ( x, y )
def SameValue(x, y):
    # The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values,
    # produces true or false. Such a comparison is performed as follows:
    #
    # 1. If Type(x) is different from Type(y), return false.
    if TypeOf(x) != TypeOf(y):
        return False
    # 2. If Type(x) is Number, then
    if isNumber(x):
        # a. If x is NaN and y is NaN, return true.
        if math.isnan(x) and math.isnan(y):
            return True
        # b. If x is +0 and y is -0, return false.
        # c. If x is -0 and y is +0, return false.
        sign_x = math.copysign(1.0, x)
        sign_y = math.copysign(1.0, y)
        if x == 0.0 and y == 0.0 and sign_x != sign_y:
            return False
        # d. If x is the same Number value as y, return true.
        # e. Return false.
        return x == y
    # 3. Return SameValueNonNumber(x, y).
    return SameValueNonNumber(x, y)
    # NOTE
    # This algorithm differs from the Strict Equality Comparison Algorithm in its treatment of signed zeroes and NaNs.


# 7.2.11 SameValueZero ( x, y )
def SameValueZero(x, y):
    # The internal comparison abstract operation SameValueZero(x, y), where x and y are ECMAScript language values,
    # produces true or false. Such a comparison is performed as follows:
    #
    #   1. If Type(x) is different from Type(y), return false.
    #   2. If Type(x) is Number, then
    #       a. If x is NaN and y is NaN, return true.
    #       b. If x is +0 and y is -0, return true.
    #       c. If x is -0 and y is +0, return true.
    #       d. If x is the same Number value as y, return true.
    #       e. Return false.
    #   3. Return SameValueNonNumber(x, y).
    if TypeOf(x) != TypeOf(y):
        return False
    if isNumber(x):
        if math.isnan(x) and math.isnan(y):
            return True
        return x == y
    return SameValueNonNumber(x, y)
    # NOTE
    # SameValueZero differs from SameValue only in its treatment of +0 and -0.


# 7.2.12 SameValueNonNumber ( x, y )
def SameValueNonNumber(x, y):
    # The internal comparison abstract operation SameValueNonNumber(x, y), where neither x nor y are Number values,
    # produces true or false. Such a comparison is performed as follows:
    #
    # 1. Assert: Type(x) is not Number.
    assert not isNumber(x)
    # 2. Assert: Type(x) is the same as Type(y).
    assert TypeOf(x) == TypeOf(y)
    # 3. If Type(x) is Undefined, return true.
    # 4. If Type(x) is Null, return true.
    # 5. If Type(x) is String, then
    # a. If x and y are exactly the same sequence of code units (same length and same code units at corresponding
    #    indices), return true; otherwise, return false.
    # 6. If Type(x) is Boolean, then
    # a. If x and y are both true or both false, return true; otherwise, return false.
    # 7. If Type(x) is Symbol, then
    # a. If x and y are both the same Symbol value, return true; otherwise, return false.
    # 8. If x and y are the same Object value, return true. Otherwise, return false.
    return x == y


# 7.2.13 Abstract Relational Comparison
def AbstractRelationalComparison(x, y, LeftFirst):
    # The comparison x < y, where x and y are values, produces true, false, or undefined (which indicates that at least one
    # operand is NaN). In addition to x and y the algorithm takes a Boolean flag named LeftFirst as a parameter. The flag is
    # used to control the order in which operations with potentially visible side-effects are performed upon x and y. It is
    # necessary because ECMAScript specifies left to right evaluation of expressions. The default value of LeftFirst is true
    # and indicates that the x parameter corresponds to an expression that occurs to the left of the y parameter's
    # corresponding expression. If LeftFirst is false, the reverse is the case and operations must be performed upon y before
    # x. Such a comparison is performed as follows:
    #
    # 1. If the LeftFirst flag is true, then
    if LeftFirst:
        # a. Let px be ? ToPrimitive(x, hint Number).
        px = ToPrimitive(x, "number")
        # b. Let py be ? ToPrimitive(y, hint Number).
        py = ToPrimitive(y, "number")
    # 2. Else the order of evaluation needs to be reversed to preserve left to right evaluation,
    else:
        # a. Let py be ? ToPrimitive(y, hint Number).
        py = ToPrimitive(y, "number")
        # b. Let px be ? ToPrimitive(x, hint Number).
        px = ToPrimitive(x, "number")
    # 3. If Type(px) is String and Type(py) is String, then
    if isString(px) and isString(py):
        # a. If IsStringPrefix(py, px) is true, return false.
        # b. If IsStringPrefix(px, py) is true, return true.
        # c. Let k be the smallest nonnegative integer such that the code unit at index k within px is different from the code
        #    unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)
        # d. Let m be the integer that is the numeric value of the code unit at index k within px.
        # e. Let n be the integer that is the numeric value of the code unit at index k within py.
        # f. If m < n, return true. Otherwise, return false.
        # -- Steps a-f are what python already does. So this is easy.
        return px < py
    # 4. Else,
    # a. NOTE: Because px and py are primitive values evaluation order is not important.
    # b. Let nx be ? ToNumber(px).
    nx = ToNumber(px)
    # c. Let ny be ? ToNumber(py).
    ny = ToNumber(py)
    # d. If nx is NaN, return undefined.
    # e. If ny is NaN, return undefined.
    if math.isnan(nx) or math.isnan(ny):
        return None
    # f. If nx and ny are the same Number value, return false.
    # g. If nx is +0 and ny is -0, return false.
    # h. If nx is -0 and ny is +0, return false.
    # i. If nx is +∞, return false.
    # j. If ny is +∞, return true.
    # k. If ny is -∞, return false.
    # l. If nx is -∞, return true.
    # m. If the mathematical value of nx is less than the mathematical value of ny—note that these mathematical values are both
    #    finite and not both zero—return true. Otherwise, return false.
    # --- Rules f-m are followed by python, so we let it do the work.
    return nx < ny
    #
    # NOTE 1
    # Step 3 differs from step 7 in the algorithm for the addition operator + (12.8.3) by using the logical-and operation
    # instead of the logical-or operation.
    #
    # NOTE 2
    # The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to
    # use the more complex, semantically oriented definitions of character or string equality and collating order defined in
    # the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could
    # test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for
    # strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from
    # that on sequences of code point values.


# 7.2.14 Abstract Equality Comparison
def AbstractEqualityComparison(x, y):
    # The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:
    #
    # 1. If Type(x) is the same as Type(y), then
    if TypeOf(x) == TypeOf(y):
        # a. Return the result of performing Strict Equality Comparison x === y.
        return StrictEqualityComparison(x, y)
    # 2. If x is null and y is undefined, return true.
    if isNull(x) and isUndefined(y):
        return True
    # 3. If x is undefined and y is null, return true.
    if isUndefined(x) and isNull(y):
        return True
    # 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).
    if isNumber(x) and isString(y):
        return AbstractEqualityComparison(x, ToNumber(y))
    # 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.
    if isString(x) and isNumber(y):
        return AbstractEqualityComparison(ToNumber(x), y)
    # 6. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.
    if isBoolean(x):
        return AbstractEqualityComparison(ToNumber(x), y)
    # 7. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).
    if isBoolean(y):
        return AbstractEqualityComparison(x, ToNumber(y))
    # 8. If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).
    if (isString(x) or isNumber(x) or isSymbol(x)) and isObject(y):
        prim = ToPrimitive(y)
        return AbstractEqualityComparison(x, prim)
    # 9. If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.
    if isObject(x) and (isString(y) or isNumber(y) or isSymbol(y)):
        prim = ToPrimitive(x)
        return AbstractEqualityComparison(prim, y)
    # 10. Return false.
    return False


# 7.2.15 Strict Equality Comparison
def StrictEqualityComparison(x, y):
    # The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:
    #
    # 1. If Type(x) is different from Type(y), return false.
    if TypeOf(x) != TypeOf(y):
        return False
    # 2. If Type(x) is Number, then
    if isNumber(x):
        # a. If x is NaN, return false.
        # b. If y is NaN, return false.
        # c. If x is the same Number value as y, return true.
        # d. If x is +0 and y is -0, return true.
        # e. If x is -0 and y is +0, return true.
        # f. Return false.
        # Implementation note: This is exactly how the Python == works, so we're good.
        return x == y
    # 3. Return SameValueNonNumber(x, y).
    return SameValueNonNumber(x, y)
    # NOTE
    # This algorithm differs from the SameValue Algorithm in its treatment of signed zeroes and NaNs.


import functools

#################################################################################################################################################################################################################
#
# 8888888888      .d8888b.       .d88888b.                                     888    d8b                                                       .d88888b.  888         d8b                   888
#       d88P     d88P  Y88b     d88P" "Y88b                                    888    Y8P                                                      d88P" "Y88b 888         Y8P                   888
#      d88P           .d88P     888     888                                    888                                                             888     888 888                               888
#     d88P           8888"      888     888 88888b.   .d88b.  888d888  8888b.  888888 888  .d88b.  88888b.  .d8888b       .d88b.  88888b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  88888888           "Y8b.     888     888 888 "88b d8P  Y8b 888P"       "88b 888    888 d88""88b 888 "88b 88K          d88""88b 888 "88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
#   d88P         888    888     888     888 888  888 88888888 888     .d888888 888    888 888  888 888  888 "Y8888b.     888  888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
#  d88P      d8b Y88b  d88P     Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  888 Y88..88P 888  888      X88     Y88..88P 888  888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# d88P       Y8P  "Y8888P"       "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888 888  "Y88P"  888  888  88888P'      "Y88P"  888  888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                           888                                                                                                                        888
#                                           888                                                                                                                       d88P
#                                           888                                                                                                                     888P"
#
#################################################################################################################################################################################################################
# 7.3.1 Get ( O, P )
def Get(obj, propkey):
    # The abstract operation Get is used to retrieve the value of a specific property of an object. The operation is
    # called with arguments O and P where O is the object and P is the property key. This abstract operation performs
    # the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(obj)
    # 2. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # Return ? O.[[Get]](P, O).
    return obj.Get(propkey, obj)


# 7.3.2 GetV ( V, P )
def GetV(value, propkey):
    # The abstract operation GetV is used to retrieve the value of a specific property of an ECMAScript language value.
    # If the value is not an object, the property lookup is performed using a wrapper object appropriate for the type
    # of the value. The operation is called with arguments V and P where V is the value and P is the property key. This
    # abstract operation performs the following steps:
    #
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 2. Let O be ? ToObject(V).
    obj = ToObject(value)
    # 3. Return ? O.[[Get]](P, V).
    return obj.Get(propkey, value)


# 7.3.3 Set ( O, P, V, Throw )
def Set(O, P, V, Throw):
    # The abstract operation Set is used to set the value of a specific property of an object. The operation is called with
    # arguments O, P, V, and Throw where O is the object, P is the property key, V is the new value for the property and Throw
    # is a Boolean flag. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(O)
    # 2. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(P)
    # 3. Assert: Type(Throw) is Boolean.
    assert isBoolean(Throw)
    # 4. Let success be ? O.[[Set]](P, V, O).
    success = O.Set(P, V, O)
    # 5. If success is false and Throw is true, throw a TypeError exception.
    if not success and Throw:
        raise ESTypeError(f"unable to set property '{P}'")
    # 6. Return success.
    return success


# 7.3.4 CreateDataProperty ( O, P, V )
def CreateDataProperty(obj, propkey, value):
    # The abstract operation CreateDataProperty is used to create a new own property of an object. The operation is
    # called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the
    # property. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(obj)
    # 2. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 3. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true,
    #    [[Configurable]]: true }.
    new_desc = PropertyDescriptor()
    new_desc.value = value
    new_desc.writable = True
    new_desc.enumerable = True
    new_desc.configurable = True
    # Return ? O.[[DefineOwnProperty]](P, newDesc).
    return obj.DefineOwnProperty(propkey, new_desc)
    # NOTE
    # This abstract operation creates a property whose attributes are set to the same defaults used for properties
    # created by the ECMAScript language assignment operator. Normally, the property will not already exist. If it does
    # exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.


# 7.3.5 CreateMethodProperty ( O, P, V )
def CreateMethodProperty(obj, propkey, value):
    # The abstract operation CreateMethodProperty is used to create a new own property of an object. The operation is
    # called with arguments O, P, and V where O is the object, P is the property key, and V is the value for the
    # property. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(obj)
    # 2. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 3. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: false,
    #    [[Configurable]]: true }.
    new_desc = PropertyDescriptor(value=value, writable=True, enumerable=False, configurable=True)
    # 4. Return ? O.[[DefineOwnProperty]](P, newDesc).
    return obj.DefineOwnProperty(propkey, new_desc)
    # NOTE
    # This abstract operation creates a property whose attributes are set to the same defaults used for built-in
    # methods and methods defined using class declaration syntax. Normally, the property will not already exist. If it
    # does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.


# 7.3.6 CreateDataPropertyOrThrow ( O, P, V )
def CreateDataPropertyOrThrow(O, P, V):
    # The abstract operation CreateDataPropertyOrThrow is used to create a new own property of an object. It throws a
    # TypeError exception if the requested property update cannot be performed. The operation is called with arguments
    # O, P, and V where O is the object, P is the property key, and V is the value for the property. This abstract
    # operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    # 2. Assert: IsPropertyKey(P) is true.
    # 3. Let success be ? CreateDataProperty(O, P, V).
    # 4. If success is false, throw a TypeError exception.
    # 5. Return success.
    assert isObject(O)
    assert IsPropertyKey(P)
    success = CreateDataProperty(O, P, V)
    if not success:
        raise ESTypeError(f"Cannot create property '{P}'")
    return success


def CreateMethodPropertyOrThrow(obj, propkey, value):
    success = CreateMethodProperty(obj, propkey, value)
    if not success:
        raise ESTypeError(f"Cannot create method '{propkey}'")
    return success


# 7.3.7 DefinePropertyOrThrow ( O, P, desc )
def DefinePropertyOrThrow(obj, propkey, desc):
    # The abstract operation DefinePropertyOrThrow is used to call the [[DefineOwnProperty]] internal method of an
    # object in a manner that will throw a TypeError exception if the requested property update cannot be performed.
    # The operation is called with arguments O, P, and desc where O is the object, P is the property key, and desc is
    # the Property Descriptor for the property. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(obj)
    # 2. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 3. Let success be ? O.[[DefineOwnProperty]](P, desc).
    success = obj.DefineOwnProperty(propkey, desc)
    # 4. If success is false, throw a TypeError exception.
    if not success:
        raise ESTypeError(f"cannot define property '{propkey}'")
    # 5. Return success.
    return success


# ------------------------------------ 𝟕.𝟑.𝟖 𝑫𝒆𝒍𝒆𝒕𝒆𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚𝑶𝒓𝑻𝒉𝒓𝒐𝒘 ( 𝑶, 𝑷 ) ------------------------------------
# 7.3.8 DeletePropertyOrThrow ( O, P )
def DeletePropertyOrThrow(O, P):
    # The abstract operation DeletePropertyOrThrow is used to remove a specific own property of an object. It throws an
    # exception if the property is not configurable. The operation is called with arguments O and P where O is the
    # object and P is the property key. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    # 2. Assert: IsPropertyKey(P) is true.
    # 3. Let success be ? O.[[Delete]](P).
    # 4. If success is false, throw a TypeError exception.
    # 5. Return success.
    assert isObject(O)
    assert IsPropertyKey(P)
    success = O.Delete(P)
    if not success:
        raise ESTypeError(f"cannot delete property '{P}'")
    return success


# ------------------------------------ 𝟕.𝟑.𝟗 𝑮𝒆𝒕𝑴𝒆𝒕𝒉𝒐𝒅 ( 𝑽, 𝑷 ) ------------------------------------
# 7.3.9 GetMethod ( V, P )
def GetMethod(value, propkey):
    # The abstract operation GetMethod is used to get the value of a specific property of an ECMAScript language value
    # when the value of the property is expected to be a function. The operation is called with arguments V and P where
    # V is the ECMAScript language value, P is the property key. This abstract operation performs the following steps:
    #
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 2. Let func be ? GetV(V, P).
    func = GetV(value, propkey)
    # 3. If func is either undefined or null, return undefined.
    if isUndefined(func) or isNull(func):
        return None
    # 4. If IsCallable(func) is false, throw a TypeError exception.
    if not IsCallable(func):
        raise ESTypeError(f"property '{propkey}' is not a method")
    # 5. Return func.
    return func


# ------------------------------------ 𝟕.𝟑.𝟏𝟎 𝑯𝒂𝒔𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚 ( 𝑶, 𝑷 ) ------------------------------------
# 7.3.10 HasProperty ( O, P )
def HasProperty(O, P):
    # The abstract operation HasProperty is used to determine whether an object has a property with the specified property key.
    # The property may be either an own or inherited. A Boolean value is returned. The operation is called with arguments O and
    # P where O is the object and P is the property key. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(O)
    # 2. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(P)
    # 3. Return ? O.[[HasProperty]](P).
    return O.HasProperty(P)


# ------------------------------------ 𝟕.𝟑.𝟏𝟏 𝑯𝒂𝒔𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚 ( 𝑶, 𝑷 ) ------------------------------------
# 7.3.11 HasOwnProperty ( O, P )
def HasOwnProperty(O, P):
    # The abstract operation HasOwnProperty is used to determine whether an object has an own property with the specified
    # property key. A Boolean value is returned. The operation is called with arguments O and P where O is the object and P is
    # the property key. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(O)
    # 2. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(P)
    # 3. Let desc be ? O.[[GetOwnProperty]](P).
    desc = O.GetOwnProperty(P)
    # 4. If desc is undefined, return false.
    # 5. Return true.
    return desc is not None


# ------------------------------------ 𝟕.𝟑.𝟏𝟐 𝑪𝒂𝒍𝒍 ( 𝑭, 𝑽 [ , 𝒂𝒓𝒈𝒖𝒎𝒆𝒏𝒕𝒔𝑳𝒊𝒔𝒕 ] ) ------------------------------------
# 7.3.12 Call ( F, V [ , argumentsList ] )
def Call(func, value, args=[]):
    # The abstract operation Call is used to call the [[Call]] internal method of a function object. The operation is
    # called with arguments F, V, and optionally argumentsList where F is the function object, V is an ECMAScript
    # language value that is the this value of the [[Call]], and argumentsList is the value passed to the corresponding
    # argument of the internal method. If argumentsList is not present, a new empty List is used as its value. This
    # abstract operation performs the following steps:
    #
    # 1. If argumentsList is not present, set argumentsList to a new empty List.
    # 2. If IsCallable(F) is false, throw a TypeError exception.
    if not IsCallable(func):
        raise ESTypeError(f"'{func!r}' is not a callable function")
    # 3. Return ? F.[[Call]](V, argumentsList).
    return func.Call(value, args)


# ------------------------------------ 𝟕.𝟑.𝟏𝟑 𝑪𝒐𝒏𝒔𝒕𝒓𝒖𝒄𝒕 ( 𝑭 [ , 𝒂𝒓𝒈𝒖𝒎𝒆𝒏𝒕𝒔𝑳𝒊𝒔𝒕 [ , 𝒏𝒆𝒘𝑻𝒂𝒓𝒈𝒆𝒕 ]] ) ------------------------------------
# 7.3.13 Construct ( F [ , argumentsList [ , newTarget ]] )
def Construct(func, args=[], newTarget=MISSING):
    # The abstract operation Construct is used to call the [[Construct]] internal method of a function object. The operation is
    # called with arguments F, and optionally argumentsList, and newTarget where F is the function object. argumentsList and
    # newTarget are the values to be passed as the corresponding arguments of the internal method. If argumentsList is not
    # present, a new empty List is used as its value. If newTarget is not present, F is used as its value. This abstract
    # operation performs the following steps:
    #
    # 1. If newTarget is not present, set newTarget to F.
    if newTarget == MISSING:
        newTarget = func
    # 2. If argumentsList is not present, set argumentsList to a new empty List.
    # 3. Assert: IsConstructor(F) is true.
    assert IsConstructor(func)
    # 4. Assert: IsConstructor(newTarget) is true.
    assert IsConstructor(newTarget)
    # 5. Return ? F.[[Construct]](argumentsList, newTarget).
    return func.Construct(args, newTarget)
    # NOTE
    # If newTarget is not present, this operation is equivalent to: new F(...argumentsList)


# ------------------------------------ 𝟕.𝟑.𝟏𝟒 𝑺𝒆𝒕𝑰𝒏𝒕𝒆𝒈𝒓𝒊𝒕𝒚𝑳𝒆𝒗𝒆𝒍 ( 𝑶, 𝒍𝒆𝒗𝒆𝒍 ) ------------------------------------
# 7.3.14 SetIntegrityLevel ( O, level )
def SetIntegrityLevel(O, level):
    # The abstract operation SetIntegrityLevel is used to fix the set of own properties of an object. This abstract
    # operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    # 2. Assert: level is either "sealed" or "frozen".
    # 3. Let status be ? O.[[PreventExtensions]]().
    # 4. If status is false, return false.
    # 5. Let keys be ? O.[[OwnPropertyKeys]]().
    # 6. If level is "sealed", then
    #    a. For each element k of keys, do
    #       i. Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor { [[Configurable]]: false }).
    # 7. Else level is "frozen",
    #    a. For each element k of keys, do
    #       i. Let currentDesc be ? O.[[GetOwnProperty]](k).
    #      ii. If currentDesc is not undefined, then
    #          1. If IsAccessorDescriptor(currentDesc) is true, then
    #             a. Let desc be the PropertyDescriptor { [[Configurable]]: false }.
    #          2. Else,
    #             a. Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.
    #          3. Perform ? DefinePropertyOrThrow(O, k, desc).
    # 8. Return true.
    assert isObject(O)
    assert level in ["sealed", "frozen"]
    status = O.PreventExtensions()
    if not status:
        return False
    keys = O.OwnPropertyKeys()
    if level == "sealed":
        for k in keys:
            DefinePropertyOrThrow(O, k, PropertyDescriptor(configurable=False))
    else:
        for k in keys:
            currentDesc = O.GetOwnProperty(k)
            if currentDesc is not None:
                if IsAccessorDescriptor(currentDesc):
                    desc = PropertyDescriptor(configurable=False)
                else:
                    desc = PropertyDescriptor(writable=False, configurable=False)
                DefinePropertyOrThrow(O, k, desc)
    return True


# ------------------------------------ 𝟕.𝟑.𝟏𝟓 𝑻𝒆𝒔𝒕𝑰𝒏𝒕𝒆𝒈𝒓𝒊𝒕𝒚𝑳𝒆𝒗𝒆𝒍 ( 𝑶, 𝒍𝒆𝒗𝒆𝒍 ) ------------------------------------
# 7.3.15 TestIntegrityLevel ( O, level )
def TestIntegrityLevel(o_value, level):
    # The abstract operation TestIntegrityLevel is used to determine if the set of own properties of an object are
    # fixed. This abstract operation performs the following steps:
    #
    # 1. Assert: Type(O) is Object.
    assert isObject(o_value)
    # 2. Assert: level is either "sealed" or "frozen".
    assert level in ["sealed", "frozen"]
    # 3. Let status be ? IsExtensible(O).
    status = IsExtensible(o_value)
    # 4. If status is true, return false.
    if status:
        return False
    # 5. NOTE: If the object is extensible, none of its properties are examined.
    # 6. Let keys be ? O.[[OwnPropertyKeys]]().
    keys = o_value.OwnPropertyKeys()
    # 7. For each element k of keys, do
    for k in keys:
        # a. Let currentDesc be ? O.[[GetOwnProperty]](k).
        current_desc = o_value.GetOwnProperty(k)
        # b. If currentDesc is not undefined, then
        if current_desc is not None:
            # i. If currentDesc.[[Configurable]] is true, return false.
            if current_desc.configurable:
                return False
            # ii. If level is "frozen" and IsDataDescriptor(currentDesc) is true, then
            if level == "frozen" and IsDataDescriptor(current_desc):
                # 1. If currentDesc.[[Writable]] is true, return false.
                if current_desc.writable:
                    return False
    # 8. Return true.
    return True


# ------------------------------------ 𝟕.𝟑.𝟏𝟔 𝑪𝒓𝒆𝒂𝒕𝒆𝑨𝒓𝒓𝒂𝒚𝑭𝒓𝒐𝒎𝑳𝒊𝒔𝒕 ( 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 ) ------------------------------------
# 7.3.16 CreateArrayFromList ( elements )
def CreateArrayFromList(elements):
    # The abstract operation CreateArrayFromList is used to create an Array object whose elements are provided by a
    # List. This abstract operation performs the following steps:
    #
    # 1. Assert: elements is a List whose elements are all ECMAScript language values.
    # 2. Let array be ! ArrayCreate(0).
    # 3. Let n be 0.
    # 4. For each element e of elements, do
    #    a. Let status be CreateDataProperty(array, ! ToString(n), e).
    #    b. Assert: status is true.
    #    c. Increment n by 1.
    # 5. Return array.
    assert isinstance(elements, list)
    assert all(isEcmaValue(x) for x in elements)
    array = ArrayCreate(0)
    for n, e in enumerate(elements):
        status = CreateDataProperty(array, ToString(n), e)
        assert status
    return array


# ------------------------------------ 𝟕.𝟑.𝟏𝟕 𝑪𝒓𝒆𝒂𝒕𝒆𝑳𝒊𝒔𝒕𝑭𝒓𝒐𝒎𝑨𝒓𝒓𝒂𝒚𝑳𝒊𝒌𝒆 ( 𝒐𝒃𝒋 [ , 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝑻𝒚𝒑𝒆𝒔 ] ) ------------------------------------
# 7.3.17 CreateListFromArrayLike ( obj [ , elementTypes ] )
def CreateListFromArrayLike(
    obj,
    elementTypes=[
        JSType.UNDEFINED,
        JSType.NULL,
        JSType.BOOLEAN,
        JSType.STRING,
        JSType.NUMBER,
        JSType.SYMBOL,
        JSType.OBJECT,
    ],
):
    # The abstract operation CreateListFromArrayLike is used to create a List value whose elements are provided by the
    # indexed properties of an array-like object, obj. The optional argument elementTypes is a List containing the
    # names of ECMAScript Language Types that are allowed for element values of the List that is created. This abstract
    # operation performs the following steps:
    #
    #   1. If elementTypes is not present, set elementTypes to « Undefined, Null, Boolean, String, Symbol, Number,
    #      Object ».
    #   2. If Type(obj) is not Object, throw a TypeError exception.
    #   3. Let len be ? ToLength(? Get(obj, "length")).
    #   4. Let list be a new empty List.
    #   5. Let index be 0.
    #   6. Repeat, while index < len
    #       a. Let indexName be ! ToString(index).
    #       b. Let next be ? Get(obj, indexName).
    #       c. If Type(next) is not an element of elementTypes, throw a TypeError exception.
    #       d. Append next as the last element of list.
    #       e. Set index to index + 1.
    #   7. Return list.
    if not isObject(obj):
        raise ESTypeError(f"{ToString(obj)} is not an object")
    get = partial(Get, obj)

    def get_and_check(idx):
        val = get(f"{idx}")
        if TypeOf(val) not in elementTypes:
            raise ESTypeError(f"{val}: bad type")
        return val

    return [get_and_check(idx) for idx in range(ToLength(get("length")))]


# ------------------------------------ 𝟕.𝟑.𝟏𝟖 𝑰𝒏𝒗𝒐𝒌𝒆 ( 𝑽, 𝑷 [ , 𝒂𝒓𝒈𝒖𝒎𝒆𝒏𝒕𝒔𝑳𝒊𝒔𝒕 ] ) ------------------------------------
# 7.3.18 Invoke ( V, P [ , argumentsList ] )
def Invoke(v, p, arguments_list=[]):
    # The abstract operation Invoke is used to call a method property of an ECMAScript language value. The operation is
    # called with arguments V, P, and optionally argumentsList where V serves as both the lookup point for the property
    # and the this value of the call, P is the property key, and argumentsList is the list of arguments values passed
    # to the method. If argumentsList is not present, a new empty List is used as its value. This abstract operation
    # performs the following steps:
    #
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(p)
    # 2. If argumentsList is not present, set argumentsList to a new empty List.
    # 3. Let func be ? GetV(V, P).
    func = GetV(v, p)
    # 4. Return ? Call(func, V, argumentsList).
    return Call(func, v, arguments_list)


# ------------------------------------ 𝟕.𝟑.𝟏𝟗 𝑶𝒓𝒅𝒊𝒏𝒂𝒓𝒚𝑯𝒂𝒔𝑰𝒏𝒔𝒕𝒂𝒏𝒄𝒆 ( 𝑪, 𝑶 ) ------------------------------------
# 7.3.19 OrdinaryHasInstance ( C, O )
def OrdinaryHasInstance(C, O):
    # The abstract operation OrdinaryHasInstance implements the default algorithm for determining if an object O inherits from
    # the instance object inheritance path provided by constructor C. This abstract operation performs the following steps:
    #
    # 1. If IsCallable(C) is false, return false.
    if not IsCallable(C):
        return False
    # 2. If C has a [[BoundTargetFunction]] internal slot, then
    if hasattr(C, "BoundTargetFunction"):
        # a. Let BC be C.[[BoundTargetFunction]].
        BC = C.BoundTargetFunction
        # b. Return ? InstanceofOperator(O, BC).
        return InstanceofOperator(O, BC)
    # 3. If Type(O) is not Object, return false.
    if not isObject(O):
        return False
    # 4. Let P be ? Get(C, "prototype").
    P = Get(C, "prototype")
    # 5. If Type(P) is not Object, throw a TypeError exception.
    if not isObject(P):
        raise ESTypeError()
    # 6. Repeat,
    while 1:
        # a. Set O to ? O.[[GetPrototypeOf]]().
        O = O.GetPrototypeOf()
        # b. If O is null, return false.
        if isNull(O):
            return False
        # c. If SameValue(P, O) is true, return true.
        if SameValue(P, O):
            return True


# ------------------------------------ 𝟕.𝟑.𝟐𝟎 𝑺𝒑𝒆𝒄𝒊𝒆𝒔𝑪𝒐𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒐𝒓 ( 𝑶, 𝒅𝒆𝒇𝒂𝒖𝒍𝒕𝑪𝒐𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒐𝒓 ) ------------------------------------
# 7.3.20 SpeciesConstructor ( O, defaultConstructor )
def SpeciesConstructor(O, defaultConstructor):
    # The abstract operation SpeciesConstructor is used to retrieve the constructor that should be used to create new
    # objects that are derived from the argument object O. The defaultConstructor argument is the constructor to use if
    # a constructor @@species property cannot be found starting from O. This abstract operation performs the following
    # steps:
    #
    #   1. Assert: Type(O) is Object.
    #   2. Let C be ? Get(O, "constructor").
    #   3. If C is undefined, return defaultConstructor.
    #   4. If Type(C) is not Object, throw a TypeError exception. (Chrome: "The .constructor property is not an object")
    #   5. Let S be ? Get(C, @@species).
    #   6. If S is either undefined or null, return defaultConstructor.
    #   7. If IsConstructor(S) is true, return S.
    #   8. Throw a TypeError exception. (Chrome: "object.constructor[Symbol.species] is not a constructor")
    assert isObject(O)
    C = Get(O, "constructor")
    if C is None:
        return defaultConstructor
    if not isObject(C):
        raise ESTypeError("The .constructor property is not an object")
    S = Get(C, wks_species)
    if S is None or isNull(S):
        return defaultConstructor
    if not IsConstructor(S):
        raise ESTypeError("object.constructor[Symbol.species] is not a constructor")
    return S


# ------------------------------------ 𝟕.𝟑.𝟐𝟏 𝑬𝒏𝒖𝒎𝒆𝒓𝒂𝒃𝒍𝒆𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚𝑵𝒂𝒎𝒆𝒔 ( 𝑶, 𝒌𝒊𝒏𝒅 ) ------------------------------------
# 7.3.21 EnumerableOwnPropertyNames ( O, kind )
def EnumerableOwnPropertyNames(O, kind):
    # When the abstract operation EnumerableOwnPropertyNames is called with Object O and String kind the following
    # steps are taken:
    #
    #   1. Assert: Type(O) is Object.
    #   2. Let ownKeys be ? O.[[OwnPropertyKeys]]().
    #   3. Let properties be a new empty List.
    #   4. For each element key of ownKeys in List order, do
    #       a. If Type(key) is String, then
    #           i. Let desc be ? O.[[GetOwnProperty]](key).
    #           ii. If desc is not undefined and desc.[[Enumerable]] is true, then
    #               1. If kind is "key", append key to properties.
    #               2. Else,
    #                   a. Let value be ? Get(O, key).
    #                   b. If kind is "value", append value to properties.
    #                   c. Else,
    #                       i. Assert: kind is "key+value".
    #                       ii. Let entry be CreateArrayFromList(« key, value »).
    #                       iii. Append entry to properties.
    #   5. Order the elements of properties so they are in the same relative order as would be produced by the Iterator
    #      that would be returned if the EnumerateObjectProperties internal method were invoked with O.
    #   6. Return properties.
    assert isObject(O)
    ownKeys = O.OwnPropertyKeys()
    properties = []
    for key in ownKeys:
        if isString(key):
            desc = O.GetOwnProperty(key)
            if desc is not None and desc.enumerable:
                if kind == "key":
                    properties.append(key)
                else:
                    value = Get(O, key)
                    if kind == "value":
                        properties.append(value)
                    else:
                        assert kind == "key+value"
                        entry = CreateArrayFromList([key, value])
                        properties.append(entry)
    # The ordering rule is just to ensure the two functions are consistent, not that there's a particular order the
    # spec provides. We're good, because the true ordering is already done in OwnPropertyKeys.
    return properties


# ------------------------------------ 𝟕.𝟑.𝟐𝟐 𝑮𝒆𝒕𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏𝑹𝒆𝒂𝒍𝒎 ( 𝒐𝒃𝒋 ) ------------------------------------
# 7.3.22 GetFunctionRealm ( obj )
def GetFunctionRealm(obj):
    # The abstract operation GetFunctionRealm with argument obj performs the following steps:
    #
    # 1. Assert: obj is a callable object.
    assert IsCallable(obj)
    # 2. If obj has a [[Realm]] internal slot, then
    if hasattr(obj, "Realm"):
        # a. Return obj.[[Realm]].
        return obj.Realm
    # 3. If obj is a Bound Function exotic object, then
    if hasattr(obj, "BoundTargetFunction"):
        # a. Let target be obj.[[BoundTargetFunction]].
        target = obj.BoundTargetFunction
        # b. Return ? GetFunctionRealm(target).
        return GetFunctionRealm(target)
    # 4. If obj is a Proxy exotic object, then
    if hasattr(obj, "ProxyHandler"):
        # a. If obj.[[ProxyHandler]] is null, throw a TypeError exception.
        if isNull(obj.ProxyHandler):
            raise ESTypeError()
        # b. Let proxyTarget be obj.[[ProxyTarget]].
        proxy_target = obj.ProxyTarget
        # c. Return ? GetFunctionRealm(proxyTarget).
        return GetFunctionRealm(proxy_target)
    # 5. Return the current Realm Record.
    return surrounding_agent.running_ec.realm
    # NOTE
    # Step 5 will only be reached if obj is a non-standard function exotic object that does not have a [[Realm]]
    # internal slot.


# ------------------------------------ 𝟕.𝟑.𝟐𝟑 𝑪𝒐𝒑𝒚𝑫𝒂𝒕𝒂𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒊𝒆𝒔 ( 𝒕𝒂𝒓𝒈𝒆𝒕, 𝒔𝒐𝒖𝒓𝒄𝒆, 𝒆𝒙𝒄𝒍𝒖𝒅𝒆𝒅𝑰𝒕𝒆𝒎𝒔 ) ------------------------------------
# 7.3.23 CopyDataProperties ( target, source, excludedItems )
def CopyDataProperties(target, source, excludedItems):
    # When the abstract operation CopyDataProperties is called with arguments target, source, and excludedItems, the
    # following steps are taken:
    #
    #   1. Assert: Type(target) is Object.
    #   2. Assert: excludedItems is a List of property keys.
    #   3. If source is undefined or null, return target.
    #   4. Let from be ! ToObject(source).
    #   5. Let keys be ? from.[[OwnPropertyKeys]]().
    #   6. For each element nextKey of keys in List order, do
    #       a. Let excluded be false.
    #       b. For each element e of excludedItems in List order, do
    #           i. If SameValue(e, nextKey) is true, then
    #               1. Set excluded to true.
    #       c. If excluded is false, then
    #           i. Let desc be ? from.[[GetOwnProperty]](nextKey).
    #           ii. If desc is not undefined and desc.[[Enumerable]] is true, then
    #               1. Let propValue be ? Get(from, nextKey).
    #               2. Perform ! CreateDataProperty(target, nextKey, propValue).
    #   7. Return target.
    #
    # NOTE The target passed in here is always a newly created object which is not directly accessible in case of
    # an error being thrown.
    #
    assert isObject(target)
    assert all(IsPropertyKey(key) for key in excludedItems)
    if source is None or isNull(source):
        return target
    from_obj = ToObject(source)
    keys = from_obj.OwnPropertyKeys()
    for nextKey in keys:
        excluded = any(SameValue(e, nextKey) for e in excludedItems)
        if not excluded:
            desc = from_obj.GetOwnProperty(nextKey)
            if desc is not None and desc.enumerable:
                propValue = Get(from_obj, nextKey)
                CreateDataProperty(target, nextKey, propValue)
    return target


#######################################################################################################################
#
# 8888888888         d8888       .d88888b.                                     888    d8b
#       d88P        d8P888      d88P" "Y88b                                    888    Y8P
#      d88P        d8P 888      888     888                                    888
#     d88P        d8P  888      888     888 88888b.   .d88b.  888d888  8888b.  888888 888  .d88b.  88888b.  .d8888b
#  88888888      d88   888      888     888 888 "88b d8P  Y8b 888P"       "88b 888    888 d88""88b 888 "88b 88K
#   d88P         8888888888     888     888 888  888 88888888 888     .d888888 888    888 888  888 888  888 "Y8888b.
#  d88P      d8b       888      Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  888 Y88..88P 888  888      X88
# d88P       Y8P       888       "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888 888  "Y88P"  888  888  88888P'
#                                           888
#                                           888
#                                           888
#
#                       8888888 888                              888
#                         888   888                              888
#                         888   888                              888
#  .d88b.  88888b.        888   888888  .d88b.  888d888  8888b.  888888  .d88b.  888d888
# d88""88b 888 "88b       888   888    d8P  Y8b 888P"       "88b 888    d88""88b 888P"
# 888  888 888  888       888   888    88888888 888     .d888888 888    888  888 888
# Y88..88P 888  888       888   Y88b.  Y8b.     888     888  888 Y88b.  Y88..88P 888
#  "Y88P"  888  888     8888888  "Y888  "Y8888  888     "Y888888  "Y888  "Y88P"  888
#
#
#
#
#  .d88888b.  888         d8b                   888
# d88P" "Y88b 888         Y8P                   888
# 888     888 888                               888
# 888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
# 888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# 888     888 888  888    888 88888888 888      888    "Y8888b.
# Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
#  "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                         888
#                        d88P
#                      888P"
#
# See Common Iteration Interfaces (25.1).
#
# 7.4.1 GetIterator ( obj [ , hint [ , method ] ] )
# 7.4.2 IteratorNext ( iteratorRecord [ , value ] )
# 7.4.3 IteratorComplete ( iterResult )
# 7.4.4 IteratorValue ( iterResult )
# 7.4.5 IteratorStep ( iteratorRecord )
# 7.4.6 IteratorClose ( iteratorRecord, completion )
# 7.4.7 AsyncIteratorClose ( iteratorRecord, completion )
# 7.4.8 CreateIterResultObject ( value, done )
# 7.4.9 CreateListIteratorRecord ( list )
# 7.4.9.1 ListIterator next ( )
#
#######################################################################################################################

# ------------------------------------ 𝟕.𝟒.𝟏 𝑮𝒆𝒕𝑰𝒕𝒆𝒓𝒂𝒕𝒐𝒓 ( 𝒐𝒃𝒋 [ , 𝒉𝒊𝒏𝒕 [ , 𝒎𝒆𝒕𝒉𝒐𝒅 ] ] ) ------------------------------------
# 7.4.1 GetIterator ( obj [ , hint [ , method ] ] )
class IteratorRecord(Record):
    __slots__ = ["Iterator", "NextMethod", "Done"]

    def __init__(self, Iterator=None, NextMethod=None, Done=None):
        self.Iterator = Iterator
        self.NextMethod = NextMethod
        self.Done = Done

    def __repr__(self):
        return f"IteratorRecord(Iterator={self.Iterator}, NextMethod={self.NextMethod}, Done={self.Done})"


def GetIterator(obj, hint=SYNC, method=EMPTY):
    # The abstract operation GetIterator with argument obj and optional arguments hint and method performs the
    # following steps:
    #
    #   1. If hint is not present, set hint to sync.
    #   2. Assert: hint is either sync or async.
    #   3. If method is not present, then
    #       a. If hint is async, then
    #           i. Set method to ? GetMethod(obj, @@asyncIterator).
    #           ii. If method is undefined, then
    #               1. Let syncMethod be ? GetMethod(obj, @@iterator).
    #               2. Let syncIteratorRecord be ? GetIterator(obj, sync, syncMethod).
    #               3. Return ? CreateAsyncFromSyncIterator(syncIteratorRecord).
    #       b. Otherwise, set method to ? GetMethod(obj, @@iterator).
    #   4. Let iterator be ? Call(method, obj).
    #   5. If Type(iterator) is not Object, throw a TypeError exception.
    #   6. Let nextMethod be ? GetV(iterator, "next").
    #   7. Let iteratorRecord be Record { [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }.
    #   8. Return iteratorRecord.
    assert hint in (SYNC, ASYNC)
    if method == EMPTY:
        if hint == ASYNC:
            method = GetMethod(obj, wks_async_iterator)
            if method is None:
                syncMethod = GetMethod(obj, wks_iterator)
                syncIteratorRecord = GetIterator(obj, SYNC, syncMethod)
                return CreateAsyncFromSyncIterator(syncIteratorRecord)
        method = GetMethod(obj, wks_iterator)
    iterator = Call(method, obj)
    if not isObject(iterator):
        raise ESTypeError("Iterator not an object")
    nextMethod = GetV(iterator, "next")
    return IteratorRecord(Iterator=iterator, NextMethod=nextMethod, Done=False)


# 7.4.2 IteratorNext ( iteratorRecord [ , value ] )
def IteratorNext(iteratorRecord, value=EMPTY):
    # The abstract operation IteratorNext with argument iteratorRecord and optional argument value performs the
    # following steps:
    #
    #   1. If value is not present, then
    #       a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « »).
    #   2. Else,
    #       a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « value »).
    #   3. If Type(result) is not Object, throw a TypeError exception.
    #   4. Return result.
    if value == EMPTY:
        arglist = []
    else:
        arglist = [value]
    result = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, arglist)
    if not isObject(result):
        raise ESTypeError("Iterator Next Method returned a non-object")
    return result


# 7.4.3 IteratorComplete ( iterResult )
def IteratorComplete(iterResult):
    # The abstract operation IteratorComplete with argument iterResult performs the following steps:
    #
    # 1. Assert: Type(iterResult) is Object.
    # 2. Return ToBoolean(? Get(iterResult, "done")).
    assert isObject(iterResult)
    return ToBoolean(Get(iterResult, "done"))


# 7.4.4 IteratorValue ( iterResult )
def IteratorValue(iterResult):
    # The abstract operation IteratorValue with argument iterResult performs the following steps:
    #
    # 1. Assert: Type(iterResult) is Object.
    # 2. Return ? Get(iterResult, "value").
    assert isObject(iterResult)
    return Get(iterResult, "value")


# 7.4.5 IteratorStep ( iteratorRecord )
def IteratorStep(iteratorRecord):
    # The abstract operation IteratorStep with argument iteratorRecord requests the next value from
    # iteratorRecord.[[Iterator]] by calling iteratorRecord.[[NextMethod]] and returns either false indicating that the
    # iterator has reached its end or the IteratorResult object if a next value is available. IteratorStep performs the
    # following steps:
    #
    # 1. Let result be ? IteratorNext(iteratorRecord).
    # 2. Let done be ? IteratorComplete(result).
    # 3. If done is true, return false.
    # 4. Return result.
    result = IteratorNext(iteratorRecord)
    done = IteratorComplete(result)
    if done:
        return False
    return result


# 7.4.6 IteratorClose ( iteratorRecord, completion )
def IteratorClose(iteratorRecord):
    # The abstract operation IteratorClose with arguments iteratorRecord and completion is used to notify an iterator
    # that it should perform any actions it would normally perform when it has reached its completed state:
    #
    #   1. Assert: Type(iteratorRecord.[[Iterator]]) is Object.
    #   2. Assert: completion is a Completion Record.
    #   3. Let iterator be iteratorRecord.[[Iterator]].
    #   4. Let return be ? GetMethod(iterator, "return").
    #   5. If return is undefined, return Completion(completion).
    #   6. Let innerResult be Call(return, iterator, « »).
    #   7. If completion.[[Type]] is throw, return Completion(completion).
    #   8. If innerResult.[[Type]] is throw, return Completion(innerResult).
    #   9. If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.
    #   10. Return Completion(completion).
    assert isObject(iteratorRecord.Iterator)
    iterator = iteratorRecord.Iterator
    return_method = GetMethod(iterator, "return")
    if return_method:
        innerResult = Call(return_method, iterator, [])
        if not isObject(innerResult):
            raise ESTypeError(f"Bad result from iterator 'return' method. (Got {ToString(innerResult)})")


# 7.4.7 AsyncIteratorClose ( iteratorRecord, completion )
def AsyncIteratorClose(iteratorRecord, completion=EMPTY):
    raise NotImplementedError("Async not yet implemented")


# ------------------------------------ 𝟕.𝟒.𝟖 𝑪𝒓𝒆𝒂𝒕𝒆𝑰𝒕𝒆𝒓𝑹𝒆𝒔𝒖𝒍𝒕𝑶𝒃𝒋𝒆𝒄𝒕 ( 𝒗𝒂𝒍𝒖𝒆, 𝒅𝒐𝒏𝒆 ) ------------------------------------
# 7.4.8 CreateIterResultObject ( value, done )
def CreateIterResultObject(value, done):
    # The abstract operation CreateIterResultObject with arguments value and done creates an object that supports the
    #   IteratorResult interface by performing the following steps:
    #
    #   1. Assert: Type(done) is Boolean.
    #   2. Let obj be ObjectCreate(%ObjectPrototype%).
    #   3. Perform CreateDataProperty(obj, "value", value).
    #   4. Perform CreateDataProperty(obj, "done", done).
    #   5. Return obj.
    assert isBoolean(done)
    obj = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
    CreateDataProperty(obj, "value", value)
    CreateDataProperty(obj, "done", done)
    return obj


# ------------------------------------ 𝟕.𝟒.𝟗 𝑪𝒓𝒆𝒂𝒕𝒆𝑳𝒊𝒔𝒕𝑰𝒕𝒆𝒓𝒂𝒕𝒐𝒓𝑹𝒆𝒄𝒐𝒓𝒅 ( 𝒍𝒊𝒔𝒕 ) ------------------------------------
# 7.4.9 CreateListIteratorRecord ( list )
def CreateListIteratorRecord(lst):
    # The abstract operation CreateListIteratorRecord with argument list creates an Iterator (25.1.1.2) object record
    # whose next method returns the successive elements of list. It performs the following steps:
    #
    #   1. Let iterator be ObjectCreate(%IteratorPrototype%, « [[IteratedList]], [[ListIteratorNextIndex]] »).
    #   2. Set iterator.[[IteratedList]] to list.
    #   3. Set iterator.[[ListIteratorNextIndex]] to 0.
    #   4. Let steps be the algorithm steps defined in ListIterator next (7.4.9.1).
    #   5. Let next be CreateBuiltinFunction(steps, « »).
    #   6. Return Record { [[Iterator]]: iterator, [[NextMethod]]: next, [[Done]]: false }.
    # NOTE The list iterator object is never directly accessible to ECMAScript code.
    iterator = ObjectCreate(
        surrounding_agent.running_ec.realm.intrinsics["%IteratorPrototype%"],
        ["IteratedList", "ListIteratorNextIndex"],
    )
    iterator.IteratedList = lst
    iterator.ListIteratorNextIndex = 0
    next_fcn = CreateBuiltinFunction(ListIterator_next, [])
    return IteratorRecord(Iterator=iterator, NextMethod=next_fcn, Done=False)


# ------------------------------------ 𝟕.𝟒.𝟗.𝟏 𝑳𝒊𝒔𝒕𝑰𝒕𝒆𝒓𝒂𝒕𝒐𝒓 𝒏𝒆𝒙𝒕 ( ) ------------------------------------
# 7.4.9.1 ListIterator next ( )
def ListIterator_next(this_value, new_target):
    # The ListIterator next method is a standard built-in function object (clause 17) that performs the following steps:
    #
    #   1. Let O be the this value.
    #   2. Assert: Type(O) is Object.
    #   3. Assert: O has an [[IteratedList]] internal slot.
    #   4. Let list be O.[[IteratedList]].
    #   5. Let index be O.[[ListIteratorNextIndex]].
    #   6. Let len be the number of elements of list.
    #   7. If index ≥ len, then
    #       a. Return CreateIterResultObject(undefined, true).
    #   8. Set O.[[ListIteratorNextIndex]] to index+1.
    #   9. Return CreateIterResultObject(list[index], false).
    O = this_value
    assert isObject(O)
    assert hasattr(O, "IteratedList")
    lst = O.IteratedList
    index = O.ListIteratorNextIndex
    length = len(lst)
    if index >= length:
        return CreateIterResultObject(None, True)
    O.ListIteratorNextIndex = index + 1
    return CreateIterResultObject(lst[index], False)


#######################################################################################################################
#
#  .d8888b.       d888       888                        d8b                   888
# d88P  Y88b     d8888       888                        Y8P                   888
# Y88b. d88P       888       888                                              888
#  "Y88888"        888       888       .d88b.  888  888 888  .d8888b  8888b.  888
# .d8P""Y8b.       888       888      d8P  Y8b `Y8bd8P' 888 d88P"        "88b 888
# 888    888       888       888      88888888   X88K   888 888      .d888888 888
# Y88b  d88P d8b   888       888      Y8b.     .d8""8b. 888 Y88b.    888  888 888
#  "Y8888P"  Y8P 8888888     88888888  "Y8888  888  888 888  "Y8888P "Y888888 888
#
#
# 8888888888                   d8b                                                           888
# 888                          Y8P                                                           888
# 888                                                                                        888
# 8888888    88888b.  888  888 888 888d888  .d88b.  88888b.  88888b.d88b.   .d88b.  88888b.  888888 .d8888b
# 888        888 "88b 888  888 888 888P"   d88""88b 888 "88b 888 "888 "88b d8P  Y8b 888 "88b 888    88K
# 888        888  888 Y88  88P 888 888     888  888 888  888 888  888  888 88888888 888  888 888    "Y8888b.
# 888        888  888  Y8bd8P  888 888     Y88..88P 888  888 888  888  888 Y8b.     888  888 Y88b.       X88
# 8888888888 888  888   Y88P   888 888      "Y88P"  888  888 888  888  888  "Y8888  888  888  "Y888  88888P'
#
# 8.1 Lexical Environments
#
# A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and
# functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an
# Environment Record and a possibly null reference to an outer Lexical Environment. Usually a Lexical Environment is
# associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a BlockStatement,
# or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.
#
# An Environment Record records the identifier bindings that are created within the scope of its associated Lexical
# Environment. It is referred to as the Lexical Environment's EnvironmentRecord.
#
# The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer
# reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the
# inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical Environment. A
# Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example, if a
# FunctionDeclaration contains two nested FunctionDeclarations then the Lexical Environments of each of the nested
# functions will have as their outer Lexical Environment the Lexical Environment of the current evaluation of the
# surrounding function.
#
# A global environment is a Lexical Environment which does not have an outer environment. The global environment's
# outer environment reference is null. A global environment's EnvironmentRecord may be prepopulated with identifier
# bindings and includes an associated global object whose properties provide some of the global environment's
# identifier bindings. As ECMAScript code is executed, additional properties may be added to the global object and the
# initial properties may be modified.
#
# A module environment is a Lexical Environment that contains the bindings for the top level declarations of a Module.
# It also contains the bindings that are explicitly imported by the Module. The outer environment of a module
# environment is a global environment.
#
# A function environment is a Lexical Environment that corresponds to the invocation of an ECMAScript function object.
# A function environment may establish a new this binding. A function environment also captures the state necessary to
# support super method invocations.
#
# Lexical Environments and Environment Record values are purely specification mechanisms and need not correspond to any
# specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or
# manipulate such values.
#
# 8.1 Lexical Environments
# 8.1.1 Environment Records
# 8.1.1.1 Declarative Environment Records
# 8.1.1.1.1 HasBinding ( N )
# 8.1.1.1.2 CreateMutableBinding ( N, D )
# 8.1.1.1.3 CreateImmutableBinding ( N, S )
# 8.1.1.1.4 InitializeBinding ( N, V )
# 8.1.1.1.5 SetMutableBinding ( N, V, S )
# 8.1.1.1.6 GetBindingValue ( N, S )
# 8.1.1.1.7 DeleteBinding ( N )
# 8.1.1.1.8 HasThisBinding ( )
# 8.1.1.1.9 HasSuperBinding ( )
# 8.1.1.1.10 WithBaseObject ( )
# 8.1.1.2 Object Environment Records
# 8.1.1.2.1 HasBinding ( N )
# 8.1.1.2.2 CreateMutableBinding ( N, D )
# 8.1.1.2.3 CreateImmutableBinding ( N, S )
# 8.1.1.2.4 InitializeBinding ( N, V )
# 8.1.1.2.5 SetMutableBinding ( N, V, S )
# 8.1.1.2.6 GetBindingValue ( N, S )
# 8.1.1.2.7 DeleteBinding ( N )
# 8.1.1.2.8 HasThisBinding ( )
# 8.1.1.2.9 HasSuperBinding ( )
# 8.1.1.2.10 WithBaseObject ( )
# 8.1.1.3 Function Environment Records
# 8.1.1.3.1 BindThisValue ( V )
# 8.1.1.3.2 HasThisBinding ( )
# 8.1.1.3.3 HasSuperBinding ( )
# 8.1.1.3.4 GetThisBinding ( )
# 8.1.1.3.5 GetSuperBase ( )
# 8.1.1.4 Global Environment Records
# 8.1.1.4.1 HasBinding ( N )
# 8.1.1.4.2 CreateMutableBinding ( N, D )
# 8.1.1.4.3 CreateImmutableBinding ( N, S )
# 8.1.1.4.4 InitializeBinding ( N, V )
# 8.1.1.4.5 SetMutableBinding ( N, V, S )
# 8.1.1.4.6 GetBindingValue ( N, S )
# 8.1.1.4.7 DeleteBinding ( N )
# 8.1.1.4.8 HasThisBinding ( )
# 8.1.1.4.9 HasSuperBinding ( )
# 8.1.1.4.10 WithBaseObject ( )
# 8.1.1.4.11 GetThisBinding ( )
# 8.1.1.4.12 HasVarDeclaration ( N )
# 8.1.1.4.13 HasLexicalDeclaration ( N )
# 8.1.1.4.14 HasRestrictedGlobalProperty ( N )
# 8.1.1.4.15 CanDeclareGlobalVar ( N )
# 8.1.1.4.16 CanDeclareGlobalFunction ( N )
# 8.1.1.4.17 CreateGlobalVarBinding ( N, D )
# 8.1.1.4.18 CreateGlobalFunctionBinding ( N, V, D )
# 8.1.1.5 Module Environment Records
# 8.1.1.5.1 GetBindingValue ( N, S )
# 8.1.1.5.2 DeleteBinding ( N )
# 8.1.1.5.3 HasThisBinding ( )
# 8.1.1.5.4 GetThisBinding ( )
# 8.1.1.5.5 CreateImportBinding ( N, M, N2 )
# 8.1.2 Lexical Environment Operations
# 8.1.2.1 GetIdentifierReference ( lex, name, strict )
# 8.1.2.2 NewDeclarativeEnvironment ( E )
# 8.1.2.3 NewObjectEnvironment ( O, E )
# 8.1.2.4 NewFunctionEnvironment ( F, newTarget )
# 8.1.2.5 NewGlobalEnvironment ( G, thisValue )
# 8.1.2.6 NewModuleEnvironment ( E )
#
#######################################################################################################################

#
# 8.1.1 Environment Records
#
# There are two primary kinds of Environment Record values used in this specification: declarative Environment Records
# and object Environment Records. Declarative Environment Records are used to define the effect of ECMAScript language
# syntactic elements such as FunctionDeclarations, VariableDeclarations, and Catch clauses that directly associate
# identifier bindings with ECMAScript language values. Object Environment Records are used to define the effect of
# ECMAScript elements such as WithStatement that associate identifier bindings with the properties of some object.
# Global Environment Records and function Environment Records are specializations that are used for specifically for
# Script global declarations and for top-level declarations within functions.
#
# For specification purposes Environment Record values are values of the Record specification type and can be thought
# of as existing in a simple object-oriented hierarchy where Environment Record is an abstract class with three
# concrete subclasses, declarative Environment Record, object Environment Record, and global Environment Record.
# Function Environment Records and module Environment Records are subclasses of declarative Environment Record. The
# abstract class includes the abstract specification methods defined in Table 14. These abstract methods have distinct
# concrete algorithms for each of the concrete subclasses.
#
# Table 14: Abstract Methods of Environment Records
#
# +------------------------------+-------------------------------------------------------------------------------------
# | Method                       | Purpose
# +------------------------------+-------------------------------------------------------------------------------------
# | HasBinding(N)                | Determine if an Environment Record has a binding for the String value N. Return true
# |                              | if it does and false if it does not.
# +------------------------------+-------------------------------------------------------------------------------------
# | CreateMutableBinding(N, D)   | Create a new but uninitialized mutable binding in an Environment Record. The String
# |                              | value N is the text of the bound name. If the Boolean argument D is true the binding
# |                              | may be subsequently deleted.
# +------------------------------+-------------------------------------------------------------------------------------
# | CreateImmutableBinding(N, S) | Create a new but uninitialized immutable binding in an Environment Record. The
# |                              | String value N is the text of the bound name. If S is true then attempts to set it
# |                              | after it has been initialized will always throw an exception, regardless of the
# |                              | strict mode setting of operations that reference that binding.
# +------------------------------+-------------------------------------------------------------------------------------
# | InitializeBinding(N, V)      | Set the value of an already existing but uninitialized binding in an Environment
# |                              | Record. The String value N is the text of the bound name. V is the value for the
# |                              | binding and is a value of any ECMAScript language type.
# +------------------------------+-------------------------------------------------------------------------------------
# | SetMutableBinding(N, V, S)   | Set the value of an already existing mutable binding in an Environment Record. The
# |                              | String value N is the text of the bound name. V is the value for the binding and may
# |                              | be a value of any ECMAScript language type. S is a Boolean flag. If S is true and
# |                              | the binding cannot be set throw a TypeError exception.
# +------------------------------+-------------------------------------------------------------------------------------
# | GetBindingValue(N, S)        | Returns the value of an already existing binding from an Environment Record. The
# |                              | String value N is the text of the bound name. S is used to identify references
# |                              | originating in strict mode code or that otherwise require strict mode reference
# |                              | semantics. If S is true and the binding does not exist throw a ReferenceError
# |                              | exception. If the binding exists but is uninitialized a ReferenceError is thrown,
# |                              | regardless of the value of S.
# +------------------------------+-------------------------------------------------------------------------------------
# | DeleteBinding(N)             | Delete a binding from an Environment Record. The String value N is the text of the
# |                              | bound name. If a binding for N exists, remove the binding and return true. If the
# |                              | binding exists but cannot be removed return false. If the binding does not exist
# |                              | return true.
# +------------------------------+-------------------------------------------------------------------------------------
# | HasThisBinding()             | Determine if an Environment Record establishes a this binding. Return true if it
# |                              | does and false if it does not.
# +------------------------------+-------------------------------------------------------------------------------------
# | HasSuperBinding()            | Determine if an Environment Record establishes a super method binding. Return true
# |                              | if it does and false if it does not.
# +------------------------------+-------------------------------------------------------------------------------------
# | WithBaseObject()             | If this Environment Record is associated with a with statement, return the with
# |                              | object. Otherwise, return undefined.
# +------------------------------+-------------------------------------------------------------------------------------

# 8.1.1.1 Declarative Environment Records
#
# Each declarative Environment Record is associated with an ECMAScript program scope containing variable, constant,
# let, class, module, import, and/or function declarations. A declarative Environment Record binds the set of
# identifiers defined by the declarations contained within its scope.
#
class DeclarativeEnvironmentRecord:
    Binding = namedtuple("Binding", ["value", "mutable", "strict", "deletable", "initialized"])

    def __init__(self):
        self.bindings = {}

    # 8.1.1.1.1 HasBinding ( N )
    def HasBinding(self, N):
        """Determine if an Environment Record has a binding for the String value N. Return true if it does and false if
           it does not."""
        # The concrete Environment Record method HasBinding for declarative Environment Records simply determines if
        # the argument identifier is one of the identifiers bound by the record:
        # 1. Let envRec be the declarative Environment Record for which the method was invoked.
        # 2. If envRec has a binding for the name that is the value of N, return true.
        # 3. Return false.
        return N in self.bindings

    # 8.1.1.1.2 CreateMutableBinding ( N, D )
    def CreateMutableBinding(self, N, D):
        """Create a new but uninitialized mutable binding in an Environment Record. The String value N is the text of
           the bound name. If the Boolean argument D is true the binding may be subsequently deleted."""
        # The concrete Environment Record method CreateMutableBinding for declarative Environment Records creates a new
        # mutable binding for the name N that is uninitialized. A binding must not already exist in this Environment
        # Record for N. If Boolean argument D has the value true the new binding is marked as being subject to deletion.
        # 1. Let envRec be the declarative Environment Record for which the method was invoked.
        # 2. Assert: envRec does not already have a binding for N.
        assert N not in self.bindings
        # 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that
        #    the newly created binding may be deleted by a subsequent DeleteBinding call.
        self.bindings[N] = self.Binding(None, True, False, D, False)
        # 4. Return NormalCompletion(empty).
        return EMPTY

    # 8.1.1.1.3 CreateImmutableBinding ( N, S )
    def CreateImmutableBinding(self, N, S):
        """Create a new but uninitialized immutable binding in an Environment Record. The String value N is the text of
           the bound name. If S is true then attempts to set it after it has been initialized will always throw an
           exception, regardless of the strict mode setting of operations that reference that binding."""
        # The concrete Environment Record method CreateImmutableBinding for declarative Environment Records creates a
        # new immutable binding for the name N that is uninitialized. A binding must not already exist in this
        # Environment Record for N. If the Boolean argument S has the value true the new binding is marked as a strict
        # binding.
        # 1. Let envRec be the declarative Environment Record for which the method was invoked.
        # 2. Assert: envRec does not already have a binding for N.
        assert N not in self.bindings
        # 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that
        #    the newly created binding is a strict binding.
        self.bindings[N] = self.Binding(None, False, S, False, False)
        # 4. Return NormalCompletion(empty).
        return EMPTY

    # 8.1.1.1.4 InitializeBinding ( N, V )
    def InitializeBinding(self, N, V):
        """Set the value of an already existing but uninitialized binding in an Environment
           Record. The String value N is the text of the bound name. V is the value for the
           binding and is a value of any ECMAScript language type."""
        # The concrete Environment Record method InitializeBinding for declarative Environment Records is used to set
        # the bound value of the current binding of the identifier whose name is the value of the argument N to the
        # value of argument V. An uninitialized binding for N must already exist.
        # 1. Let envRec be the declarative Environment Record for which the method was invoked.
        # 2. Assert: envRec must have an uninitialized binding for N.
        assert N in self.bindings and not self.bindings[N].initialized
        # 3. Set the bound value for N in envRec to V.
        # 4. Record that the binding for N in envRec has been initialized.
        self.bindings[N] = self.bindings[N]._replace(value=V, initialized=True)
        # 5. Return NormalCompletion(empty).
        return EMPTY

    # 8.1.1.1.5 SetMutableBinding ( N, V, S )
    def SetMutableBinding(self, N, V, S):
        """Set the value of an already existing mutable binding in an Environment Record. The
        String value N is the text of the bound name. V is the value for the binding and may
        be a value of any ECMAScript language type. S is a Boolean flag. If S is true and
        the binding cannot be set throw a TypeError exception."""
        # The concrete Environment Record method SetMutableBinding for declarative Environment Records attempts to
        # change the bound value of the current binding of the identifier whose name is the value of the argument N to
        # the value of argument V. A binding for N normally already exists, but in rare cases it may not. If the
        # binding is an immutable binding, a TypeError is thrown if S is true.
        # 1. Let envRec be the declarative Environment Record for which the method was invoked.
        # 2. If envRec does not have a binding for N, then
        if N not in self.bindings:
            # a. If S is true, throw a ReferenceError exception.
            if S:
                raise ESReferenceError()
            # b. Perform envRec.CreateMutableBinding(N, true).
            self.CreateMutableBinding(N, True)
            # c. Perform envRec.InitializeBinding(N, V).
            self.InitializeBinding(N, V)
            # d. Return NormalCompletion(empty).
            return EMPTY
        # 3. If the binding for N in envRec is a strict binding, set S to true.
        if self.bindings[N].strict:
            S = True
        # 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.
        if not self.bindings[N].initialized:
            raise ESReferenceError()
        # 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.
        if self.bindings[N].mutable:
            self.bindings[N] = self.bindings[N]._replace(value=V)
        # 6. Else,
        else:
            # a. Assert: This is an attempt to change the value of an immutable binding.
            # b. If S is true, throw a TypeError exception.
            if S:
                raise ESTypeError()
        # 7. Return NormalCompletion(empty).
        return EMPTY
        # NOTE
        # An example of ECMAScript code that results in a missing binding at step 2 is:
        #
        # function f(){eval("var x; x = (delete x, 0);")}

    # 8.1.1.1.6 GetBindingValue ( N, S )
    def GetBindingValue(self, N, _):
        # The concrete Environment Record method GetBindingValue for declarative Environment Records simply returns
        # the value of its bound identifier whose name is the value of the argument N. If the binding exists but is
        # uninitialized a ReferenceError is thrown, regardless of the value of S.
        # 1. Let envRec be the declarative Environment Record for which the method was invoked.
        # 2. Assert: envRec has a binding for N.
        # 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.
        if not self.bindings[N].initialized:
            raise ESReferenceError()
        # 4. Return the value currently bound to N in envRec.
        return self.bindings[N].value

    # 8.1.1.1.7 DeleteBinding ( N )
    def DeleteBinding(self, N):
        # The concrete Environment Record method DeleteBinding for declarative Environment Records can only delete
        # bindings that have been explicitly designated as being subject to deletion.
        # 1. Let envRec be the declarative Environment Record for which the method was invoked.
        # 2. Assert: envRec has a binding for the name that is the value of N.
        # 3. If the binding for N in envRec cannot be deleted, return false.
        if not self.bindings[N].deletable:
            return False
        # 4. Remove the binding for N from envRec.
        del self.bindings[N]
        # 5. Return true.
        return True

    # 8.1.1.1.8 HasThisBinding ( )
    def HasThisBinding(self):
        # Regular declarative Environment Records do not provide a this binding.
        #
        # 1. Return false.
        return False

    # 8.1.1.1.9 HasSuperBinding ( )
    def HasSuperBinding(self):
        # Regular declarative Environment Records do not provide a super binding.
        #
        # 1. Return false.
        return False

    # 8.1.1.1.10 WithBaseObject ( )
    def WithBaseObject(self):
        # Declarative Environment Records always return undefined as their WithBaseObject.
        #
        # 1. Return undefined.
        return None


# 8.1.1.2 Object Environment Records
#
# Each object Environment Record is associated with an object called its binding object. An object Environment Record
# binds the set of string identifier names that directly correspond to the property names of its binding object.
# Property keys that are not strings in the form of an IdentifierName are not included in the set of bound identifiers.
# Both own and inherited properties are included in the set regardless of the setting of their [[Enumerable]]
# attribute. Because properties can be dynamically added and deleted from objects, the set of identifiers bound by an
# object Environment Record may potentially change as a side-effect of any operation that adds or deletes properties.
# Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the
# Writable attribute of the corresponding property has the value false. Immutable bindings do not exist for object
# Environment Records.
#
# Object Environment Records created for with statements (13.11) can provide their binding object as an implicit this
# value for use in function calls. The capability is controlled by a withEnvironment Boolean value that is associated
# with each object Environment Record. By default, the value of withEnvironment is false for any object Environment
# Record.


class ObjectEnvironmentRecord:
    def __init__(self, binding_object, with_environment=False):
        self.binding_object = ToObject(binding_object)
        self.with_environment = ToBoolean(with_environment)

    # 8.1.1.2.1 HasBinding ( N )
    def HasBinding(self, N):
        # The concrete Environment Record method HasBinding for object Environment Records determines if its associated
        # binding object has a property whose name is the value of the argument N:
        # 1. Let envRec be the object Environment Record for which the method was invoked.
        # 2. Let bindings be the binding object for envRec.
        # 3. Let foundBinding be ? HasProperty(bindings, N).
        found_binding = HasProperty(self.binding_object, N)
        # 4. If foundBinding is false, return false.
        if not found_binding:
            return False
        # 5. If the withEnvironment flag of envRec is false, return true.
        if not self.with_environment:
            return True
        # 6. Let unscopables be ? Get(bindings, @@unscopables).
        unscopables = Get(self.binding_object, wks_unscopables)
        # 7. If Type(unscopables) is Object, then
        if isObject(unscopables):
            # a. Let blocked be ToBoolean(? Get(unscopables, N)).
            blocked = Get(unscopables, N)
            blocked = ToBoolean(blocked)
            # b. If blocked is true, return false.
            if blocked:
                return False
        # 8. Return true.
        return True

    # 8.1.1.2.2 CreateMutableBinding ( N, D )
    def CreateMutableBinding(self, name, deletable):
        # The concrete Environment Record method CreateMutableBinding for object Environment Records creates in an
        # Environment Record's associated binding object a property whose name is the String value and initializes it
        # to the value undefined. If Boolean argument D has the value true the new property's [[Configurable]]
        # attribute is set to true; otherwise it is set to false.

        # 1. Let envRec be the object Environment Record for which the method was invoked.
        # 2. Let bindings be the binding object for envRec.
        # 3. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true,
        #             [[Enumerable]]: true, [[Configurable]]: D }).
        return DefinePropertyOrThrow(
            self.binding_object,
            name,
            PropertyDescriptor(value=None, writable=True, enumerable=True, configurable=deletable),
        )
        # NOTE
        # Normally envRec will not have a binding for N but if it does, the semantics of DefinePropertyOrThrow may
        # result in an existing binding being replaced or shadowed or cause an abrupt completion to be returned.

    # 8.1.1.2.4 InitializeBinding ( N, V )
    def InitializeBinding(self, name, value):
        # The concrete Environment Record method InitializeBinding for object Environment Records is used to set the
        # bound value of the current binding of the identifier whose name is the value of the argument N to the value of
        # argument V. An uninitialized binding for N must already exist.

        # 1. Let envRec be the object Environment Record for which the method was invoked.
        # 2. Assert: envRec must have an uninitialized binding for N.
        # 3. Record that the binding for N in envRec has been initialized.
        # 4. Return ? envRec.SetMutableBinding(N, V, false).
        return self.SetMutableBinding(name, value, False)
        # NOTE
        # In this specification, all uses of CreateMutableBinding for object Environment Records are immediately
        # followed by a call to InitializeBinding for the same name. Hence, implementations do not need to explicitly
        # track the initialization state of individual object Environment Record bindings.

    # 8.1.1.2.5 SetMutableBinding ( N, V, S )
    def SetMutableBinding(self, name, value, strict):
        # The concrete Environment Record method SetMutableBinding for object Environment Records attempts to set the
        # value of the Environment Record's associated binding object's property whose name is the value of the
        # argument N to the value of argument V. A property named N normally already exists but if it does not or is
        # not currently writable, error handling is determined by the value of the Boolean argument S.

        # 1. Let envRec be the object Environment Record for which the method was invoked.
        # 2. Let bindings be the binding object for envRec.
        # 3. Return ? Set(bindings, N, V, S).
        return Set(self.binding_object, name, value, strict)

    # 8.1.1.2.6 GetBindingValue ( N, S )
    def GetBindingValue(self, name, strict):
        # The concrete Environment Record method GetBindingValue for object Environment Records returns the value of
        # its associated binding object's property whose name is the String value of the argument identifier N. The
        # property should already exist but if it does not the result depends upon the value of the S argument:

        # 1. Let envRec be the object Environment Record for which the method was invoked.
        # 2. Let bindings be the binding object for envRec.
        # 3. Let value be ? HasProperty(bindings, N).
        value = HasProperty(self.binding_object, name)
        # 4. If value is false, then
        if not value:
            # a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.
            if not strict:
                return None
            raise ESReferenceError()
        # 5. Return ? Get(bindings, N).
        return Get(self.binding_object, name)

    # 8.1.1.2.7 DeleteBinding ( N )
    def DeleteBinding(self, name):
        # The concrete Environment Record method DeleteBinding for object Environment Records can only delete bindings
        # that correspond to properties of the environment object whose [[Configurable]] attribute have the value true.

        # 1. Let envRec be the object Environment Record for which the method was invoked.
        # 2. Let bindings be the binding object for envRec.
        # 3. Return ? bindings.[[Delete]](N).
        return self.binding_object.Delete(name)

    # 8.1.1.2.8 HasThisBinding ( )
    def HasThisBinding(self):
        # Regular object Environment Records do not provide a this binding.
        # 1. Return false.
        return False

    # 8.1.1.2.9 HasSuperBinding ( )
    def HasSuperBinding(self):
        # Regular object Environment Records do not provide a super binding.
        # 1. Return false.
        return False

    # 8.1.1.2.10 WithBaseObject ( )
    def WithBaseObject(self):
        # Object Environment Records return undefined as their WithBaseObject unless their withEnvironment flag is
        # true.

        # 1. Let envRec be the object Environment Record for which the method was invoked.
        # 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.
        if self.with_environment:
            return self.binding_object
        # 3. Otherwise, return undefined.
        return None


# 8.1.1.3 Function Environment Records
#
# A function Environment Record is a declarative Environment Record that is used to represent the top-level scope of a
# function and, if the function is not an ArrowFunction, provides a this binding. If a function is not an ArrowFunction
# function and references super, its function Environment Record also contains the state that is used to perform super
# method invocations from within the function.
#
# Function Environment Records have the additional state fields listed in Table 15.
#
# Table 15: Additional Fields of Function Environment Records
# +-----------------------+---------------------------+-----------------------------------------------------------------
# | Field Name            | Value                     | Meaning
# +-----------------------+---------------------------+-----------------------------------------------------------------
# | [[ThisValue]]         | Any                       | This is the this value used for this invocation of the function.
# +-----------------------+---------------------------+-----------------------------------------------------------------
# | [[ThisBindingStatus]] | "lexical" | "initialized" | If the value is "lexical", this is an ArrowFunction and does not
# |                       |   | "uninitialized"       | have a local this value.
# +-----------------------+---------------------------+-----------------------------------------------------------------
# | [[FunctionObject]]    | Object                    | The function object whose invocation caused this Environment
# |                       |                           | Record to be created.
# +-----------------------+---------------------------+-----------------------------------------------------------------
# | [[HomeObject]]        | Object | undefined        | If the associated function has super property accesses and is
# |                       |                           | not an ArrowFunction, [[HomeObject]] is the object that the
# |                       |                           | function is bound to as a method. The default value for
# |                       |                           | [[HomeObject]] is undefined.
# +-----------------------+---------------------------+-----------------------------------------------------------------
# | [[NewTarget]]         | Object | undefined        | If this Environment Record was created by the [[Construct]]
# |                       |                           | internal method, [[NewTarget]] is the value of the [[Construct]]
# |                       |                           | newTarget parameter. Otherwise, its value is undefined.
# +-----------------------+---------------------------+-----------------------------------------------------------------
#
# Function Environment Records support all of the declarative Environment Record methods listed in Table 14 and share
# the same specifications for all of those methods except for HasThisBinding and HasSuperBinding. In addition, function
# Environment Records support the methods listed in Table 16:
#
# Table 16: Additional Methods of Function Environment Records
# +------------------+--------------------------------------------------------------------------------------------------
# | Method           | Purpose
# +------------------+--------------------------------------------------------------------------------------------------
# | BindThisValue(V) | Set the [[ThisValue]] and record that it has been initialized.
# +------------------+--------------------------------------------------------------------------------------------------
# | GetThisBinding() | Return the value of this Environment Record's this binding. Throws a ReferenceError if the this
# |                  | binding has not been initialized.
# +------------------+--------------------------------------------------------------------------------------------------
# | GetSuperBase()   | Return the object that is the base for super property accesses bound in this Environment Record.
# |                  | The object is derived from this Environment Record's [[HomeObject]] field. The value undefined
# |                  | indicates that super property accesses will produce runtime errors.
# +------------------+--------------------------------------------------------------------------------------------------
class FunctionEnvironmentRecord(DeclarativeEnvironmentRecord):
    def __init__(self):
        super().__init__()
        self.this_value = None
        self.this_binding_status = "uninitialized"
        self.function_object = JSNull.NULL
        self.home_object = None
        self.new_target = None

    # 8.1.1.3.1 BindThisValue ( V )
    def BindThisValue(self, value):
        # 1. Let envRec be the function Environment Record for which the method was invoked.
        # 2. Assert: envRec.[[ThisBindingStatus]] is not "lexical".
        assert self.this_binding_status != "lexical"
        # 3. If envRec.[[ThisBindingStatus]] is "initialized", throw a ReferenceError exception.
        if self.this_binding_status == "initialized":
            raise ESReferenceError()
        # 4. Set envRec.[[ThisValue]] to V.
        self.this_value = value
        # 5. Set envRec.[[ThisBindingStatus]] to "initialized".
        self.this_binding_status = "initialized"
        # 6. Return V.
        return value

    # 8.1.1.3.2 HasThisBinding ( )
    def HasThisBinding(self):
        # 1. Let envRec be the function Environment Record for which the method was invoked.
        # 2. If envRec.[[ThisBindingStatus]] is "lexical", return false; otherwise, return true.
        return self.this_binding_status != "lexical"

    # 8.1.1.3.3 HasSuperBinding ( )
    def HasSuperBinding(self):
        # 1. Let envRec be the function Environment Record for which the method was invoked.
        # 2. If envRec.[[ThisBindingStatus]] is "lexical", return false.
        if self.this_binding_status == "lexical":
            return False
        # e. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.
        return self.home_object is not None

    # 8.1.1.3.4 GetThisBinding ( )
    def GetThisBinding(self):
        # 1. Let envRec be the function Environment Record for which the method was invoked.
        # 2. Assert: envRec.[[ThisBindingStatus]] is not "lexical".
        assert self.this_binding_status != "lexical"
        # 3. If envRec.[[ThisBindingStatus]] is "uninitialized", throw a ReferenceError exception.
        if self.this_binding_status == "uninitialized":
            raise ESReferenceError()
        # 4. Return envRec.[[ThisValue]].
        return self.this_value

    # 8.1.1.3.5 GetSuperBase ( )
    def GetSuperBase(self):
        # 1. Let envRec be the function Environment Record for which the method was invoked.
        # 2. Let home be envRec.[[HomeObject]].
        home = self.home_object
        # 3. If home has the value undefined, return undefined.
        if home is None:
            return None
        # 4. Assert: Type(home) is Object.
        assert isObject(home)
        # 5. Return ? home.[[GetPrototypeOf]]().
        return home.GetPrototypeOf()


# 8.1.1.4 Global Environment Records
#
# A global Environment Record is used to represent the outer most scope that is shared by all of the ECMAScript Script
# elements that are processed in a common realm. A global Environment Record provides the bindings for built-in globals
# (clause 18), properties of the global object, and for all top-level declarations (13.2.8, 13.2.10) that occur within
# a Script.
#
# A global Environment Record is logically a single record but it is specified as a composite encapsulating an object
# Environment Record and a declarative Environment Record. The object Environment Record has as its base object the
# global object of the associated Realm Record. This global object is the value returned by the global Environment
# Record's GetThisBinding concrete method. The object Environment Record component of a global Environment Record
# contains the bindings for all built-in globals (clause 18) and all bindings introduced by a FunctionDeclaration,
# GeneratorDeclaration, AsyncFunctionDeclaration, AsyncGeneratorDeclaration, or VariableStatement contained in global
# code. The bindings for all other ECMAScript declarations in global code are contained in the declarative Environment
# Record component of the global Environment Record.
#
# Properties may be created directly on a global object. Hence, the object Environment Record component of a global
# Environment Record may contain both bindings created explicitly by FunctionDeclaration, GeneratorDeclaration,
# AsyncFunctionDeclaration, AsyncGeneratorDeclaration, or VariableDeclaration declarations and bindings created
# implicitly as properties of the global object. In order to identify which bindings were explicitly created using
# declarations, a global Environment Record maintains a list of the names bound using its CreateGlobalVarBinding and
# CreateGlobalFunctionBinding concrete methods.
#
# Global Environment Records have the additional fields listed in Table 17 and the additional methods listed in Table
# 18.
#
# Table 17: Additional Fields of Global Environment Records
# +-----------------------+--------------------------------+------------------------------------------------------------
# | Field Name            | Value                          | Meaning
# +-----------------------+--------------------------------+------------------------------------------------------------
# | [[ObjectRecord]]      | Object Environment Record      | Binding object is the global object. It contains global
# |                       |                                | built-in bindings as well as FunctionDeclaration,
# |                       |                                | GeneratorDeclaration, AsyncFunctionDeclaration,
# |                       |                                | AsyncGeneratorDeclaration, and VariableDeclaration bindings
# |                       |                                | in global code for the associated realm.
# +-----------------------+--------------------------------+------------------------------------------------------------
# | [[GlobalThisValue]]   | Object                         | The value returned by this in global scope. Hosts may
# |                       |                                | provide any ECMAScript Object value.
# +-----------------------+--------------------------------+------------------------------------------------------------
# | [[DeclarativeRecord]] | Declarative Environment Record | Contains bindings for all declarations in global code for
# |                       |                                | the associated realm code except for FunctionDeclaration,
# |                       |                                | GeneratorDeclaration, AsyncFunctionDeclaration,
# |                       |                                | AsyncGeneratorDeclaration, and VariableDeclaration
# |                       |                                | bindings.
# +-----------------------+--------------------------------+------------------------------------------------------------
# | [[VarNames]]          | List of String                 | The string names bound by FunctionDeclaration,
# |                       |                                | GeneratorDeclaration, AsyncFunctionDeclaration,
# |                       |                                | AsyncGeneratorDeclaration, and VariableDeclaration
# |                       |                                | declarations in global code for the associated realm.
# +-----------------------+--------------------------------+------------------------------------------------------------
#
# Table 18: Additional Methods of Global Environment Records
# +--------------------------------------+------------------------------------------------------------------------------
# | Method                               | Purpose
# +--------------------------------------+------------------------------------------------------------------------------
# | GetThisBinding()                     | Return the value of this Environment Record's this binding.
# +--------------------------------------+------------------------------------------------------------------------------
# | HasVarDeclaration (N)                | Determines if the argument identifier has a binding in this Environment
# |                                      | Record that was created using a VariableDeclaration, FunctionDeclaration,
# |                                      | GeneratorDeclaration, AsyncFunctionDeclaration, or AsyncGeneratorDeclaration.
# +--------------------------------------+------------------------------------------------------------------------------
# | HasLexicalDeclaration (N)            | Determines if the argument identifier has a binding in this Environment
# |                                      | Record that was created using a lexical declaration such as a
# |                                      | LexicalDeclaration or a ClassDeclaration.
# +--------------------------------------+------------------------------------------------------------------------------
# | HasRestrictedGlobalProperty (N)      | Determines if the argument is the name of a global object property that may
# |                                      | not be shadowed by a global lexical binding.
# +--------------------------------------+------------------------------------------------------------------------------
# | CanDeclareGlobalVar (N)              | Determines if a corresponding CreateGlobalVarBinding call would succeed if
# |                                      | called for the same argument N.
# +--------------------------------------+------------------------------------------------------------------------------
# | CanDeclareGlobalFunction (N)         | Determines if a corresponding CreateGlobalFunctionBinding call would succeed
# |                                      | if called for the same argument N.
# +--------------------------------------+------------------------------------------------------------------------------
# | CreateGlobalVarBinding(N, D)         | Used to create and initialize to undefined a global var binding in the
# |                                      | [[ObjectRecord]] component of a global Environment Record. The binding will
# |                                      | be a mutable binding. The corresponding global object property will have
# |                                      | attribute values appropriate for a var. The String value N is the bound name.
# |                                      | If D is true the binding may be deleted. Logically equivalent to
# |                                      | CreateMutableBinding followed by a SetMutableBinding but it allows var
# |                                      | declarations to receive special treatment.
# +--------------------------------------+------------------------------------------------------------------------------
# | CreateGlobalFunctionBinding(N, V, D) | Create and initialize a global function binding in the [[ObjectRecord]]
# |                                      | component of a global Environment Record. The binding will be a mutable
# |                                      | binding. The corresponding global object property will have attribute values
# |                                      | appropriate for a function. The String value N is the bound name. V is the
# |                                      | initialization value. If the Boolean argument D is true the binding may be
# |                                      | deleted. Logically equivalent to CreateMutableBinding followed by a
# |                                      | SetMutableBinding but it allows function declarations to receive special
# |                                      | treatment.
# +--------------------------------------+------------------------------------------------------------------------------


class GlobalEnvironmentRecord:
    def __init__(self, binding_object, global_this_value):
        self.object_record = ObjectEnvironmentRecord(binding_object, False)
        self.global_this_value = ToObject(global_this_value)
        self.declarative_record = DeclarativeEnvironmentRecord()
        self.var_names = []

    # 8.1.1.4.1 HasBinding ( N )
    def HasBinding(self, name):
        # The concrete Environment Record method HasBinding for global Environment Records simply determines if the
        # argument identifier is one of the identifiers bound by the record:
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. If DclRec.HasBinding(N) is true, return true.
        if self.declarative_record.HasBinding(name):
            return True
        # 4. Let ObjRec be envRec.[[ObjectRecord]].
        # 5. Return ? ObjRec.HasBinding(N).
        return self.object_record.HasBinding(name)

    # 8.1.1.4.2 CreateMutableBinding ( N, D )
    def CreateMutableBinding(self, name, deletable):
        # The concrete Environment Record method CreateMutableBinding for global Environment Records creates a new
        # mutable binding for the name N that is uninitialized. The binding is created in the associated
        # DeclarativeRecord. A binding for N must not already exist in the DeclarativeRecord. If Boolean argument D has
        # the value true the new binding is marked as being subject to deletion.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.
        if self.declarative_record.HasBinding(name):
            raise ESTypeError()
        # 4. Return DclRec.CreateMutableBinding(N, D).
        return self.declarative_record.CreateMutableBinding(name, deletable)

    # 8.1.1.4.3 CreateImmutableBinding ( N, S )
    def CreateImmutableBinding(self, name, strict):
        # The concrete Environment Record method CreateImmutableBinding for global Environment Records creates a new
        # immutable binding for the name N that is uninitialized. A binding must not already exist in this Environment
        # Record for N. If the Boolean argument S has the value true the new binding is marked as a strict binding.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.
        if self.declarative_record.HasBinding(name):
            raise ESTypeError()
        # 4. Return DclRec.CreateImmutableBinding(N, S).
        return self.declarative_record.CreateImmutableBinding(name, strict)

    # 8.1.1.4.4 InitializeBinding ( N, V )
    def InitializeBinding(self, name, value):
        # The concrete Environment Record method InitializeBinding for global Environment Records is used to set the
        # bound value of the current binding of the identifier whose name is the value of the argument N to the value
        # of argument V. An uninitialized binding for N must already exist.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. If DclRec.HasBinding(N) is true, then
        if self.declarative_record.HasBinding(name):
            # a. Return DclRec.InitializeBinding(N, V).
            return self.declarative_record.InitializeBinding(name, value)
        # 4. Assert: If the binding exists, it must be in the object Environment Record.
        # 5. Let ObjRec be envRec.[[ObjectRecord]].
        # 6. Return ? ObjRec.InitializeBinding(N, V).
        return self.object_record.InitializeBinding(name, value)

    # 8.1.1.4.5 SetMutableBinding ( N, V, S )
    def SetMutableBinding(self, name, value, strict):
        # The concrete Environment Record method SetMutableBinding for global Environment Records attempts to change
        # the bound value of the current binding of the identifier whose name is the value of the argument N to the
        # value of argument V. If the binding is an immutable binding, a TypeError is thrown if S is true. A property
        # named N normally already exists but if it does not or is not currently writable, error handling is determined
        # by the value of the Boolean argument S.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. If DclRec.HasBinding(N) is true, then
        if self.declarative_record.HasBinding(name):
            # a. Return DclRec.SetMutableBinding(N, V, S).
            return self.declarative_record.SetMutableBinding(name, value, strict)
        # 4. Let ObjRec be envRec.[[ObjectRecord]].
        # 5. Return ? ObjRec.SetMutableBinding(N, V, S).
        return self.object_record.SetMutableBinding(name, value, strict)

    # 8.1.1.4.6 GetBindingValue ( N, S )
    def GetBindingValue(self, name, strict):
        # The concrete Environment Record method GetBindingValue for global Environment Records returns the value of
        # its bound identifier whose name is the value of the argument N. If the binding is an uninitialized binding
        # throw a ReferenceError exception. A property named N normally already exists but if it does not or is not
        # currently writable, error handling is determined by the value of the Boolean argument S.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. If DclRec.HasBinding(N) is true, then
        if self.declarative_record.HasBinding(name):
            # a. Return DclRec.GetBindingValue(N, S).
            return self.declarative_record.GetBindingValue(name, strict)
        # 4. Let ObjRec be envRec.[[ObjectRecord]].
        # 5. Return ? ObjRec.GetBindingValue(N, S).
        return self.object_record.GetBindingValue(name, strict)

    # 8.1.1.4.7 DeleteBinding ( N )
    def DeleteBinding(self, name):
        # The concrete Environment Record method DeleteBinding for global Environment Records can only delete bindings
        # that have been explicitly designated as being subject to deletion.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. If DclRec.HasBinding(N) is true, then
        if self.declarative_record.HasBinding(name):
            # a. Return DclRec.DeleteBinding(N).
            return self.declarative_record.DeleteBinding(name)
        # 4. Let ObjRec be envRec.[[ObjectRecord]].
        # 5. Let globalObject be the binding object for ObjRec.
        global_object = self.object_record.binding_object
        # 6. Let existingProp be ? HasOwnProperty(globalObject, N).
        existing_prop = HasOwnProperty(global_object, name)
        # 7. If existingProp is true, then
        if existing_prop:
            # a. Let status be ? ObjRec.DeleteBinding(N).
            status = self.object_record.DeleteBinding(name)
            # b. If status is true, then
            if status:
                # i. Let varNames be envRec.[[VarNames]].
                # ii. If N is an element of varNames, remove that element from the varNames.
                try:
                    self.var_names.remove(name)
                except ValueError:
                    pass
            # c. Return status.
            return status
        # 8. Return true.
        return True

    # 8.1.1.4.8 HasThisBinding ( )
    def HasThisBinding(self):
        # Return true.
        return True

    # 8.1.1.4.9 HasSuperBinding ( )
    def HasSuperBinding(self):
        # Return false.
        return False

    # 8.1.1.4.10 WithBaseObject ( )
    def WithBaseObject(self):
        # Global Environment Records always return undefined as their WithBaseObject.
        # Return undefined.
        return None

    # 8.1.1.4.11 GetThisBinding ( )
    def GetThisBinding(self):
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Return envRec.[[GlobalThisValue]].
        return self.global_this_value

    # 8.1.1.4.12 HasVarDeclaration ( N )
    def HasVarDeclaration(self, name):
        # The concrete Environment Record method HasVarDeclaration for global Environment Records determines if the
        # argument identifier has a binding in this record that was created using a VariableStatement or a
        # FunctionDeclaration:
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let varDeclaredNames be envRec.[[VarNames]].
        # 3. If varDeclaredNames contains N, return true.
        # 4. Return false.
        return name in self.var_names

    # 8.1.1.4.13 HasLexicalDeclaration ( N )
    def HasLexicalDeclaration(self, name):
        # The concrete Environment Record method HasLexicalDeclaration for global Environment Records determines if the
        # argument identifier has a binding in this record that was created using a lexical declaration such as a
        # LexicalDeclaration or a ClassDeclaration:
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let DclRec be envRec.[[DeclarativeRecord]].
        # 3. Return DclRec.HasBinding(N).
        return self.declarative_record.HasBinding(name)

    # 8.1.1.4.14 HasRestrictedGlobalProperty ( N )
    def HasRestrictedGlobalProperty(self, name):
        # The concrete Environment Record method HasRestrictedGlobalProperty for global Environment Records determines
        # if the argument identifier is the name of a property of the global object that must not be shadowed by a
        # global lexical binding:
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let ObjRec be envRec.[[ObjectRecord]].
        # 3. Let globalObject be the binding object for ObjRec.
        global_object = self.object_record.binding_object
        # 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
        existing_prop = global_object.GetOwnProperty(name)
        # 5. If existingProp is undefined, return false.
        if isUndefined(existing_prop):
            return False
        # 6. If existingProp.[[Configurable]] is true, return false.
        # 7. Return true.
        return not existing_prop.Configurable
        # NOTE
        # Properties may exist upon a global object that were directly created rather than being declared using a var
        # or function declaration. A global lexical binding may not be created that has the same name as a
        # non-configurable property of the global object. The global property undefined is an example of such a
        # property.

    # 8.1.1.4.15 CanDeclareGlobalVar ( N )
    def CanDeclareGlobalVar(self, name):
        # The concrete Environment Record method CanDeclareGlobalVar for global Environment Records determines if a
        # corresponding CreateGlobalVarBinding call would succeed if called for the same argument N. Redundant var
        # declarations and var declarations for pre-existing global object properties are allowed.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let ObjRec be envRec.[[ObjectRecord]].
        # 3. Let globalObject be the binding object for ObjRec.
        global_object = self.object_record.binding_object
        # 4. Let hasProperty be ? HasOwnProperty(globalObject, N).
        has_property = HasOwnProperty(global_object, name)
        # 5. If hasProperty is true, return true.
        if has_property:
            return True
        # 6. Return ? IsExtensible(globalObject).
        return IsExtensible(global_object)

    # 8.1.1.4.16 CanDeclareGlobalFunction ( N )
    def CanDeclareGlobalFunction(self, name):
        # The concrete Environment Record method CanDeclareGlobalFunction for global Environment Records determines if
        # a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument N.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let ObjRec be envRec.[[ObjectRecord]].
        # 3. Let globalObject be the binding object for ObjRec.
        global_object = self.object_record.binding_object
        # 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
        existing_prop = global_object.GetOwnProperty(name)
        # 5. If existingProp is undefined, return ? IsExtensible(globalObject).
        if isUndefined(existing_prop):
            return IsExtensible(global_object)
        # 6. If existingProp.[[Configurable]] is true, return true.
        if existing_prop.configurable:
            return True
        # 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values { [[Writable]]: true,
        #    [[Enumerable]]: true }, return true.
        if IsDataDescriptor(existing_prop) and existing_prop.writable and existing_prop.enumerable:
            return True
        # 8. Return false.
        return False

    # 8.1.1.4.17 CreateGlobalVarBinding ( N, D )
    def CreateGlobalVarBinding(self, name, deletable):
        # The concrete Environment Record method CreateGlobalVarBinding for global Environment Records creates and
        # initializes a mutable binding in the associated object Environment Record and records the bound name in the
        # associated [[VarNames]] List. If a binding already exists, it is reused and assumed to be initialized.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let ObjRec be envRec.[[ObjectRecord]].
        # 3. Let globalObject be the binding object for ObjRec.
        global_object = self.object_record.binding_object
        # 4. Let hasProperty be ? HasOwnProperty(globalObject, N).
        has_property = HasOwnProperty(global_object, name)
        # 5. Let extensible be ? IsExtensible(globalObject).
        extensible = IsExtensible(global_object)
        # 6. If hasProperty is false and extensible is true, then
        if not has_property and extensible:
            # a. Perform ? ObjRec.CreateMutableBinding(N, D).
            self.object_record.CreateMutableBinding(name, deletable)
            # b. Perform ? ObjRec.InitializeBinding(N, undefined).
            self.object_record.InitializeBinding(name, None)
        # 7. Let varDeclaredNames be envRec.[[VarNames]].
        # 8. If varDeclaredNames does not contain N, then
        if name not in self.var_names:
            # a. Append N to varDeclaredNames.
            self.var_names.append(name)
        # 9. Return NormalCompletion(empty).
        return EMPTY

    # 8.1.1.4.18 CreateGlobalFunctionBinding ( N, V, D )
    def CreateGlobalFunctionBinding(self, name, value, deletable):
        # The concrete Environment Record method CreateGlobalFunctionBinding for global Environment Records creates and
        # initializes a mutable binding in the associated object Environment Record and records the bound name in the
        # associated [[VarNames]] List. If a binding already exists, it is replaced.
        #
        # 1. Let envRec be the global Environment Record for which the method was invoked.
        # 2. Let ObjRec be envRec.[[ObjectRecord]].
        # 3. Let globalObject be the binding object for ObjRec.
        global_object = self.object_record.binding_object
        # 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
        existing_prop = global_object.GetOwnProperty(name)
        # 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then
        if existing_prop is None or existing_prop.configurable:
            # a. Let desc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true,
            #    [[Configurable]]: D }.
            desc = PropertyDescriptor(value=value, writable=True, enumerable=True, configurable=deletable)
        # 6. Else,
        else:
            # a. Let desc be the PropertyDescriptor { [[Value]]: V }.
            desc = PropertyDescriptor(value=value)
        # 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).
        DefinePropertyOrThrow(global_object, name, desc)
        # 8. Record that the binding for N in ObjRec has been initialized.
        # .... object records aren't supposed to need to do this, so I'm not sure where I'm storing this info and when
        # it's used. A problem for later....
        pass
        # 9. Perform ? Set(globalObject, N, V, false).
        Set(global_object, name, value, False)
        # 10. Let varDeclaredNames be envRec.[[VarNames]].
        # 11. If varDeclaredNames does not contain N, then
        if name not in self.var_names:
            # a. Append N to varDeclaredNames.
            self.var_names.append(name)
        # 12. Return NormalCompletion(empty).
        return EMPTY
        # NOTE
        # Global function declarations are always represented as own properties of the global object. If possible, an
        # existing own property is reconfigured to have a standard set of attribute values. Steps 8-9 are equivalent to
        # what calling the InitializeBinding concrete method would do and if globalObject is a Proxy will produce the
        # same sequence of Proxy trap calls.


class LexicalEnvironment:
    pass


# 8.1.2.1 GetIdentifierReference ( lex, name, strict )
def GetIdentifierReference(lex, name, strict):
    # The abstract operation GetIdentifierReference is called with a Lexical Environment lex, a String name, and a
    # Boolean flag strict. The value of lex may be null. When called, the following steps are performed:
    #
    # 1. If lex is the value null, then
    if isNull(lex):
        # a. Return a value of type Reference whose base value component is undefined, whose referenced name component
        #    is name, and whose strict reference flag is strict.
        return Reference(None, name, strict)
    # 2. Let envRec be lex's EnvironmentRecord.
    env_rec = lex.environment_record
    # 3. Let exists be ? envRec.HasBinding(name).
    exists = env_rec.HasBinding(name)
    # 4. If exists is true, then
    if exists:
        # a. Return a value of type Reference whose base value component is envRec, whose referenced name component is
        # name, and whose strict reference flag is strict.
        return Reference(env_rec, name, strict)
    # 5. Else,
    # a. Let outer be the value of lex's outer environment reference.
    outer = lex.outer
    # b. Return ? GetIdentifierReference(outer, name, strict).
    return GetIdentifierReference(outer, name, strict)


# 8.1.2.2 NewDeclarativeEnvironment ( E )
def NewDeclarativeEnvironment(outer):
    # When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the
    # following steps are performed:
    #
    # 1. Let env be a new Lexical Environment.
    env = LexicalEnvironment()
    # 2. Let envRec be a new declarative Environment Record containing no bindings.
    env_rec = DeclarativeEnvironmentRecord()
    # 3. Set env's EnvironmentRecord to envRec.
    env.environment_record = env_rec
    # 4. Set the outer lexical environment reference of env to E.
    env.outer = outer
    # 5. Return env.
    return env


# 8.1.2.3 NewObjectEnvironment ( O, E )
def NewObjectEnvironment(obj, outer):
    # When the abstract operation NewObjectEnvironment is called with an Object O and a Lexical Environment E as
    # arguments, the following steps are performed:
    #
    # 1. Let env be a new Lexical Environment.
    env = LexicalEnvironment()
    # 2. Let envRec be a new object Environment Record containing O as the binding object.
    env_rec = ObjectEnvironmentRecord(obj)
    # 3. Set env's EnvironmentRecord to envRec.
    env.environment_record = env_rec
    # 4. Set the outer lexical environment reference of env to E.
    env.outer = outer
    # 5. Return env.
    return env


# 8.1.2.4 NewFunctionEnvironment ( F, newTarget )
def NewFunctionEnvironment(func, new_target):
    # When the abstract operation NewFunctionEnvironment is called with arguments F and newTarget the following steps
    # are performed:
    #
    # 1. Assert: F is an ECMAScript function.
    # 2. Assert: Type(newTarget) is Undefined or Object.
    assert isUndefined(new_target) or isObject(new_target)
    # 3. Let env be a new Lexical Environment.
    env = LexicalEnvironment()
    # 4. Let envRec be a new function Environment Record containing no bindings.
    env_rec = FunctionEnvironmentRecord()
    # 5. Set envRec.[[FunctionObject]] to F.
    env_rec.function_object = func
    # 6. If F.[[ThisMode]] is lexical, set envRec.[[ThisBindingStatus]] to "lexical".
    if func.ThisMode == LEXICAL:
        env_rec.this_binding_status = "lexical"
    # 7. Else, set envRec.[[ThisBindingStatus]] to "uninitialized".
    else:
        env_rec.this_binding_status = "uninitialized"
    # 8. Let home be F.[[HomeObject]].
    home = func.HomeObject
    # 9. Set envRec.[[HomeObject]] to home.
    env_rec.home_object = home
    # 10. Set envRec.[[NewTarget]] to newTarget.
    env_rec.new_target = new_target
    # 11. Set env's EnvironmentRecord to envRec.
    env.environment_record = env_rec
    # 12. Set the outer lexical environment reference of env to F.[[Environment]].
    env.outer = func.Environment
    # 13. Return env.
    return env


# 8.1.2.5 NewGlobalEnvironment ( G, thisValue )
def NewGlobalEnvironment(global_obj, this_value):
    # When the abstract operation NewGlobalEnvironment is called with arguments G and thisValue, the following steps
    # are performed:
    #
    # 1. Let env be a new Lexical Environment.
    env = LexicalEnvironment()
    # 2. Let objRec be a new object Environment Record containing G as the binding object.
    # 3. Let dclRec be a new declarative Environment Record containing no bindings.
    # 4. Let globalRec be a new global Environment Record.
    # 5. Set globalRec.[[ObjectRecord]] to objRec.
    # 6. Set globalRec.[[GlobalThisValue]] to thisValue.
    # 7. Set globalRec.[[DeclarativeRecord]] to dclRec.
    # 8. Set globalRec.[[VarNames]] to a new empty List.
    global_rec = GlobalEnvironmentRecord(global_obj, this_value)
    # 9. Set env's EnvironmentRecord to globalRec.
    env.environment_record = global_rec
    # 10. Set the outer lexical environment reference of env to null.
    env.outer = JSNull.NULL
    # 11. Return env.
    return env


#######################################################################################################################
#
#  .d8888b.       .d8888b.      8888888b.                    888
# d88P  Y88b     d88P  Y88b     888   Y88b                   888
# Y88b. d88P            888     888    888                   888
#  "Y88888"           .d88P     888   d88P  .d88b.   8888b.  888 88888b.d88b.  .d8888b
# .d8P""Y8b.      .od888P"      8888888P"  d8P  Y8b     "88b 888 888 "888 "88b 88K
# 888    888     d88P"          888 T88b   88888888 .d888888 888 888  888  888 "Y8888b.
# Y88b  d88P d8b 888"           888  T88b  Y8b.     888  888 888 888  888  888      X88
#  "Y8888P"  Y8P 888888888      888   T88b  "Y8888  "Y888888 888 888  888  888  88888P'
#
# Before it is evaluated, all ECMAScript code must be associated with a realm. Conceptually, a realm consists of a set
# of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of
# that global environment, and other associated state and resources.
#
# A realm is represented in this specification as a Realm Record with the fields specified in Table 20:
#
# Table 20: Realm Record Fields
# +------------------+----------------------------------------+------------------------------------------------------
# | Field Name       | Value                                  | Meaning
# +------------------+----------------------------------------+------------------------------------------------------
# | [[Intrinsics]]   | Record whose field names are intrinsic | The intrinsic values used by code associated with
# |                  | keys and whose values are objects      | this realm
# +------------------+----------------------------------------+------------------------------------------------------
# | [[GlobalObject]] | Object                                 | The global object for this realm
# +------------------+----------------------------------------+------------------------------------------------------
# | [[GlobalEnv]]    | Lexical Environment                    | The global environment for this realm
# +------------------+----------------------------------------+------------------------------------------------------
# | [[TemplateMap]]  | A List of Record                       | Template objects are canonicalized separately for
# |                  | { [[Site]]: Parse Node,                | each realm using its Realm Record's [[TemplateMap]].
# |                  |   [[Array]]: Object }.                 | Each [[Site]] value is a Parse Node that is a
# |                  |                                        | TemplateLiteral. The associated [[Array]] value is the
# |                  |                                        | corresponding template object that is passed to a tag
# |                  |                                        | function.
# +------------------+----------------------------------------+------------------------------------------------------
# | [[HostDefined]]  |   Any, default value is undefined.     | Field reserved for use by host environments that need
# |                  |                                        | to associate additional information with a Realm
# |                  |                                        | Record.
# +------------------+----------------------------------------+------------------------------------------------------
#
# NOTE (for [[TemplateMap]])
# Once a Parse Node becomes unreachable, the corresponding [[Array]] is also unreachable, and it would be unobservable
# if an implementation removed the pair from the [[TemplateMap]] list.
#
# 8.2.1 CreateRealm ( )
# 8.2.2 CreateIntrinsics ( realmRec )
# 8.2.3 SetRealmGlobalObject ( realmRec, globalObj, thisValue )
# 8.2.4 SetDefaultGlobalBindings ( realmRec )
#
#########################################################################################################################


class Realm:
    def __init__(self):
        self.intrinsics = {}
        self.global_object = None
        self.global_env = None
        self.template_map = []
        self.host_defined = None


# 8.2.1 CreateRealm ( )
def CreateRealm():
    # The abstract operation CreateRealm with no arguments performs the following steps:
    #   1. Let realmRec be a new Realm Record.
    #   2. Perform CreateIntrinsics(realmRec).
    #   3. Set realmRec.[[GlobalObject]] to undefined.
    #   4. Set realmRec.[[GlobalEnv]] to undefined.
    #   5. Set realmRec.[[TemplateMap]] to a new empty List.
    #   6. Return realmRec.
    realm_rec = Realm()  # Note: Steps 3-5 are done in this constructor
    CreateIntrinsics(realm_rec)
    return realm_rec


def CreateFilledRealm(add_host_defined_globals: Callable[[Realm], None] = lambda x: None):
    realm = CreateRealm()
    SetRealmGlobalObject(realm, None, None)
    SetDefaultGlobalBindings(realm)
    add_host_defined_globals(realm)
    return realm


def internal_throw_type_error(*args, **kwargs):
    raise ESTypeError("type invalid for operation")


# 8.2.2 CreateIntrinsics ( realmRec )
def CreateIntrinsics(realm_rec):
    # The abstract operation CreateIntrinsics with argument realmRec performs the following steps:
    #
    # 1. Let intrinsics be a new Record.
    intrinsics = {}
    # 2. Set realmRec.[[Intrinsics]] to intrinsics.
    realm_rec.intrinsics = intrinsics
    # 3. Let objProto be ObjectCreate(null).
    obj_proto = ObjectCreate(JSNull.NULL)
    # Transform that prototype into an exotic object. See 19.1.3.
    obj_proto.SetPrototypeOf = types.MethodType(SetImmutablePrototype, obj_proto)
    # 4. Set intrinsics.[[%ObjectPrototype%]] to objProto.
    intrinsics["%ObjectPrototype%"] = obj_proto
    # 5. Let throwerSteps be the algorithm steps specified in 9.2.9.1 for the %ThrowTypeError% function.
    thrower_steps = internal_throw_type_error
    # 6. Let thrower be CreateBuiltinFunction(throwerSteps, « », realmRec, null).
    thrower = CreateBuiltinFunction(thrower_steps, [], realm_rec, JSNull.NULL)
    # 7. Set intrinsics.[[%ThrowTypeError%]] to thrower.
    intrinsics["%ThrowTypeError%"] = thrower
    # 8. Let noSteps be an empty sequence of algorithm steps.
    no_steps = lambda *args, **kwargs: None
    # 9. Let funcProto be CreateBuiltinFunction(noSteps, « », realmRec, objProto).
    func_proto = CreateBuiltinFunction(no_steps, [], realm_rec, obj_proto)
    # 10. Set intrinsics.[[%FunctionPrototype%]] to funcProto.
    intrinsics["%FunctionPrototype%"] = func_proto
    # 11. Call thrower.[[SetPrototypeOf]](funcProto).
    thrower.SetPrototypeOf(func_proto)
    # 12. Perform AddRestrictedFunctionProperties(funcProto, realmRec).
    AddRestrictedFunctionProperties(func_proto, realm_rec)
    # 13. Set fields of intrinsics with the values listed in Table 7 that have not already been handled above. The
    #     field names are the names listed in column one of the table. The value of each field is a new object
    #     value fully and recursively populated with property values as defined by the specification of each object
    #     in clauses 18-26. All object property values are newly created object values. All values that are
    #     built-in function objects are created by performing CreateBuiltinFunction(<steps>, <slots>, realmRec,
    #     <prototype>) where <steps> is the definition of that function provided by this specification, <slots> is
    #     a list of the names, if any, of the function's specified internal slots, and <prototype> is the specified
    #     value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties
    #     must be ordered to avoid any dependencies upon objects that have not yet been created.
    Object_establish_intrinsics(realm_rec)
    intrinsics["%Error%"] = CreateErrorConstructor(realm_rec)
    intrinsics["%ErrorPrototype%"] = CreateErrorPrototype(realm_rec)
    ErrorFixups(realm_rec)
    for name in ["Eval", "Range", "Reference", "Syntax", "Type", "URI"]:
        intrinsics[f"%{name}Error%"] = CreateNativeErrorConstructor(realm_rec, name)
        intrinsics[f"%{name}ErrorPrototype%"] = CreateNativeErrorPrototype(realm_rec, name)
    NativeErrorFixups(realm_rec)
    intrinsics["%IteratorPrototype%"] = CreateIteratorPrototype(realm_rec)
    intrinsics["%Boolean%"] = CreateBooleanConstructor(realm_rec)
    intrinsics["%BooleanPrototype%"] = CreateBooleanPrototype(realm_rec)
    BooleanFixups(realm_rec)
    intrinsics["%Number%"] = CreateNumberConstructor(realm_rec)
    intrinsics["%NumberPrototype%"] = CreateNumberPrototype(realm_rec)
    NumberFixups(realm_rec)
    intrinsics["%String%"] = CreateStringConstructor(realm_rec)
    intrinsics["%StringPrototype%"] = CreateStringPrototype(realm_rec)
    StringFixups(realm_rec)
    intrinsics["%Array%"] = CreateArrayConstructor(realm_rec)
    intrinsics["%ArrayPrototype%"] = CreateArrayPrototype(realm_rec)
    ArrayFixups(realm_rec)
    intrinsics["%ArrayIteratorPrototype%"] = CreateArrayIteratorPrototype(realm_rec)
    intrinsics["%Date%"] = CreateDateConstructor(realm_rec)
    intrinsics["%DatePrototype%"] = CreateDatePrototype(realm_rec)
    DateFixups(realm_rec)
    intrinsics["%ArrayBuffer%"] = CreateArrayBufferConstructor(realm_rec)
    intrinsics["%ArrayBufferPrototype%"] = CreateArrayBufferPrototype(realm_rec)
    ArrayBufferFixups(realm_rec)
    intrinsics["%Function%"] = CreateFunctionConstructor(realm_rec)
    FunctionFixups(realm_rec)
    AttachFunctionPrototypeProperties(intrinsics["%FunctionPrototype%"], realm_rec)
    intrinsics["%GeneratorPrototype%"] = CreateGeneratorPrototype(realm_rec)
    intrinsics["%Generator%"] = CreateGeneratorFunctionPrototype(realm_rec)
    intrinsics["%GeneratorFunction%"] = CreateGeneratorFunctionConstructor(realm_rec)
    GeneratorFixups(realm_rec)
    intrinsics["%Reflect%"] = CreateReflectObject(realm_rec)
    intrinsics["%Math%"] = CreateMathObject(realm_rec)
    intrinsics["%RegExp%"] = CreateRegexConstructor(realm_rec)
    intrinsics["%RegExpPrototype%"] = CreateRegExpPrototype(realm_rec)
    RegExpFixups(realm_rec)
    intrinsics["%Symbol%"] = CreateSymbolConstructor(realm_rec)
    intrinsics["%SymbolPrototype%"] = CreateSymbolPrototype(realm_rec)
    SymbolFixups(realm_rec)
    intrinsics["%eval%"] = CreateAnnotatedFunctionObject(realm_rec, global_eval)
    intrinsics["%isFinite%"] = CreateAnnotatedFunctionObject(realm_rec, global_isFinite)
    intrinsics["%isNaN%"] = CreateAnnotatedFunctionObject(realm_rec, global_isNaN)
    intrinsics["%parseInt%"] = CreateAnnotatedFunctionObject(realm_rec, global_parseInt)
    intrinsics["%parseFloat%"] = CreateAnnotatedFunctionObject(realm_rec, global_parseFloat)
    intrinsics["%TypedArray%"] = CreateTypedArrayIntrinsicObject(realm_rec)
    intrinsics["%TypedArrayPrototype%"] = CreateTypedArrayPrototype(realm_rec)
    TypedArrayFixups(realm_rec)
    for name in TA_ElementSize:
        intrinsics[f"%{name}%"] = CreateSpecificTypedArrayConstructor(realm_rec, name)
        intrinsics[f"%{name}Prototype%"] = CreateSpecificTypedArrayPrototype(realm_rec, name)
        SpecificTypedArrayFixups(realm_rec, name)

    # 14. Return intrinsics.
    return intrinsics


# 8.2.3 SetRealmGlobalObject ( realmRec, globalObj, thisValue )
def SetRealmGlobalObject(realm_rec, global_obj, this_value):
    # The abstract operation SetRealmGlobalObject with arguments realmRec, globalObj, and thisValue performs the
    # following steps:
    #
    # 1. If globalObj is undefined, then
    if global_obj is None:
        # a. Let intrinsics be realmRec.[[Intrinsics]].
        intrinsics = realm_rec.intrinsics
        # b. Set globalObj to ObjectCreate(intrinsics.[[%ObjectPrototype%]]).
        global_obj = ObjectCreate(intrinsics["%ObjectPrototype%"])
    # 2. Assert: Type(globalObj) is Object.
    assert isObject(global_obj)
    # 3. If thisValue is undefined, set thisValue to globalObj.
    if this_value is None:
        this_value = global_obj
    # 4. Set realmRec.[[GlobalObject]] to globalObj.
    realm_rec.global_object = global_obj
    # 5. Let newGlobalEnv be NewGlobalEnvironment(globalObj, thisValue).
    new_global_env = NewGlobalEnvironment(global_obj, this_value)
    # 6. Set realmRec.[[GlobalEnv]] to newGlobalEnv.
    realm_rec.global_env = new_global_env
    # 7. Return realmRec.
    return realm_rec


# 8.2.4 SetDefaultGlobalBindings ( realmRec )
def SetDefaultGlobalBindings(realm_rec):
    # The abstract operation SetDefaultGlobalBindings with argument realmRec performs the following steps:
    #
    # 1. Let global be realmRec.[[GlobalObject]].
    globl = realm_rec.global_object
    # 2. For each property of the Global Object specified in clause 18, do
    global_values = [("Infinity", math.inf), ("NaN", math.nan), ("undefined", None)]
    global_intrinsics = [
        "eval",
        "isFinite",
        "isNaN",
        "parseFloat",
        "parseInt",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "Array",
        "ArrayBuffer",
        "Boolean",
        "DataView",
        "Date",
        "Error",
        "EvalError",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Number",
        "Object",
        "Promise",
        "Proxy",
        "RangeError",
        "ReferenceError",
        "RegExp",
        "Set",
        "SharedArrayBuffer",
        "String",
        "Symbol",
        "SyntaxError",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "URIError",
        "WeapMap",
        "WeakSet",
        "Atomics",
        "JSON",
        "Math",
        "Reflect",
    ]
    # @@@ Note: The "if" clause, below, should not be there. It's just to allow this fcn to work even if I haven't
    # implemented everything yet.
    for name, value, writable, enumerable, configurable in chain(
        ((*v, False, False, False) for v in global_values),
        (
            (name, realm_rec.intrinsics["%" + name + "%"], True, False, True)
            for name in global_intrinsics
            if "%" + name + "%" in realm_rec.intrinsics
        ),
    ):
        # a. Let name be the String value of the property name.x
        # b. Let desc be the fully populated data property descriptor for the property containing the specified
        #    attributes for the property. For properties listed in 18.2, 18.3, or 18.4 the value of the [[Value]]
        #    attribute is the corresponding intrinsic object from realmRec.
        # c. Perform ? DefinePropertyOrThrow(global, name, desc).
        desc = PropertyDescriptor(value=value, writable=writable, enumerable=enumerable, configurable=configurable)
        DefinePropertyOrThrow(globl, name, desc)
    # 3. Return global.
    return globl


######################################################################################################################################################################################
#
#  .d8888b.       .d8888b.      8888888888                                     888    d8b                        .d8888b.                    888                      888
# d88P  Y88b     d88P  Y88b     888                                            888    Y8P                       d88P  Y88b                   888                      888
# Y88b. d88P          .d88P     888                                            888                              888    888                   888                      888
#  "Y88888"          8888"      8888888    888  888  .d88b.   .d8888b 888  888 888888 888  .d88b.  88888b.      888         .d88b.  88888b.  888888  .d88b.  888  888 888888 .d8888b
# .d8P""Y8b.          "Y8b.     888        `Y8bd8P' d8P  Y8b d88P"    888  888 888    888 d88""88b 888 "88b     888        d88""88b 888 "88b 888    d8P  Y8b `Y8bd8P' 888    88K
# 888    888     888    888     888          X88K   88888888 888      888  888 888    888 888  888 888  888     888    888 888  888 888  888 888    88888888   X88K   888    "Y8888b.
# Y88b  d88P d8b Y88b  d88P     888        .d8""8b. Y8b.     Y88b.    Y88b 888 Y88b.  888 Y88..88P 888  888     Y88b  d88P Y88..88P 888  888 Y88b.  Y8b.     .d8""8b. Y88b.       X88
#  "Y8888P"  Y8P  "Y8888P"      8888888888 888  888  "Y8888   "Y8888P  "Y88888  "Y888 888  "Y88P"  888  888      "Y8888P"   "Y88P"  888  888  "Y888  "Y8888  888  888  "Y888  88888P'
#
######################################################################################################################################################################################
# 8.3 Execution Contexts
#
# An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript
# implementation. At any point in time, there is at most one execution context per agent that is actually executing
# code. This is known as the agent's running execution context. All references to the running execution context in this
# specification denote the running execution context of the surrounding agent.
#
# The execution context stack is used to track execution contexts. The running execution context is always the top
# element of this stack. A new execution context is created whenever control is transferred from the executable code
# associated with the currently running execution context to executable code that is not associated with that execution
# context. The newly created execution context is pushed onto the stack and becomes the running execution context.
#
# An execution context contains whatever implementation specific state is necessary to track the execution progress of
# its associated code. Each execution context has at least the state components listed in Table 21.
#
# Table 21: State Components for All Execution Contexts
# +-----------------------+---------------------------------------------------------------------------------------------
# | Component             | Purpose
# +-----------------------+---------------------------------------------------------------------------------------------
# | code evaluation state | Any state needed to perform, suspend, and resume evaluation of the code associated with
# |                       | this execution context.
# +-----------------------+---------------------------------------------------------------------------------------------
# | Function              | If this execution context is evaluating the code of a function object, then the value of
# |                       | this component is that function object. If the context is evaluating the code of a Script
# |                       | or Module, the value is null.
# +-----------------------+---------------------------------------------------------------------------------------------
# | Realm                 | The Realm Record from which associated code accesses ECMAScript resources.
# +-----------------------+---------------------------------------------------------------------------------------------
# | ScriptOrModule        | The Module Record or Script Record from which associated code originates. If there is no
# |                       | originating script or module, as is the case for the original execution context created in
# |                       | InitializeHostDefinedRealm, the value is null.
# +-----------------------+---------------------------------------------------------------------------------------------
#
# Evaluation of code by the running execution context may be suspended at various points defined within this
# specification. Once the running execution context has been suspended a different execution context may become the
# running execution context and commence evaluating its code. At some later time a suspended execution context may
# again become the running execution context and continue evaluating its code at the point where it had previously been
# suspended. Transition of the running execution context status among execution contexts usually occurs in stack-like
# last-in/first-out manner. However, some ECMAScript features require non-LIFO transitions of the running execution
# context.
#
# The value of the Realm component of the running execution context is also called the current Realm Record. The value
# of the Function component of the running execution context is also called the active function object.
#
# Execution contexts for ECMAScript code have the additional state components listed in Table 22.
#
# Table 22: Additional State Components for ECMAScript Code Execution Contexts
# +---------------------+-----------------------------------------------------------------------------------------------
# | Component           | Purpose
# +---------------------+-----------------------------------------------------------------------------------------------
# | LexicalEnvironment  | Identifies the Lexical Environment used to resolve identifier references made by code within
# |                     | this execution context.
# +---------------------+-----------------------------------------------------------------------------------------------
# | VariableEnvironment | Identifies the Lexical Environment whose EnvironmentRecord holds bindings created by
# |                     | VariableStatements within this execution context.
# +---------------------+-----------------------------------------------------------------------------------------------
#
# The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments.
#
# Execution contexts representing the evaluation of generator objects have the additional state components listed in
# Table 23.
#
# Table 23: Additional State Components for Generator Execution Contexts
# +-----------+---------------------------------------------------------------------------------------------------------
# | Component | Purpose
# +-----------+---------------------------------------------------------------------------------------------------------
# | Generator | The GeneratorObject that this execution context is evaluating.
# +-----------+---------------------------------------------------------------------------------------------------------
#
# In most situations only the running execution context (the top of the execution context stack) is directly manipulated
# by algorithms within this specification. Hence when the terms “LexicalEnvironment”, and “VariableEnvironment” are
# used without qualification they are in reference to those components of the running execution context.
#
# An execution context is purely a specification mechanism and need not correspond to any particular artefact of an
# ECMAScript implementation. It is impossible for ECMAScript code to directly access or observe an execution context.
class ExecutionContext:
    def __init__(self):
        self.state = None
        self.function = JSNull.NULL
        self.realm = None
        self.script_or_module = JSNull.NULL
        self.lexical_environment = None
        self.variable_environment = None
        self.generator = None
        # The following are "code evaluation state"
        self.is_suspended = False
        # caller = inspect.stack()[1]
        # self.created_by = f"{caller.function} on line {caller.lineno}"

    def suspend(self, on_resume=None):
        self.is_suspended = True

    def resume(self, *args):
        self.is_suspended = False


# 8.3.1 GetActiveScriptOrModule ( )
def GetActiveScriptOrModule():
    # The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the
    # running execution context. GetActiveScriptOrModule performs the following steps:
    #
    # 1. If the execution context stack is empty, return null.
    # 2. Let ec be the topmost execution context on the execution context stack whose ScriptOrModule component is not
    #    null.
    # 3. If no such execution context exists, return null. Otherwise, return ec's ScriptOrModule component.
    for idx in range(len(surrounding_agent.ec_stack) - 1, -1, -1):
        som = surrounding_agent.ec_stack[idx].script_or_module
        if not isNull(som):
            return som
    return JSNull.NULL


# 8.3.2 ResolveBinding ( name [ , env ] )
def ResolveBinding(name, strict, env=None):
    # The ResolveBinding abstract operation is used to determine the binding of name passed as a String value. The
    # optional argument env can be used to explicitly provide the Lexical Environment that is to be searched for the
    # binding. During execution of ECMAScript code, ResolveBinding is performed using the following algorithm:
    #
    # 1. If env is not present or if env is undefined, then
    if env is None:
        # a. Set env to the running execution context's LexicalEnvironment.
        env = surrounding_agent.running_ec.lexical_environment
    # 2. Assert: env is a Lexical Environment.
    assert isinstance(env, LexicalEnvironment)
    # 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let
    #    strict be true, else let strict be false.
    # 4. Return ? GetIdentifierReference(env, name, strict).
    return GetIdentifierReference(env, name, strict)
    # NOTE
    # The result of ResolveBinding is always a Reference value with its referenced name component equal to the name
    # argument.


# 8.3.3 GetThisEnvironment ( )
def GetThisEnvironment():
    # The abstract operation GetThisEnvironment finds the Environment Record that currently supplies the binding of the
    # keyword this. GetThisEnvironment performs the following steps:
    #
    # 1. Let lex be the running execution context's LexicalEnvironment.
    lex = surrounding_agent.running_ec.lexical_environment
    # 2. Repeat,
    while 1:
        # a. Let envRec be lex's EnvironmentRecord.
        env_rec = lex.environment_record
        # b. Let exists be envRec.HasThisBinding().
        exists = env_rec.HasThisBinding()
        # c. If exists is true, return envRec.
        if exists:
            return env_rec
        # d. Let outer be the value of lex's outer environment reference.
        outer = lex.outer
        # e. Assert: outer is not null.
        assert not isNull(outer)
        # f. Set lex to outer.
        lex = outer
    # NOTE
    # The loop in step 2 will always terminate because the list of environments always ends with the global environment
    # which has a this binding.


# 8.3.4 ResolveThisBinding ( )
def ResolveThisBinding():
    # The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment
    # of the running execution context. ResolveThisBinding performs the following steps:
    #
    # 1. Let envRec be GetThisEnvironment().
    env_rec = GetThisEnvironment()
    # 2. Return ? envRec.GetThisBinding().
    return env_rec.GetThisBinding()


# 8.3.5 GetNewTarget ( )
def GetNewTarget():
    # The abstract operation GetNewTarget determines the NewTarget value using the LexicalEnvironment of the running
    # execution context. GetNewTarget performs the following steps:
    #
    # 1. Let envRec be GetThisEnvironment().
    env_rec = GetThisEnvironment()
    # 2. Assert: envRec has a [[NewTarget]] field.
    assert hasattr(env_rec, "new_target")
    # 3. Return envRec.[[NewTarget]].
    return env_rec.new_target


def GetActiveFunction():
    # From the header of section 8.3:
    # The value of the Function component of the running execution context is also called the active function object.
    return surrounding_agent.running_ec.function


# 8.3.6 GetGlobalObject ( )
def GetGlobalObject():
    # The abstract operation GetGlobalObject returns the global object used by the currently running execution context.
    # GetGlobalObject performs the following steps:
    #
    # 1. Let ctx be the running execution context.
    ctx = surrounding_agent.running_ec
    # 2. Let currentRealm be ctx's Realm.
    current_realm = ctx.realm
    # 3. Return currentRealm.[[GlobalObject]].
    return current_realm.global_object


# 8.4 Jobs and Job Queues
#
# A Job is an abstract operation that initiates an ECMAScript computation when no other ECMAScript computation is
# currently in progress. A Job abstract operation may be defined to accept an arbitrary set of job parameters.
#
# Execution of a Job can be initiated only when there is no running execution context and the execution context stack
# is empty. A PendingJob is a request for the future execution of a Job. A PendingJob is an internal Record whose
# fields are specified in Table 24. Once execution of a Job is initiated, the Job always executes to completion. No
# other Job may be initiated until the currently running Job completes. However, the currently running Job or external
# events may cause the enqueuing of additional PendingJobs that may be initiated sometime after completion of the
# currently running Job.
#
# Table 24: PendingJob Record Fields
# +--------------------+----------------------------+------------------------------------------------------------------
# | Field Name         | Value                      | Meaning
# +--------------------+----------------------------+------------------------------------------------------------------
# | [[Job]]            | The name of a Job abstract | This is the abstract operation that is performed when execution
# |                    | operation                  |  of this PendingJob is initiated.
# +--------------------+----------------------------+------------------------------------------------------------------
# | [[Arguments]]      | A List                     | The List of argument values that are to be passed to [[Job]] when
# |                    |                            | it is activated.
# +--------------------+----------------------------+------------------------------------------------------------------
# | [[Realm]]          | A Realm Record             | The Realm Record for the initial execution context when this
# |                    |                            | PendingJob is initiated.
# +--------------------+----------------------------+------------------------------------------------------------------
# | [[ScriptOrModule]] | A Script Record or Module  | The script or module for the initial execution context when this
# |                    | Record                     | PendingJob is initiated.
# +--------------------+----------------------------+------------------------------------------------------------------
# | [[HostDefined]]    | Any, default value is      | Field reserved for use by host environments that need to
# |                    | undefined.                 |  associate additional information with a pending Job.
# +--------------------+----------------------------+------------------------------------------------------------------
#
# A Job Queue is a FIFO queue of PendingJob records. Each Job Queue has a name and the full set of available Job Queues
# are defined by an ECMAScript implementation. Every ECMAScript implementation has at least the Job Queues defined in
# Table 25.
#
# Each agent has its own set of named Job Queues. All references to a named job queue in this specification denote the
# named job queue of the surrounding agent.
#
# Table 25: Required Job Queues
# +-------------+------------------------------------------------------------------------------------------------------
# | Name        | Purpose
# +-------------+------------------------------------------------------------------------------------------------------
# | ScriptJobs  | Jobs that validate and evaluate ECMAScript Script and Module source text. See clauses 10 and 15.
# +-------------+------------------------------------------------------------------------------------------------------
# | PromiseJobs | Jobs that are responses to the settlement of a Promise (see 25.6).
# +-------------+------------------------------------------------------------------------------------------------------
#
# A request for the future execution of a Job is made by enqueueing, on a Job Queue, a PendingJob record that includes
# a Job abstract operation name and any necessary argument values. When there is no running execution context and the
# execution context stack is empty, the ECMAScript implementation removes the first PendingJob from a Job Queue and
# uses the information contained in it to create an execution context and starts execution of the associated Job
# abstract operation.
#
# The PendingJob records from a single Job Queue are always initiated in FIFO order. This specification does not define
# the order in which multiple Job Queues are serviced. An ECMAScript implementation may interweave the FIFO evaluation
# of the PendingJob records of a Job Queue with the evaluation of the PendingJob records of one or more other Job
# Queues. An implementation must define what occurs when there are no running execution context and all Job Queues are
# empty.
#
# NOTE
# Typically an ECMAScript implementation will have its Job Queues pre-initialized with at least one PendingJob and one
# of those Jobs will be the first to be executed. An implementation might choose to free all resources and terminate if
# the current Job completes and all Job Queues are empty. Alternatively, it might choose to wait for a some
# implementation specific agent or mechanism to enqueue new PendingJob requests.

# 8.4.1 EnqueueJob ( queueName, job, arguments )
def EnqueueJob(queue_name, job, arguments):
    # The EnqueueJob abstract operation requires three arguments: queueName, job, and arguments. It performs the
    # following steps:
    #
    # 1. Assert: Type(queueName) is String and its value is the name of a Job Queue recognized by this implementation.
    assert isString(queue_name)
    # 2. Assert: job is the name of a Job.
    # 3. Assert: arguments is a List that has the same number of elements as the number of parameters required by job.
    # 4. Let callerContext be the running execution context.
    caller_context = surrounding_agent.running_ec
    # 5. Let callerRealm be callerContext's Realm.
    caller_realm = caller_context.realm
    # 6. Let callerScriptOrModule be callerContext's ScriptOrModule.
    caller_script_or_module = caller_context.script_or_module
    # 7. Let pending be PendingJob { [[Job]]: job, [[Arguments]]: arguments, [[Realm]]: callerRealm,
    #    [[ScriptOrModule]]: callerScriptOrModule, [[HostDefined]]: undefined }.
    pending = Record(
        job=job, arguments=arguments, realm=caller_realm, script_or_module=caller_script_or_module, host_defined=None
    )
    # 8. Perform any implementation or host environment defined processing of pending. This may include modifying the
    #    [[HostDefined]] field or any other field of pending.
    # 9. Add pending at the back of the Job Queue named by queueName.
    surrounding_agent.job_queues[queue_name].append(pending)
    # 10. Return NormalCompletion(empty).
    return EMPTY


# 8.5 InitializeHostDefinedRealm ( )
def InitializeHostDefinedRealm(add_host_defined_globals: Callable[[Realm], None] = lambda x: None):
    # The abstract operation InitializeHostDefinedRealm performs the following steps:
    #
    # 1. Let realm be CreateRealm().
    realm = CreateRealm()
    # 2. Let newContext be a new execution context.
    new_context = ExecutionContext()
    # 3. Set the Function of newContext to null.
    new_context.function = JSNull.NULL
    # 4. Set the Realm of newContext to realm.
    new_context.realm = realm
    # 5. Set the ScriptOrModule of newContext to null.
    new_context.script_or_module = JSNull.NULL
    # 6. Push newContext onto the execution context stack; newContext is now the running execution context.
    surrounding_agent.ec_stack.append(new_context)
    surrounding_agent.running_ec = new_context
    # 7. If the host requires use of an exotic object to serve as realm's global object, let global be such an object
    #    created in an implementation-defined manner. Otherwise, let global be undefined, indicating that an ordinary
    #    object should be created as the global object.
    global_exotic = None
    # 8. If the host requires that the this binding in realm's global scope return an object other than the global
    #    object, let thisValue be such an object created in an implementation-defined manner. Otherwise, let thisValue
    #    be undefined, indicating that realm's global this binding should be the global object.
    this_value = None
    # 9. Perform SetRealmGlobalObject(realm, global, thisValue).
    SetRealmGlobalObject(realm, global_exotic, this_value)
    # 10. Let globalObj be ? SetDefaultGlobalBindings(realm).
    SetDefaultGlobalBindings(realm)
    # 11. Create any implementation-defined global object properties on globalObj.
    # (Assign the prior to a var and edit the object) Gonna want to add things like "console" here...
    add_host_defined_globals(realm)
    # 12. Return NormalCompletion(empty).
    return EMPTY


# 8.6 RunJobs
def RunJobs(scripts=[], modules=[], add_host_defined_globals: Callable[[Realm], None] = lambda x: None):
    # 1. Perform ? InitializeHostDefinedRealm().
    InitializeHostDefinedRealm(add_host_defined_globals)
    # 2. In an implementation-dependent manner, obtain the ECMAScript source texts (see clause 10) and any
    #    associated host-defined values for zero or more ECMAScript scripts and/or ECMAScript modules.
    host_defined = None
    #    For each such sourceText and hostDefined, do
    #        a. If sourceText is the source code of a script, then
    #            i. Perform EnqueueJob("ScriptJobs", ScriptEvaluationJob, « sourceText, hostDefined »).
    #        b. Else sourceText is the source code of a module,
    #            i. Perform EnqueueJob("ScriptJobs", TopLevelModuleEvaluationJob, « sourceText, hostDefined »).
    for source_text in modules:
        EnqueueJob("ScriptJobs", TopLevelModuleEvaluationJob, [source_text, host_defined])
    for source_text in scripts:
        EnqueueJob("ScriptJobs", ScriptEvaluationJob, [source_text, host_defined])
    # 3. Repeat,
    while 1:
        # a. Suspend the running execution context and remove it from the execution context stack.
        surrounding_agent.running_ec.suspend()
        surrounding_agent.running_ec = None
        surrounding_agent.ec_stack.pop()  # discarding the result
        # b. Assert: The execution context stack is now empty.
        assert len(surrounding_agent.ec_stack) == 0
        # c. Let nextQueue be a non-empty Job Queue chosen in an implementation-defined manner. If all Job Queues are
        #    empty, the result is implementation-defined.
        non_empty_job_queues = [name for name, queue in surrounding_agent.job_queues.items() if len(queue) > 0]
        if len(non_empty_job_queues) == 0:
            break
        next_queue = random.choice(non_empty_job_queues)
        # d. Let nextPending be the PendingJob record at the front of nextQueue. Remove that record from nextQueue.
        next_pending = surrounding_agent.job_queues[next_queue].popleft()
        # e. Let newContext be a new execution context.
        new_context = ExecutionContext()
        # f. Set newContext's Function to null.
        new_context.function = JSNull.NULL
        # g. Set newContext's Realm to nextPending.[[Realm]].
        new_context.realm = next_pending.realm
        # h. Set newContext's ScriptOrModule to nextPending.[[ScriptOrModule]].
        new_context.script_or_module = next_pending.script_or_module
        # i. Push newContext onto the execution context stack; newContext is now the running execution context.
        surrounding_agent.ec_stack.append(new_context)
        surrounding_agent.running_ec = new_context
        # j. Perform any implementation or host environment defined job initialization using nextPending.
        # (Nothing yet.)
        # k. Let result be the result of performing the abstract operation named by nextPending.[[Job]] using the
        #    elements of nextPending.[[Arguments]] as its arguments.
        try:
            result = (next_pending.job)(*next_pending.arguments)
        except ESError as err:
            # l. If result is an abrupt completion, perform HostReportErrors(« result.[[Value]] »).
            HostReportErrors([err.ecma_object])
            result = None
    return result


# 8.7 Agents

# An agent comprises a set of ECMAScript execution contexts, an execution context stack, a running execution context, a
# set of named job queues, an Agent Record, and an executing thread. Except for the executing thread, the constituents
# of an agent belong exclusively to that agent.

# An agent's executing thread executes the jobs in the agent's job queues on the agent's execution contexts
# independently of other agents, except that an executing thread may be used as the executing thread by multiple
# agents, provided none of the agents sharing the thread have an Agent Record whose [[CanBlock]] property is true.

# While an agent's executing thread executes the jobs in the agent's job queues, the agent is the surrounding agent
# for the code in those jobs. The code uses the surrounding agent to access the specification level execution objects
# held within the agent: the running execution context, the execution context stack, the named job queues, and the
# Agent Record's fields.
class AgentRecord(object):
    def __init__(self) -> None:
        self.little_endian = True
        self.can_block = True  # as a first guess
        self.signifier = uuid.uuid4()
        self.is_lock_free_1 = True
        self.is_lock_free_2 = True


class Agent(object):
    def __init__(self) -> None:
        self.ec_stack: List[Any]
        self.ec_stack = []  # For this stack, add with "append", remove with "pop". (LIFO)
        self.running_ec = None
        self.job_queues: Mapping[str, Deque[Any]]
        self.job_queues = {  # For these queues, add with "append", remove with "popleft". (FIFO)
            "ScriptJobs": deque([]),
            "PromiseJobs": deque([]),
        }
        self.agent_record = AgentRecord()
        random.seed()  # Probably should store random state in the agent, but: meh.


# Global: the "surrounding agent". (We only have one agent, so it's always the surrounding agent.)
surrounding_agent: Agent
surrounding_agent = Agent()

# 8.7.1 AgentSignifier()
def AgentSignifier() -> uuid.UUID:
    # The abstract operation AgentSignifier takes no arguments. It performs the following steps:
    # 1. Let AR be the Agent Record of the surrounding agent.
    AR = surrounding_agent.agent_record
    # 2. Return AR.[[Signifier]].
    return AR.signifier


# 8.7.2 AgentCanSuspend()
def AgentCanSuspend() -> bool:
    # The abstract operation AgentCanSuspend takes no arguments. It performs the following steps:
    # 1. Let AR be the Agent Record of the surrounding agent.
    AR = surrounding_agent.agent_record
    # 2. Return AR.[[CanBlock]].
    return AR.can_block
    # NOTE: In some environments it may not be reasonable for a given agent to suspend. For example, in a
    # web browser environment, it may be reasonable to disallow suspending a document's main event
    # handling thread, while still allowing workers' event handling threads to suspend.


def connect_JSObject_methods(cls):
    if hasattr(cls, "GetPrototypeOf"):
        return

    # 9.1.1 [[GetPrototypeOf]] ( )
    def GetPrototypeOf(self):
        """Determine the object that provides inherited properties for this object. A null value indicates that there are no
           inherited properties."""
        # 1. Return O.[[Prototype]].
        return self.Prototype

    cls.GetPrototypeOf = GetPrototypeOf

    # 9.1.2 [[SetPrototypeOf]] ( V )
    def SetPrototypeOf(self, value):
        """Associate this object with another object that provides inherited properties. Passing null indicates that there are
           no inherited properties. Returns true indicating that the operation was completed successfully or false indicating
           that the operation was not successful."""
        # When the abstract operation OrdinarySetPrototypeOf is called with Object O and value V, the following steps
        # are taken:
        # 1. Assert: Either Type(V) is Object or Type(V) is Null.
        assert isObject(value) or isNull(value)
        # 2. Let extensible be O.[[Extensible]].
        extensible = self.Extensible
        # 3. Let current be O.[[Prototype]].
        current = self.Prototype
        # 4. If SameValue(V, current) is true, return true.
        if SameValue(value, current):
            return True
        # 5. If extensible is false, return false.
        if not extensible:
            return False
        # 6. Let p be V.
        p = value
        # 7. Let done be false.
        done = False
        # 8. Repeat, while done is false,
        while not done:
            # a. If p is null, set done to true.
            if isNull(p):
                done = True
            # b. Else if SameValue(p, O) is true, return false.
            elif SameValue(p, self):
                return False
            # c. Else,
            else:
                # i. If p.[[GetPrototypeOf]] is not the ordinary object internal method defined in 9.1.1, set done to
                #    true.
                if p.GetPrototypeOf.__func__ != cls.GetPrototypeOf:
                    done = True
                # ii. Else, set p to p.[[Prototype]].
                else:
                    p = p.Prototype
        # 9. Set O.[[Prototype]] to V.
        self.Prototype = value
        # 10. Return true.
        return True
        # NOTE
        # The loop in step 8 guarantees that there will be no circularities in any prototype chain that only includes
        # objects that use the ordinary object definitions for [[GetPrototypeOf]] and [[SetPrototypeOf]].

    cls.SetPrototypeOf = SetPrototypeOf

    # 9.1.3 [[IsExtensible]] ( )
    def IsExtensible(self):
        """Determine whether it is permitted to add additional properties to this object."""
        # 1. Return O.[[Extensible]].
        return self.Extensible

    cls.IsExtensible = IsExtensible

    # 9.1.4 [[PreventExtensions]] ( )
    def PreventExtensions(self):
        """Control whether new properties may be added to this object. Returns true if the operation was successful or false if
           the operation was unsuccessful."""
        # 1. Set O.[[Extensible]] to false.
        self.Extensible = False
        # 2. Return true.
        return True

    cls.PreventExtensions = PreventExtensions

    # 9.1.5 [[GetOwnProperty]] ( P )
    def GetOwnProperty(self, propkey):
        """Return a Property Descriptor for the own property of this object whose key is propertyKey, or undefined if no such
           property exists."""
        return OrdinaryGetOwnProperty(self, propkey)

    cls.GetOwnProperty = GetOwnProperty

    # 9.1.6 [[DefineOwnProperty]] ( P, Desc )
    def DefineOwnProperty(self, propkey, desc):
        """Create or alter the own property, whose key is propertyKey, to have the state described by PropertyDescriptor.
           Return true if that property was successfully created/updated or false if the property could not be created or
           updated."""
        return OrdinaryDefineOwnProperty(self, propkey, desc)

    cls.DefineOwnProperty = DefineOwnProperty

    # 9.1.7 [[HasProperty]] ( P )
    def HasProperty(self, propkey):
        """Return a Boolean value indicating whether this object already has either an own or inherited property whose key is
           propertyKey."""
        return OrdinaryHasProperty(self, propkey)

    cls.HasProperty = HasProperty

    # 9.1.8 [[Get]] ( P, Receiver )
    def Get(self, propkey, receiver):
        """Return the value of the property whose key is propertyKey from this object. If any ECMAScript code must be executed
           to retrieve the property value, Receiver is used as the this value when evaluating the code."""
        return OrdinaryGet(self, propkey, receiver)

    cls.Get = Get

    # 9.1.9 [[Set]] ( P, V, Receiver )
    def Set(self, propkey, value, receiver):
        """Set the value of the property whose key is propertyKey to value. If any ECMAScript code must be executed to set the
           property value, Receiver is used as the this value when evaluating the code. Returns true if the property value was
           set or false if it could not be set."""
        # When the [[Set]] internal method of O is called with property key P, value V, and ECMAScript language value
        # Receiver, the following steps are taken:
        #
        # 1. Return ? OrdinarySet(O, P, V, Receiver).
        return OrdinarySet(self, propkey, value, receiver)

    cls.Set = Set

    # 9.1.10 [[Delete]] ( P )
    def Delete(self, propkey):
        """Remove the own property whose key is propertyKey from this object. Return false if the property was not deleted and
           is still present. Return true if the property was deleted or is not present."""
        # When the [[Delete]] internal method of O is called with property key P, the following steps are taken:
        #
        # 1. Return ? OrdinaryDelete(O, P).
        return OrdinaryDelete(self, propkey)

    cls.Delete = Delete

    # 9.1.11 [[OwnPropertyKeys]] ( )
    def OwnPropertyKeys(self):
        """Return a List whose elements are all of the own property keys for the object."""
        # When the [[OwnPropertyKeys]] internal method of O is called, the following steps are taken:
        #
        # 1. Return ! OrdinaryOwnPropertyKeys(O).
        return OrdinaryOwnPropertyKeys(self)

    cls.OwnPropertyKeys = OwnPropertyKeys


connect_JSObject_methods(JSObject)

# 9.1.5.1 OrdinaryGetOwnProperty ( O, P )
def OrdinaryGetOwnProperty(obj, propkey):
    # When the abstract operation OrdinaryGetOwnProperty is called with Object O and with property key P, the following steps
    # are taken:
    #
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 2. If O does not have an own property with key P, return undefined.
    if propkey not in obj.properties:
        return None
    # 3. Let D be a newly created Property Descriptor with no fields.
    desc = PropertyDescriptor()
    # 4. Let X be O's own property whose key is P.
    own = obj.properties[propkey]
    # 5. If X is a data property, then
    if hasattr(own, "value"):
        # a. Set D.[[Value]] to the value of X's [[Value]] attribute.
        desc.value = own.value
        # b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.
        desc.writable = own.writable
    # 6. Else X is an accessor property,
    else:
        # a. Set D.[[Get]] to the value of X's [[Get]] attribute.
        desc.Get = own.Get
        # b. Set D.[[Set]] to the value of X's [[Set]] attribute.
        desc.Set = own.Set
    # 7. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.
    desc.enumerable = own.enumerable
    # 8. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.
    desc.configurable = own.configurable
    # 9. Return D.
    return desc


# 9.1.6.1 OrdinaryDefineOwnProperty ( O, P, Desc )
def OrdinaryDefineOwnProperty(obj, propkey, desc):
    # When the abstract operation OrdinaryDefineOwnProperty is called with Object O, property key P, and Property Descriptor
    # Desc, the following steps are taken:
    #
    # 1. Let current be ? O.[[GetOwnProperty]](P).
    current = obj.GetOwnProperty(propkey)
    # 2. Let extensible be O.[[Extensible]].
    extensible = obj.Extensible
    # 3. Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).
    return ValidateAndApplyPropertyDescriptor(obj, propkey, extensible, desc, current)


# 9.1.6.2 IsCompatiblePropertyDescriptor ( Extensible, Desc, Current )
def IsCompatiblePropertyDescriptor(Extensible, Desc, Current):
    # When the abstract operation IsCompatiblePropertyDescriptor is called with Boolean value Extensible, and Property
    # Descriptors Desc, and Current, the following steps are taken:
    #
    #   1. Return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current).
    return ValidateAndApplyPropertyDescriptor(None, None, Extensible, Desc, Current)


# 9.1.6.3 ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current )
def ValidateAndApplyPropertyDescriptor(obj, propkey, extensible, desc, current):
    # When the abstract operation ValidateAndApplyPropertyDescriptor is called with Object O, property key P, Boolean
    # value extensible, and Property Descriptors Desc, and current, the following steps are taken:
    #
    # NOTE
    # If undefined is passed as O, only validation is performed and no object updates are performed.
    #
    # 1. Assert: If O is not undefined, then IsPropertyKey(P) is true.
    assert obj is None or IsPropertyKey(propkey)
    # 2. If current is undefined, then
    if current is None:
        # a. If extensible is false, return false.
        if not extensible:
            return False
        # b. Assert: extensible is true.
        # c. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then
        if IsDataDescriptor(desc) or IsGenericDescriptor(desc):
            # i. If O is not undefined, create an own data property named P of object O whose [[Value]], [[Writable]],
            #    [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an
            #    attribute field of Desc is absent, the attribute of the newly created property is set to its default
            #    value.
            if obj is not None:
                newprop = JSObject.Property(
                    value=desc.value if hasattr(desc, "value") else None,
                    writable=desc.writable if hasattr(desc, "writable") else False,
                    enumerable=desc.enumerable if hasattr(desc, "enumerable") else False,
                    configurable=desc.configurable if hasattr(desc, "configurable") else False,
                )
                obj.properties[propkey] = newprop
        # d. Else Desc must be an accessor Property Descriptor,
        else:
            # i. If O is not undefined, create an own accessor property named P of object O whose [[Get]], [[Set]],
            #    [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an
            #    attribute field of Desc is absent, the attribute of the newly created property is set to its default
            #    value.
            if obj is not None:
                newprop = JSObject.Property(
                    Get=desc.Get if hasattr(desc, "Get") else None,
                    Set=desc.Set if hasattr(desc, "Set") else None,
                    enumerable=desc.enumerable if hasattr(desc, "enumerable") else False,
                    configurable=desc.configurable if hasattr(desc, "configurable") else False,
                )
                obj.properties[propkey] = newprop
        # e. Return true.
        return True
    # 3. If every field in Desc is absent, return true.
    if not any(hasattr(desc, field) for field in ["value", "writable", "Get", "Set", "enumerable", "configurable"]):
        return True
    # 4. If current.[[Configurable]] is false, then
    if not current.configurable:
        # a. If Desc.[[Configurable]] is present and its value is true, return false.
        if hasattr(desc, "configurable") and desc.configurable:
            return False
        # b. If Desc.[[Enumerable]] is present and the [[Enumerable]] fields of current and Desc are the Boolean
        #    negation of each other, return false.
        if hasattr(desc, "enumerable") and desc.enumerable != current.enumerable:
            return False
    # 5. If IsGenericDescriptor(Desc) is true, no further validation is required.
    if IsGenericDescriptor(desc):
        pass
    # 6. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
    elif IsDataDescriptor(current) != IsDataDescriptor(desc):
        # a. If current.[[Configurable]] is false, return false.
        if not current.configurable:
            return False
        # b. If IsDataDescriptor(current) is true, then
        if IsDataDescriptor(current):
            # i. If O is not undefined, convert the property named P of object O from a data property to an accessor
            #    property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]]
            #    attributes and set the rest of the property's attributes to their default values.
            if obj is not None:
                obj.properties[propkey].Get = None
                obj.properties[propkey].Set = None
                del obj.properties[propkey].value
                del obj.properties[propkey].writable
        # c. Else,
        else:
            # i. If O is not undefined, convert the property named P of object O from an accessor property to a data
            #    property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]]
            #    attributes and set the rest of the property's attributes to their default values.
            if obj is not None:
                obj.properties[propkey].value = None
                obj.properties[propkey].writable = False
                del obj.properties[propkey].Get
                del obj.properties[propkey].Set
    # 7. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
    elif IsDataDescriptor(current) and IsDataDescriptor(desc):
        # a. If current.[[Configurable]] is false and current.[[Writable]] is false, then
        if not current.configurable and not current.writable:
            # i. If Desc.[[Writable]] is present and Desc.[[Writable]] is true, return false.
            if hasattr(desc, "writable") and desc.writable:
                return False
            # ii. If Desc.[[Value]] is present and SameValue(Desc.[[Value]], current.[[Value]]) is false, return false.
            if hasattr(desc, "value") and not SameValue(desc.value, current.value):
                return False
            # iii. Return true.
            return True
    # 8. Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,
    else:
        # a. If current.[[Configurable]] is false, then
        if not current.configurable:
            # i. If Desc.[[Set]] is present and SameValue(Desc.[[Set]], current.[[Set]]) is false, return false.
            if hasattr(desc, "Set") and not SameValue(desc.Set, current.Set):
                return False
            # ii. If Desc.[[Get]] is present and SameValue(Desc.[[Get]], current.[[Get]]) is false, return false.
            if hasattr(desc, "Get") and not SameValue(desc.Get, current.Get):
                return False
            # iii. Return true.
            return True
    # 9. If O is not undefined, then
    if obj is not None:
        # a. For each field of Desc that is present, set the corresponding attribute of the property named P of object
        #    O to the value of the field.
        for fieldname in (
            f for f in ["value", "writable", "Get", "Set", "configurable", "enumerable"] if hasattr(desc, f)
        ):
            setattr(obj.properties[propkey], fieldname, getattr(desc, fieldname))
    # 10. Return true.
    return True


# 9.1.7.1 OrdinaryHasProperty ( O, P )
def OrdinaryHasProperty(O, propkey):
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 2. Let hasOwn be ? O.[[GetOwnProperty]](P).
    has_own = O.GetOwnProperty(propkey)
    # 3. If hasOwn is not undefined, return true.
    if has_own is not None:
        return True
    # 4. Let parent be ? O.[[GetPrototypeOf]]().
    parent = O.GetPrototypeOf()
    # 5. If parent is not null, then
    #    a. Return ? parent.[[HasProperty]](P).
    # 6. Return false.
    return not isNull(parent) and parent.HasProperty(propkey)


# 9.1.8.1 OrdinaryGet ( O, P, Receiver )
def OrdinaryGet(obj, propkey, receiver):
    # When the abstract operation OrdinaryGet is called with Object O, property key P, and ECMAScript language
    # value Receiver, the following steps are taken:
    #
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 2. Let desc be ? O.[[GetOwnProperty]](P).
    desc = obj.GetOwnProperty(propkey)
    # 3. If desc is undefined, then
    if desc is None:
        # a. Let parent be ? O.[[GetPrototypeOf]]().
        parent = obj.GetPrototypeOf()
        # b. If parent is null, return undefined.
        if isNull(parent):
            return None
        # c. Return ? parent.[[Get]](P, Receiver).
        return parent.Get(propkey, receiver)
    # 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].
    if desc.is_data_descriptor():
        return desc.value
    # 5. Assert: IsAccessorDescriptor(desc) is true.
    assert desc.is_accessor_descriptor()
    # 6. Let getter be desc.[[Get]].
    getter = desc.Get
    # 7. If getter is undefined, return undefined.
    if getter is None:
        return None
    # 8. Return ? Call(getter, Receiver).
    return Call(getter, receiver)


# 9.1.9.1 OrdinarySet ( O, P, V, Receiver )
def OrdinarySet(obj, propkey, value, receiver):
    # When the abstract operation OrdinarySet is called with Object O, property key P, value V, and ECMAScript language
    # value Receiver, the following steps are taken:
    #
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 2. Let ownDesc be ? O.[[GetOwnProperty]](P).
    own_desc = obj.GetOwnProperty(propkey)
    # 3. Return OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc).
    return OrdinarySetWithOwnDescriptor(obj, propkey, value, receiver, own_desc)


# 9.1.9.2 OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )
def OrdinarySetWithOwnDescriptor(obj, propkey, value, receiver, own_desc):
    # When the abstract operation OrdinarySetWithOwnDescriptor is called with Object O, property key P, value V,
    # ECMAScript language value Receiver, and Property Descriptor (or undefined) ownDesc, the following steps are
    # taken:
    #
    # 1. Assert: IsPropertyKey(P) is true.
    assert IsPropertyKey(propkey)
    # 2. If ownDesc is undefined, then
    if own_desc is None:
        # a. Let parent be ? O.[[GetPrototypeOf]]().
        parent = obj.GetPrototypeOf()
        # b. If parent is not null, then
        if not isNull(parent):
            # i. Return ? parent.[[Set]](P, V, Receiver).
            return parent.Set(propkey, value, receiver)
        # c. Else,
        else:
            # i. Set ownDesc to the PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true,
            #    [[Enumerable]]: true, [[Configurable]]: true }.
            own_desc = PropertyDescriptor()
            own_desc.value = None
            own_desc.writable = True
            own_desc.enumerable = True
            own_desc.configurable = True
    # 3. If IsDataDescriptor(ownDesc) is true, then
    if own_desc.is_data_descriptor():
        # a. If ownDesc.[[Writable]] is false, return false.
        if not own_desc.writable:
            return False
        # b. If Type(Receiver) is not Object, return false.
        if not isObject(receiver):
            return False
        # c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
        existing_descriptor = receiver.GetOwnProperty(propkey)
        # d. If existingDescriptor is not undefined, then
        if existing_descriptor is not None:
            # i. If IsAccessorDescriptor(existingDescriptor) is true, return false.
            if existing_descriptor.is_accessor_descriptor():
                return False
            # ii. If existingDescriptor.[[Writable]] is false, return false.
            if not existing_descriptor.writable:
                return False
            # iii. Let valueDesc be the PropertyDescriptor { [[Value]]: V }.
            value_desc = PropertyDescriptor()
            value_desc.value = value
            # iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
            return receiver.DefineOwnProperty(propkey, value_desc)
        # e. Else Receiver does not currently have a property P,
        else:
            # i. Return ? CreateDataProperty(Receiver, P, V).
            return CreateDataProperty(receiver, propkey, value)
    # 4. Assert: IsAccessorDescriptor(ownDesc) is true.
    assert own_desc.is_accessor_descriptor()
    # 5. Let setter be ownDesc.[[Set]].
    setter = own_desc.Set
    # 6. If setter is undefined, return false.
    if setter is None:
        return False
    # 7. Perform ? Call(setter, Receiver, « V »).
    Call(setter, receiver, [value])
    # 8. Return true.
    return True


# 9.1.10.1 OrdinaryDelete ( O, P )
def OrdinaryDelete(obj, propkey):
    # When the abstract operation OrdinaryDelete is called with Object O and property key P, the following steps are
    # taken:
    #
    assert IsPropertyKey(propkey)  # 1. Assert: IsPropertyKey(P) is true.
    desc = obj.GetOwnProperty(propkey)  # 2. Let desc be ? O.[[GetOwnProperty]](P).
    if desc is None:  # 3. If desc is undefined, return true.
        return True  #
    if desc.configurable:  # 4. If desc.[[Configurable]] is true, then
        del obj.properties[propkey]  #    a. Remove the own property with name P from O.
        return True  #    b. Return true.
    return False  # 5. Return false.


def isIntegerIndex(key):
    # An integer index is a String-valued property key that is a canonical numeric String (see 7.1.16) and whose
    # numeric value is either +0 or a positive integer ≤ 2^53-1.
    if not isString(key):
        return False
    n = CanonicalNumericIndexString(key)
    return n is not None and IsInteger(n) and math.copysign(1.0, n) == 1.0 and n <= 2 ** 53 - 1


# 9.1.11.1 OrdinaryOwnPropertyKeys ( O )
def OrdinaryOwnPropertyKeys(obj):
    # When the abstract operation OrdinaryOwnPropertyKeys is called with Object O, the following steps are taken:
    #
    # 1. Let keys be a new empty List.
    keys = []
    # 2. For each own property key P of O that is an integer index, in ascending numeric index order, do
    index_keys = [key for key in obj.properties.keys() if isIntegerIndex(key)]
    index_keys.sort(key=lambda k: CanonicalNumericIndexString(k))
    for p in index_keys:
        # a. Add P as the last element of keys.
        keys.append(p)
    # 3. For each own property key P of O that is a String but is not an integer index, in ascending chronological
    # order of property creation, do
    for p in (key for key in obj.properties.keys() if isString(key) and not isIntegerIndex(key)):
        # a. Add P as the last element of keys.
        keys.append(p)
    # 4. For each own property key P of O that is a Symbol, in ascending chronological order of property creation, do
    for p in (key for key in obj.properties.keys() if isSymbol(key)):
        # a. Add P as the last element of keys.
        keys.append(p)
    # 5. Return keys.
    return keys


# 9.1.12 ObjectCreate ( proto [ , internalSlotsList ] )
def ObjectCreate(proto, internal_slots_list=[]):
    """Creates a new ECMAScript object.

    Arguments:
       proto: This is the object's prototype, and is stored in the internal
           [[Prototype]] slot.
       internal_slots_list: This is a list of strings which are additional "slots"
           to add to the object. They share the same namespace as the rest of the
           object's internal members, so please tread lightly. (Adding "Prototype"
           to the list, for instance, while not necessarily harmful, does **not**
           mean that there are now two [[Prototype]] slots. There's still only one.)

    Returns the created object.

    The object is an "ordinary" object, in that it inherits all the standard
    internal object methods.

    The object is also marked as Extensible; that is: additional properties may be
    added to it. If this is not desired, use the [[PreventExtensions]] method to
    disable further changes. (A typical use case is to expand as you need during
    initialization and then prevent further changes.)

    This function is defined in section 9.1.12 of the ECMAScript specification.
    """
    # The abstract operation ObjectCreate with argument proto (an object or null) is used to specify the runtime
    # creation of new ordinary objects. The optional argument internalSlotsList is a List of the names of additional
    # internal slots that must be defined as part of the object. If the list is not provided, a new empty List is used.
    # This abstract operation performs the following steps:
    #
    # 1. If internalSlotsList is not present, set internalSlotsList to a new empty List.
    # 2. Let obj be a newly created object with an internal slot for each name in internalSlotsList.
    obj = JSObject()
    for name in internal_slots_list:
        setattr(obj, name, None)
    # 3. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
    connect_JSObject_methods(JSObject)
    # 4. Set obj.[[Prototype]] to proto.
    obj.Prototype = proto
    # 5. Set obj.[[Extensible]] to true.
    obj.Extensible = True
    # 6. Return obj.
    return obj


# 9.1.13 OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] )
def OrdinaryCreateFromConstructor(constructor, intrinsic_default_proto, internal_slots_list=[]):
    """Create a new ECMAScript object, using the constructor's prototype.

    Arguments:
       constructor: An object, hopefully with a "prototype" property.
       intrinsic_default_proto: The string name of an intrinsic property, used to
          supply a prototype if the constructor didn't have one.
       internal_slots_list: This is a list of strings which are additional "slots"
           to add to the object. They share the same namespace as the rest of the
           object's internal members, so please tread lightly. (Adding "Prototype"
           to the list, for instance, while not necessarily harmful, does **not**
           mean that there are now two [[Prototype]] slots. There's still only one.)

    Returns the created object.

    The [[Prototype]] intenal slot of the new object is set to:
       * The value of the constructor's "prototype" property, if it exists
       * The value of the intrinsic object named by intrinsic_default_proto. (Note
         that the realm used to find the intrinsic is the one associated with the
         constructor, not the running execution context.)

    The [[Extensible]] internal slot is set to True. (In other words, the object is
    extensible.)

    Beyond that, the object is completely normal. In particular, any function body
    connected to the constructor is **not** run.

    (This function is typically used in the built-in constructors for objects as
    the first step in the build process.)

    This function is defined in section 9.1.13 of the ECMAScript specificiation.
    """
    # The abstract operation OrdinaryCreateFromConstructor creates an ordinary object whose [[Prototype]] value is
    # retrieved from a constructor's prototype property, if it exists. Otherwise the intrinsic named by
    # intrinsicDefaultProto is used for [[Prototype]]. The optional internalSlotsList is a List of the names of
    # additional internal slots that must be defined as part of the object. If the list is not provided, a new empty
    # List is used. This abstract operation performs the following steps:
    #
    # 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The
    #    corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.
    # 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).
    proto = GetPrototypeFromConstructor(constructor, intrinsic_default_proto)
    # 3. Return ObjectCreate(proto, internalSlotsList).
    return ObjectCreate(proto, internal_slots_list)


# 9.1.14 GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )
def GetPrototypeFromConstructor(constructor, intrinsic_default_proto):
    """Determine the [[Prototype]] to create an object from a constructor.

    This operation determines the [[Prototype]] value that should be used to create
    an object corresponding to a specific constructor. The value is retrieved from
    the constructor's "prototype" property, if it exists. Otherwise the intricsic
    named by the intrinsic_default_proto argument is used.

    Arguments:
       constructor: The constructor to create an object from
       intrinsic_default_proto: The string name of the intrinsic prototype to use if
          the constructor itself is unable to provide one.

    Returns the prototype object.

    Note: If "constructor" does not supply a [[Prototype]] value, the default value
    that is used is obtained from the realm of the constructor function rather than
    from the running execution context.

    This process is described in section 9.1.14 of the ECMAScript specification.
    """
    # The abstract operation GetPrototypeFromConstructor determines the [[Prototype]] value that should be used to
    # create an object corresponding to a specific constructor. The value is retrieved from the constructor's prototype
    # property, if it exists. Otherwise the intrinsic named by intrinsicDefaultProto is used for [[Prototype]]. This
    # abstract operation performs the following steps:
    #
    # 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The
    #    corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.
    # 2. Assert: IsCallable(constructor) is true.
    assert IsCallable(constructor)
    # 3. Let proto be ? Get(constructor, "prototype").
    proto = Get(constructor, "prototype")
    # 4. If Type(proto) is not Object, then
    if not isObject(proto):
        # a. Let realm be ? GetFunctionRealm(constructor).
        realm = GetFunctionRealm(constructor)
        # b. Set proto to realm's intrinsic object named intrinsicDefaultProto.
        proto = realm.intrinsics[intrinsic_default_proto]
    # 5. Return proto.
    return proto
    # NOTE
    # If constructor does not supply a [[Prototype]] value, the default value that is used is obtained from the realm of
    # the constructor function rather than from the running execution context.


"""
 .d8888b.       .d8888b.      8888888888  .d8888b.  888b     d888        d8888  .d8888b.                   d8b          888
d88P  Y88b     d88P  Y88b     888        d88P  Y88b 8888b   d8888       d88888 d88P  Y88b                  Y8P          888
888    888            888     888        888    888 88888b.d88888      d88P888 Y88b.                                    888
Y88b. d888          .d88P     8888888    888        888Y88888P888     d88P 888  "Y888b.    .d8888b 888d888 888 88888b.  888888
 "Y888P888      .od888P"      888        888        888 Y888P 888    d88P  888     "Y88b. d88P"    888P"   888 888 "88b 888
       888     d88P"          888        888    888 888  Y8P  888   d88P   888       "888 888      888     888 888  888 888
Y88b  d88P d8b 888"           888        Y88b  d88P 888   "   888  d8888888888 Y88b  d88P Y88b.    888     888 888 d88P Y88b.
 "Y8888P"  Y8P 888888888      8888888888  "Y8888P"  888       888 d88P     888  "Y8888P"   "Y8888P 888     888 88888P"   "Y888
                                                                                                               888
8888888888                            888    d8b                        .d88888b.  888         d8b             888   888
888                                   888    Y8P                       d88P" "Y88b 888         Y8P             888   888
888                                   888                              888     888 888                               888
8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
888        888  888 888  888 888      888    888 888  888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
                                                                                               888
                                                                                              d88P
                                                                                            888P"
9.2 ECMAScript Function Objects

ECMAScript function objects encapsulate parameterized ECMAScript code closed over a lexical environment and support the
dynamic evaluation of that code. An ECMAScript function object is an ordinary object and has the same internal slots and the
same internal methods as other ordinary objects. The code of an ECMAScript function object may be either strict mode code
(10.2.1) or non-strict code. An ECMAScript function object whose code is strict mode code is called a strict function. One
whose code is not strict mode code is called a non-strict function.

ECMAScript function objects have the additional internal slots listed in Table 27.

Table 27: Internal Slots of ECMAScript Function Objects
+----------------------+---------------------+-------------------------------------------------------------------------------
| Internal Slot        | Type                | Description
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[Environment]]      | Lexical Environment | The Lexical Environment that the function was closed over. Used as the outer
|                      |                     | environment when evaluating the code of the function.
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[FormalParameters]] | Parse Node          | The root parse node of the source text that defines the function's formal
|                      |                     | parameter list.
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[FunctionKind]]     | String              | Either "normal", "classConstructor", "generator", or "async".
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[ECMAScriptCode]]   | Parse Node          | The root parse node of the source text that defines the function's body.
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[ConstructorKind]]  | String              | Either "base" or "derived".
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[Realm]]            | Realm Record        | The realm in which the function was created and which provides any intrinsic
|                      |                     | objects that are accessed when evaluating the function.
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[ScriptOrModule]]   | Script Record or    | The script or module in which the function was created.
|                      | Module Record       |
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[ThisMode]]         | (lexical, strict,   | Defines how this references are interpreted within the formal parameters and
|                      | global)             | code body of the function. lexical means that this refers to the this value of
|                      |                     | a lexically enclosing function. strict means that the this value is used
|                      |                     | exactly as provided by an invocation of the function. global means that a this
|                      |                     | value of undefined is interpreted as a reference to the global object.
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[Strict]]           | Boolean             | true if this is a strict function, false if this is a non-strict function.
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[HomeObject]]       | Object              | If the function uses super, this is the object whose [[GetPrototypeOf]]
|                      |                     | provides the object where  super property lookups begin.
+----------------------+---------------------+-------------------------------------------------------------------------------
| [[SourceText]]       | String              | The source text that defines the function.
+----------------------+---------------------+-------------------------------------------------------------------------------

All ECMAScript function objects have the [[Call]] internal method defined here. ECMAScript functions that are also
constructors in addition have the [[Construct]] internal method.
"""


#######################################################################################################################################
#
#  .d8888b.       .d8888b.      8888888888  .d8888b.  888b     d888        d8888  .d8888b.                   d8b          888
# d88P  Y88b     d88P  Y88b     888        d88P  Y88b 8888b   d8888       d88888 d88P  Y88b                  Y8P          888
# 888    888            888     888        888    888 88888b.d88888      d88P888 Y88b.                                    888
# Y88b. d888          .d88P     8888888    888        888Y88888P888     d88P 888  "Y888b.    .d8888b 888d888 888 88888b.  888888
#  "Y888P888      .od888P"      888        888        888 Y888P 888    d88P  888     "Y88b. d88P"    888P"   888 888 "88b 888
#        888     d88P"          888        888    888 888  Y8P  888   d88P   888       "888 888      888     888 888  888 888
# Y88b  d88P d8b 888"           888        Y88b  d88P 888   "   888  d8888888888 Y88b  d88P Y88b.    888     888 888 d88P Y88b.
#  "Y8888P"  Y8P 888888888      8888888888  "Y8888P"  888       888 d88P     888  "Y8888P"   "Y8888P 888     888 88888P"   "Y888
#                                                                                                                888
# 8888888888                            888    d8b                        .d88888b.  888         d8b             888   888
# 888                                   888    Y8P                       d88P" "Y88b 888         Y8P             888   888
# 888                                   888                              888     888 888                               888
# 8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
# 888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# 888        888  888 888  888 888      888    888 888  888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
# 888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                888
#                                                                                               d88P
#                                                                                             888P"
#
#######################################################################################################################################


class JSFunction(JSObject):
    def __init__(self):
        super().__init__()
        self.Environment = None
        self.FormalParameters = None
        self.FunctionKind = None
        self.ECMAScriptCode = None
        self.ConstructorKind = None
        self.Realm = None
        self.ScriptOrModule = None
        self.ThisMode = None
        self.Strict = None
        self.HomeObject = None
        self.SourceText = None

    # 9.2.1 [[Call]] ( thisArgument, argumentsList )
    def Call(self, thisArgument, argumentsList):
        # The [[Call]] internal method for an ECMAScript function object F is called with parameters thisArgument and
        # argumentsList, a List of ECMAScript language values. The following steps are taken:
        pass  # 1. Assert: F is an ECMAScript function object.
        if self.FunctionKind == "classConstructor":  # 2. If F.[[FunctionKind]] is "classConstructor",
            raise ESTypeError()  #    throw a TypeError exception
        callerContext = surrounding_agent.running_ec  # 3. Let callerContext be the running execution context.
        calleeContext = PrepareForOrdinaryCall(
            self, None
        )  # 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).
        assert (
            calleeContext == surrounding_agent.running_ec
        )  # 5. Assert: calleeContext is now the running execution context.
        OrdinaryCallBindThis(
            self, calleeContext, thisArgument
        )  # 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
        try:
            OrdinaryCallEvaluateBody(
                self, argumentsList
            )  # 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).
            result = None
        except ESReturn as abrupt:
            result = abrupt.completion.value
        finally:
            surrounding_agent.ec_stack.pop()  # 8. Remove calleeContext from the execution context stack and
            surrounding_agent.running_ec = surrounding_agent.ec_stack[
                -1
            ]  # restore callerContext as the running execution context.
            surrounding_agent.running_ec.resume()
            assert surrounding_agent.running_ec == callerContext
        return result
        # NOTE
        # When calleeContext is removed from the execution context stack in step 8 it must not be destroyed if it is suspended
        # and retained for later resumption by an accessible generator object.


# 9.2.1.1 PrepareForOrdinaryCall ( F, newTarget )
def PrepareForOrdinaryCall(F, newTarget):
    # When the abstract operation PrepareForOrdinaryCall is called with function object F and ECMAScript language value
    # newTarget, the following steps are taken:
    #
    assert newTarget is None or isObject(newTarget)  # 1. Assert: Type(newTarget) is Undefined or Object.
    callerContext = surrounding_agent.running_ec  # 2. Let callerContext be the running execution context.
    calleeContext = ExecutionContext()  # 3. Let calleeContext be a new ECMAScript code execution context.
    calleeContext.function = F  # 4. Set the Function of calleeContext to F.
    calleeRealm = F.Realm  # 5. Let calleeRealm be F.[[Realm]].
    calleeContext.realm = calleeRealm  # 6. Set the Realm of calleeContext to calleeRealm.
    calleeContext.script_or_module = (
        F.ScriptOrModule
    )  # 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
    localEnv = NewFunctionEnvironment(F, newTarget)  # 8. Let localEnv be NewFunctionEnvironment(F, newTarget).
    calleeContext.lexical_environment = localEnv  # 9. Set the LexicalEnvironment of calleeContext to localEnv.
    calleeContext.variable_environment = localEnv  # 10. Set the VariableEnvironment of calleeContext to localEnv.
    callerContext.suspend()  # 11. If callerContext is not already suspended, suspend callerContext.
    surrounding_agent.ec_stack.append(
        calleeContext
    )  # 12. Push calleeContext onto the execution context stack; calleeContext
    surrounding_agent.running_ec = calleeContext  #     is now the running execution context.
    # 13. NOTE: Any exception objects produced after this point are associated with calleeRealm.
    return calleeContext  # 14. Return calleeContext.


# 9.2.1.2 OrdinaryCallBindThis ( F, calleeContext, thisArgument )
def OrdinaryCallBindThis(F, calleeContext, thisArgument):
    # When the abstract operation OrdinaryCallBindThis is called with function object F, execution context calleeContext, and
    # ECMAScript value thisArgument, the following steps are taken:
    #
    thisMode = F.ThisMode  # 1. Let thisMode be F.[[ThisMode]].
    if thisMode == LEXICAL:  # 2. If thisMode is lexical, return undefined
        return None
    calleeRealm = F.Realm  # 3. Let calleeRealm be F.[[Realm]].
    localEnv = calleeContext.lexical_environment  # 4. Let localEnv be the LexicalEnvironment of calleeContext.
    if thisMode == STRICT:  # 5. If thisMode is strict, let thisValue be thisArgument.
        thisValue = thisArgument
    else:  # 6. Else,
        if thisArgument is None or isNull(thisArgument):  #    a. If thisArgument is undefined or null, then
            globalEnv = calleeRealm.global_env  #       i. Let globalEnv be calleeRealm.[[GlobalEnv]].
            globalEnvRec = (
                globalEnv.environment_record
            )  #      ii. Let globalEnvRec be globalEnv's EnvironmentRecord.
            assert isinstance(
                globalEnvRec, GlobalEnvironmentRecord
            )  #  iii. Assert: globalEnvRec is a global Environment Record.
            thisValue = globalEnvRec.global_this_value  #      iv. Let thisValue be globalEnvRec.[[GlobalThisValue]].
        else:  #    b. Else,
            thisValue = ToObject(thisArgument)  #       i. Let thisValue be ! ToObject(thisArgument).
            # ii. NOTE: ToObject produces wrapper objects using calleeRealm.
    envRec = localEnv.environment_record  # 7. Let envRec be localEnv's EnvironmentRecord.
    assert isinstance(envRec, FunctionEnvironmentRecord)  # 8. Assert: envRec is a function Environment Record.
    # 9. Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not "initialized".
    assert envRec.this_binding_status != "initialized"
    return envRec.BindThisValue(thisValue)  # 10. Return envRec.BindThisValue(thisValue).


# 9.2.1.3 OrdinaryCallEvaluateBody ( F, argumentsList )
def OrdinaryCallEvaluateBody(F, argumentsList):
    # When the abstract operation OrdinaryCallEvaluateBody is called with function object F and List argumentsList, the
    # following steps are taken:
    #
    # 1. Return the result of EvaluateBody of the parsed code that is F.[[ECMAScriptCode]] passing F and argumentsList as the
    #    arguments.
    return F.ECMAScriptCode.EvaluateBody(F, argumentsList)


# 9.2.2 [[Construct]] ( argumentsList, newTarget )
def JSFunction_Construct(F, argumentsList, newTarget):
    # The [[Construct]] internal method for an ECMAScript function object F is called with parameters argumentsList and
    # newTarget. argumentsList is a possibly empty List of ECMAScript language values. The following steps are taken:
    #
    # 1. Assert: F is an ECMAScript function object.
    assert isinstance(F, JSFunction)
    # 2. Assert: Type(newTarget) is Object.
    assert isObject(newTarget)
    # 3. Let callerContext be the running execution context.
    # callerContext = surrounding_agent.running_ec
    # 4. Let kind be F.[[ConstructorKind]].
    kind = F.ConstructorKind
    # 5. If kind is "base", then
    if kind == "base":
        # a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, "%ObjectPrototype%").
        thisArgument = OrdinaryCreateFromConstructor(newTarget, "%ObjectPrototype%")
    # 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).
    calleeContext = PrepareForOrdinaryCall(F, newTarget)
    # 7. Assert: calleeContext is now the running execution context.
    assert surrounding_agent.running_ec == calleeContext
    # 8. If kind is "base", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
    if kind == "base":
        OrdinaryCallBindThis(F, calleeContext, thisArgument)
    # 9. Let constructorEnv be the LexicalEnvironment of calleeContext.
    constructorEnv = calleeContext.lexical_environment
    # 10. Let envRec be constructorEnv's EnvironmentRecord.
    envRec = constructorEnv.environment_record
    # 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).
    try:
        OrdinaryCallEvaluateBody(F, argumentsList)
        saw_return = False
    except ESReturn as abrupt:
        result = abrupt.completion.value
        saw_return = True
    finally:
        # 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
        surrounding_agent.ec_stack.pop()
        surrounding_agent.running_ec = surrounding_agent.ec_stack[-1]
        surrounding_agent.running_ec.resume()
    # 13. If result.[[Type]] is return, then
    if saw_return:
        # a. If Type(result.[[Value]]) is Object, return result.[[Value]])
        if isObject(result):
            return result
        # b. If kind is "base", return thisArgument
        if kind == "base":
            return thisArgument
        # c. If result.[[Value]] is not undefined, throw a TypeError exception.
        if result is not None:
            raise ESTypeError("Constructor failed to create an object")
    # 14. Else, ReturnIfAbrupt(result).
    # 15. Return ? envRec.GetThisBinding().
    return envRec.GetThisBinding()


# 9.2.3 FunctionAllocate ( functionPrototype, strict, functionKind )
def FunctionAllocate(functionPrototype, strict, functionKind):
    # The abstract operation FunctionAllocate requires the three arguments functionPrototype, strict and functionKind.
    # FunctionAllocate performs the following steps:
    #
    # 1. Assert: Type(functionPrototype) is Object.
    assert isObject(functionPrototype)
    # 2. Assert: functionKind is either "normal", "non-constructor", "generator", "async", or "async generator".
    assert functionKind in ["normal", "non-constructor", "generator", "async", "async generator"]
    # 3. If functionKind is "normal", let needsConstruct be true.
    # 4. Else, let needsConstruct be false.
    needsConstruct = functionKind == "normal"
    # 5. If functionKind is "non-constructor", set functionKind to "normal".
    if functionKind == "non-constructor":
        functionKind = "normal"
    # 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal
    #    slots are initialized to undefined.
    # 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.
    # 8. Set F.[[Call]] to the definition specified in 9.2.1.
    F = JSFunction()
    # 9. If needsConstruct is true, then
    if needsConstruct:
        # a. Set F.[[Construct]] to the definition specified in 9.2.2.
        F.Construct = types.MethodType(JSFunction_Construct, F)
        # b. Set F.[[ConstructorKind]] to "base".
        F.ConstructorKind = "base"
    # 10. Set F.[[Strict]] to strict.
    F.Strict = strict
    # 11. Set F.[[FunctionKind]] to functionKind.
    F.FunctionKind = functionKind
    # 12. Set F.[[Prototype]] to functionPrototype.
    F.Prototype = functionPrototype
    # 13. Set F.[[Extensible]] to true.
    F.Extensible = True
    # 14. Set F.[[Realm]] to the current Realm Record.
    F.Realm = surrounding_agent.running_ec.realm
    # 15. Return F.
    return F


# 9.2.4 FunctionInitialize ( F, kind, ParameterList, Body, Scope )
@unique
class FNKind(Enum):
    NORMAL = auto()
    METHOD = auto()
    ARROW = auto()


NORMAL = FNKind.NORMAL
METHOD = FNKind.METHOD
ARROW = FNKind.ARROW


def FunctionInitialize(F, kind, ParameterList, Body, Scope):
    # The abstract operation FunctionInitialize requires the arguments: a function object F, kind which is one of (Normal,
    # Method, Arrow), a parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical
    # Environment specified by Scope. FunctionInitialize performs the following steps:
    #
    # 1. Let len be the ExpectedArgumentCount of ParameterList.
    len_ = ParameterList.ExpectedArgumentCount()
    # 2. Perform ! SetFunctionLength(F, len).
    SetFunctionLength(F, len_)
    # 3. Let Strict be F.[[Strict]].
    Strict = F.Strict
    # 4. Set F.[[Environment]] to Scope.
    F.Environment = Scope
    # 5. Set F.[[FormalParameters]] to ParameterList.
    F.FormalParameters = ParameterList
    # 6. Set F.[[ECMAScriptCode]] to Body.
    F.ECMAScriptCode = Body
    # 7. Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().
    F.ScriptOrModule = GetActiveScriptOrModule()
    # 8. If kind is Arrow, set F.[[ThisMode]] to lexical.
    if kind == FNKind.ARROW:
        F.ThisMode = LEXICAL
    # 9. Else if Strict is true, set F.[[ThisMode]] to strict.
    elif Strict:
        F.ThisMode = STRICT
    # 10. Else, set F.[[ThisMode]] to global.
    else:
        F.ThisMode = GLOBAL
    # 11. Return F.
    return F


# 9.2.5 FunctionCreate ( kind, ParameterList, Body, Scope, Strict [ , prototype ] )
def FunctionCreate(kind, ParameterList, Body, Scope, Strict, prototype=MISSING):
    # The abstract operation FunctionCreate requires the arguments: kind which is one of (Normal, Method, Arrow), a parameter
    # list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by
    # Scope, a Boolean flag Strict, and optionally, an object prototype. FunctionCreate performs the following steps:
    #
    # 1. If prototype is not present, then
    if prototype == MISSING:
        # a. Set prototype to the intrinsic object %FunctionPrototype%.
        prototype = surrounding_agent.running_ec.realm.intrinsics["%FunctionPrototype%"]
    # 2. If kind is not Normal, let allocKind be "non-constructor".
    if kind != FNKind.NORMAL:
        allocKind = "non-constructor"
    # 3. Else, let allocKind be "normal".
    else:
        allocKind = "normal"
    # 4. Let F be FunctionAllocate(prototype, Strict, allocKind).
    F = FunctionAllocate(prototype, Strict, allocKind)
    # 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).
    return FunctionInitialize(F, kind, ParameterList, Body, Scope)


# 9.2.6 GeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict )
def GeneratorFunctionCreate(kind, ParameterList, Body, Scope, Strict):
    # The abstract operation GeneratorFunctionCreate requires the arguments: kind which is one of (Normal, Method), a parameter
    # list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment specified by
    # Scope, and a Boolean flag Strict. GeneratorFunctionCreate performs the following steps:
    #
    # 1. Let functionPrototype be the intrinsic object %Generator%.
    functionPrototype = surrounding_agent.running_ec.realm.intrinsics["%Generator%"]
    # 2. Let F be FunctionAllocate(functionPrototype, Strict, "generator").
    F = FunctionAllocate(functionPrototype, Strict, "generator")
    # 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).
    return FunctionInitialize(F, kind, ParameterList, Body, Scope)


# 9.2.7 AsyncGeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict )
def AsyncGeneratorFunctionCreate(kind, ParameterList, Body, Scope, Strict):
    # The abstract operation AsyncGeneratorFunctionCreate requires the arguments: kind which is one of (Normal, Method), a
    # parameter list Parse Node specified by ParameterList, a body Parse Node specified by Body, a Lexical Environment
    # specified by Scope, and a Boolean flag Strict. AsyncGeneratorFunctionCreate performs the following steps:
    #
    # 1. Let functionPrototype be the intrinsic object %AsyncGenerator%.
    functionPrototype = surrounding_agent.running_ec.realm.intrinsics["%AsyncGenerator%"]
    # 2. Let F be ! FunctionAllocate(functionPrototype, Strict, "generator").
    F = FunctionAllocate(functionPrototype, Strict, "generator")
    # 3. Return ! FunctionInitialize(F, kind, ParameterList, Body, Scope).
    return FunctionInitialize(F, kind, ParameterList, Body, Scope)


# 9.2.8 AsyncFunctionCreate ( kind, parameters, body, Scope, Strict )
def AsyncFunctionCreate(kind, parameters, body, Scope, Strict):
    # The abstract operation AsyncFunctionCreate requires the arguments: kind which is one of (Normal, Method, Arrow), a
    # parameter list Parse Node specified by parameters, a body Parse Node specified by body, a Lexical Environment specified
    # by Scope, and a Boolean flag Strict. AsyncFunctionCreate performs the following steps:
    #
    # 1. Let functionPrototype be the intrinsic object %AsyncFunctionPrototype%.
    functionPrototype = surrounding_agent.running_ec.realm.intrinsics["%AsyncFunctionPrototype%"]
    # 2. Let F be ! FunctionAllocate(functionPrototype, Strict, "async").
    F = FunctionAllocate(functionPrototype, Strict, "async")
    # 3. Return ! FunctionInitialize(F, kind, parameters, body, Scope).
    return FunctionInitialize(F, kind, parameters, body, Scope)


# 9.2.9 AddRestrictedFunctionProperties ( F, realm )
def AddRestrictedFunctionProperties(func, realm):
    # The abstract operation AddRestrictedFunctionProperties is called with a function object F and Realm Record realm
    # as its argument. It performs the following steps:
    #
    # 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.
    assert isinstance(realm.intrinsics["%ThrowTypeError%"], BuiltinFunction)
    # 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].
    thrower = realm.intrinsics["%ThrowTypeError%"]
    # 3. Perform ! DefinePropertyOrThrow(F, "caller", PropertyDescriptor { [[Get]]: thrower, [[Set]]: thrower,
    #    [[Enumerable]]: false, [[Configurable]]: true }).
    DefinePropertyOrThrow(
        func, "caller", PropertyDescriptor(Get=thrower, Set=thrower, enumerable=False, configurable=True)
    )
    # 4. Return ! DefinePropertyOrThrow(F, "arguments", PropertyDescriptor { [[Get]]: thrower, [[Set]]: thrower,
    #    [[Enumerable]]: false, [[Configurable]]: true }).
    return DefinePropertyOrThrow(
        func, "arguments", PropertyDescriptor(Get=thrower, Set=thrower, enumerable=False, configurable=True)
    )


# 9.2.10 MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )
def MakeConstructor(F, writeablePrototype=True, prototype=MISSING):
    # The abstract operation MakeConstructor requires a Function argument F and optionally, a Boolean writablePrototype and an
    # object prototype. If prototype is provided it is assumed to already contain, if needed, a "constructor" property whose
    # value is F. This operation converts F into a constructor by performing the following steps:
    #
    # 1. Assert: F is an ECMAScript function object.
    assert isinstance(F, JSFunction)
    # 2. Assert: IsConstructor(F) is true.
    assert IsConstructor(F)
    # 3. Assert: F is an extensible object that does not have a prototype own property.
    assert IsExtensible(F) and not HasOwnProperty(F, "prototype")
    # 4. If writablePrototype is not present, set writablePrototype to true.
    # 5. If prototype is not present, then
    if prototype == MISSING:
        # a. Set prototype to ObjectCreate(%ObjectPrototype%).
        prototype = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
        # b. Perform ! DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor { [[Value]]: F, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }).
        DefinePropertyOrThrow(
            prototype,
            "constructor",
            PropertyDescriptor(value=F, writable=writeablePrototype, enumerable=False, configurable=True),
        )
    # 6. Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false }).
    DefinePropertyOrThrow(
        F,
        "prototype",
        PropertyDescriptor(value=prototype, writable=writeablePrototype, enumerable=False, configurable=False),
    )
    # 7. Return undefined
    return None


# 9.2.11 MakeClassConstructor ( F )
def MakeClassConstructor(F):
    # The abstract operation MakeClassConstructor with argument F performs the following steps:
    #
    # 1. Assert: F is an ECMAScript function object.
    assert isinstance(F, JSFunction)
    # 2. Assert: F.[[FunctionKind]] is "normal".
    assert F.FunctionKind == "normal"
    # 3. Set F.[[FunctionKind]] to "classConstructor".
    F.FunctionKind = "classConstructor"
    # 4. Return undefined)
    return None


# 9.2.12 MakeMethod ( F, homeObject )
def MakeMethod(F, homeObject):
    # The abstract operation MakeMethod with arguments F and homeObject configures F as a method by performing the following
    # steps:
    #
    # 1. Assert: F is an ECMAScript function object.
    assert isinstance(F, JSFunction)
    # 2. Assert: Type(homeObject) is Object.
    assert isObject(homeObject)
    # 3. Set F.[[HomeObject]] to homeObject.
    F.HomeObject = homeObject
    # 4. Return undefined)
    return None


# 9.2.13 SetFunctionName ( F, name [ , prefix ] )
def SetFunctionName(F, name, prefix=MISSING):
    # The abstract operation SetFunctionName requires a Function argument F, a String or Symbol argument name and optionally a
    # String argument prefix. This operation adds a name property to F by performing the following steps:
    #
    # 1. Assert: F is an extensible object that does not have a name own property.
    assert IsExtensible(F) and not HasOwnProperty(F, "name")
    # 2. Assert: Type(name) is either Symbol or String.
    assert isString(name) or isSymbol(name)
    # 3. Assert: If prefix is present, then Type(prefix) is String.
    assert prefix == MISSING or isString(prefix)
    # 4. If Type(name) is Symbol, then
    if isSymbol(name):
        # a. Let description be name's [[Description]] value.
        description = name.description
        # b. If description is undefined, set name to the empty String.
        if description is None:
            name = ""
        # c. Else, set name to the string-concatenation of "[", description, and "]".
        else:
            name = f"[{description}]"
    # 5. If prefix is present, then
    if prefix != MISSING:
        # a. Set name to the string-concatenation of prefix, the code unit 0x0020 (SPACE), and name.
        name = f"{prefix} {name}"
    # 6. Return ! DefinePropertyOrThrow(F, "name", PropertyDescriptor { [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
    return DefinePropertyOrThrow(
        F, "name", PropertyDescriptor(value=name, writable=False, enumerable=False, configurable=True)
    )


# 9.2.14 SetFunctionLength ( F, length )
def SetFunctionLength(F, length):
    # The abstract operation SetFunctionLength requires a Function argument F and a Number argument length. This operation adds
    # a length property to F by performing the following steps:
    #
    # 1. Assert: F is an extensible object that does not have a length own property.
    assert IsExtensible(F) and not HasOwnProperty(F, "length")
    # 2. Assert: Type(length) is Number.
    assert isNumber(length)
    # 3. Assert: length ≥ 0 and ! ToInteger(length) is equal to length.
    assert length >= 0 and ToInteger(length) == length
    # 4. Return ! DefinePropertyOrThrow(F, "length",
    #        PropertyDescriptor { [[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
    desc = PropertyDescriptor(value=length, writable=False, enumerable=False, configurable=True)
    return DefinePropertyOrThrow(F, "length", desc)


# 9.2.15 FunctionDeclarationInstantiation ( func, argumentsList )
# NOTE 1
# When an execution context is established for evaluating an ECMAScript function a new function Environment Record is created
# and bindings for each formal parameter are instantiated in that Environment Record. Each declaration in the function body is
# also instantiated. If the function's formal parameters do not include any default value initializers then the body
# declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers
# exist, a second Environment Record is created for the body declarations. Formal parameters and functions are initialized as
# part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.
def FunctionDeclarationInstantiation(func, argumentsList):
    # FunctionDeclarationInstantiation is performed as follows using arguments func and argumentsList. func is the function
    # object for which the execution context is being established.
    #
    # 1. Let calleeContext be the running execution context.
    calleeContext = surrounding_agent.running_ec
    # 2. Let env be the LexicalEnvironment of calleeContext.
    env = calleeContext.lexical_environment
    # 3. Let envRec be env's EnvironmentRecord.
    envRec = env.environment_record
    # 4. Let code be func.[[ECMAScriptCode]].
    code = func.ECMAScriptCode
    # 5. Let strict be func.[[Strict]].
    strict = func.Strict
    # 6. Let formals be func.[[FormalParameters]].
    formals = func.FormalParameters
    # 7. Let parameterNames be the BoundNames of formals.
    parameterNames = formals.BoundNames()
    # 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.
    hasDuplicates = len(parameterNames) != len(set(parameterNames))
    # 9. Let simpleParameterList be IsSimpleParameterList of formals.
    simpleParameterList = formals.IsSimpleParameterList()
    # 10. Let hasParameterExpressions be ContainsExpression of formals.
    hasParameterExpressions = formals.ContainsExpression()
    # 11. Let varNames be the VarDeclaredNames of code.
    varNames = code.VarDeclaredNames()
    # 12. Let varDeclarations be the VarScopedDeclarations of code.
    varDeclarations = code.VarScopedDeclarations()
    # 13. Let lexicalNames be the LexicallyDeclaredNames of code.
    lexicalNames = code.LexicallyDeclaredNames()
    # 14. Let functionNames be a new empty List.
    functionNames = deque([])
    # 15. Let functionsToInitialize be a new empty List.
    functionsToInitialize = deque([])
    # 16. For each d in varDeclarations, in reverse list order, do
    for d in (varDeclarations[x] for x in range(len(varDeclarations) - 1, -1, -1)):
        # a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
        if d.name not in ["VariableDeclaration", "ForBinding", "BindingIdentifier"]:
            # i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an
            #    AsyncGeneratorDeclaration.
            assert d.name in [
                "FunctionDeclaration",
                "GeneratorDeclaration",
                "AsyncFunctionDeclaration",
                "AsyncGeneratorDeclaration",
            ]
            # ii. Let fn be the sole element of the BoundNames of d.
            fn = d.BoundNames()[0]
            # iii. If fn is not an element of functionNames, then
            if fn not in functionNames:
                # 1. Insert fn as the first element of functionNames.
                functionNames.appendleft(fn)
                # 2. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
                # 3. Insert d as the first element of functionsToInitialize.
                functionsToInitialize.appendleft(d)
    # 17. Let argumentsObjectNeeded be true.
    argumentsObjectNeeded = True
    # 18. If func.[[ThisMode]] is lexical, then
    if func.ThisMode == LEXICAL:
        # a. NOTE: Arrow functions never have an arguments objects.
        # b. Set argumentsObjectNeeded to false.
        argumentsObjectNeeded = False
    # 19. Else if "arguments" is an element of parameterNames, then
    elif "arguments" in parameterNames:
        # a. Set argumentsObjectNeeded to false.
        argumentsObjectNeeded = False
    # 20. Else if hasParameterExpressions is false, then
    elif not hasParameterExpressions:
        # a. If "arguments" is an element of functionNames or if "arguments" is an element of lexicalNames, then
        if "arguments" in functionNames or "arguments" in lexicalNames:
            # i. Set argumentsObjectNeeded to false.
            argumentsObjectNeeded = False
    # 21. For each String paramName in parameterNames, do
    for paramName in parameterNames:
        # a. Let alreadyDeclared be envRec.HasBinding(paramName).
        alreadyDeclared = envRec.HasBinding(paramName)
        # b. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have
        #          parameter default values or rest parameters.
        # c. If alreadyDeclared is false, then
        if not alreadyDeclared:
            # i. Perform ! envRec.CreateMutableBinding(paramName, false).
            envRec.CreateMutableBinding(paramName, False)
            # ii. If hasDuplicates is true, then
            if hasDuplicates:
                # 1. Perform ! envRec.InitializeBinding(paramName, undefined).
                envRec.InitializeBinding(paramName, None)
    # 22. If argumentsObjectNeeded is true, then
    if argumentsObjectNeeded:
        # a. If strict is true or if simpleParameterList is false, then
        if strict or not simpleParameterList:
            # i. Let ao be CreateUnmappedArgumentsObject(argumentsList).
            ao = CreateUnmappedArgumentsObject(argumentsList)
        # b. Else,
        else:
            # i. NOTE: mapped argument object is only provided for non-strict functions that don't have a rest parameter, any
            #    parameter default value initializers, or any destructured parameters.
            # ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).
            ao = CreateMappedArgumentsObject(func, formals, argumentsList, envRec)
        # c. If strict is true, then
        if strict:
            # i. Perform ! envRec.CreateImmutableBinding("arguments", false).
            envRec.CreateImmutableBinding("arguments", False)
        # d. Else,
        else:
            # i. Perform ! envRec.CreateMutableBinding("arguments", false).
            envRec.CreateMutableBinding("arguments", False)
        # e. Call envRec.InitializeBinding("arguments", ao).
        envRec.InitializeBinding("arguments", ao)
        # f. Let parameterBindings be a new List of parameterNames with "arguments" appended.
        parameterBindings = parameterNames + ["arguments"]
    # 23. Else,
    else:
        # a. Let parameterBindings be parameterNames.
        parameterBindings = parameterNames
    # 24. Let iteratorRecord be CreateListIteratorRecord(argumentsList).
    iteratorRecord = CreateListIteratorRecord(argumentsList)
    # 25. If hasDuplicates is true, then
    if hasDuplicates:
        # a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.
        formals.IteratorBindingInitialization(iteratorRecord, None)
    # 26. Else,
    else:
        # a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.
        formals.IteratorBindingInitialization(iteratorRecord, env)
    # 27. If hasParameterExpressions is false, then
    if not hasParameterExpressions:
        # a. NOTE: Only a single lexical environment is needed for the parameters and top-level vars.
        # b. Let instantiatedVarNames be a copy of the List parameterBindings.
        instantiatedVarNames = list(parameterBindings)
        # c. For each n in varNames, do
        for n in varNames:
            # i. If n is not an element of instantiatedVarNames, then
            if n not in instantiatedVarNames:
                # 1. Append n to instantiatedVarNames.
                instantiatedVarNames.append(n)
                # 2. Perform ! envRec.CreateMutableBinding(n, false).
                envRec.CreateMutableBinding(n, False)
                # 3. Call envRec.InitializeBinding(n, undefined).
                envRec.InitializeBinding(n, None)
        # d. Let varEnv be env.
        varEnv = env
        # e. Let varEnvRec be envRec.
        varEnvRec = envRec
    # 28. Else,
    else:
        # a. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal
        #    parameter list do not have visibility of declarations in the function body.
        # b. Let varEnv be NewDeclarativeEnvironment(env).
        varEnv = NewDeclarativeEnvironment(env)
        # c. Let varEnvRec be varEnv's EnvironmentRecord.
        varEnvRec = varEnv.environment_record
        # d. Set the VariableEnvironment of calleeContext to varEnv.
        calleeContext.variable_environment = varEnv
        # e. Let instantiatedVarNames be a new empty List.
        instantiatedVarNames = []
        # f. For each n in varNames, do
        for n in varNames:
            # i. If n is not an element of instantiatedVarNames, then
            if n not in instantiatedVarNames:
                # 1. Append n to instantiatedVarNames.
                instantiatedVarNames.append(n)
                # 2. Perform ! varEnvRec.CreateMutableBinding(n, false).
                varEnvRec.CreateMutableBinding(n, False)
                # 3. If n is not an element of parameterBindings or if n is an element of functionNames, let initialValue be undefined.
                if n not in parameterBindings or n in functionNames:
                    initialValue = None
                # 4. Else,
                else:
                    # a. Let initialValue be ! envRec.GetBindingValue(n, false).
                    initialValue = envRec.GetBindingValue(n, False)
                # 5. Call varEnvRec.InitializeBinding(n, initialValue).
                varEnvRec.InitializeBinding(n, initialValue)
                # 6. NOTE: vars whose names are the same as a formal parameter, initially have the same value as the
                #    corresponding initialized parameter.
    # 29. NOTE: Annex B.3.3.1 adds additional steps at this point.
    # 30. If strict is false, then
    if not strict:
        # a. Let lexEnv be NewDeclarativeEnvironment(varEnv).
        lexEnv = NewDeclarativeEnvironment(varEnv)
        # b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a
        #          direct eval can determine whether any var scoped declarations introduced by the eval code conflict with
        #          pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a
        #          strict direct eval always places all declarations into a new Environment Record.
    # 31. Else, let lexEnv be varEnv.
    else:
        lexEnv = varEnv
    # 32. Let lexEnvRec be lexEnv's EnvironmentRecord.
    lexEnvRec = lexEnv.environment_record
    # 33. Set the LexicalEnvironment of calleeContext to lexEnv.
    calleeContext.lexical_environment = lexEnv
    # 34. Let lexDeclarations be the LexicallyScopedDeclarations of code.
    lexDeclarations = code.LexicallyScopedDeclarations()
    # 35. For each element d in lexDeclarations, do
    for d in lexDeclarations:
        # a. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var
        #          name. Lexically declared names are only instantiated here but not initialized.
        # b. For each element dn of the BoundNames of d, do
        for dn in d.BoundNames():
            # i. If IsConstantDeclaration of d is true, then
            if d.IsConstantDeclaration():
                # 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).
                lexEnvRec.CreateImmutableBinding(dn, True)
            # ii. Else,
            else:
                # 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).
                lexEnvRec.CreateMutableBinding(dn, False)
    # 36. For each Parse Node f in functionsToInitialize, do
    for f in functionsToInitialize:
        # a. Let fn be the sole element of the BoundNames of f.
        fn = f.BoundNames()[0]
        # b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.
        fo = f.InstantiateFunctionObject(lexEnv)
        # c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).
        varEnvRec.SetMutableBinding(fn, fo, False)
    # 37. Return NormalCompletion(empty).
    return EMPTY
    # NOTE 2
    # B.3.3 provides an extension to the above algorithm that is necessary for backwards compatibility with web browser
    # implementations of ECMAScript that predate ECMAScript 2015.
    # NOTE 3
    # Parameter Initializers may contain direct eval expressions. Any top level declarations of such evals are only visible
    # to the eval code (10.2). The creation of the environment for such declarations is described in 14.1.19.


"""
 .d8888b.       .d8888b.      888888b.            d8b 888 888           d8b
d88P  Y88b     d88P  Y88b     888  "88b           Y8P 888 888           Y8P
888    888          .d88P     888  .88P               888 888
Y88b. d888         8888"      8888888K.  888  888 888 888 888888        888 88888b.
 "Y888P888          "Y8b.     888  "Y88b 888  888 888 888 888           888 888 "88b
       888     888    888     888    888 888  888 888 888 888    888888 888 888  888
Y88b  d88P d8b Y88b  d88P     888   d88P Y88b 888 888 888 Y88b.         888 888  888
 "Y8888P"  Y8P  "Y8888P"      8888888P"   "Y88888 888 888  "Y888        888 888  888



8888888888                            888    d8b
888                                   888    Y8P
888                                   888
8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.
888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b
888        888  888 888  888 888      888    888 888  888 888  888
888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888
888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888



 .d88888b.  888         d8b                   888
d88P" "Y88b 888         Y8P                   888
888     888 888                               888
888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
888     888 888  888    888 88888888 888      888    "Y8888b.
Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
 "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
                        888
                       d88P
                     888P"

The built-in function objects defined in this specification may be implemented as either ECMAScript function objects
(9.2) whose behaviour is provided using ECMAScript code or as implementation provided function exotic objects whose
behaviour is provided in some other manner. In either case, the effect of calling such functions must conform to their
specifications. An implementation may also provide additional built-in function objects that are not defined in this
specification.

If a built-in function object is implemented as an exotic object it must have the ordinary object behaviour specified
in 9.1. All such function exotic objects also have [[Prototype]], [[Extensible]], [[Realm]], and [[ScriptOrModule]]
internal slots.

Unless otherwise specified every built-in function object has the %FunctionPrototype% object as the initial value of
its [[Prototype]] internal slot.

The behaviour specified for each built-in function via algorithm steps or other means is the specification of the
function body behaviour for both [[Call]] and [[Construct]] invocations of the function. However, [[Construct]]
invocation is not supported by all built-in functions. For each built-in function, when invoked with [[Call]], the
[[Call]] thisArgument provides the this value, the [[Call]] argumentsList provides the named parameters, and the
NewTarget value is undefined. When invoked with [[Construct]], the this value is uninitialized, the [[Construct]]
argumentsList provides the named parameters, and the [[Construct]] newTarget parameter provides the NewTarget value. If
the built-in function is implemented as an ECMAScript function object then this specified behaviour must be implemented
by the ECMAScript code that is the body of the function. Built-in functions that are ECMAScript function objects must
be strict functions. If a built-in constructor has any [[Call]] behaviour other than throwing a TypeError exception, an
ECMAScript implementation of the function must be done in a manner that does not cause the function's [[FunctionKind]]
internal slot to have the value "classConstructor".

Built-in function objects that are not identified as constructors do not implement the [[Construct]] internal method
unless otherwise specified in the description of a particular function. When a built-in constructor is called as part
of a new expression the argumentsList parameter of the invoked [[Construct]] internal method provides the values for
the built-in constructor's named parameters.

Built-in functions that are not constructors do not have a prototype property unless otherwise specified in the
description of a particular function.
"""

################################################################################################################################################################################################################################
#
#  .d8888b.       .d8888b.      888888b.            d8b 888 888           d8b              8888888888                            888    d8b                        .d88888b.  888         d8b                   888
# d88P  Y88b     d88P  Y88b     888  "88b           Y8P 888 888           Y8P              888                                   888    Y8P                       d88P" "Y88b 888         Y8P                   888
# 888    888          .d88P     888  .88P               888 888                            888                                   888                              888     888 888                               888
# Y88b. d888         8888"      8888888K.  888  888 888 888 888888        888 88888b.      8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  "Y888P888          "Y8b.     888  "Y88b 888  888 888 888 888           888 888 "88b     888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
#        888     888    888     888    888 888  888 888 888 888    888888 888 888  888     888        888  888 888  888 888      888    888 888  888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
# Y88b  d88P d8b Y88b  d88P     888   d88P Y88b 888 888 888 Y88b.         888 888  888     888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
#  "Y8888P"  Y8P  "Y8888P"      8888888P"   "Y88888 888 888  "Y888        888 888  888     888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                                                                                                         888
#                                                                                                                                                                                        d88P
#                                                                                                                                                                                      888P"
#
################################################################################################################################################################################################################################


class BuiltinFunction(JSObject):
    def __init__(self, steps, realm, prototype, extensible, script_or_module, internal_slots_list):
        super().__init__()
        self.steps = steps
        self.realm = realm
        self.Prototype = prototype
        self.Extensible = extensible
        self.script_or_module = script_or_module
        for slotname in internal_slots_list:
            setattr(self, slotname, None)

    # 9.3.1 [[Call]] ( thisArgument, argumentsList )
    def Call(self, this_argument, arguments_list):
        # The [[Call]] internal method for a built-in function object F is called with parameters thisArgument and
        # argumentsList, a List of ECMAScript language values. The following steps are taken:
        #
        # 1. Let callerContext be the running execution context.
        caller_context = surrounding_agent.running_ec
        # 2. If callerContext is not already suspended, suspend callerContext.
        caller_context.suspend()
        # 3. Let calleeContext be a new ECMAScript code execution context.
        callee_context = ExecutionContext()
        # 4. Set the Function of calleeContext to F.
        callee_context.function = self
        # 5. Let calleeRealm be F.[[Realm]].
        callee_realm = self.realm
        # 6. Set the Realm of calleeContext to calleeRealm.
        callee_context.realm = callee_realm
        # 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
        callee_context.script_or_module = self.script_or_module
        # 8. Perform any necessary implementation-defined initialization of calleeContext.
        # 9. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
        surrounding_agent.ec_stack.append(callee_context)
        surrounding_agent.running_ec = callee_context
        # 10. Let result be the Completion Record that is the result of evaluating F in an implementation-defined
        #     manner that conforms to the specification of F. thisArgument is the this value, argumentsList provides
        #     the named parameters, and the NewTarget value is undefined.
        try:
            result = self.steps(this_argument, None, *arguments_list)
        finally:
            # 11. Remove calleeContext from the execution context stack and restore callerContext as the running execution
            #     context.
            surrounding_agent.ec_stack.pop()
            surrounding_agent.running_ec = caller_context
            surrounding_agent.running_ec.resume()
        # 12. Return result.
        return result
        # NOTE
        # When calleeContext is removed from the execution context stack it must not be destroyed if it has been
        # suspended and retained by an accessible generator object for later resumption.


# 9.3.2 [[Construct]] ( argumentsList, newTarget )
def BuiltinFunction_Construct(self, arguments_list, new_target):
    # The [[Construct]] internal method for built-in function object F is called with parameters argumentsList and newTarget.
    # The steps performed are the same as [[Call]] (see 9.3.1) except that step 10 is replaced by:
    #
    # 10. Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that
    #     conforms to the specification of F. The this value is uninitialized, argumentsList provides the named parameters, and
    #     newTarget provides the NewTarget value.
    #
    # Implementation note: The [[Construct]] method is **not** present on all Builtin Functions --- it's only there for
    # functions which are also constructors. So we don't put it in the class definition. Instead we leave it here and add it
    # during the CreateBuiltinFunction call, if we detect a "Construct" sitting in the interal_slots_list.
    #
    # 1. Let callerContext be the running execution context.
    caller_context = surrounding_agent.running_ec
    # 2. If callerContext is not already suspended, suspend callerContext.
    caller_context.suspend()
    # 3. Let calleeContext be a new ECMAScript code execution context.
    callee_context = ExecutionContext()
    # 4. Set the Function of calleeContext to F.
    callee_context.function = self
    # 5. Let calleeRealm be F.[[Realm]].
    callee_realm = self.realm
    # 6. Set the Realm of calleeContext to calleeRealm.
    callee_context.realm = callee_realm
    # 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
    callee_context.script_or_module = self.script_or_module
    # 8. Perform any necessary implementation-defined initialization of calleeContext.
    # 9. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
    surrounding_agent.ec_stack.append(callee_context)
    surrounding_agent.running_ec = callee_context
    # 10. Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that
    #     conforms to the specification of F. The this value is uninitialized, argumentsList provides the named parameters, and
    #     newTarget provides the NewTarget value.
    try:
        result = self.steps(None, new_target, *arguments_list)
    # 11. Remove calleeContext from the execution context stack and restore callerContext as the running execution
    #     context.
    finally:
        surrounding_agent.ec_stack.pop()
        surrounding_agent.running_ec = caller_context
        surrounding_agent.running_ec.resume()
    # 12. Return result.
    return result
    # NOTE
    # When calleeContext is removed from the execution context stack it must not be destroyed if it has been
    # suspended and retained by an accessible generator object for later resumption.


# 9.3.3 CreateBuiltinFunction ( steps, internalSlotsList [ , realm [ , prototype ] ] )
def CreateBuiltinFunction(steps, internal_slots_list, realm=MISSING, prototype=MISSING):
    # The abstract operation CreateBuiltinFunction takes arguments steps, internalSlotsList, realm, and prototype. The
    # argument internalSlotsList is a List of the names of additional internal slots that must be defined as part of the
    # object. CreateBuiltinFunction returns a built-in function object created by the following steps:
    #
    # 1. Assert: steps is either a set of algorithm steps or other definition of a function's behaviour provided in this
    #    specification.
    # 2. If realm is not present, set realm to the current Realm Record.
    if realm == MISSING:
        realm = surrounding_agent.running_ec.realm
    # 3. Assert: realm is a Realm Record.
    assert isinstance(realm, Realm)
    # 4. If prototype is not present, set prototype to realm.[[Intrinsics]].[[%FunctionPrototype%]].
    if prototype == MISSING:
        prototype = realm.intrinsics["%FunctionPrototype%"]
    # 5. Let func be a new built-in function object that when called performs the action described by steps. The new
    #    function object has internal slots whose names are the elements of internalSlotsList. The initial value of each
    #    of those internal slots is undefined.
    func = BuiltinFunction(steps, realm, prototype, True, JSNull.NULL, internal_slots_list)
    if "Construct" in internal_slots_list:
        func.Construct = types.MethodType(BuiltinFunction_Construct, func)
    # 6. Set func.[[Realm]] to realm.
    # 7. Set func.[[Prototype]] to prototype.
    # 8. Set func.[[Extensible]] to true.
    # 9. Set func.[[ScriptOrModule]] to null.
    # 10. Return func.
    return func
    # Each built-in function defined in this specification is created by calling the CreateBuiltinFunction abstract
    # operation.


"""
 .d8888b.          d8888      888888b.            d8b 888 888           d8b
d88P  Y88b        d8P888      888  "88b           Y8P 888 888           Y8P
888    888       d8P 888      888  .88P               888 888
Y88b. d888      d8P  888      8888888K.  888  888 888 888 888888        888 88888b.
 "Y888P888     d88   888      888  "Y88b 888  888 888 888 888           888 888 "88b
       888     8888888888     888    888 888  888 888 888 888    888888 888 888  888
Y88b  d88P d8b       888      888   d88P Y88b 888 888 888 Y88b.         888 888  888
 "Y8888P"  Y8P       888      8888888P"   "Y88888 888 888  "Y888        888 888  888




8888888888                   888    d8b               .d88888b.  888         d8b                   888
888                          888    Y8P              d88P" "Y88b 888         Y8P                   888
888                          888                     888     888 888                               888
8888888    888  888  .d88b.  888888 888  .d8888b     888     888 88888b.    8888  .d88b.   .d8888b 888888
888        `Y8bd8P' d88""88b 888    888 d88P"        888     888 888 "88b   "888 d8P  Y8b d88P"    888
888          X88K   888  888 888    888 888          888     888 888  888    888 88888888 888      888
888        .d8""8b. Y88..88P Y88b.  888 Y88b.        Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.
8888888888 888  888  "Y88P"   "Y888 888  "Y8888P      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888
                                                                             888
                                                                            d88P
                                                                          888P"

8888888          888                                       888
  888            888                                       888
  888            888                                       888
  888   88888b.  888888  .d88b.  888d888 88888b.   8888b.  888
  888   888 "88b 888    d8P  Y8b 888P"   888 "88b     "88b 888
  888   888  888 888    88888888 888     888  888 .d888888 888
  888   888  888 Y88b.  Y8b.     888     888  888 888  888 888
8888888 888  888  "Y888  "Y8888  888     888  888 "Y888888 888




888b     d888          888    888                    888                                     888
8888b   d8888          888    888                    888                                     888
88888b.d88888          888    888                    888                                     888
888Y88888P888  .d88b.  888888 88888b.   .d88b.   .d88888 .d8888b       8888b.  88888b.   .d88888
888 Y888P 888 d8P  Y8b 888    888 "88b d88""88b d88" 888 88K              "88b 888 "88b d88" 888
888  Y8P  888 88888888 888    888  888 888  888 888  888 "Y8888b.     .d888888 888  888 888  888
888   "   888 Y8b.     Y88b.  888  888 Y88..88P Y88b 888      X88     888  888 888  888 Y88b 888
888       888  "Y8888   "Y888 888  888  "Y88P"   "Y88888  88888P'     "Y888888 888  888  "Y88888




 .d8888b.  888          888
d88P  Y88b 888          888
Y88b.      888          888
 "Y888b.   888  .d88b.  888888 .d8888b
    "Y88b. 888 d88""88b 888    88K
      "888 888 888  888 888    "Y8888b.
Y88b  d88P 888 Y88..88P Y88b.       X88
 "Y8888P"  888  "Y88P"   "Y888  88888P'

9.4 Built-in Exotic Object Internal Methods and Slots

This specification defines several kinds of built-in exotic objects. These objects generally behave similar to ordinary
objects except for a few specific situations. The following exotic objects use the ordinary object internal methods except
where it is explicitly specified otherwise below:
"""

# 9.4.1 Bound Function Exotic Objects
#
# A bound function is an exotic object that wraps another function object. A bound function is callable (it has a [[Call]]
# internal method and may have a [[Construct]] internal method). Calling a bound function generally results in a call of its
# wrapped function.
#
# Bound function objects do not have the internal slots of ECMAScript function objects defined in Table 27. Instead they have
# the internal slots defined in Table 28.
#
# Table 28: Internal Slots of Bound Function Exotic Objects
# +-------------------------+-----------------+--------------------------------------------------------------------------------
# | Internal Slot           | Type            | Description
# +-------------------------+-----------------+--------------------------------------------------------------------------------
# | [[BoundTargetFunction]] | Callable Object | The wrapped function object.
# +-------------------------+-----------------+--------------------------------------------------------------------------------
# | [[BoundThis]]           | Any             | The value that is always passed as the this value when calling the wrapped
# |                         |                 | function.
# +-------------------------+-----------------+--------------------------------------------------------------------------------
# | [[BoundArguments]]      | List of Any     | A list of values whose elements are used as the first arguments to any call to
# |                         |                 | the wrapped function.
# +-------------------------+-----------------+--------------------------------------------------------------------------------
# Bound function objects provide all of the essential internal methods as specified in 9.1. However, they use the following
# definitions for the essential internal methods of function objects.


class BoundFunctionObject(JSObject):
    # 9.4.1.1 [[Call]] ( thisArgument, argumentsList )
    def Call(self, thisArgument, argumentsList):
        # When the [[Call]] internal method of a bound function exotic object, F, which was created using the bind function is
        # called with parameters thisArgument and argumentsList, a List of ECMAScript language values, the following steps are
        # taken:
        #
        # 1. Let target be F.[[BoundTargetFunction]].
        target = self.BoundTargetFunction
        # 2. Let boundThis be F.[[BoundThis]].
        boundThis = self.BoundThis
        # 3. Let boundArgs be F.[[BoundArguments]].
        boundArgs = self.BoundArguments
        # 4. Let args be a new list containing the same values as the list boundArgs in the same order followed by the same
        #    values as the list argumentsList in the same order.
        args = boundArgs + argumentsList
        # 5. Return ? Call(target, boundThis, args).
        return Call(target, boundThis, *args)


# 9.4.1.2 [[Construct]] ( argumentsList, newTarget )
def BoundFunction_Construct(self, argumentsList, newTarget):
    # When the [[Construct]] internal method of a bound function exotic object, F that was created using the bind function is
    # called with a list of arguments argumentsList and newTarget, the following steps are taken:
    #
    # 1. Let target be F.[[BoundTargetFunction]].
    target = self.BoundTargetFunction
    # 2. Assert: IsConstructor(target) is true.
    assert IsConstructor(target)
    # 3. Let boundArgs be F.[[BoundArguments]].
    boundArgs = self.BoundArguments
    # 4. Let args be a new list containing the same values as the list boundArgs in the same order followed by the same values
    #    as the list argumentsList in the same order.
    args = boundArgs + argumentsList
    # 5. If SameValue(F, newTarget) is true, set newTarget to target.
    if SameValue(self, newTarget):
        newTarget = target
    # 6. Return ? Construct(target, args, newTarget).
    return Construct(target, args, newTarget)


# 9.4.1.3 BoundFunctionCreate ( targetFunction, boundThis, boundArgs )
def BoundFunctionCreate(targetFunction, boundThis, boundArgs):
    # The abstract operation BoundFunctionCreate with arguments targetFunction, boundThis and boundArgs is used to specify the
    # creation of new Bound Function exotic objects. It performs the following steps:
    #
    # 1. Assert: Type(targetFunction) is Object.
    assert isObject(targetFunction)
    # 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().
    proto = targetFunction.GetPrototypeOf()
    # 3. Let obj be a newly created object.
    # 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
    # 5. Set obj.[[Call]] as described in 9.4.1.1.
    obj = BoundFunctionObject()
    # 6. If IsConstructor(targetFunction) is true, then
    if IsConstructor(targetFunction):
        # a. Set obj.[[Construct]] as described in 9.4.1.2.
        obj.Construct = types.MethodType(BoundFunction_Construct, obj)
    # 7. Set obj.[[Prototype]] to proto.
    obj.Prototype = proto
    # 8. Set obj.[[Extensible]] to true.
    obj.Extensible = True
    # 9. Set obj.[[BoundTargetFunction]] to targetFunction.
    obj.BoundTargetFunction = targetFunction
    # 10. Set obj.[[BoundThis]] to boundThis.
    obj.BoundThis = boundThis
    # 11. Set obj.[[BoundArguments]] to boundArgs.
    obj.BoundArguments = boundArgs
    # 12. Return obj.
    return obj


# ------------------------------------ 𝟗.𝟒.𝟐 𝑨𝒓𝒓𝒂𝒚 𝑬𝒙𝒐𝒕𝒊𝒄 𝑶𝒃𝒋𝒆𝒄𝒕𝒔 ------------------------------------
# 9.4.2 Array Exotic Objects
#
# An Array object is an exotic object that gives special treatment to array index property keys (see 6.1.7). A property
# whose property name is an array index is also called an element. Every Array object has a length property whose value
# is always a nonnegative integer less than 2^32. The value of the length property is numerically greater than the name
# of every own property whose name is an array index; whenever an own property of an Array object is created or changed,
# other properties are adjusted as necessary to maintain this invariant. Specifically, whenever an own property is
# added whose name is an array index, the value of the length property is changed, if necessary, to be one more than the
# numeric value of that array index; and whenever the value of the length property is changed, every own property whose
# name is an array index whose value is not smaller than the new length is deleted. This constraint applies only to own
# properties of an Array object and is unaffected by length or array index properties that may be inherited from its
# prototypes.
#
# NOTE
# A String property name P is an array index if and only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not
# equal to 2^32-1.
#
# Array exotic objects always have a non-configurable property named "length".
#
# Array exotic objects provide an alternative definition for the [[DefineOwnProperty]] internal method. Except for that
# internal method, Array exotic objects provide all of the other essential internal methods as specified in 9.1.
#
class ArrayObject(JSObject):
    # -------------------------------- 𝟗.𝟒.𝟐.𝟏 [[𝑫𝒆𝒇𝒊𝒏𝒆𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚]] ( 𝑷, 𝑫𝒆𝒔𝒄 ) ------------------------------------
    # 9.4.2.1 [[DefineOwnProperty]] ( P, Desc )
    def DefineOwnProperty(self, P, Desc):
        # When the [[DefineOwnProperty]] internal method of an Array exotic object A is called with property key P, and
        # Property Descriptor Desc, the following steps are taken:
        #
        # 1. Assert: IsPropertyKey(P) is true.
        assert IsPropertyKey(P)
        # 2. If P is "length", then
        if P == "length":
            # a. Return ? ArraySetLength(A, Desc).
            return ArraySetLength(self, Desc)
        # 3. Else if P is an array index, then
        if isString(P):
            index = ToUint32(P)
            if ToString(index) == P and index != 0xFFFFFFFF:
                # a. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").
                oldLenDesc = OrdinaryGetOwnProperty(self, "length")
                # b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created
                #    with a length data property that cannot be deleted or reconfigured.
                assert oldLenDesc is not None and IsDataDescriptor(oldLenDesc)
                # c. Let oldLen be oldLenDesc.[[Value]].
                oldLen = oldLenDesc.value
                # d. Let index be ! ToUint32(P).
                # e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.
                if index >= oldLen and not oldLenDesc.writable:
                    return False
                # f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).
                succeeded = OrdinaryDefineOwnProperty(self, P, Desc)
                # g. If succeeded is false, return false.
                if not succeeded:
                    return False
                # h. If index ≥ oldLen, then
                if index >= oldLen:
                    # i. Set oldLenDesc.[[Value]] to index + 1.
                    oldLenDesc.value = index + 1
                    # ii. Let succeeded be OrdinaryDefineOwnProperty(A, "length", oldLenDesc).
                    succeeded = OrdinaryDefineOwnProperty(self, "length", oldLenDesc)
                    # iii. Assert: succeeded is true.
                    assert succeeded
                # i. Return true.
                return True
        # 4. Return OrdinaryDefineOwnProperty(A, P, Desc).
        return OrdinaryDefineOwnProperty(self, P, Desc)

    def __repr__(self):
        return f"[{ToString(self)}]"


# ------------------------------------ 𝟗.𝟒.𝟐.𝟐 𝑨𝒓𝒓𝒂𝒚𝑪𝒓𝒆𝒂𝒕𝒆 ( 𝒍𝒆𝒏𝒈𝒕𝒉 [ , 𝒑𝒓𝒐𝒕𝒐 ] ) ------------------------------------
# 9.4.2.2 ArrayCreate ( length [ , proto ] )
def ArrayCreate(length, proto=None):
    # The abstract operation ArrayCreate with argument length (either 0 or a positive integer) and optional argument proto is
    # used to specify the creation of new Array exotic objects. It performs the following steps:
    #
    # 1. Assert: length is an integer Number ≥ 0.
    assert isNumber(length) and length >= 0 and math.floor(length) == length
    # 2. If length is -0, set length to +0.
    if math.copysign(1.0, length) < 0:
        length = 0
    # 3. If length > 2^32-1, throw a RangeError exception.
    if length > 0xFFFFFFFF:
        raise ESRangeError(f"length {length} is too large for array indices")
    # 4. If proto is not present, set proto to the intrinsic object %ArrayPrototype%.
    if proto is None:
        proto = surrounding_agent.running_ec.realm.intrinsics["%ArrayPrototype%"]
    # 5. Let A be a newly created Array exotic object.
    # 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions
    #    specified in 9.1.
    # 7. Set A.[[DefineOwnProperty]] as specified in 9.4.2.1.
    A = ArrayObject()
    # 8. Set A.[[Prototype]] to proto.
    A.Prototype = proto
    # 9. Set A.[[Extensible]] to true.
    A.Extensible = True
    # 10. Perform ! OrdinaryDefineOwnProperty(A, "length",
    #           PropertyDescriptor { [[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
    OrdinaryDefineOwnProperty(
        A, "length", PropertyDescriptor(value=length, writable=True, enumerable=False, configurable=False)
    )
    # 11. Return A.
    return A


# ------------------------------------ 𝟗.𝟒.𝟐.𝟑 𝑨𝒓𝒓𝒂𝒚𝑺𝒑𝒆𝒄𝒊𝒆𝒔𝑪𝒓𝒆𝒂𝒕𝒆 ( 𝒐𝒓𝒊𝒈𝒊𝒏𝒂𝒍𝑨𝒓𝒓𝒂𝒚, 𝒍𝒆𝒏𝒈𝒕𝒉 ) ------------------------------------
# 9.4.2.3 ArraySpeciesCreate ( originalArray, length )
def ArraySpeciesCreate(originalArray, length):
    # The abstract operation ArraySpeciesCreate with arguments originalArray and length is used to specify the creation of a
    # new Array object using a constructor function that is derived from originalArray. It performs the following steps:
    #
    # 1. Assert: length is an integer Number ≥ 0.
    assert isNumber(length) and length >= 0 and math.floor(length) == length
    # 2. If length is -0, set length to +0.
    if math.copysign(1.0, length) < 0:
        length = 0
    # 3. Let isArray be ? IsArray(originalArray).
    isArray = IsArray(originalArray)
    # 4. If isArray is false, return ? ArrayCreate(length).
    if not isArray:
        return ArrayCreate(length)
    # 5. Let C be ? Get(originalArray, "constructor").
    C = Get(originalArray, "constructor")
    # 6. If IsConstructor(C) is true, then
    if IsConstructor(C):
        # a. Let thisRealm be the current Realm Record.
        thisRealm = surrounding_agent.running_ec.realm
        # b. Let realmC be ? GetFunctionRealm(C).
        realmC = GetFunctionRealm(C)
        # c. If thisRealm and realmC are not the same Realm Record, then
        if thisRealm != realmC:
            # i. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, set C to undefined.
            if SameValue(C, realmC.intrinsics["%Array%"]):
                C = None
    # 7. If Type(C) is Object, then
    if isObject(C):
        # a. Set C to ? Get(C, @@species).
        C = Get(C, wks_species)
        # b. If C is null, set C to undefined.
        if isNull(C):
            C = None
    # 8. If C is undefined, return ? ArrayCreate(length).
    if C is None:
        return ArrayCreate(length)
    # 9. If IsConstructor(C) is false, throw a TypeError exception.
    if not IsConstructor(C):
        raise ESTypeError()
    # 10. Return ? Construct(C, « length »).
    return Construct(C, [length])
    # NOTE
    # If originalArray was created using the standard built-in Array constructor for a realm that is not the realm of the
    # running execution context, then a new Array is created using the realm of the running execution context. This maintains
    # compatibility with Web browsers that have historically had that behaviour for the Array.prototype methods that now are
    # defined using ArraySpeciesCreate.


# ------------------------------------ 𝟗.𝟒.𝟐.𝟒 𝑨𝒓𝒓𝒂𝒚𝑺𝒆𝒕𝑳𝒆𝒏𝒈𝒕𝒉 ( 𝑨, 𝑫𝒆𝒔𝒄 ) ------------------------------------
# 9.4.2.4 ArraySetLength ( A, Desc )
def ArraySetLength(A, Desc):
    # When the abstract operation ArraySetLength is called with an Array exotic object A, and Property Descriptor Desc,
    # the following steps are taken:
    #
    #   1. If Desc.[[Value]] is absent, then
    #       a. Return OrdinaryDefineOwnProperty(A, "length", Desc).
    #   2. Let newLenDesc be a copy of Desc.
    #   3. Let newLen be ? ToUint32(Desc.[[Value]]).
    #   4. Let numberLen be ? ToNumber(Desc.[[Value]]).
    #   5. If newLen ≠ numberLen, throw a RangeError exception.
    #   6. Set newLenDesc.[[Value]] to newLen.
    #   7. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").
    #   8. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created with
    #      a length data property that cannot be deleted or reconfigured.
    #   9. Let oldLen be oldLenDesc.[[Value]].
    #   10. If newLen ≥ oldLen, then
    #       a. Return OrdinaryDefineOwnProperty(A, "length", newLenDesc).
    #   11. If oldLenDesc.[[Writable]] is false, return false.
    #   12. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
    #   13. Else,
    #       a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
    #       b. Let newWritable be false.
    #       c. Set newLenDesc.[[Writable]] to true.
    #   14. Let succeeded be ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).
    #   15. If succeeded is false, return false.
    #   16. Repeat, while newLen < oldLen,
    #       a. Set oldLen to oldLen - 1.
    #       b. Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).
    #       c. If deleteSucceeded is false, then
    #           i. Set newLenDesc.[[Value]] to oldLen + 1.
    #           ii. If newWritable is false, set newLenDesc.[[Writable]] to false.
    #           iii. Perform ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).
    #           iv. Return false.
    #   17. If newWritable is false, then
    #       a. Return OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Writable]]: false }). This call
    #          will always return true.
    #   18. Return true.
    # NOTE
    # In steps 3 and 4, if Desc.[[Value]] is an object then its valueOf method is called twice. This is legacy
    # behaviour that was specified with this effect starting with the 2nd Edition of this specification.
    if not hasattr(Desc, "value"):
        return OrdinaryDefineOwnProperty(A, "length", Desc)
    newLenDesc = copy(Desc)
    newLen = ToUint32(Desc.value)
    numberLen = ToNumber(Desc.value)
    if newLen != numberLen:
        raise ESRangeError(f"Array length {ToString(Desc.value)} is invalid")
    newLenDesc.value = newLen
    oldLenDesc = OrdinaryGetOwnProperty(A, "length")
    assert oldLenDesc is not None and not oldLenDesc.is_accessor_descriptor()
    oldLen = oldLenDesc.value
    if newLen >= oldLen:
        return OrdinaryDefineOwnProperty(A, "length", newLenDesc)
    if not oldLenDesc.writable:
        return False
    if getattr(newLenDesc, "writable", True):
        newWritable = True
    else:
        newWritable = False
        newLenDesc.writable = True  # Need to defer setting [[Writable]] in case any elements cannot be deleted
    succeeded = OrdinaryDefineOwnProperty(A, "length", newLenDesc)
    if not succeeded:
        return False
    while newLen < oldLen:
        oldLen -= 1
        deleteSucceeded = A.Delete(ToString(oldLen))
        if not deleteSucceeded:
            newLenDesc.value = oldLen + 1
            if not newWritable:
                newLenDesc.writable = False
            OrdinaryDefineOwnProperty(A, "length", newLenDesc)
            return False
    if not newWritable:
        return OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor(writable=False))
    return True


# ------------------------------------ 𝟗.𝟒.𝟑 𝑺𝒕𝒓𝒊𝒏𝒈 𝑬𝒙𝒐𝒕𝒊𝒄 𝑶𝒃𝒋𝒆𝒄𝒕𝒔 ------------------------------------
# 9.4.3 String Exotic Objects
# A String object is an exotic object that encapsulates a String value and exposes virtual integer-indexed data
# properties corresponding to the individual code unit elements of the String value. String exotic objects always
# have a data property named "length" whose value is the number of code unit elements in the encapsulated String value.
# Both the code unit data properties and the "length" property are non-writable and non-configurable.
#
# String exotic objects have the same internal slots as ordinary objects. They also have a [[StringData]] internal
# slot.
#
# String exotic objects provide alternative definitions for the following internal methods. All of the other String
# exotic object essential internal methods that are not defined below are as specified in 9.1.
class StringObject(JSObject):
    def __init__(self, value, prototype):
        # Essentially, this is all just StringCreate
        super().__init__()
        self.StringData = value
        self.Prototype = prototype
        self.Extensible = True
        desc = PropertyDescriptor(value=len(value), writable=False, enumerable=False, configurable=False)
        DefinePropertyOrThrow(self, "length", desc)

    def __repr__(self):
        return f"String({self.StringData!r})"

    # -------------------------------- 𝟗.𝟒.𝟑.𝟏 [[𝑮𝒆𝒕𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚]] ( 𝑷 ) ------------------------------------
    # 9.4.3.1 [[GetOwnProperty]] ( P )
    def GetOwnProperty(self, P):
        # When the [[GetOwnProperty]] internal method of a String exotic object S is called with property key P, the
        # following steps are taken:
        #
        # 1. Assert: IsPropertyKey(P) is true.
        # 2. Let desc be OrdinaryGetOwnProperty(S, P).
        # 3. If desc is not undefined, return desc.
        # 4. Return ! StringGetOwnProperty(S, P).
        assert IsPropertyKey(P)
        desc = OrdinaryGetOwnProperty(self, P)
        if desc is not None:
            return desc
        return StringGetOwnProperty(self, P)

    # -------------------------------- 𝟗.𝟒.𝟑.𝟐 [[𝑫𝒆𝒇𝒊𝒏𝒆𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚]] ( 𝑷, 𝑫𝒆𝒔𝒄 ) ------------------------------------
    # 9.4.3.2 [[DefineOwnProperty]] ( P, Desc )
    def DefineOwnProperty(self, P, Desc):
        # When the [[DefineOwnProperty]] internal method of a String exotic object S is called with property key P, and
        # Property Descriptor Desc, the following steps are taken:
        #
        # 1. Assert: IsPropertyKey(P) is true.
        # 2. Let stringDesc be ! StringGetOwnProperty(S, P).
        # 3. If stringDesc is not undefined, then
        #    a. Let extensible be S.[[Extensible]].
        #    b. Return ! IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc).
        # 4. Return ! OrdinaryDefineOwnProperty(S, P, Desc).
        assert IsPropertyKey(P)
        stringDesc = StringGetOwnProperty(self, P)
        if stringDesc is not None:
            extensible = self.Extensible
            rval = IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc)
            return rval
        rval = OrdinaryDefineOwnProperty(self, P, Desc)
        return rval

    # -------------------------------- 𝟗.𝟒.𝟑.𝟑 [[𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚𝑲𝒆𝒚𝒔]] ( ) ------------------------------------
    # 9.4.3.3 [[OwnPropertyKeys]] ( )
    def OwnPropertyKeys(self):
        # When the [[OwnPropertyKeys]] internal method of a String exotic object O is called, the following steps are
        # taken:
        #
        # 1. Let keys be a new empty List.
        # 2. Let str be the String value of O.[[StringData]].
        # 3. Let len be the length of str.
        # 4. For each integer i starting with 0 such that i < len, in ascending order, do
        #    a. Add ! ToString(i) as the last element of keys.
        # 5. For each own property key P of O such that P is an integer index and ToInteger(P) ≥ len, in ascending
        #    numeric index order, do
        #    a. Add P as the last element of keys.
        # 6. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending
        #    chronological order of property creation, do
        #    a. Add P as the last element of keys.
        # 7. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property
        #    creation, do
        #    a. Add P as the last element of keys.
        # 8. Return keys.
        g1 = (ToString(i) for i in range(len(self.StringData)))
        g2 = sorted(
            (
                key
                for key in self.properties.keys()
                if isIntegerIndex(key) and ToInteger(key) >= len(self.StringData)
            ),
            key=lambda x: ToInteger(x),
        )
        g3 = (key for key in self.properties.keys() if isString(key) and not isIntegerIndex(key))
        g4 = (key for key in self.properties.keys() if isSymbol(key))
        return list(chain(g1, g2, g3, g4))


# ------------------------------------ 𝟗.𝟒.𝟑.𝟒 𝑺𝒕𝒓𝒊𝒏𝒈𝑪𝒓𝒆𝒂𝒕𝒆 ( 𝒗𝒂𝒍𝒖𝒆, 𝒑𝒓𝒐𝒕𝒐𝒕𝒚𝒑𝒆 ) ------------------------------------
# 9.4.3.4 StringCreate ( value, prototype )
def StringCreate(value, prototype):
    # The abstract operation StringCreate with arguments value and prototype is used to specify the creation of new
    # String exotic objects. It performs the following steps:
    #
    # 1. Assert: Type(value) is String.
    # 2. Let S be a newly created String exotic object.
    # 3. Set S.[[StringData]] to value.
    # 4. Set S's essential internal methods to the default ordinary object definitions specified in 9.1.
    # 5. Set S.[[GetOwnProperty]] as specified in 9.4.3.1.
    # 6. Set S.[[DefineOwnProperty]] as specified in 9.4.3.2.
    # 7. Set S.[[OwnPropertyKeys]] as specified in 9.4.3.3.
    # 8. Set S.[[Prototype]] to prototype.
    # 9. Set S.[[Extensible]] to true.
    # 10. Let length be the number of code unit elements in value.
    # 11. Perform ! DefinePropertyOrThrow(S, "length", PropertyDescriptor { [[Value]]: length, [[Writable]]: false,
    #     [[Enumerable]]: false, [[Configurable]]: false }).
    # 12. Return S.
    assert isString(value)
    return StringObject(value, prototype)


# ------------------------------------ 𝟗.𝟒.𝟑.𝟓 𝑺𝒕𝒓𝒊𝒏𝒈𝑮𝒆𝒕𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚 ( 𝑺, 𝑷 ) ------------------------------------
# 9.4.3.5 StringGetOwnProperty ( S, P )
def StringGetOwnProperty(S, P):
    # The abstract operation StringGetOwnProperty called with arguments S and P performs the following steps:
    #
    # 1. Assert: S is an Object that has a [[StringData]] internal slot.
    # 2. Assert: IsPropertyKey(P) is true.
    # 3. If Type(P) is not String, return undefined.
    # 4. Let index be ! CanonicalNumericIndexString(P).
    # 5. If index is undefined, return undefined.
    # 6. If IsInteger(index) is false, return undefined.
    # 7. If index = -0, return undefined.
    # 8. Let str be the String value of S.[[StringData]].
    # 9. Let len be the length of str.
    # 10. If index < 0 or len ≤ index, return undefined.
    # 11. Let resultStr be the String value of length 1, containing one code unit from str, specifically the code unit
    #     at index index.
    # 12. Return a PropertyDescriptor { [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true,
    #     [[Configurable]]: false }.
    assert isObject(S) and hasattr(S, "StringData")
    assert IsPropertyKey(P)
    if not isString(P):
        return None
    index = CanonicalNumericIndexString(P)
    if index is None:
        return None
    if not IsInteger(index):
        return None
    if index == 0 and math.copysign(1.0, index) < 0:
        return None
    if index < 0 or len(S.StringData) <= index:
        return None
    return PropertyDescriptor(value=S.StringData[int(index)], writable=False, enumerable=True, configurable=False)


# ------------------------------------ 𝟗.𝟒.𝟒 𝑨𝒓𝒈𝒖𝒎𝒆𝒏𝒕𝒔 𝑬𝒙𝒐𝒕𝒊𝒄 𝑶𝒃𝒋𝒆𝒄𝒕𝒔 ------------------------------------
# 9.4.4 Arguments Exotic Objects
# Most ECMAScript functions make an arguments object available to their code. Depending upon the characteristics of the
# function definition, its arguments object is either an ordinary object or an arguments exotic object. An arguments
# exotic object is an exotic object whose array index properties map to the formal parameters bindings of an invocation
# of its associated ECMAScript function.
#
# Arguments exotic objects have the same internal slots as ordinary objects. They also have a [[ParameterMap]] internal
# slot. Ordinary arguments objects also have a [[ParameterMap]] internal slot whose value is always undefined. For
# ordinary argument objects the [[ParameterMap]] internal slot is only used by  Object.prototype.toString (19.1.3.6) to
# identify them as such.
#
# Arguments exotic objects provide alternative definitions for the following internal methods. All of the other
# arguments exotic object essential internal methods that are not defined below are as specified in 9.1
#
# NOTE 1
# The integer-indexed data properties of an arguments exotic object whose numeric name values are less than the number
# of formal parameters of the corresponding function object initially share their values with the corresponding
# argument bindings in the function's execution context. This means that changing the property changes the
# corresponding value of the argument binding and vice-versa. This correspondence is broken if such a property is
# deleted and then redefined or if the property is changed into an accessor property. If the arguments object is an
# ordinary object, the values of its properties are simply a copy of the arguments passed to the function and there is
# no dynamic linkage between the property values and the formal parameter values.
#
# NOTE 2
# The ParameterMap object and its property values are used as a device for specifying the arguments object
# correspondence to argument bindings. The ParameterMap object and the objects that are the values of its properties
# are not directly observable from ECMAScript code. An ECMAScript implementation does not need to actually create or
# use such objects to implement the specified semantics.
#
# NOTE 3
# Ordinary arguments objects define a non-configurable accessor property named "callee" which throws a TypeError
# exception on access. The "callee" property has a more specific meaning for arguments exotic objects, which are
# created only for some class of non-strict functions. The definition of this property in the ordinary variant exists
# to ensure that it is not defined in any other manner by conforming ECMAScript implementations.
#
# NOTE 4
# ECMAScript implementations of arguments exotic objects have historically contained an accessor property named
# "caller". Prior to ECMAScript 2017, this specification included the definition of a throwing "caller" property on
# ordinary arguments objects. Since implementations do not contain this extension any longer, ECMAScript 2017 dropped
# the requirement for a throwing "caller" accessor.
class ArgumentsObject(JSObject):
    def __init__(self):
        super().__init__()
        self.ParameterMap = None

    def __repr__(self):
        return f"Arguments(_something_)"

    # -------------------------------- 𝟗.𝟒.𝟒.𝟏 [[𝑮𝒆𝒕𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚]] ( 𝑷 ) ------------------------------------
    def GetOwnProperty(self, P):
        # 9.4.4.1 [[GetOwnProperty]] ( P )
        # The [[GetOwnProperty]] internal method of an arguments exotic object when called with a property key P
        # performs the following steps:
        #
        #   1. Let args be the arguments object.
        #   2. Let desc be OrdinaryGetOwnProperty(args, P).
        #   3. If desc is undefined, return desc.
        #   4. Let map be args.[[ParameterMap]].
        #   5. Let isMapped be ! HasOwnProperty(map, P).
        #   6. If isMapped is true, then
        #   7. Set desc.[[Value]] to Get(map, P).
        #   8. Return desc.
        desc = OrdinaryGetOwnProperty(self, P)
        if desc:
            map = self.ParameterMap
            if HasOwnProperty(map, P):
                desc.value = Get(map, P)
        return desc

    # -------------------------------- 𝟗.𝟒.𝟒.𝟐 [[𝑫𝒆𝒇𝒊𝒏𝒆𝑶𝒘𝒏𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒚]] ( 𝑷, 𝑫𝒆𝒔𝒄 ) ------------------------------------
    def DefineOwnProperty(self, P, Desc):
        # 9.4.4.2 [[DefineOwnProperty]] ( P, Desc )
        # The [[DefineOwnProperty]] internal method of an arguments exotic object when called with a property key P and
        # Property Descriptor Desc performs the following steps:
        #   1. Let args be the arguments object.
        #   2. Let map be args.[[ParameterMap]].
        #   3. Let isMapped be HasOwnProperty(map, P).
        #   4. Let newArgDesc be Desc.
        #   5. If isMapped is true and IsDataDescriptor(Desc) is true, then
        #       a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then
        #           i. Set newArgDesc to a copy of Desc.
        #           ii. Set newArgDesc.[[Value]] to Get(map, P).
        #   6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).
        #   7. If allowed is false, return false.
        #   8. If isMapped is true, then
        #       a. If IsAccessorDescriptor(Desc) is true, then
        #           i. Call map.[[Delete]](P).
        #       b. Else,
        #           i. If Desc.[[Value]] is present, then
        #               1. Let setStatus be Set(map, P, Desc.[[Value]], false).
        #               2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.
        #           ii. If Desc.[[Writable]] is present and its value is false, then
        #               1. Call map.[[Delete]](P).
        #   9. Return true.
        map = self.ParameterMap
        isMapped = HasOwnProperty(map, P)
        newArgDesc = Desc
        if isMapped and IsDataDescriptor(Desc):
            if not hasattr(Desc, "value") and hasattr(Desc, "writable") and not Desc.writable:
                newArgDesc = copy(Desc)
                newArgDesc.value = Get(map, P)
        allowed = OrdinaryDefineOwnProperty(self, P, newArgDesc)
        if not allowed:
            return False
        if isMapped:
            if IsAccessorDescriptor(Desc):
                map.Delete(P)  # pylint: disable=no-member
            else:
                if hasattr(Desc, "value"):
                    setStatus = Set(map, P, Desc.value, False)
                    assert setStatus
                if hasattr(Desc, "writable") and not Desc.writable:
                    map.Delete(P)  # pylint: disable=no-member
        return True

    # -------------------------------- 𝟗.𝟒.𝟒.𝟑 [[𝑮𝒆𝒕]] ( 𝑷, 𝑹𝒆𝒄𝒆𝒊𝒗𝒆𝒓 ) ------------------------------------
    def Get(self, P, Receiver):
        # 9.4.4.3 [[Get]] ( P, Receiver )
        # The [[Get]] internal method of an arguments exotic object when called with a property key P and ECMAScript
        # language value Receiver performs the following steps:
        #
        #   1. Let args be the arguments object.
        #   2. Let map be args.[[ParameterMap]].
        #   3. Let isMapped be ! HasOwnProperty(map, P).
        #   4. If isMapped is false, then
        #       a. Return ? OrdinaryGet(args, P, Receiver).
        #   5. Else map contains a formal parameter mapping for P,
        #   6. Return Get(map, P).
        map = self.ParameterMap
        if not HasOwnProperty(map, P):
            return OrdinaryGet(self, P, Receiver)
        return Get(map, P)

    # -------------------------------- 𝟗.𝟒.𝟒.𝟒 [[𝑺𝒆𝒕]] ( 𝑷, 𝑽, 𝑹𝒆𝒄𝒆𝒊𝒗𝒆𝒓 ) ------------------------------------
    def Set(self, P, V, Receiver):
        # 9.4.4.4 [[Set]] ( P, V, Receiver )
        # The [[Set]] internal method of an arguments exotic object when called with property key P, value V, and
        # ECMAScript language value Receiver performs the following steps:
        #
        #   1. Let args be the arguments object.
        #   2. If SameValue(args, Receiver) is false, then
        #       a. Let isMapped be false.
        #   3. Else,
        #       a. Let map be args.[[ParameterMap]].
        #       b. Let isMapped be ! HasOwnProperty(map, P).
        #   4. If isMapped is true, then
        #       a. Let setStatus be Set(map, P, V, false).
        #       b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.
        #   5. Return ? OrdinarySet(args, P, V, Receiver).
        if not SameValue(self, Receiver):
            isMapped = False
        else:
            map = self.ParameterMap
            isMapped = HasOwnProperty(map, P)
        if isMapped:
            setStatus = Set(map, P, V, False)
            assert setStatus
        return OrdinarySet(self, P, V, Receiver)

    def Delete(self, P):
        # 9.4.4.5 [[Delete]] ( P )
        # The [[Delete]] internal method of an arguments exotic object when called with a property key P performs the
        # following steps:
        #
        #   1. Let args be the arguments object.
        #   2. Let map be args.[[ParameterMap]].
        #   3. Let isMapped be ! HasOwnProperty(map, P).
        #   4. Let result be ? OrdinaryDelete(args, P).
        #   5. If result is true and isMapped is true, then
        #       a. Call map.[[Delete]](P).
        #   6. Return result.
        map = self.ParameterMap
        isMapped = HasOwnProperty(map, P)
        result = OrdinaryDelete(self, P)
        if result and isMapped:
            map.Delete(P)  # pylint: disable=no-member
        return result


# 9.4.4.6 CreateUnmappedArgumentsObject ( argumentsList )
def CreateUnmappedArgumentsObject(argumentsList):
    # The abstract operation CreateUnmappedArgumentsObject called with an argument argumentsList performs the following
    # steps:
    #
    #   1. Let len be the number of elements in argumentsList.
    #   2. Let obj be ObjectCreate(%ObjectPrototype%, « [[ParameterMap]] »).
    #   3. Set obj.[[ParameterMap]] to undefined.
    #   4. Perform DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: len, [[Writable]]: true,
    #      [[Enumerable]]: false, [[Configurable]]: true }).
    #   5. Let index be 0.
    #   6. Repeat, while index < len,
    #       a. Let val be argumentsList[index].
    #       b. Perform CreateDataProperty(obj, ! ToString(index), val).
    #       c. Increase index by 1.
    #   7. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%,
    #      [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
    #   8. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Get]]: %ThrowTypeError%,
    #      [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false }).
    #   9. Return obj.
    length = len(argumentsList)
    obj = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"], ["ParameterMap"])
    obj.ParameterMap = None
    desc = PropertyDescriptor(value=length, writable=True, enumerable=False, configurable=True)
    DefinePropertyOrThrow(obj, "length", desc)
    for index, val in enumerate(argumentsList):
        CreateDataProperty(obj, ToString(index), val)
    arrayproto_values = surrounding_agent.running_ec.realm.intrinsics["%ArrayProto_values%"]
    desc = PropertyDescriptor(value=arrayproto_values, writable=True, enumerable=False, configurable=True)
    DefinePropertyOrThrow(obj, wks_iterator, desc)
    throw_type_error = surrounding_agent.running_ec.realm.intrinsics["%ThrowTypeError%"]
    desc = PropertyDescriptor(Get=throw_type_error, Set=throw_type_error, enumerable=False, configurable=False)
    DefinePropertyOrThrow(obj, "callee", desc)
    return obj


# 9.4.4.7 CreateMappedArgumentsObject ( func, formals, argumentsList, env )
def CreateMappedArgumentsObject(func, formals, argumentsList, env):
    # The abstract operation CreateMappedArgumentsObject is called with object func, Parse Node formals, List
    # argumentsList, and Environment Record env. The following steps are performed:
    #
    #   1. Assert: formals does not contain a rest parameter, any binding patterns, or any initializers. It may contain
    #      duplicate identifiers.
    #   2. Let len be the number of elements in argumentsList.
    #   3. Let obj be a newly created arguments exotic object with a [[ParameterMap]] internal slot.
    #   4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
    #   5. Set obj.[[GetOwnProperty]] as specified in 9.4.4.1.
    #   6. Set obj.[[DefineOwnProperty]] as specified in 9.4.4.2.
    #   7. Set obj.[[Get]] as specified in 9.4.4.3.
    #   8. Set obj.[[Set]] as specified in 9.4.4.4.
    #   9. Set obj.[[Delete]] as specified in 9.4.4.5.
    #   10. Set obj.[[Prototype]] to %ObjectPrototype%.
    #   11. Set obj.[[Extensible]] to true.
    #   12. Let map be ObjectCreate(null).
    #   13. Set obj.[[ParameterMap]] to map.
    #   14. Let parameterNames be the BoundNames of formals.
    #   15. Let numberOfParameters be the number of elements in parameterNames.
    #   16. Let index be 0.
    #   17. Repeat, while index < len,
    #       a. Let val be argumentsList[index].
    #       b. Perform CreateDataProperty(obj, ! ToString(index), val).
    #       c. Increase index by 1.
    #   18. Perform DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: len, [[Writable]]: true,
    #       [[Enumerable]]: false, [[Configurable]]: true }).
    #   19. Let mappedNames be a new empty List.
    #   20. Let index be numberOfParameters - 1.
    #   21. Repeat, while index ≥ 0,
    #       a. Let name be parameterNames[index].
    #       b. If name is not an element of mappedNames, then
    #           i. Add name as an element of the list mappedNames.
    #           ii. If index < len, then
    #               1. Let g be MakeArgGetter(name, env).
    #               2. Let p be MakeArgSetter(name, env).
    #               3. Perform map.[[DefineOwnProperty]](! ToString(index), PropertyDescriptor { [[Set]]: p,
    #                  [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true }).
    #       c. Decrease index by 1.
    #   22. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%,
    #       [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
    #   23. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Value]]: func, [[Writable]]: true,
    #       [[Enumerable]]: false, [[Configurable]]: true }).
    #   24. Return obj.
    length = len(argumentsList)
    obj = ArgumentsObject()
    obj.Prototype = surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"]
    obj.Extensible = True
    map = ObjectCreate(JSNull.NULL)
    obj.ParameterMap = map
    parameterNames = formals.BoundNames()
    numberOfParameters = len(parameterNames)
    for index, val in enumerate(argumentsList):
        CreateDataProperty(obj, ToString(index), val)
    DefinePropertyOrThrow(
        obj, "length", PropertyDescriptor(value=length, writable=True, enumerable=False, configurable=True)
    )
    mappedNames = []
    for index in range(numberOfParameters - 1, -1, -1):
        name = parameterNames[index]
        if name not in mappedNames:
            mappedNames += name
            if index < length:
                g = MakeArgGetter(name, env)
                p = MakeArgSetter(name, env)
                map.DefineOwnProperty(  # pylint: disable=no-member
                    ToString(index), PropertyDescriptor(Set=p, Get=g, enumerable=False, configurable=True)
                )
    DefinePropertyOrThrow(
        obj,
        wks_iterator,
        PropertyDescriptor(
            value=surrounding_agent.running_ec.realm.intrinsics["%ArrayProto_values%"],
            writable=True,
            enumerable=False,
            configurable=True,
        ),
    )
    DefinePropertyOrThrow(
        obj, "callee", PropertyDescriptor(value=func, writable=True, enumerable=False, configurable=True)
    )
    return obj


# 9.4.4.7.1 MakeArgGetter ( name, env )
def MakeArgGetter(name, env):
    # The abstract operation MakeArgGetter called with String name and Environment Record env creates a built-in
    # function object that when executed returns the value bound for name in env. It performs the following steps:
    #
    #   1. Let steps be the steps of an ArgGetter function as specified below.
    #   2. Let getter be CreateBuiltinFunction(steps, « [[Name]], [[Env]] »).
    #   3. Set getter.[[Name]] to name.
    #   4. Set getter.[[Env]] to env.
    #   5. Return getter.
    #
    # An ArgGetter function is an anonymous built-in function with [[Name]] and [[Env]] internal slots. When an
    # ArgGetter function that expects no arguments is called it performs the following steps:
    #
    #   1. Let f be the active function object.
    #   2. Let name be f.[[Name]].
    #   3. Let env be f.[[Env]].
    #   4. Return env.GetBindingValue(name, false).
    # NOTE
    # ArgGetter functions are never directly accessible to ECMAScript code.
    def ArgGetter(this_value, new_target, *_):
        f = GetActiveFunction()
        return f.Env.GetBindingValue(f.Name, False)

    getter = CreateBuiltinFunction(ArgGetter, ["Name", "Env"])
    getter.Name = name
    getter.Env = env
    return getter


# 9.4.4.7.2 MakeArgSetter ( name, env )
def MakeArgSetter(name, env):
    # The abstract operation MakeArgSetter called with String name and Environment Record env creates a built-in
    # function object that when executed sets the value bound for name in env. It performs the following steps:
    #
    #   1. Let steps be the steps of an ArgSetter function as specified below.
    #   2. Let setter be CreateBuiltinFunction(steps, « [[Name]], [[Env]] »).
    #   3. Set setter.[[Name]] to name.
    #   4. Set setter.[[Env]] to env.
    #   5. Return setter.
    #
    # An ArgSetter function is an anonymous built-in function with [[Name]] and [[Env]] internal slots. When an
    # ArgSetter function is called with argument value it performs the following steps:
    #
    #   1. Let f be the active function object.
    #   2. Let name be f.[[Name]].
    #   3. Let env be f.[[Env]].
    #   4. Return env.SetMutableBinding(name, value, false).
    #
    # NOTE
    # ArgSetter functions are never directly accessible to ECMAScript code.
    def ArgSetter(this_value, new_target, value=None, *_):
        f = GetActiveFunction()
        return f.Env.SetMutableBinding(f.Name, value, False)

    setter = CreateBuiltinFunction(ArgSetter, ["Name", "Env"])
    setter.Name = name
    setter.Env = env
    return setter


# 9.4.5 Integer-Indexed Exotic Objects
# An Integer-Indexed exotic object is an exotic object that performs special handling of integer index property
# keys.
#
# Integer-Indexed exotic objects have the same internal slots as ordinary objects and additionally
# [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
#
# Integer-Indexed exotic objects provide alternative definitions for the following internal methods. All of the
# other Integer-Indexed exotic object essential internal methods that are not defined below are as specified in 9.1.
class IntegerIndexedObject(JSObject):
    def __init__(self):
        self.ViewedArrayBuffer = None
        self.ArrayLength = None
        self.ByteOffset = None
        self.TypedArrayName = None
        super().__init__()

    # 9.4.5.1 [[GetOwnProperty]] ( P )
    def GetOwnProperty(self, P):
        # When the [[GetOwnProperty]] internal method of an Integer-Indexed exotic object O is called with property
        # key P, the following steps are taken:
        #   1. Assert: IsPropertyKey(P) is true.
        #   2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
        #   3. If Type(P) is String, then
        #       a. Let numericIndex be ! CanonicalNumericIndexString(P).
        #       b. If numericIndex is not undefined, then
        #           i. Let value be ? IntegerIndexedElementGet(O, numericIndex).
        #           ii. If value is undefined, return undefined.
        #           iii. Return a PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true,
        #                [[Configurable]]: false }.
        #   4. Return OrdinaryGetOwnProperty(O, P).
        assert IsPropertyKey(P)
        if isString(P):
            numericIndex = CanonicalNumericIndexString(P)
            if numericIndex is not None:
                value = IntegerIndexedElementGet(self, numericIndex)
                if value is None:
                    return None
                return PropertyDescriptor(value=value, writable=True, enumerable=True, configurable=False)
        return OrdinaryGetOwnProperty(self, P)

    # 9.4.5.2 [[HasProperty]] ( P )
    def HasProperty(self, P):
        # When the [[HasProperty]] internal method of an Integer-Indexed exotic object O is called with property key
        # P, the following steps are taken:
        #   1. Assert: IsPropertyKey(P) is true.
        #   2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
        #   3. If Type(P) is String, then
        #       a. Let numericIndex be ! CanonicalNumericIndexString(P).
        #       b. If numericIndex is not undefined, then
        #           i. Let buffer be O.[[ViewedArrayBuffer]].
        #           ii. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
        #           iii. If IsInteger(numericIndex) is false, return false.
        #           iv. If numericIndex = -0, return false.
        #           v. If numericIndex < 0, return false.
        #           vi. If numericIndex ≥ O.[[ArrayLength]], return false.
        #           vii. Return true.
        #   4. Return ? OrdinaryHasProperty(O, P).
        assert IsPropertyKey(P)
        if isString(P):
            numericIndex = CanonicalNumericIndexString(P)
            if numericIndex is not None:
                buffer = self.ViewedArrayBuffer
                if IsDetachedBuffer(buffer):
                    raise ESTypeError("[[HasProperty]] called with detached buffer")
                return not (
                    (not IsInteger(numericIndex))
                    or (numericIndex == 0 and math.copysign(1, numericIndex) == -1)
                    or numericIndex < 0
                    or numericIndex >= self.ArrayLength
                )
        return OrdinaryHasProperty(self, P)

    # 9.4.5.3 [[DefineOwnProperty]] ( P, Desc )
    def DefineOwnProperty(self, P, Desc):
        # When the [[DefineOwnProperty]] internal method of an Integer-Indexed exotic object O is called with
        # property key P, and Property Descriptor Desc, the following steps are taken:
        #   1. Assert: IsPropertyKey(P) is true.
        #   2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
        #   3. If Type(P) is String, then
        #       a. Let numericIndex be ! CanonicalNumericIndexString(P).
        #       b. If numericIndex is not undefined, then
        #           i. If IsInteger(numericIndex) is false, return false.
        #           ii. If numericIndex = -0, return false.
        #           iii. If numericIndex < 0, return false.
        #           iv. Let length be O.[[ArrayLength]].
        #           v. If numericIndex ≥ length, return false.
        #           vi. If IsAccessorDescriptor(Desc) is true, return false.
        #           vii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is true, return false.
        #           viii. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.
        #           ix. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.
        #           x. If Desc has a [[Value]] field, then
        #               1. Let value be Desc.[[Value]].
        #               2. Return ? IntegerIndexedElementSet(O, numericIndex, value).
        #           xi. Return true.
        #   4. Return ! OrdinaryDefineOwnProperty(O, P, Desc).
        assert IsPropertyKey(P)
        if isString(P):
            numericIndex = CanonicalNumericIndexString(P)
            if numericIndex is not None:
                if (
                    not IsInteger(numericIndex)
                    or (numericIndex == 0 and math.copysign(1, numericIndex) == -1)
                    or numericIndex < 0
                    or numericIndex >= self.ArrayLength
                    or IsAccessorDescriptor(Desc)
                    or getattr(Desc, "configurable", False)
                    or not getattr(Desc, "enumerable", True)
                    or not getattr(Desc, "writable", True)
                ):
                    return False
                if hasattr(Desc, "value"):
                    value = Desc.value
                    return IntegerIndexedElementSet(self, numericIndex, value)
                return True
        return OrdinaryDefineOwnProperty(self, P, Desc)

    # 9.4.5.4 [[Get]] ( P, Receiver )
    def Get(self, P, Receiver):
        # When the [[Get]] internal method of an Integer-Indexed exotic object O is called with property key P and
        # ECMAScript language value Receiver, the following steps are taken:
        #   1. Assert: IsPropertyKey(P) is true.
        #   2. If Type(P) is String, then
        #       a. Let numericIndex be ! CanonicalNumericIndexString(P).
        #       b. If numericIndex is not undefined, then
        #           i. Return ? IntegerIndexedElementGet(O, numericIndex).
        #   3. Return ? OrdinaryGet(O, P, Receiver).
        assert IsPropertyKey(P)
        if isString(P):
            numericIndex = CanonicalNumericIndexString(P)
            if numericIndex is not None:
                return IntegerIndexedElementGet(self, numericIndex)
        return OrdinaryGet(self, P, Receiver)

    # 9.4.5.5 [[Set]] ( P, V, Receiver )
    def Set(self, P, V, Receiver):
        # When the [[Set]] internal method of an Integer-Indexed exotic object O is called with property key P,
        # value V, and ECMAScript language value Receiver, the following steps are taken:
        #   1. Assert: IsPropertyKey(P) is true.
        #   2. If Type(P) is String, then
        #       a. Let numericIndex be ! CanonicalNumericIndexString(P).
        #       b. If numericIndex is not undefined, then
        #           i. Return ? IntegerIndexedElementSet(O, numericIndex, V).
        #   3. Return ? OrdinarySet(O, P, V, Receiver).
        assert IsPropertyKey(P)
        if isString(P):
            numericIndex = CanonicalNumericIndexString(P)
            if numericIndex is not None:
                return IntegerIndexedElementSet(self, numericIndex, V)
        return OrdinarySet(self, P, V, Receiver)

    # 9.4.5.6 [[OwnPropertyKeys]] ( )
    def OwnPropertyKeys(self):
        # When the [[OwnPropertyKeys]] internal method of an Integer-Indexed exotic object O is called, the
        # following steps are taken:
        #   1. Let keys be a new empty List.
        #   2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and
        #      [[TypedArrayName]] internal slots.
        #   3. Let len be O.[[ArrayLength]].
        #   4. For each integer i starting with 0 such that i < len, in ascending order, do
        #       a. Add ! ToString(i) as the last element of keys.
        #   5. For each own property key P of O such that Type(P) is String and P is not an integer index, in
        #      ascending chronological order of property creation, do
        #       a. Add P as the last element of keys.
        #   6. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of
        #      property creation, do
        #       a. Add P as the last element of keys.
        #   7. Return keys.
        return list(
            chain(
                (ToString(i) for i in range(self.ArrayLength)),
                (key for key in self.properties.keys() if isString(key) and not isIntegerIndex(key)),
                (key for key in self.properties.keys() if isSymbol(key)),
            )
        )


# 9.4.5.7 IntegerIndexedObjectCreate ( prototype, internalSlotsList )
def IntegerIndexedObjectCreate(prototype, internalSlotsList):
    # The abstract operation IntegerIndexedObjectCreate with arguments prototype and internalSlotsList is used to
    # specify the creation of new Integer-Indexed exotic objects. The argument internalSlotsList is a List of the
    # names of additional internal slots that must be defined as part of the object. IntegerIndexedObjectCreate
    # performs the following steps:
    #   1. Assert: internalSlotsList contains the names [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and
    #      [[TypedArrayName]].
    #   2. Let A be a newly created object with an internal slot for each name in internalSlotsList.
    #   3. Set A's essential internal methods to the default ordinary object definitions specified in 9.1.
    #   4. Set A.[[GetOwnProperty]] as specified in 9.4.5.1.
    #   5. Set A.[[HasProperty]] as specified in 9.4.5.2.
    #   6. Set A.[[DefineOwnProperty]] as specified in 9.4.5.3.
    #   7. Set A.[[Get]] as specified in 9.4.5.4.
    #   8. Set A.[[Set]] as specified in 9.4.5.5.
    #   9. Set A.[[OwnPropertyKeys]] as specified in 9.4.5.6.
    #   10. Set A.[[Prototype]] to prototype.
    #   11. Set A.[[Extensible]] to true.
    #   12. Return A.
    required_slots = ("ViewedArrayBuffer", "ArrayLength", "ByteOffset", "TypedArrayName")
    assert all(slot in internalSlotsList for slot in required_slots)
    A = IntegerIndexedObject()
    for slot in (slot for slot in internalSlotsList if slot not in required_slots):
        setattr(A, slot, None)
    A.Prototype = prototype
    A.Extensible = True
    return A


# 9.4.5.8 IntegerIndexedElementGet ( O, index )
def IntegerIndexedElementGet(O, index):
    # The abstract operation IntegerIndexedElementGet with arguments O and index performs the following steps:
    #   1. Assert: Type(index) is Number.
    #   2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and
    #      [[TypedArrayName]] internal slots.
    #   3. Let buffer be O.[[ViewedArrayBuffer]].
    #   4. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    #   5. If IsInteger(index) is false, return undefined.
    #   6. If index = -0, return undefined.
    #   7. Let length be O.[[ArrayLength]].
    #   8. If index < 0 or index ≥ length, return undefined.
    #   9. Let offset be O.[[ByteOffset]].
    #   10. Let arrayTypeName be the String value of O.[[TypedArrayName]].
    #   11. Let elementSize be the Number value of the Element Size value specified in Table 59 for arrayTypeName.
    #   12. Let indexedPosition be (index × elementSize) + offset.
    #   13. Let elementType be the String value of the Element Type value in Table 59 for arrayTypeName.
    #   14. Return GetValueFromBuffer(buffer, indexedPosition, elementType, true, "Unordered").
    assert isNumber(index)
    assert isObject(O) and all(
        hasattr(O, name) for name in ("ViewedArrayBuffer", "ArrayLength", "ByteOffset", "TypedArrayName")
    )
    buffer = O.ViewedArrayBuffer
    if IsDetachedBuffer(buffer):
        raise ESTypeError("Can't get from a detached buffer")
    if not IsInteger(index):
        return None
    if index == 0 and math.copysign(1, index) == -1:
        return None
    if index < 0 or index >= O.ArrayLength:
        return None
    offset = O.ByteOffset
    arrayTypeName = O.TypedArrayName
    elementSize = TA_ElementSize[arrayTypeName]
    indexedPosition = index * elementSize + offset
    elementType = TA_ElementTypeName[arrayTypeName]
    return GetValueFromBuffer(buffer, indexedPosition, elementType, True, "Unordered")


# 9.4.5.9 IntegerIndexedElementSet ( O, index, value )
def IntegerIndexedElementSet(O, index, value):
    # The abstract operation IntegerIndexedElementSet with arguments O, index, and value performs the following
    # steps:
    #   1. Assert: Type(index) is Number.
    #   2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and
    #      [[TypedArrayName]] internal slots.
    #   3. Let numValue be ? ToNumber(value).
    #   4. Let buffer be O.[[ViewedArrayBuffer]].
    #   5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    #   6. If IsInteger(index) is false, return false.
    #   7. If index = -0, return false.
    #   8. Let length be O.[[ArrayLength]].
    #   9. If index < 0 or index ≥ length, return false.
    #   10. Let offset be O.[[ByteOffset]].
    #   11. Let arrayTypeName be the String value of O.[[TypedArrayName]].
    #   12. Let elementSize be the Number value of the Element Size value specified in Table 59 for arrayTypeName.
    #   13. Let indexedPosition be (index × elementSize) + offset.
    #   14. Let elementType be the String value of the Element Type value in Table 59 for arrayTypeName.
    #   15. Perform SetValueInBuffer(buffer, indexedPosition, elementType, numValue, true, "Unordered").
    #   16. Return true.
    assert isNumber(index)
    assert isObject(O) and all(
        hasattr(O, name) for name in ("ViewedArrayBuffer", "ArrayLength", "ByteOffset", "TypedArrayName")
    )
    numValue = ToNumber(value)
    buffer = O.ViewedArrayBuffer
    if IsDetachedBuffer(buffer):
        raise ESTypeError("Can't Set to a detached buffer")
    if not IsInteger(index):
        return False
    if index == 0 and math.copysign(1, index) == -1:
        return False
    if index < 0 or index >= O.ArrayLength:
        return False
    offset = O.ByteOffset
    arrayTypeName = O.TypedArrayName
    elementSize = TA_ElementSize[arrayTypeName]
    indexedPosition = index * elementSize + offset
    elementType = TA_ElementTypeName[arrayTypeName]
    SetValueInBuffer(buffer, indexedPosition, elementType, numValue, True, "Unordered")
    return True


# ------------------------------------ 𝟗.𝟒.𝟕 𝑰𝒎𝒎𝒖𝒕𝒂𝒃𝒍𝒆 𝑷𝒓𝒐𝒕𝒐𝒕𝒚𝒑𝒆 𝑬𝒙𝒐𝒕𝒊𝒄 𝑶𝒃𝒋𝒆𝒄𝒕𝒔 ------------------------------------
# 9.4.7 Immutable Prototype Exotic Objects
#
# An immutable prototype exotic object is an exotic object that has a [[Prototype]] internal slot that will not change
# once it is initialized.
#
# Immutable prototype exotic objects have the same internal slots as ordinary objects. They are exotic only in the
# following internal methods. All other internal methods of immutable prototype exotic objects that are not explicitly
# defined below are instead defined as in ordinary objects.
#
# 9.4.7.1 [[SetPrototypeOf]] ( V )
# When the [[SetPrototypeOf]] internal method of an immutable prototype exotic object O is called with argument V, the
# following steps are taken:
#
# 1. Return ? SetImmutablePrototype(O, V).
#
# 9.4.7.2 SetImmutablePrototype ( O, V )
def SetImmutablePrototype(obj, value):
    # When the SetImmutablePrototype abstract operation is called with arguments O and V, the following steps are
    # taken:
    #
    # 1. Assert: Either Type(V) is Object or Type(V) is Null.
    assert isObject(value) or isNull(value)
    # 2. Let current be ? O.[[GetPrototypeOf]]().
    current = obj.GetPrototypeOf()
    # 3. If SameValue(V, current) is true, return true.
    # 4. Return false.
    return SameValue(value, current)


# 9.5 ProxyObjects
class ProxyObject(JSObject):
    pass


def prep_for_bitwise(lval, rval):
    lnum = ToInt32(lval)  # 1. Let lnum be ? ToInt32(lval).
    rnum = ToInt32(rval)  # 2. Let rnum be ? ToInt32(rval).
    return (lnum, rnum)  # Return (lnum, rnum)


def BitwiseANDOperation(lval, rval):
    # Do integer conversion on the operands, forming lnum and rnum
    operands = prep_for_bitwise(lval, rval)
    lnum, rnum = operands
    # Return the result of applying the bitwise operator & to lnum and rnum. The result is a signed 32-bit integer.
    return lnum & rnum


def BitwiseXOROperation(lval, rval):
    # Do integer conversion on the operands, forming lnum and rnum
    operands = prep_for_bitwise(lval, rval)
    lnum, rnum = operands
    # Return the result of applying the bitwise operator ^ to lnum and rnum. The result is a signed 32-bit integer.
    return lnum ^ rnum


def BitwiseOROperation(lval, rval):
    # Do integer conversion on the operands, forming lnum and rnum
    operands = prep_for_bitwise(lval, rval)
    lnum, rnum = operands
    # Return the result of applying the bitwise operator | to lnum and rnum. The result is a signed 32-bit integer.
    return lnum | rnum


def AdditionOperation(lval, rval):
    lprim = ToPrimitive(lval)
    rprim = ToPrimitive(rval)
    if isString(lprim) or isString(rprim):
        lstr = ToString(lprim)
        rstr = ToString(rprim)
        return lstr + rstr
    # Do number conversion on the operands, forming lnum and rnum
    operands = prep_for_math(lval, rval)
    lnum, rnum = operands
    # Return the result of applying the addition operator to lnum and rnum.
    return lnum + rnum


def SubtractionOperation(lval, rval):
    # Do number conversion on the operands, forming lnum and rnum
    operands = prep_for_math(lval, rval)
    lnum, rnum = operands
    # Return the result of applying the modulo operator to lnum and rnum.
    return lnum - rnum


def prep_for_signed_shift(lval, rval):
    # Converts args to integer values, in preparation for signed shifting.
    lnum = ToInt32(lval)  # 1. Let lnum be ? ToInt32(lval).
    rnum = ToUint32(rval)  # 2. Let rnum be ? ToUnit32(rval).
    return (int(lnum), int(rnum))  # 3. Return (lnum, rnum).


def LeftShiftOperation(lval, rval):
    # Do number conversion on the operands, forming lnum and rnum
    operands = prep_for_signed_shift(lval, rval)
    lnum, rnum = operands
    # Strip the right operand to 5 bits and shift the left. Then put it back into a 32-bit int.
    shiftCount = rnum & 0x1F
    return ToInt32(lnum << shiftCount)


def RightShiftOperation(lval, rval):
    # Do number conversion on the operands, forming lnum and rnum
    operands = prep_for_signed_shift(lval, rval)
    lnum, rnum = operands
    shiftCount = rnum & 0x1F
    return lnum >> shiftCount


def prep_for_unsigned_shift(lval, rval):
    # Converts args to integer values, in preparation for unsigned shifting.
    lnum = ToUint32(lval)  # 1. Let lnum be ? ToUint32(lval)
    rnum = ToUint32(rval)  # 2. Let rnum be ? ToUnit32(rval)
    return (int(lnum), int(rnum))  # 3. Return (lnum, rnum)


def UnsignedRightShiftOperation(lval, rval):
    # Do number conversion on the operands, forming lnum and rnum
    operands = prep_for_unsigned_shift(lval, rval)
    lnum, rnum = operands
    shiftCount = rnum & 0x1F
    return lnum >> shiftCount


# Parser Common Functions
def trampoline(f, *args):
    v = f(*args)
    while callable(v):
        v = v()
    return v


class ParseNode2:
    def __init__(self, ctx, name, strict, children=[]):
        self.name = name
        self.context = ctx
        assert isinstance(children, list)
        self.children = children
        self.strict = strict

    @cached_property
    def after(self):
        if hasattr(self.children[-1], "span"):
            return self.children[-1].span.after
        return self.children[-1].after

    @cached_property
    def start(self):
        if hasattr(self.children[0], "span"):
            return self.children[0].span.start
        return self.children[0].start

    @cached_property
    def src(self):
        return self.children[0].src

    @property
    def pn_count(self):
        return 1 + sum(node.pn_count for node in self.children if isinstance(node, ParseNode2))

    def terminals(self):
        for child in filter(None, self.children):
            if not isinstance(child, ParseNode2):
                yield child
            else:
                for sub_token in child.terminals():
                    yield sub_token

    def matched_source(self):
        return self.src[self.start : self.after]

    def defer_target(self):
        # When a function defers by default to its children, it picks the sole nonterminal. The routine here figures out which
        # parse node that actually is. (And asserts if there wasn't a sole nonterminal.)
        child_nonterminals = [ch for ch in self.children if isinstance(ch, ParseNode2)]
        assert len(child_nonterminals) == 1, "Child Deferral Failed: more than one child (or none of them)"
        return child_nonterminals[0]

    def __repr__(self):
        children = " ".join(
            ch.name if isinstance(ch, ParseNode2) else f"{ch.type}" for ch in filter(None, self.children)
        )
        terms = " ".join(repr(trm.value) if trm.type == "STRING" else str(trm.value) for trm in self.terminals())
        return f"ParseNode[{self.name} : {children}] ({terms})"

    def Contains(self, symbol):
        return (
            any(child.name == symbol for child in self.children if hasattr(child, "name"))
            or any(
                child.type == "IDENTIFIER" and child.value == symbol
                for child in self.children
                if (hasattr(child, "type") and hasattr(child, "value"))
            )
            or any(child.Contains(symbol) for child in self.children if hasattr(child, "Contains"))
        )

    def Is(self, symbol):
        return self.name == symbol or (
            len(self.children) == 1 and hasattr(self.children[0], "Is") and self.children[0].Is(symbol)
        )

    def Derived(self, symbol):
        if (type(symbol) == str and self.name == symbol) or (type(symbol) == type and isinstance(self, symbol)):
            return self
        if len(self.children) == 1 and isinstance(self.children[0], ParseNode2):
            return self.children[0].Derived(symbol)
        return None

    def covering(self, parse_fcn, *args):
        sublexer = self.context.lexer_interface(self.src[self.start : self.after], self.CreateSyntaxError)
        parse_node = parse_fcn(self.context, sublexer, 0, *args)
        return parse_node if parse_node.after == self.after - self.start else None

    def EarlyErrorsScan(self):
        errs = []
        # Check the children first
        for ch in (child for child in self.children if hasattr(child, "EarlyErrorsScan")):
            errs.extend(ch.EarlyErrorsScan())
        # Now myself.
        errs.extend(self.EarlyErrors())
        return errs

    def EarlyErrors(self):
        return []

    @cached_property
    def early_errors_eval_outside_functions(self):
        return tuple(
            chain(*(c.early_errors_eval_outside_functions for c in self.children if isinstance(c, ParseNode2)))
        )

    @cached_property
    def early_errors_eval_outside_methods(self):
        return tuple(
            chain(*(c.early_errors_eval_outside_methods for c in self.children if isinstance(c, ParseNode2)))
        )

    @cached_property
    def early_errors_eval_outside_constructor_methods(self):
        return tuple(
            chain(
                *(
                    c.early_errors_eval_outside_constructor_methods
                    for c in self.children
                    if isinstance(c, ParseNode2)
                )
            )
        )

    def set_strict_in_subtree(self):
        self.strict = True
        for ch in (child for child in self.children if isinstance(child, ParseNode2)):
            ch.set_strict_in_subtree()

    @property
    def direct_eval(self):
        return self.context.direct_eval

    @property
    def CreateSyntaxError(self):
        return self.context.CreateSyntaxError

    def IsFunctionDefinition(self, *args, **kwargs):
        return self.defer_target().IsFunctionDefinition(*args, **kwargs)

    def IsValidSimpleAssignmentTarget(self, *args, **kwargs):
        return self.defer_target().IsValidSimpleAssignmentTarget(*args, **kwargs)

    def LexicallyDeclaredNames(self, *args, **kwargs):
        return self.defer_target().LexicallyDeclaredNames(*args, **kwargs)

    def TopLevelLexicallyDeclaredNames(self, *args, **kwargs):
        return self.defer_target().TopLevelLexicallyDeclaredNames(*args, **kwargs)

    def VarDeclaredNames(self, *args, **kwargs):
        return self.defer_target().VarDeclaredNames(*args, **kwargs)

    def TopLevelVarDeclaredNames(self, *args, **kwargs):
        return self.defer_target().TopLevelVarDeclaredNames(*args, **kwargs)

    def VarScopedDeclarations(self, *args, **kwargs):
        return self.defer_target().VarScopedDeclarations(*args, **kwargs)

    def TopLevelVarScopedDeclarations(self, *args, **kwargs):
        return self.defer_target().TopLevelVarScopedDeclarations(*args, **kwargs)

    def LexicallyScopedDeclarations(self, *args, **kwargs):
        return self.defer_target().LexicallyScopedDeclarations(*args, **kwargs)

    def TopLevelLexicallyScopedDeclarations(self, *args, **kwargs):
        return self.defer_target().TopLevelLexicallyScopedDeclarations(*args, **kwargs)

    def ContainsDuplicateLabels(self, *args, **kwargs):
        return self.defer_target().ContainsDuplicateLabels(*args, **kwargs)

    def ContainsUndefinedBreakTarget(self, *args, **kwargs):
        return self.defer_target().ContainsUndefinedBreakTarget(*args, **kwargs)

    def ContainsUndefinedContinueTarget(self, *args, **kwargs):
        return self.defer_target().ContainsUndefinedContinueTarget(*args, **kwargs)

    def BoundNames(self, *args, **kwargs):
        return self.defer_target().BoundNames(*args, **kwargs)

    @cached_property
    def StringValue(self):
        return self.defer_target().StringValue

    def ArgumentListEvaluation(self, *args, **kwargs):
        return self.defer_target().ArgumentListEvaluation(*args, **kwargs)

    def IsConstantDeclaration(self, *args, **kwargs):
        return self.defer_target().IsConstantDeclaration(*args, **kwargs)

    def PropertyDefinitionEvaluation(self, *args, **kwargs):
        return self.defer_target().PropertyDefinitionEvaluation(*args, **kwargs)

    def IteratorDestructuringAssignmentEvaluation(self, *args, **kwargs):
        return self.defer_target().IteratorDestructuringAssignmentEvaluation(*args, **kwargs)

    def DestructuringAssignmentEvaluation(self, *args, **kwargs):
        return self.defer_target().DestructuringAssignmentEvaluation(*args, **kwargs)

    def PropertyBindingInitialization(self, *args, **kwargs):
        return self.defer_target().PropertyBindingInitialization(*args, **kwargs)

    def IsDestructuring(self, *args, **kwargs):
        return self.defer_target().IsDestructuring(*args, **kwargs)

    def IsSimpleParameterList(self, *args, **kwargs):
        return self.defer_target().IsSimpleParameterList(*args, **kwargs)

    def ExpectedArgumentCount(self, *args, **kwargs):
        return self.defer_target().ExpectedArgumentCount(*args, **kwargs)

    def HasInitializer(self, *args, **kwargs):
        return self.defer_target().HasInitializer(*args, **kwargs)

    def DeclarationPart(self, *args, **kwargs):
        return self.defer_target().DeclarationPart(*args, **kwargs)

    def ContainsExpression(self, *args, **kwargs):
        return self.defer_target().ContainsExpression(*args, **kwargs)

    def IteratorBindingInitialization(self, *args, **kwargs):
        return self.defer_target().IteratorBindingInitialization(*args, **kwargs)

    def BindingInitialization(self, *args, **kwargs):
        return self.defer_target().BindingInitialization(*args, **kwargs)

    def TemplateStrings(self, *args, **kwargs):
        return self.defer_target().TemplateStrings(*args, **kwargs)

    def LeadingStrings(self, *args, **kwargs):
        return self.defer_target().LeadingStrings(*args, **kwargs)

    def IsStrict(self, *args, **kwargs):
        return self.defer_target().IsStrict(*args, **kwargs)

    def ContainsUseStrict(self, *args, **kwargs):
        return self.defer_target().ContainsUseStrict(*args, **kwargs)

    @cached_property
    def AssignmentTargetType(self):
        return self.defer_target().AssignmentTargetType

    def IsMissingInitializers(self, *args, **kwargs):
        return self.defer_target().IsMissingInitializers(*args, **kwargs)

    def PropName(self, *args, **kwargs):
        return self.defer_target().PropName(*args, **kwargs)

    def HasName(self, *args, **kwargs):
        return self.defer_target().HasName(*args, **kwargs)

    @cached_property
    def ConstructorMethod(self):
        return self.defer_target().ConstructorMethod

    @cached_property
    def NonConstructorMethodDefinitions(self):
        return self.defer_target().NonConstructorMethodDefinitions

    def KeyedBindingInitialization(self, *args, **kwargs):
        return self.defer_target().KeyedBindingInitialization(*args, **kwargs)

    def ComputedPropertyContains(self, *args, **kwargs):
        return self.defer_target().ComputedPropertyContains(*args, **kwargs)

    def NamedEvaluation(self, *args, **kwargs):
        return self.defer_target().NamedEvaluation(*args, **kwargs)

    def EvaluateBody(self, *args, **kwargs):
        return self.defer_target().EvaluateBody(*args, **kwargs)

    def LabelledEvaluation(self, *args, **kwargs):
        return self.defer_target().LabelledEvaluation(*args, **kwargs)

    def evaluate(self, *args, **kwargs):
        # Subclasses need to override this, or we'll throw an AttributeError when we hit a terminal.
        rval = self.defer_target().evaluate(*args, **kwargs)
        return rval

    @cached_property
    def contains_unenclosed_continue(self):
        # This is True for continue statements up to their enclosing iteration statement. (unless a function boundary
        # intervenes)
        return any(item.contains_unenclosed_continue for item in self.children if isinstance(item, ParseNode2))

    @cached_property
    def contains_encapsulated_unenclosed_continue(self):
        # This is True when a continue statement cannot be made whole by an iteration statement.
        # E.g.: "for (i=0; i<N; i++) { a = function () { continue; }; }"
        return any(
            item.contains_encapsulated_unenclosed_continue for item in self.children if isinstance(item, ParseNode2)
        )

    @cached_property
    def contains_unenclosed_break(self):
        # This is true for break statements up to their enclosing iteration or switch statements, unless a function
        # boundary intervenes).
        return any(item.contains_unenclosed_break for item in self.children if isinstance(item, ParseNode2))

    @cached_property
    def contains_encapsulated_unenclosed_break(self):
        # This is true for unenclosed break statements inside functions. I.e.: it's true for the production formed by:
        # a = function () { break; }
        return any(
            item.contains_encapsulated_unenclosed_break for item in self.children if isinstance(item, ParseNode2)
        )

    IsStringLiteral = False
    HasUseStrict = False


class Parse2Context:
    def __init__(self, direct_eval=False, syntax_error_ctor=SyntaxError, goal="Script", lexer=LexerCore):
        self.direct_eval = direct_eval
        self.CreateSyntaxError = syntax_error_ctor
        self.goal = goal
        self.lexer_interface = lexer


def empty_node(ctx):
    return ParseNode2(ctx, "[empty]", False)


"""
 d888    .d8888b.       d888       8888888      888                   888    d8b  .d888 d8b
d8888   d88P  Y88b     d8888         888        888                   888    Y8P d88P"  Y8P
  888          888       888         888        888                   888        888
  888        .d88P       888         888    .d88888  .d88b.  88888b.  888888 888 888888 888  .d88b.  888d888 .d8888b
  888    .od888P"        888         888   d88" 888 d8P  Y8b 888 "88b 888    888 888    888 d8P  Y8b 888P"   88K
  888   d88P"            888         888   888  888 88888888 888  888 888    888 888    888 88888888 888     "Y8888b.
  888   888"       d8b   888         888   Y88b 888 Y8b.     888  888 Y88b.  888 888    888 Y8b.     888          X88
8888888 888888888  Y8P 8888888     8888888  "Y88888  "Y8888  888  888  "Y888 888 888    888  "Y8888  888      88888P'

12.1 Identifiers
12.1.1 SS: Early Errors
12.1.2 SS: BoundNames
12.1.3 SS: AssignmentTargetType
12.1.4 SS: StringValue
12.1.5 RS: BindingInitialization
12.1.5.1 RS: InitializeBoundName ( name, value, environment )
12.1.6 RS: Evaluation
"""

####################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟐.𝟏 𝓘𝓭𝓮𝓷𝓽𝓲𝓯𝓲𝓮𝓻𝓼 .....●·._..●·._..●·._.·´ #
####################################################################################
# 12.1 Identifiers


def _reference_helper(ctx, lexer, pos, strict, Yield, Await, driver):
    ident = parse_Identifier(ctx, lexer, pos, strict)
    if ident:
        _, ctor = driver["IDENTIFIER"]
        return ctor(ctx, strict, [ident], Yield, Await)
    for kind in ("YIELD", "AWAIT"):
        check, ctor = driver[kind]
        if check:
            tok = lexer.id_if(pos, kind.lower())
            if tok:
                return ctor(ctx, strict, [tok], Yield, Await)
    return None


class _P2_Common_Identifier_YIELD(ParseNode2):
    def EarlyErrors(self):
        # 12.1.1 Static Semantics: Early Errors
        # * It is a Syntax Error if the code matched by this production is contained in strict mode code.
        if self.strict:
            return [self.CreateSyntaxError("'yield' not allowed as an identifier in strict mode")]
        return []

    # 12.1.4 Static Semantics: StringValue
    # IdentifierReference : yield
    # BindingIdentifier : yield
    # LabelIdentifier : yield
    #   1. Return "yield".
    StringValue = "yield"


class _P2_Common_Identifier_AWAIT(ParseNode2):
    def EarlyErrors(self):
        # 12.1.1 Static Semantics: Early Errors
        # * It is a Syntax Error if the goal symbol of the syntactic grammar is Module.
        if self.context.goal == "Module":
            return [self.CreateSyntaxError("'await' not allowed as an identifier in modules")]
        return []

    # 12.1.4 Static Semantics: StringValue
    # IdentifierReference : await
    # BindingIdentifier : await
    # LabelIdentifier : await
    #   1. Return "await".
    StringValue = "await"


class _P2_Common_Identifier_Identifier(ParseNode2):
    def EarlyErrors(self):
        # 12.1.1 Static Semantics: Early Errors
        # * It is a Syntax Error if this production has a [Yield] parameter and StringValue of Identifier is "yield".
        # * It is a Syntax Error if this production has an [Await] parameter and StringValue of Identifier is "await".
        # pylint: disable=no-member
        if self.Yield and self.Identifier.StringValue == "yield":
            return [
                self.CreateSyntaxError(
                    "'yield' not allowed as an identifier when 'yield' can be used as a statement"
                )
            ]
        if self.Await and self.Identifier.StringValue == "await":
            return [
                self.CreateSyntaxError(
                    "'await' not allowed as an identifier when 'await' can be used as a statement keyword"
                )
            ]
        return []


# --------======= 𝓘𝓭𝓮𝓷𝓽𝓲𝓯𝓲𝓮𝓻𝓡𝓮𝓯𝓮𝓻𝓮𝓷𝓬𝓮 =======--------
# 12.1 Identifiers
# Syntax
#   IdentifierReference :
#       Identifier
#       yield
#       await
class P2_IdentifierReference(ParseNode2):
    def __init__(self, ctx, strict, children, Yield, Await):
        super().__init__(ctx, "IdentifierReference", strict, children)
        self.Yield = Yield
        self.Await = Await


class P2_IdentifierReference_Identifier(_P2_Common_Identifier_Identifier, P2_IdentifierReference):
    # IdentifierReference : Identifier
    @property
    def Identifier(self):
        return self.children[0]

    @cached_property
    def AssignmentTargetType(self):
        # 12.1.3 Static Semantics: AssignmentTargetType
        #   IdentifierReference : Identifier
        #   1. If this IdentifierReference is contained in strict mode code and StringValue of Identifier is "eval" or
        #      "arguments", return strict.
        #   2. Return simple.
        if self.strict and self.Identifier.StringValue in ("eval", "arguments"):
            return STRICT
        return SIMPLE

    def evaluate(self):
        # 12.1.6 Runtime Semantics: Evaluation
        #       IdentifierReference : Identifier
        #   1. Return ? ResolveBinding(StringValue of Identifier).
        # NOTE 1
        # The result of evaluating an IdentifierReference is always a value of type Reference.
        # NOTE 2
        # In non-strict code, the keyword yield may be used as an identifier. Evaluating the IdentifierReference
        # resolves the binding of yield as if it was an Identifier. Early Error restriction ensures that such an
        # evaluation only can occur for non-strict code.
        return ResolveBinding(self.Identifier.StringValue, self.strict)


class P2_IdentifierReference_YIELD(_P2_Common_Identifier_YIELD, P2_IdentifierReference):
    # IdentifierReference : yield

    # 12.1.3 Static Semantics: AssignmentTargetType
    #   IdentifierReference : yield
    #   1. Return simple.
    AssignmentTargetType = SIMPLE

    def evaluate(self):
        # 12.1.6 Runtime Semantics: Evaluation
        #       IdentifierReference : yield
        #   1. Return ? ResolveBinding("yield").
        # NOTE 1
        # The result of evaluating an IdentifierReference is always a value of type Reference.
        # NOTE 2
        # In non-strict code, the keyword yield may be used as an identifier. Evaluating the IdentifierReference
        # resolves the binding of yield as if it was an Identifier. Early Error restriction ensures that such an
        # evaluation only can occur for non-strict code.
        return ResolveBinding("yield", self.strict)


class P2_IdentifierReference_AWAIT(_P2_Common_Identifier_AWAIT, P2_IdentifierReference):
    # IdentifierReference : await

    # 12.1.3 Static Semantics: AssignmentTargetType
    #   IdentifierReference : await
    #   1. Return simple.
    AssignmentTargetType = SIMPLE

    def evaluate(self):
        # 12.1.6 Runtime Semantics: Evaluation
        #       IdentifierReference : await
        #   1. Return ? ResolveBinding("await").
        # NOTE 1
        # The result of evaluating an IdentifierReference is always a value of type Reference.
        return ResolveBinding("await", self.strict)


def parse_IdentifierReference(ctx, lexer, pos, strict, Yield, Await):
    # Syntax
    #   IdentifierReference[Yield, Await]:
    #       Identifier
    #       [~Yield]yield
    #       [~Await]await
    return _reference_helper(
        ctx,
        lexer,
        pos,
        strict,
        Yield,
        Await,
        {
            "IDENTIFIER": (True, P2_IdentifierReference_Identifier),
            "YIELD": (not Yield, P2_IdentifierReference_YIELD),
            "AWAIT": (not Await, P2_IdentifierReference_AWAIT),
        },
    )


class P2_Identifier(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Identifier", strict, children)


class P2_Identifier_IdentifierName(P2_Identifier):
    @property
    def IdentifierName(self):
        return self.children[0]

    @cached_property
    def StringValue(self):
        return self.IdentifierName.value

    def EarlyErrors(self):
        # 12.1.1 Static Semantics: Early Errors
        #   * It is a Syntax Error if this phrase is contained in strict mode code and the StringValue of
        #     IdentifierName is: "implements", "interface", "let", "package", "private", "protected", "public",
        #     "static", or "yield".
        #   * It is a Syntax Error if the goal symbol of the syntactic grammar is Module and the StringValue of
        #     IdentifierName is "await".
        #   * It is a Syntax Error if StringValue of IdentifierName is the same String value as the StringValue of any
        #     ReservedWord except for yield or await.
        # NOTE
        #   StringValue of IdentifierName normalizes any Unicode escape sequences in IdentifierName hence such escapes
        #   cannot be used to write an Identifier whose code point sequence is the same as a ReservedWord.
        identifier_name = self.StringValue
        if self.strict and identifier_name in (
            "implements",
            "interface",
            "let",
            "package",
            "private",
            "protected",
            "public",
            "static",
            "yield",
        ):
            return [self.CreateSyntaxError(f"'{identifier_name}' is a reserved word in strict mode")]
        if self.context.goal == "Module" and identifier_name == "await":
            return [self.CreateSyntaxError("'await' is a reserved word for modules")]
        if identifier_name in (
            "break",
            "case",
            "catch",
            "class",
            "const",
            "continue",
            "debugger",
            "default",
            "delete",
            "do",
            "else",
            "export",
            "extends",
            "finally",
            "for",
            "function",
            "if",
            "import",
            "in",
            "instanceof",
            "new",
            "return",
            "super",
            "switch",
            "this",
            "throw",
            "try",
            "typeof",
            "var",
            "void",
            "while",
            "with",
            "enum",
            "null",
            "true",
            "false",
        ):
            return [self.CreateSyntaxError(f"'{identifier_name}' is a reserved word")]
        return []


def parse_Identifier(ctx, lexer, pos, strict):
    ident = lexer.token_if(pos, "IDENTIFIER")
    if ident and ident.src[ident.span.start : ident.span.after] not in lexer.reserved_words:
        return P2_Identifier_IdentifierName(ctx, strict, [ident])
    return None


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓘𝓭𝓮𝓷𝓽𝓲𝓯𝓲𝓮𝓻 =======--------
# BindingIdentifier
# Syntax
#   BindingIdentifier :
#       Identifier
#       yield
#       await
#
class P2_BindingIdentifier(ParseNode2):
    def __init__(self, ctx, strict, children, Yield, Await):
        super().__init__(ctx, "BindingIdentifier", strict, children)
        self.Yield = Yield
        self.Await = Await


class P2_BindingIdentifier_Identifier(_P2_Common_Identifier_Identifier, P2_BindingIdentifier):
    # BindingIdentifier : Identifier
    @property
    def Identifier(self):
        return self.children[0]

    def EarlyErrors(self):
        # 12.1.1 Static Semantics: Early Errors
        #   BindingIdentifier : Identifier
        #   * It is a Syntax Error if the code matched by this production is contained in strict mode code and the
        #     StringValue of Identifier is  "arguments" or "eval".
        #   * See the common EarlyErrors for the remaining syntax errors
        sv = self.Identifier.StringValue
        if self.strict and sv in ("arguments", "eval"):
            return [self.CreateSyntaxError(f"'{sv}' not allowed as an identifier in strict mode")]
        return super().EarlyErrors()

    def BoundNames(self):
        # 12.1.2 Static Semantics: BoundNames
        #   BindingIdentifier : Identifier
        #   1. Return a new List containing the StringValue of Identifier.
        return [self.Identifier.StringValue]

    def BindingInitialization(self, value, environment):
        # 12.1.5 Runtime Semantics: BindingInitialization
        #   BindingIdentifier : Identifier
        #   1. Let name be StringValue of Identifier.
        #   2. Return ? InitializeBoundName(name, value, environment).
        return InitializeBoundName(self.Identifier.StringValue, value, environment, self.strict)


class P2_BindingIdentifier_YIELD(_P2_Common_Identifier_YIELD, P2_BindingIdentifier):
    # BindingIdentifier : yield
    def EarlyErrors(self):
        # 12.1.1 Static Semantics: Early Errors
        #   BindingIdentifier : yield
        #   Common checks plus:
        #   * It is a Syntax Error if this production has a [Yield] parameter.
        if self.Yield:
            return [
                self.CreateSyntaxError(
                    "'yield' not allowed as an identifier when 'yield' can be used as a statement"
                )
            ]
        return super().EarlyErrors()

    def BoundNames(self):
        # 12.1.2 Static Semantics: BoundNames
        #           BindingIdentifier : yield
        # 1. Return a new List containing "yield".
        return ["yield"]

    def BindingInitialization(self, value, environment):
        # 12.1.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        #           BindingIdentifier : yield
        # 1. Return ? InitializeBoundName("yield", value, environment).
        return InitializeBoundName("yield", value, environment, self.strict)


class P2_BindingIdentifier_AWAIT(_P2_Common_Identifier_AWAIT, P2_BindingIdentifier):
    # BindingIdentifier : await
    def EarlyErrors(self):
        # 12.1.1 Static Semantics: Early Errors
        #   BindingIdentifier : await
        #   Common checks plus:
        #   * It is a Syntax Error if this production has a [Await] parameter.
        if self.Await:
            return [
                self.CreateSyntaxError(
                    "'await' not allowed as an identifier when 'await' can be used as a statement keyword"
                )
            ]
        return super().EarlyErrors()

    def BoundNames(self):
        # 12.1.2 Static Semantics: BoundNames
        #           BindingIdentifier : await
        # 1. Return a new List containing "await".
        return ["await"]

    def BindingInitialization(self, value, environment):
        # 12.1.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        #           BindingIdentifier : await
        # 1. Return ? InitializeBoundName("await", value, environment).
        return InitializeBoundName("await", value, environment, self.strict)


def parse_BindingIdentifier(ctx, lexer, pos, strict, Yield, Await):
    # Syntax
    #   BindingIdentifier[Yield, Await] :
    #       Identifier
    #       yield
    #       await
    return _reference_helper(
        ctx,
        lexer,
        pos,
        strict,
        Yield,
        Await,
        {
            "IDENTIFIER": (True, P2_BindingIdentifier_Identifier),
            "YIELD": (True, P2_BindingIdentifier_YIELD),
            "AWAIT": (True, P2_BindingIdentifier_AWAIT),
        },
    )


# --------======= 𝓛𝓪𝓫𝓮𝓵𝓘𝓭𝓮𝓷𝓽𝓲𝓯𝓲𝓮𝓻 =======--------
# LabelIdentifier
# Syntax
#   LabelIdentifier :
#       Identifier
#       yield
#       await
#
class P2_LabelIdentifier(ParseNode2):
    def __init__(self, ctx, strict, children, Yield, Await):
        super().__init__(ctx, "LabelIdentifier", strict, children)
        self.Yield = Yield
        self.Await = Await


class P2_LabelIdentifier_Identifier(_P2_Common_Identifier_Identifier, P2_LabelIdentifier):
    # LabelIdentifier : Identifier
    @property
    def Identifier(self):
        return self.children[0]


class P2_LabelIdentifier_YIELD(_P2_Common_Identifier_YIELD, P2_LabelIdentifier):
    # LabelIdentifier : yield
    pass


class P2_LabelIdentifier_AWAIT(_P2_Common_Identifier_AWAIT, P2_LabelIdentifier):
    # LabelIdentifier : await
    pass


def parse_LabelIdentifier(ctx, lexer, pos, strict, Yield, Await):
    # Syntax
    #   LabelIdentifier[Yield, Await]:
    #       Identifier
    #       [~Yield]yield
    #       [~Await]await
    return _reference_helper(
        ctx,
        lexer,
        pos,
        strict,
        Yield,
        Await,
        {
            "IDENTIFIER": (True, P2_LabelIdentifier_Identifier),
            "YIELD": (not Yield, P2_LabelIdentifier_YIELD),
            "AWAIT": (not Await, P2_LabelIdentifier_AWAIT),
        },
    )


# 12.1.5.1 Runtime Semantics: InitializeBoundName ( name, value, environment )
def InitializeBoundName(name, value, environment, strict):
    # 1. Assert: Type(name) is String.
    # 2. If environment is not undefined, then
    #   a. Let env be the EnvironmentRecord component of environment.
    #   b. Perform env.InitializeBinding(name, value).
    #   c. Return NormalCompletion(undefined).
    # 3. Else,
    #   a. Let lhs be ResolveBinding(name).
    #   b. Return ? PutValue(lhs, value).
    assert isString(name)
    if environment is not None:
        env = environment.environment_record
        env.InitializeBinding(name, value)
        return None
    lhs = ResolveBinding(name, strict)
    return PutValue(lhs, value)


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.      8888888b.          d8b
# d8888   d88P  Y88b     d88P  Y88b     888   Y88b         Y8P
#   888          888            888     888    888
#   888        .d88P          .d88P     888   d88P 888d888 888 88888b.d88b.   8888b.  888d888 888  888
#   888    .od888P"       .od888P"      8888888P"  888P"   888 888 "888 "88b     "88b 888P"   888  888
#   888   d88P"          d88P"          888        888     888 888  888  888 .d888888 888     888  888
#   888   888"       d8b 888"           888        888     888 888  888  888 888  888 888     Y88b 888
# 8888888 888888888  Y8P 888888888      888        888     888 888  888  888 "Y888888 888      "Y88888
#                                                                                                  888
#                                                                                             Y8b d88P
#                                                                                              "Y88P"
#
# 8888888888                                                      d8b
# 888                                                             Y8P
# 888
# 8888888    888  888 88888b.  888d888  .d88b.  .d8888b  .d8888b  888  .d88b.  88888b.
# 888        `Y8bd8P' 888 "88b 888P"   d8P  Y8b 88K      88K      888 d88""88b 888 "88b
# 888          X88K   888  888 888     88888888 "Y8888b. "Y8888b. 888 888  888 888  888
# 888        .d8""8b. 888 d88P 888     Y8b.          X88      X88 888 Y88..88P 888  888
# 8888888888 888  888 88888P"  888      "Y8888   88888P'  88888P' 888  "Y88P"  888  888
#                     888
#                     888
#                     888
#
#
# 12.2 Primary Expression
# 12.2.1 Semantics
# 12.2.1.1 SS: CoveredParenthesizedExpression
# 12.2.1.2 SS: HasName
# 12.2.1.3 SS: IsFunctionDefinition
# 12.2.1.4 SS: IsIdentifierRef
# 12.2.1.5 SS: AssignmentTargetType
# 12.2.2 The this Keyword
# 12.2.2.1 RS: Evaluation
# 12.2.3 Identifier Reference
# 12.2.4 Literals
# 12.2.4.1 RS: Evaluation
# 12.2.5 Array Initializer
# 12.2.5.1 SS: ElisionWidth
# 12.2.5.2 RS: ArrayAccumulation
# 12.2.5.3 RS: Evaluation
# 12.2.6 Object Initializer
# 12.2.6.1 SS: Early Errors
# 12.2.6.2 SS: ComputedPropertyContains
# 12.2.6.3 SS: Contains
# 12.2.6.4 SS: IsComputedPropertyKey
# 12.2.6.5 SS: PropName
# 12.2.6.6 SS: PropertyNameList
# 12.2.6.7 RS: Evaluation
# 12.2.6.8 RS: PropertyDefinitionEvaluation
# 12.2.7 Function Defining Expressions
# 12.2.8 Regular Expression Literals
# 12.2.8.1 SS: Early Errors
# 12.2.8.2 RS: Evaluation
# 12.2.9 Template Literals
# 12.2.9.1 SS: Early Errors
# 12.2.9.2 SS: TemplateStrings
# 12.2.9.3 RS: ArgumentListEvaluation
# 12.2.9.4 RS: GetTemplateObject ( templateLiteral )
# 12.2.9.5 RS: SubstitutionEvaluation
# 12.2.9.6 RS: Evaluation
# 12.2.10 The Grouping Operator
# 12.2.10.1 SS: Early Errors
# 12.2.10.2 SS: IsFunctionDefinition
# 12.2.10.3 SS: AssignmentTargetType
# 12.2.10.4 RS: NamedEvaluation
# 12.2.10.5 RS: Evaluation
#######################################################################################################################

# pylint: disable=assignment-from-none


#################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟐.𝟐 𝓟𝓻𝓲𝓶𝓪𝓻𝔂 𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 .....●·._..●·._..●·._.·´ #
#################################################################################
# 12.2 Primary Expression

# --------======= 𝓟𝓻𝓲𝓶𝓪𝓻𝔂𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   PrimaryExpression :
#       this
#       IdentifierReference
#       Literal
#       ArrayLiteral
#       ObjectLiteral
#       FunctionExpression
#       ClassExpression
#       GeneratorExpression
#       AsyncFunctionExpression
#       AsyncGeneratorExpression
#       RegularExpressionLiteral
#       TemplateLiteral
#       CoverParenthesizedExpressionAndArrowParameterList
#
class P2_PrimaryExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "PrimaryExpression", strict, children)


class P2_PrimaryExpression_THIS(P2_PrimaryExpression):
    # PrimaryExpression : this
    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : this
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : this
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : this
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.2.2.1 Runtime Semantics: Evaluation
        #   PrimaryExpression : this
        #   1. Return ? ResolveThisBinding().
        return ResolveThisBinding()


class P2_PrimaryExpression_IdentifierReference(P2_PrimaryExpression):
    # PrimaryExpression : IdentifierReference
    @property
    def IdentifierReference(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : IdentifierReference
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : IdentifierReference
        #   1. Return true.
        return True


class P2_PrimaryExpression_Literal(P2_PrimaryExpression):
    # PrimaryExpression : Literal
    @property
    def Literal(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : Literal
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : Literal
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : Literal
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    @cached_property
    def IsStringLiteral(self):
        return self.Literal.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.Literal.HasUseStrict


class P2_PrimaryExpression_ArrayLiteral(P2_PrimaryExpression):
    # PrimaryExpression : ArrayLiteral
    @property
    def ArrayLiteral(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : ArrayLiteral
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : ArrayLiteral
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : ArrayLiteral
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_PrimaryExpression_ObjectLiteral(P2_PrimaryExpression):
    # PrimaryExpression : ObjectLiteral
    @property
    def ObjectLiteral(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : ObjectLiteral
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : ObjectLiteral
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : ObjectLiteral
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_PrimaryExpression_FunctionExpression(P2_PrimaryExpression):
    # PrimaryExpression : FunctionExpression
    @property
    def FunctionExpression(self):
        return self.children[0]

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : FunctionExpression
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : FunctionExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_PrimaryExpression_ClassExpression(P2_PrimaryExpression):
    # PrimaryExpression : ClassExpression
    @property
    def ClassExpression(self):
        return self.children[0]

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : ClassExpression
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : ClassExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_PrimaryExpression_GeneratorExpression(P2_PrimaryExpression):
    # PrimaryExpression : GeneratorExpression
    @property
    def GeneratorExpression(self):
        return self.children[0]

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : GeneratorExpression
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : GeneratorExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_PrimaryExpression_AsyncFunctionExpression(P2_PrimaryExpression):
    # PrimaryExpression : AsyncFunctionExpression
    @property
    def AsyncFunctionExpression(self):
        return self.children[0]

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : AsyncFunctionExpression
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : AsyncFunctionExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_PrimaryExpression_AsyncGeneratorExpression(P2_PrimaryExpression):
    # PrimaryExpression : AsyncGeneratorExpression
    @property
    def AsyncGeneratorExpression(self):
        return self.children[0]

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : AsyncGeneratorExpression
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : AsyncGeneratorExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


bad_regex_flag_match = regex.compile("[^gimsuy]")


class P2_PrimaryExpression_RegularExpressionLiteral(P2_PrimaryExpression):
    # PrimaryExpression : RegularExpressionLiteral
    @property
    def RegularExpressionLiteral(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : RegularExpressionLiteral
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : RegularExpressionLiteral
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : RegularExpressionLiteral
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def EarlyErrors(self):
        # 12.2.8.1 Static Semantics: Early Errors
        # PrimaryExpression:RegularExpressionLiteral
        #   * It is a Syntax Error if BodyText of RegularExpressionLiteral cannot be recognized using the goal symbol
        #     Pattern of the ECMAScript RegExp grammar specified in 21.2.1.
        #   * It is a Syntax Error if FlagText of RegularExpressionLiteral contains any code points other than "g",
        #     "i", "m", "s", "u", or "y", or if it contains the same code point more than once.
        errs = []
        rel = self.RegularExpressionLiteral.value
        re_lex = e262_regexp.parse_Pattern(rel.body, 0, False, False)
        if re_lex is None:
            errs.append(self.CreateSyntaxError("Bad Regular Expression"))
        if bad_regex_flag_match.search(rel.flags) or len(rel.flags) != len(set(rel.flags)):
            errs.append(self.CreateSyntaxError("Bad Regular Expression Flags"))
        return errs

    def evaluate(self):
        # 12.2.8.2 Runtime Semantics: Evaluation
        # PrimaryExpression:RegularExpressionLiteral
        #   1. Let pattern be the String value consisting of the UTF16Encoding of each code point of BodyText of
        #      RegularExpressionLiteral.
        #   2. Let flags be the String value consisting of the UTF16Encoding of each code point of FlagText of
        #      RegularExpressionLiteral.
        #   3. Return RegExpCreate(pattern, flags).
        rel = self.RegularExpressionLiteral.value
        return RegExpCreate(rel.body, rel.flags)


class P2_PrimaryExpression_TemplateLiteral(P2_PrimaryExpression):
    # PrimaryExpression : TemplateLiteral
    @property
    def TemplateLiteral(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : TemplateLiteral
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : TemplateLiteral
        #   1. Return false.
        return False

    # 12.2.1.5 Static Semantics: AssignmentTargetType
    #   PrimaryExpression : TemplateLiteral
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_PrimaryExpression_CoverParenthesizedExpressionAndArrowParameterList(P2_PrimaryExpression):
    # PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
    @property
    def CoverParenthesizedExpressionAndArrowParameterList(self):
        return self.children[0]

    def HasName(self):
        # 12.2.1.2 Static Semantics: HasName
        #   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. If IsFunctionDefinition of expr is false, return false.
        #   3. Return HasName of expr.
        expr = self.CoverParenthesizedExpressionAndArrowParameterList.CoveredParenthesizedExpression
        return expr.IsFunctionDefinition() and expr.HasName()

    def IsFunctionDefinition(self):
        # 12.2.1.3 Static Semantics: IsFunctionDefinition
        #   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. Return IsFunctionDefinition of expr.
        expr = self.CoverParenthesizedExpressionAndArrowParameterList.CoveredParenthesizedExpression
        return expr.IsFunctionDefinition()

    def IsIdentifierRef(self):
        # 12.2.1.4 Static Semantics: IsIdentifierRef
        #   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Return false.
        return False

    @cached_property
    def AssignmentTargetType(self):
        # 12.2.1.5 Static Semantics: AssignmentTargetType
        #   PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. Return AssignmentTargetType of expr.
        expr = self.CoverParenthesizedExpressionAndArrowParameterList.CoveredParenthesizedExpression
        return expr.AssignmentTargetType

    def EarlyErrors(self):
        # 12.2.10.1 Static Semantics: Early Errors
        # PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        #   * It is a Syntax Error if CoverParenthesizedExpressionAndArrowParameterList is not covering a
        #     ParenthesizedExpression.
        #   * All Early Error rules for ParenthesizedExpression and its derived productions also apply to
        #     CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.
        expr = self.CoverParenthesizedExpressionAndArrowParameterList.CoveredParenthesizedExpression
        if expr:
            return []
        return [self.CreateSyntaxError("Bad grouping syntax")]

    def NamedEvaluation(self, name):
        # 12.2.10.4 Runtime Semantics: NamedEvaluation
        #   With parameter name.
        # PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. Return the result of performing NamedEvaluation for expr with argument name.
        return self.CoverParenthesizedExpressionAndArrowParameterList.CoveredParenthesizedExpression.NamedEvaluation(
            name
        )

    def evaluate(self):
        # 12.2.10.5 Runtime Semantics: Evaluation
        # PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. Return the result of evaluating expr.
        return self.CoverParenthesizedExpressionAndArrowParameterList.CoveredParenthesizedExpression.evaluate()


def parse_PrimaryExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.2 Primary Expression
    # Syntax
    #   PrimaryExpression[Yield, Await] :
    #       this
    #       IdentifierReference[?Yield, ?Await]
    #       Literal
    #       ArrayLiteral[?Yield, ?Await]
    #       ObjectLiteral[?Yield, ?Await]
    #       FunctionExpression
    #       ClassExpression[?Yield, ?Await]
    #       GeneratorExpression
    #       AsyncFunctionExpression
    #       AsyncGeneratorExpression
    #       RegularExpressionLiteral
    #       TemplateLiteral[?Yield, ?Await, ~Tagged]
    #       CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]

    tok = lexer.id_if(pos, "this")
    if tok:
        return P2_PrimaryExpression_THIS(ctx, strict, [tok])
    id = parse_IdentifierReference(ctx, lexer, pos, strict, Yield, Await)
    if id:
        return P2_PrimaryExpression_IdentifierReference(ctx, strict, [id])
    lit = parse_Literal(ctx, lexer, pos, strict)
    if lit:
        return P2_PrimaryExpression_Literal(ctx, strict, [lit])
    al = parse_ArrayLiteral(ctx, lexer, pos, strict, Yield, Await)
    if al:
        return P2_PrimaryExpression_ArrayLiteral(ctx, strict, [al])
    ol = parse_ObjectLiteral(ctx, lexer, pos, strict, Yield, Await)
    if ol:
        return P2_PrimaryExpression_ObjectLiteral(ctx, strict, [ol])
    fe = parse_FunctionExpression(ctx, lexer, pos, strict)
    if fe:
        return P2_PrimaryExpression_FunctionExpression(ctx, strict, [fe])
    ce = parse_ClassExpression(ctx, lexer, pos, strict, Yield, Await)
    if ce:
        return P2_PrimaryExpression_ClassExpression(ctx, strict, [ce])
    ge = parse_GeneratorExpression(ctx, lexer, pos, strict)
    if ge:
        return P2_PrimaryExpression_GeneratorExpression(ctx, strict, [ge])
    afe = parse_AsyncFunctionExpression(ctx, lexer, pos, strict)
    if afe:
        return P2_PrimaryExpression_AsyncFunctionExpression(ctx, strict, [afe])
    age = parse_AsyncGeneratorExpression(ctx, lexer, pos, strict)
    if age:
        return P2_PrimaryExpression_AsyncGeneratorExpression(ctx, strict, [age])
    rel = lexer.token_if(pos, "REGEXP")
    if rel:
        return P2_PrimaryExpression_RegularExpressionLiteral(ctx, strict, [rel])
    tl = parse_TemplateLiteral(ctx, lexer, pos, strict, Yield, Await, False)
    if tl:
        return P2_PrimaryExpression_TemplateLiteral(ctx, strict, [tl])
    cpeapl = parse_CoverParenthesizedExpressionAndArrowParameterList(ctx, lexer, pos, strict, Yield, Await)
    if cpeapl:
        return P2_PrimaryExpression_CoverParenthesizedExpressionAndArrowParameterList(ctx, strict, [cpeapl])
    return None


# --------======= 𝓒𝓸𝓿𝓮𝓻𝓟𝓪𝓻𝓮𝓷𝓽𝓱𝓮𝓼𝓲𝔃𝓮𝓭𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷𝓐𝓷𝓭𝓐𝓻𝓻𝓸𝔀𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   CoverParenthesizedExpressionAndArrowParameterList :
#       ( Expression )
#       ( Expression , )
#       ( )
#       ( ... BindingIdentifier )
#       ( ... BindingPattern )
#       ( Expression , ... BindingIdentifier )
#       ( Expression , ... BindingPattern )
#
class P2_CoverParenthesizedExpressionAndArrowParameterList(ParseNode2):
    def __init__(self, ctx, strict, children, Yield, Await):
        super().__init__(ctx, "CoverParenthesizedExpressionAndArrowParameterList", strict, children)
        # Need to capture these for potential cover parse, later.
        self.Yield = Yield
        self.Await = Await
        self.has_parenthesized_expression = False  # We have not yet tried to parse the covered expression
        self.parenthesized_expression = None  # But not a legit none until we try

    # 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
    # This is the default implementation: the return value means, nope, there's no covered production.
    CoveredParenthesizedExpression = None

    @cached_property
    def CoveredFormalsList(self):
        # 14.2.9 Static Semantics: CoveredFormalsList
        #   1. Return the ArrowFormalParameters that is covered by CoverParenthesizedExpressionAndArrowParameterList.
        return self.covering(parse_ArrowFormalParameters, self.strict, self.Yield, self.Await)


class P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_RPAREN(
    P2_CoverParenthesizedExpressionAndArrowParameterList
):
    @property
    def Expression(self):
        return self.children[1]

    @cached_property
    def CoveredParenthesizedExpression(self):
        # 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        #   CoverParenthesizedExpressionAndArrowParameterList : ( Expression )
        #   1. Return the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
        return self.covering(parse_ParenthesizedExpression, self.strict, self.Yield, self.Await)


class P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_COMMA_RPAREN(
    P2_CoverParenthesizedExpressionAndArrowParameterList
):
    @property
    def Expression(self):
        return self.children[1]


class P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_RPAREN(
    P2_CoverParenthesizedExpressionAndArrowParameterList
):
    pass


class P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_DOTDOTDOT_BindingIdentifier_RPAREN(
    P2_CoverParenthesizedExpressionAndArrowParameterList
):
    @property
    def BindingIdentifier(self):
        return self.children[2]


class P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_DOTDOTDOT_BindingPattern_RPAREN(
    P2_CoverParenthesizedExpressionAndArrowParameterList
):
    @property
    def BindingPattern(self):
        return self.children[2]


class P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_COMMA_DOTDOTDOT_BindingIdentifier_RPAREN(
    P2_CoverParenthesizedExpressionAndArrowParameterList
):
    @property
    def Expression(self):
        return self.children[1]

    @property
    def BindingIdentifier(self):
        return self.children[4]


class P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_COMMA_DOTDOTDOT_BindingPattern_RPAREN(
    P2_CoverParenthesizedExpressionAndArrowParameterList
):
    @property
    def Expression(self):
        return self.children[1]

    @property
    def BindingPattern(self):
        return self.children[4]


def parse_CoverParenthesizedExpressionAndArrowParameterList(ctx, lexer, pos, strict, Yield, Await):
    # 12.2 Primary Expression
    # Syntax
    #   CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
    #       ( Expression[+In, ?Yield, ?Await] )
    #       ( Expression[+In, ?Yield, ?Await] , )
    #       ( )
    #       ( ... BindingIdentifier[?Yield, ?Await] )
    #       ( ... BindingPattern[?Yield, ?Await] )
    #       ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] )
    #       ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] )
    #

    lp = lexer.token_if(pos, "(")
    if lp:
        exp = parse_Expression(ctx, lexer, lp.span.after, strict, True, Yield, Await)
        if exp:
            rp1 = lexer.token_if(exp.after, ")")
            if rp1:
                return P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_RPAREN(
                    ctx, strict, [lp, exp, rp1], Yield, Await
                )
            comma = lexer.token_if(exp.after, ",")
            if comma:
                rp2 = lexer.token_if(comma.span.after, ")")
                if rp2:
                    return P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_COMMA_RPAREN(
                        ctx, strict, [lp, exp, comma, rp2], Yield, Await
                    )
                dots = lexer.token_if(comma.span.after, "...")
                if dots:
                    bi = parse_BindingIdentifier(ctx, lexer, dots.span.after, strict, Yield, Await)
                    if bi:
                        rp3 = lexer.token_if(")")
                        if rp3:
                            return P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_COMMA_DOTDOTDOT_BindingIdentifier_RPAREN(
                                ctx, strict, [lp, exp, comma, dots, bi, rp3], Yield, Await
                            )
                    bp = parse_BindingPattern(ctx, lexer, dots.span.after, strict, Yield, Await)
                    if bp:
                        rp4 = lexer.token_if(")")
                        if rp4:
                            return P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_COMMA_DOTDOTDOT_BindingPattern_RPAREN(
                                ctx, strict, [lp, exp, comma, dots, bp, rp4], Yield, Await
                            )
        rp5 = lexer.token_if(lp.span.after, ")")
        if rp5:
            return P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_RPAREN(
                ctx, strict, [lp, rp5], Yield, Await
            )
        dots = lexer.token_if(lp.span.after, "...")
        if dots:
            bi = parse_BindingIdentifier(ctx, lexer, dots.span.after, strict, Yield, Await)
            if bi:
                rp6 = lexer.token_if(bi.after, ")")
                if rp6:
                    return P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_DOTDOTDOT_BindingIdentifier_RPAREN(
                        ctx, strict, [lp, dots, bi, rp6], Yield, Await
                    )
            bp = parse_BindingPattern(ctx, lexer, dots.span.after, strict, Yield, Await)
            if bp:
                rp7 = lexer.token_if(bp.after, ")")
                if rp7:
                    return P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_DOTDOTDOT_BindingPattern_RPAREN(
                        ctx, strict, [lp, dots, bp, rp7], Yield, Await
                    )
    return None


# --------======= 𝓟𝓪𝓻𝓮𝓷𝓽𝓱𝓮𝓼𝓲𝔃𝓮𝓭𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   ParenthesizedExpression :
#       ( Expression )
#
class P2_ParenthesizedExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ParenthesizedExpression", strict, children)


class P2_ParenthesizedExpression_LPAREN_Expression_RPAREN(P2_ParenthesizedExpression):
    @property
    def Expression(self):
        return self.children[1]

    # 12.2.10.2 Static Semantics: IsFunctionDefinition
    # ParenthesizedExpression : ( Expression )
    #   1. Return IsFunctionDefinition of Expression.
    # Implementation Note: This is handled correctly by the normal deferred semantics system.

    # 12.2.10.3 Static Semantics: AssignmentTargetType
    # ParenthesizedExpression : ( Expression )
    #   1. Return AssignmentTargetType of Expression.
    # Implementation Note: This is handled correctly by the normal deferred semantics system.

    def NamedEvaluation(self, name):
        # 12.2.10.4 Runtime Semantics: NamedEvaluation
        #   With parameter name.
        # ParenthesizedExpression : ( Expression )
        # 1. Assert: IsAnonymousFunctionDefinition(Expression) is true.
        # 2. Return the result of performing NamedEvaluation for Expression with argument name.
        assert IsAnonymousFunctionDefinition(self.Expression)
        return self.Expression.NamedEvaluation(name)

    # 12.2.10.5 Runtime Semantics: Evaluation
    # ParenthesizedExpression : ( Expression )
    #   1. Return the result of evaluating Expression. This may be of type Reference.
    # NOTE
    # This algorithm does not apply GetValue to the result of evaluating Expression. The principal motivation for
    # this is so that operators such as delete and typeof may be applied to parenthesized expressions.
    # Implementation Note: This is handled correctly by the normal deferred semantics system.


def parse_ParenthesizedExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.2 Primary Expression
    # Syntax
    #   ParenthesizedExpression[Yield, Await] :
    #       ( Expression[+In, ?Yield, ?Await] )
    #
    lp = lexer.token_if(pos, "(")
    if lp:
        exp = parse_Expression(ctx, lexer, lp.span.after, strict, True, Yield, Await)
        if exp:
            rp = lexer.token_if(exp.after, ")")
            if rp:
                return P2_ParenthesizedExpression_LPAREN_Expression_RPAREN(ctx, strict, [lp, exp, rp])
    return None


# --------======= 𝓛𝓲𝓽𝓮𝓻𝓪𝓵 =======--------
# Syntax
#   Literal:
#       NullLiteral
#       BooleanLiteral
#       NumericLiteral
#       StringLiteral
#
class P2_Literal(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Literal", strict, children)


class P2_Literal_NullLiteral(P2_Literal):
    # Literal : NullLiteral
    @property
    def NullLiteral(self):
        return self.children[0]

    def evaluate(self):
        # 12.2.4.1 Runtime Semantics: Evaluation
        #   Literal : NullLiteral
        #   1. Return null.
        return JSNull.NULL


class P2_Literal_BooleanLiteral(P2_Literal):
    # Literal : BooleanLiteral
    @property
    def BooleanLiteral(self):
        return self.children[0]

    def evaluate(self):
        # 12.2.4.1 Runtime Semantics: Evaluation
        #   Literal : BooleanLiteral
        #   1. If BooleanLiteral is the token false, return false.
        #   2. If BooleanLiteral is the token true, return true.
        return self.BooleanLiteral.value == "true"


class P2_Literal_NumericLiteral(P2_Literal):
    # Literal : NumericLiteral
    @property
    def NumericLiteral(self):
        return self.children[0]

    def evaluate(self):
        # 12.2.4.1 Runtime Semantics: Evaluation
        #   Literal : NumericLiteral
        #   1. Return the number whose value is MV of NumericLiteral as defined in 11.8.3.
        return self.NumericLiteral.value


_use_strict_pat = regex.compile(r"([\"'])use strict\1")


class P2_Literal_StringLiteral(P2_Literal):
    # Literal : StringLiteral
    @property
    def StringLiteral(self):
        return self.children[0]

    def evaluate(self):
        # 12.2.4.1 Runtime Semantics: Evaluation
        #   Literal : StringLiteral
        #   1. Return the StringValue of StringLiteral as defined in 11.8.4.1.
        return self.StringLiteral.value

    IsStringLiteral = True

    @cached_property
    def HasUseStrict(self):
        span = self.StringLiteral.span
        srctext = self.StringLiteral.src[span[0] : span[1]]
        return _use_strict_pat.match(srctext) is not None


Literal_Constructors = {
    "null": P2_Literal_NullLiteral,
    "true": P2_Literal_BooleanLiteral,
    "false": P2_Literal_BooleanLiteral,
    "NUMERIC": P2_Literal_NumericLiteral,
    "STRING": P2_Literal_StringLiteral,
}


def parse_Literal(ctx, lexer, pos, strict):
    # 12.2.4 Literals
    # Syntax
    #   Literal:
    #       NullLiteral
    #       BooleanLiteral
    #       NumericLiteral
    #       StringLiteral
    tok = lexer.token(pos)
    if tok:
        return Literal_Constructors.get(
            tok.type if tok.type != "IDENTIFIER" else tok.src[tok.span.start : tok.span.after], lambda *args: None
        )(ctx, strict, [tok])
    return None


# 12.2.5 Array Initializer
#
# | NOTE    An ArrayLiteral is an expression describing the initialization of an Array object, using a list, of zero or
# |         more expressions each of which represents an array element, enclosed in square brackets. The elements need
# |         not be literals; they are evaluated each time the array initializer is evaluated.
#
# Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element
# list is not preceded by an AssignmentExpression (i.e., a comma at the beginning or after another comma), the missing
# array element contributes to the length of the Array and increases the index of subsequent elements. Elided array
# elements are not defined. If an element is elided at the end of an array, that element does not contribute to the
# length of the Array.

# --------======= 𝓐𝓻𝓻𝓪𝔂𝓛𝓲𝓽𝓮𝓻𝓪𝓵 =======--------
# Syntax
#   ArrayLiteral:
#       [ ]
#       [ Elision ]
#       [ ElementList ]
#       [ ElementList , ]
#       [ ElementList , Elision ]
#
class P2_ArrayLiteral(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ArrayLiteral", strict, children)


class P2_ArrayLiteral_LBRACKET_RBRACKET(P2_ArrayLiteral):
    # ArrayLiteral : [ ]
    def evaluate(self):
        # 12.2.5.3 Runtime Semantics: Evaluation
        # ArrayLiteral : [ ]
        #   1. Let array be ! ArrayCreate(0).
        #   2. Let pad be 0.
        #   3. Perform Set(array, "length", ToUint32(pad), false).
        #   4. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
        #   5. Return array.
        array = ArrayCreate(0)
        Set(array, "length", 0, False)
        return array


class P2_ArrayLiteral_LBRACKET_Elision_RBRACKET(P2_ArrayLiteral):
    # ArrayLiteral : [ Elision ]
    @property
    def Elision(self):
        return self.children[1]

    def evaluate(self):
        # 12.2.5.3 Runtime Semantics: Evaluation
        # ArrayLiteral : [ Elision ]
        #   1. Let array be ! ArrayCreate(0).
        #   2. Let pad be the ElisionWidth of Elision.
        #   3. Perform Set(array, "length", ToUint32(pad), false).
        #   4. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
        #   5. Return array.
        array = ArrayCreate(0)
        Set(array, "length", self.Elision.ElisionWidth(), False)
        return array


class P2_ArrayLiteral_LBRACKET_ElementList_RBRACKET(P2_ArrayLiteral):
    # ArrayLiteral : [ ElementList ]
    @property
    def ElementList(self):
        return self.children[1]

    def evaluate(self):
        # 12.2.5.3 Runtime Semantics: Evaluation
        # ArrayLiteral : [ ElementList ]
        #   1. Let array be ! ArrayCreate(0).
        #   2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
        #   3. ReturnIfAbrupt(len).
        #   4. Perform Set(array, "length", ToUint32(len), false).
        #   5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
        #   6. Return array.
        array = ArrayCreate(0)
        length = self.ElementList.ArrayAccumulation(array, 0)
        Set(array, "length", ToUint32(length), False)
        return array


class P2_ArrayLiteral_LBRACKET_ElementList_COMMA_RBRACKET(P2_ArrayLiteral_LBRACKET_ElementList_RBRACKET):
    # ArrayLiteral : [ ElementList , ]
    @property
    def ElementList(self):
        return self.children[1]


class P2_ArrayLiteral_LBRACKET_ElementList_COMMA_Elision_RBRACKET(P2_ArrayLiteral):
    # ArrayLiteral : [ ElementList , Elision ]
    @property
    def ElementList(self):
        return self.children[1]

    @property
    def Elision(self):
        return self.children[3]

    def evaluate(self):
        # 12.2.5.3 Runtime Semantics: Evaluation
        # ArrayLiteral : [ ElementList , Elision ]
        #   1. Let array be ! ArrayCreate(0).
        #   2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
        #   3. ReturnIfAbrupt(len).
        #   4. Let padding be the ElisionWidth of Elision.
        #   5. Perform Set(array, "length", ToUint32(padding+len), false).
        #   6. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
        #   7. Return array.
        array = ArrayCreate(0)
        length = self.ElementList.ArrayAccumulation(array, 0)
        padding = self.Elision.ElisionWidth()
        Set(array, "length", ToUint32(padding + length), False)
        return array


def parse_ArrayLiteral(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.5 Array Initializer
    # Syntax
    #   ArrayLiteral[Yield, Await] :
    #       [ ]
    #       [ Elision ]
    #       [ ElementList[?Yield, ?Await] ]
    #       [ ElementList[?Yield, ?Await] , ]
    #       [ ElementList[?Yield, ?Await] , Elision ]
    lb = lexer.token_if(pos, "[")
    if lb:
        rb1 = lexer.token_if(lb.span.after, "]")
        if rb1:
            return P2_ArrayLiteral_LBRACKET_RBRACKET(ctx, strict, [lb, rb1])
        elision = parse_Elision(ctx, lexer, lb.span.after, strict)
        if elision:
            rb2 = lexer.token_if(elision.after, "]")
            if rb2:
                return P2_ArrayLiteral_LBRACKET_Elision_RBRACKET(ctx, strict, [lb, elision, rb2])
        el = parse_ElementList(ctx, lexer, lb.span.after, strict, Yield, Await)
        if el:
            rb3 = lexer.token_if(el.after, "]")
            if rb3:
                return P2_ArrayLiteral_LBRACKET_ElementList_RBRACKET(ctx, strict, [lb, el, rb3])
            comma = lexer.token_if(el.after, ",")
            if comma:
                rb4 = lexer.token_if(comma.span.after, "]")
                if rb4:
                    return P2_ArrayLiteral_LBRACKET_ElementList_COMMA_RBRACKET(ctx, strict, [lb, el, comma, rb4])
                elision2 = parse_Elision(ctx, lexer, comma.span.after, strict)
                if elision2:
                    rb5 = lexer.token_if(elision2.after, "]")
                    if rb5:
                        return P2_ArrayLiteral_LBRACKET_ElementList_COMMA_Elision_RBRACKET(
                            ctx, strict, [lb, el, comma, elision2, rb5]
                        )
    return None


# --------======= 𝓔𝓵𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   ElementList:
#     AssignmentExpression
#     Elision AssignmentExpression
#     SpreadElement
#     Elision SpreadElement
#     ElementList , AssignmentExpression
#     ElementList , Elision AssignmentExpression
#     ElementList , SpreadElement
#     ElementList , Elision SpreadElement
#
class P2_ElementList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ElementList", strict, children)


class P2_ElementList_AssignmentExpression(P2_ElementList):
    # ElementList : AssignmentExpression
    @property
    def AssignmentExpression(self):
        return self.children[0]

    Elision = None

    def ArrayAccumulation(self, array, nextIndex):
        # 12.2.5.2 Runtime Semantics: ArrayAccumulation
        #   With parameters array and nextIndex.
        # ElementList : Elision AssignmentExpression
        # ElementList : AssignmentExpression
        #   1. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
        #   2. Let initResult be the result of evaluating AssignmentExpression.
        #   3. Let initValue be ? GetValue(initResult).
        #   4. Let created be CreateDataProperty(array, ToString(ToUint32(nextIndex+padding)), initValue).
        #   5. Assert: created is true.
        #   6. Return nextIndex+padding+1.
        padding = self.Elision.ElisionWidth() if self.Elision else 0
        initResult = self.AssignmentExpression.evaluate()
        initValue = GetValue(initResult)
        created = CreateDataProperty(array, ToString(ToUint32(nextIndex + padding)), initValue)
        assert created
        return nextIndex + padding + 1


class P2_ElementList_Elision_AssignmentExpression(P2_ElementList_AssignmentExpression):
    # ElementList : Elision AssignmentExpression
    @property
    def Elision(self):
        return self.children[0]

    @property
    def AssignmentExpression(self):
        return self.children[1]


class P2_ElementList_SpreadElement(P2_ElementList):
    # ElementList : SpreadElement
    @property
    def SpreadElement(self):
        return self.children[0]

    Elision = None

    def ArrayAccumulation(self, array, nextIndex):
        # 12.2.5.2 Runtime Semantics: ArrayAccumulation
        #   With parameters array and nextIndex.
        # ElementList : Elision SpreadElement
        # ElementList : SpreadElement
        #   1. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
        #   2. Return the result of performing ArrayAccumulation for SpreadElement with arguments array and nextIndex+padding.
        padding = self.Elision.ElisionWidth() if self.Elision else 0
        return self.SpreadElement.ArrayAccumulation(array, nextIndex + padding)


class P2_ElementList_Elision_SpreadElement(P2_ElementList_SpreadElement):
    # ElementList : Elision SpreadElement
    @property
    def Elision(self):
        return self.children[0]

    @property
    def SpreadElement(self):
        return self.children[1]


class P2_ElementList_ElementList_COMMA_AssignmentExpression(P2_ElementList):
    # ElementList : ElementList , AssignmentExpression
    @property
    def ElementList(self):
        return self.children[0]

    Elision = None

    @property
    def AssignmentExpression(self):
        return self.children[2]

    def ArrayAccumulation(self, array, nextIndex):
        # 12.2.5.2 Runtime Semantics: ArrayAccumulation
        #   With parameters array and nextIndex.
        # ElementList : ElementList , Elision AssignmentExpression
        # ElementList : ElementList , AssignmentExpression
        #   1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
        #   2. ReturnIfAbrupt(postIndex).
        #   3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
        #   4. Let initResult be the result of evaluating AssignmentExpression.
        #   5. Let initValue be ? GetValue(initResult).
        #   6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex+padding)), initValue).
        #   7. Assert: created is true.
        #   8. Return postIndex+padding+1.
        postIndex = self.ElementList.ArrayAccumulation(array, nextIndex)
        padding = self.Elision.ElisionWidth() if self.Elision else 0
        initResult = self.AssignmentExpression.evaluate()
        initValue = GetValue(initResult)
        created = CreateDataProperty(array, ToString(ToUint32(postIndex + padding)), initValue)
        assert created
        return postIndex + padding + 1


class P2_ElementList_ElementList_COMMA_Elision_AssignmentExpression(
    P2_ElementList_ElementList_COMMA_AssignmentExpression
):
    # ElementList : ElementList , Elision AssignmentExpression
    @property
    def ElementList(self):
        return self.children[0]

    @property
    def Elision(self):
        return self.children[2]

    @property
    def AssignmentExpression(self):
        return self.children[3]


class P2_ElementList_ElementList_COMMA_SpreadElement(P2_ElementList):
    # ElementList : ElementList , SpreadElement
    @property
    def ElementList(self):
        return self.children[0]

    Elision = None

    @property
    def SpreadElement(self):
        return self.children[2]

    def ArrayAccumulation(self, array, nextIndex):
        # 12.2.5.2 Runtime Semantics: ArrayAccumulation
        #   With parameters array and nextIndex.
        # ElementList : ElementList , Elision SpreadElement
        # ElementList : ElementList , SpreadElement
        #   1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
        #   2. ReturnIfAbrupt(postIndex).
        #   3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
        #   4. Return the result of performing ArrayAccumulation for SpreadElement with arguments array and postIndex+padding.
        postIndex = self.ElementList.ArrayAccumulation(array, nextIndex)
        padding = self.Elision.ElisionWidth() if self.Elision else 0
        return self.SpreadElement.ArrayAccumulation(array, postIndex + padding)


class P2_ElementList_ElementList_COMMA_Elision_SpreadElement(P2_ElementList_ElementList_COMMA_SpreadElement):
    # ElementList : ElementList , Elision SpreadElement
    @property
    def ElementList(self):
        return self.children[0]

    @property
    def Elision(self):
        return self.children[2]

    @property
    def SpreadElement(self):
        return self.children[3]


def parse_ElementList(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.5 Array Initializer
    # Syntax
    #   ElementList[Yield, Await] :
    #       Elision_opt AssignmentExpression[+In, ?Yield, ?Await]
    #       Elision_opt SpreadElement[?Yield, ?Await]
    #       ElementList[?Yield, ?Await] , Elision_opt AssignmentExpression[+In, ?Yield, ?Await]
    #       ElementList[?Yield, ?Await] , Elision_opt SpreadElement[?Yield, ?Await]
    def parse(position, previous=None):
        if previous is not None:
            comma = lexer.token_if(position, ",")
            if not comma:
                return previous
            pos = comma.span.after
        else:
            pos = position
        elision = parse_Elision(ctx, lexer, pos, strict)
        ae = parse_AssignmentExpression(ctx, lexer, elision.after if elision else pos, strict, True, Yield, Await)
        if ae:
            if previous is None:
                if elision is not None:
                    return lambda: parse(
                        ae.after, P2_ElementList_Elision_AssignmentExpression(ctx, strict, [elision, ae])
                    )
                return lambda: parse(ae.after, P2_ElementList_AssignmentExpression(ctx, strict, [ae]))
            if elision is not None:
                return lambda: parse(
                    ae.after,
                    P2_ElementList_ElementList_COMMA_Elision_AssignmentExpression(
                        ctx, strict, [previous, comma, elision, ae]
                    ),
                )
            return lambda: parse(
                ae.after, P2_ElementList_ElementList_COMMA_AssignmentExpression(ctx, strict, [previous, comma, ae])
            )
        se = parse_SpreadElement(ctx, lexer, elision.after if elision else pos, strict, Yield, Await)
        if se:
            if previous is None:
                if elision is not None:
                    return lambda: parse(se.after, P2_ElementList_Elision_SpreadElement(ctx, strict, [elision, se]))
                return lambda: parse(se.after, P2_ElementList_SpreadElement(ctx, strict, [se]))
            if elision is not None:
                return lambda: parse(
                    se.after,
                    P2_ElementList_ElementList_COMMA_Elision_SpreadElement(
                        ctx, strict, [previous, comma, elision, se]
                    ),
                )
            return lambda: parse(
                se.after, P2_ElementList_ElementList_COMMA_SpreadElement(ctx, strict, [previous, comma, se])
            )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓔𝓵𝓲𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   Elision :
#     ,
#     Elision ,
#
class P2_Elision(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Elision", strict, children)


class P2_Elision_COMMA(P2_Elision):
    # Elision : ,
    def ElisionWidth(self):
        # 12.2.5.1 Static Semantics: ElisionWidth
        # Elision : ,
        # 1. Return the numeric value 1.
        return 1

    def IteratorDestructuringAssignmentEvaluation(self, iteratorRecord):
        # 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation
        #   With parameter iteratorRecord.
        # Elision : ,
        #   1. If iteratorRecord.[[Done]] is false, then
        #       a. Let next be IteratorStep(iteratorRecord).
        #       b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #       c. ReturnIfAbrupt(next).
        #       d. If next is false, set iteratorRecord.[[Done]] to true.
        #   2. Return NormalCompletion(empty).
        if not iteratorRecord.Done:
            try:
                nextVal = IteratorStep(iteratorRecord)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            if not nextVal:
                iteratorRecord.Done = True
        return EMPTY


class P2_Elision_Elision_COMMA(P2_Elision):
    # Elision : Elision ,
    @property
    def Elision(self):
        return self.children[0]

    def ElisionWidth(self):
        # 12.2.5.1 Static Semantics: ElisionWidth
        #   Elision : Elision,
        #   1. Let preceding be the ElisionWidth of Elision.
        #   2. Return preceding + 1.
        return 1 + self.Elision.ElisionWidth()

    def IteratorDestructuringAssignmentEvaluation(self, iteratorRecord):
        # 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation
        #   With parameter iteratorRecord.
        # Elision : Elision ,
        #   1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
        #   2. If iteratorRecord.[[Done]] is false, then
        #       a. Let next be IteratorStep(iteratorRecord).
        #       b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #       c. ReturnIfAbrupt(next).
        #       d. If next is false, set iteratorRecord.[[Done]] to true.
        #   3. Return NormalCompletion(empty).
        self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        if not iteratorRecord.Done:
            try:
                nextVal = IteratorStep(iteratorRecord)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            if not nextVal:
                iteratorRecord.Done = True
        return EMPTY


def parse_Elision(ctx, lexer, pos, strict):
    # 12.2.5 Array Initializer
    # Syntax
    #   Elision :
    #       ,
    #       Elision ,
    def parse(pos, previous=None):
        comma = lexer.token_if(pos, ",")
        if not comma:
            return previous
        if previous is None:
            return lambda: parse(comma.span.after, P2_Elision_COMMA(ctx, strict, [comma]))
        return lambda: parse(comma.span.after, P2_Elision_Elision_COMMA(ctx, strict, [previous, comma]))

    return trampoline(lambda: parse(pos))


# --------======= 𝓢𝓹𝓻𝓮𝓪𝓭𝓔𝓵𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   SpreadElement :
#       ... AssignmentExpression
#
class P2_SpreadElement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "SpreadElement", strict, children)


class P2_SpreadElement_DOTDOTDOT_AssignmentExpression(P2_SpreadElement):
    # SpreadElement : ... AssignmentExpression
    @property
    def AssignmentExpression(self):
        return self.children[1]

    def ArrayAccumulation(self, array, nextIndex):
        # 12.2.5.2 Runtime Semantics: ArrayAccumulation
        #   With parameters array and nextIndex.
        # SpreadElement : ... AssignmentExpression
        #   1. Let spreadRef be the result of evaluating AssignmentExpression.
        #   2. Let spreadObj be ? GetValue(spreadRef).
        #   3. Let iteratorRecord be ? GetIterator(spreadObj).
        #   4. Repeat,
        #       a. Let next be ? IteratorStep(iteratorRecord).
        #       b. If next is false, return nextIndex.
        #       c. Let nextValue be ? IteratorValue(next).
        #       d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).
        #       e. Assert: status is true.
        #       f. Let nextIndex be nextIndex + 1.
        spreadRef = self.AssignmentExpression.evaluate()
        spreadObj = GetValue(spreadRef)
        iteratorRecord = GetIterator(spreadObj)
        while 1:
            next = IteratorStep(iteratorRecord)
            if not next:
                return nextIndex
            nextValue = IteratorValue(next)
            status = CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue)
            assert status
            nextIndex += 1


def parse_SpreadElement(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.5 Array Initializer
    # Syntax
    #   SpreadElement[Yield, Await]:
    #       ... AssignmentExpression[+In, ?Yield, ?Await]
    #
    dots = lexer.token_if(pos, "...")
    if dots:
        ae = parse_AssignmentExpression(ctx, lexer, dots.span.after, strict, True, Yield, Await)
        if ae:
            return P2_SpreadElement_DOTDOTDOT_AssignmentExpression(ctx, strict, [dots, ae])
    return None


# 12.2.6 Object Initializer
# NOTE 1    An object initializer is an expression describing the initialization of an Object, written in a form
#           resembling a literal. It is a list of zero or more pairs of property keys and associated values, enclosed
#           in curly brackets. The values need not be literals; they are evaluated each time the object initializer is
#           evaluated.
#
# NOTE 2    MethodDefinition is defined in 14.3.
#
# NOTE 3    In certain contexts, ObjectLiteral is used as a cover grammar for a more restricted secondary grammar. The
#           CoverInitializedName production is necessary to fully cover these secondary grammars. However, use of this
#           production results in an early Syntax Error in normal contexts where an actual ObjectLiteral is expected.

# --------======= 𝓞𝓫𝓳𝓮𝓬𝓽𝓛𝓲𝓽𝓮𝓻𝓪𝓵 =======--------
# Syntax
#   ObjectLiteral :
#       { }
#       { PropertyDefinitionList }
#       { PropertyDefinitionList , }
#
class P2_ObjectLiteral(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ObjectLiteral", strict, children)


class P2_ObjectLiteral_LCURLY_RCURLY(P2_ObjectLiteral):
    def evaluate(self):
        # 12.2.6.7 Runtime Semantics: Evaluation
        # ObjectLiteral : { }
        #   1. Return ObjectCreate(%ObjectPrototype%).
        return ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])


class P2_ObjectLiteral_LCURLY_PropertyDefinitionList_RCURLY(P2_ObjectLiteral):
    @property
    def PropertyDefinitionList(self):
        return self.children[1]

    def evaluate(self):
        # 12.2.6.7 Runtime Semantics: Evaluation
        # ObjectLiteral : { PropertyDefinitionList }
        # ObjectLiteral : { PropertyDefinitionList , }
        #   1. Let obj be ObjectCreate(%ObjectPrototype%).
        #   2. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.
        #   3. Return obj.
        obj = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
        self.PropertyDefinitionList.PropertyDefinitionEvaluation(obj, True)
        return obj


class P2_ObjectLiteral_LCURLY_PropertyDefinitionList_COMMA_RCURLY(
    P2_ObjectLiteral_LCURLY_PropertyDefinitionList_RCURLY
):
    pass


def parse_ObjectLiteral(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.6 Object Initializer
    # Syntax
    #   ObjectLiteral[Yield, Await] :
    #       { }
    #       { PropertyDefinitionList[?Yield, ?Await] }
    #       { PropertyDefinitionList[?Yield, ?Await] , }
    #
    lcurly = lexer.token_if(pos, "{")
    if lcurly:
        pdl = parse_PropertyDefinitionList(ctx, lexer, lcurly.span.after, strict, Yield, Await)
        if pdl:
            comma = lexer.token_if(pdl.after, ",")
            if comma:
                rcurly = lexer.token_if(comma.span.after, "}")
                if rcurly:
                    return P2_ObjectLiteral_LCURLY_PropertyDefinitionList_COMMA_RCURLY(
                        ctx, strict, [lcurly, pdl, comma, rcurly]
                    )
            rc2 = lexer.token_if(pdl.after, "}")
            if rc2:
                return P2_ObjectLiteral_LCURLY_PropertyDefinitionList_RCURLY(ctx, strict, [lcurly, pdl, rc2])
        else:
            rcurly = lexer.token_if(lcurly.span.after, "}")
            if rcurly:
                return P2_ObjectLiteral_LCURLY_RCURLY(ctx, strict, [lcurly, rcurly])
    return None


# --------======= 𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂𝓓𝓮𝓯𝓲𝓷𝓲𝓽𝓲𝓸𝓷𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   PropertyDefinitionList :
#       PropertyDefinition
#       PropertyDefinitionList , PropertyDefinition
#


class P2_PropertyDefinitionList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "PropertyDefinitionList", strict, children)


class P2_PropertyDefinitionList_PropertyDefinition(P2_PropertyDefinitionList):
    @property
    def PropertyDefinition(self):
        return self.children[0]

    def PropertyNameList(self):
        # 12.2.6.6 Static Semantics: PropertyNameList
        # PropertyDefinitionList : PropertyDefinition
        #   1. If PropName of PropertyDefinition is empty, return a new empty List.
        #   2. Return a new List containing PropName of PropertyDefinition.
        pn = self.PropertyDefinition.PropName()
        return [] if pn == EMPTY else [pn]


class P2_PropertyDefinitionList_PropertyDefinitionList_COMMA_PropertyDefinition(P2_PropertyDefinitionList):
    @property
    def PropertyDefinitionList(self):
        return self.children[0]

    @property
    def PropertyDefinition(self):
        return self.children[2]

    def PropertyNameList(self):
        # 12.2.6.6 Static Semantics: PropertyNameList
        # PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
        #   1. Let list be PropertyNameList of PropertyDefinitionList.
        #   2. If PropName of PropertyDefinition is empty, return list.
        #   3. Append PropName of PropertyDefinition to the end of list.
        #   4. Return list.
        lst = self.PropertyDefinitionList.PropertyNameList()
        pn = self.PropertyDefinition.PropName()
        if pn != EMPTY:
            lst.append(pn)
        return lst

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation
        #   With parameters object and enumerable.
        # PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition
        #   1. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments object and enumerable.
        #   2. Return the result of performing PropertyDefinitionEvaluation of PropertyDefinition with arguments object
        #      and enumerable.
        self.PropertyDefinitionList.PropertyDefinitionEvaluation(object, enumerable)
        return self.PropertyDefinition.PropertyDefinitionEvaluation(object, enumerable)


def parse_PropertyDefinitionList(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.6 Object Initializer
    # Syntax
    #   PropertyDefinitionList[Yield, Await] :
    #       PropertyDefinition[?Yield, ?Await]
    #       PropertyDefinitionList[?Yield, ?Await] , PropertyDefinition[?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is not None:
            comma = lexer.token_if(pos, ",")
            if not comma:
                return previous
        else:
            comma = None
        pd = parse_PropertyDefinition(ctx, lexer, comma.span.after if comma else pos, strict, Yield, Await)
        if pd:
            if previous is None:
                return lambda: parse(pd.after, P2_PropertyDefinitionList_PropertyDefinition(ctx, strict, [pd]))
            return lambda: parse(
                pd.after,
                P2_PropertyDefinitionList_PropertyDefinitionList_COMMA_PropertyDefinition(
                    ctx, strict, [previous, comma, pd]
                ),
            )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂𝓓𝓮𝓯𝓲𝓷𝓲𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   PropertyDefinition :
#       IdentifierReference
#       CoverInitializedName
#       PropertyName : AssignmentExpression
#       MethodDefinition
#       ... AssignmentExpression
#


class P2_PropertyDefinition(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "PropertyDefinition", strict, children)


class P2_PropertyDefinition_IdentifierReference(P2_PropertyDefinition):
    # PropertyDefinition : IdentifierReference
    @property
    def IdentifierReference(self):
        return self.children[0]

    def PropName(self):
        # 12.2.6.5 Static Semantics: PropName
        # PropertyDefinition : IdentifierReference
        #   1. Return StringValue of IdentifierReference.
        return self.IdentifierReference.StringValue

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation
        #   With parameters object and enumerable.
        # PropertyDefinition : IdentifierReference
        #   1. Let propName be StringValue of IdentifierReference.
        #   2. Let exprValue be the result of evaluating IdentifierReference.
        #   3. Let propValue be ? GetValue(exprValue).
        #   4. Assert: enumerable is true.
        #   5. Assert: object is an ordinary, extensible object with no non-configurable properties.
        #   6. Return CreateDataPropertyOrThrow(object, propName, propValue).
        assert enumerable
        # @@@ the assertion in step 5 is new. Need to implement.
        propName = self.IdentifierReference.StringValue
        propValue = GetValue(self.IdentifierReference.evaluate())
        return CreateDataPropertyOrThrow(object, propName, propValue)


class P2_PropertyDefinition_CoverInitializedName(P2_PropertyDefinition):
    # PropertyDefinition : CoverInitializedName
    @property
    def CoverInitializedName(self):
        return self.children[0]

    def EarlyErrors(self):
        # 12.2.6.1 Static Semantics: Early Errors
        #
        # In addition to describing an actual object initializer the ObjectLiteral productions are also used as a cover
        # grammar for ObjectAssignmentPattern and may be recognized as part of a
        # CoverParenthesizedExpressionAndArrowParameterList. When ObjectLiteral appears in a context where
        # ObjectAssignmentPattern is required the following Early Error rules are not applied. In addition, they are
        # not applied when initially parsing a CoverParenthesizedExpressionAndArrowParameterList or
        # CoverCallExpressionAndAsyncArrowHead.
        #
        # PropertyDefinition : CoverInitializedName
        # * Always throw a Syntax Error if code matches this production.
        #
        # NOTE
        # This production exists so that ObjectLiteral can serve as a cover grammar for ObjectAssignmentPattern. It
        # cannot occur in an actual object initializer.
        #
        # @@@ Need to add some kind of guard like the note says. Not sure how to do that. Maybe. Or maybe since covering
        # generally happens *after* early errors, it doesn't matter?
        return [self.CreateSyntaxError("Production not allowed in object initializers")]


class P2_PropertyDefinition_PropertyName_COLON_AssignmentExpression(P2_PropertyDefinition):
    # PropertyDefinition : PropertyName : AssignmentExpression
    @property
    def PropertyName(self):
        return self.children[0]

    @property
    def AssignmentExpression(self):
        return self.children[2]

    def PropName(self):
        # 12.2.6.5 Static Semantics: PropName
        # PropertyDefinition : PropertyName : AssignmentExpression
        #   1. Return PropName of PropertyName.
        return self.PropertyName.PropName()

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation
        #   With parameters object and enumerable.
        # PropertyDefinition : PropertyName : AssignmentExpression
        #   1. Let propKey be the result of evaluating PropertyName.
        #   2. ReturnIfAbrupt(propKey).
        #   3. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then
        #       a. Let propValue be the result of performing NamedEvaluation for AssignmentExpression with argument
        #          propKey.
        #   4. Else,
        #       a. Let exprValueRef be the result of evaluating AssignmentExpression.
        #       b. Let propValue be ? GetValue(exprValueRef).
        #   5. Assert: enumerable is true.
        #   6. Assert: object is an ordinary, extensible object with no non-configurable properties.
        #   7. Return ! CreateDataPropertyOrThrow(object, propKey, propValue).
        propKey = self.PropertyName.evaluate()
        if IsAnonymousFunctionDefinition(self.AssignmentExpression):
            propValue = self.AssignmentExpression.NamedEvaluation(propKey)
        else:
            propValue = GetValue(self.AssignmentExpression.evaluate())
        assert enumerable
        # @@@ The assertion in step 6 is new. Need to implement
        return CreateDataPropertyOrThrow(object, propKey, propValue)


class P2_PropertyDefinition_MethodDefinition(P2_PropertyDefinition):
    # PropertyDefinition : MethodDefinition
    @property
    def MethodDefinition(self):
        return self.children[0]

    def EarlyErrors(self):
        # 12.2.6.1 Static Semantics: Early Errors
        # PropertyDefinition : MethodDefinition
        # * It is a Syntax Error if HasDirectSuper of MethodDefinition is true.
        return list(
            filter(
                None,
                [
                    self.MethodDefinition.HasDirectSuper()
                    and self.CreateSyntaxError("super not allowed in object literal creation")
                ],
            )
        )

    def Contains(self, symbol):
        # 12.2.6.3 Static Semantics: Contains
        #   With parameter symbol.
        # PropertyDefinition : MethodDefinition
        #   1. If symbol is MethodDefinition, return true.
        #   2. Return the result of ComputedPropertyContains for MethodDefinition with argument symbol.
        return symbol == "MethodDefinition" or self.MethodDefinition.ComputedPropertyContains(symbol)
        # NOTE
        # Static semantic rules that depend upon substructure generally do not look into function definitions.


class P2_PropertyDefinition_DOTDOTDOT_AssignmentExpression(P2_PropertyDefinition):
    # PropertyDefinition : ... AssignmentExpression
    @property
    def AssignmentExpression(self):
        return self.children[1]

    def PropName(self):
        # 12.2.6.5 Static Semantics: PropName
        # PropertyDefinition : ... AssignmentExpression
        #   1. Return empty.
        return EMPTY

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation
        #   With parameters object and enumerable.
        # PropertyDefinition : ... AssignmentExpression
        #   1. Let exprValue be the result of evaluating AssignmentExpression.
        #   2. Let fromValue be ? GetValue(exprValue).
        #   3. Let excludedNames be a new empty List.
        #   4. Return ? CopyDataProperties(object, fromValue, excludedNames).
        return CopyDataProperties(object, GetValue(self.AssignmentExpression.evaluate()), [])


def parse_PropertyDefinition(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.6 Object Initializer
    # Syntax
    #   PropertyDefinition[Yield, Await] :
    #       IdentifierReference[?Yield, ?Await]
    #       CoverInitializedName[?Yield, ?Await]
    #       PropertyName[?Yield, ?Await] : AssignmentExpression[+In, ?Yield, ?Await]
    #       MethodDefinition[?Yield, ?Await]
    #       ... AssignmentExpression[+In, ?Yield, ?Await]
    #
    # Note: Have to try IdentifierReference after all the other ones, since it starts off the same as most of the others.
    cin = parse_CoverInitializedName(ctx, lexer, pos, strict, Yield, Await)
    if cin:
        return P2_PropertyDefinition_CoverInitializedName(ctx, strict, [cin])
    pn = parse_PropertyName(ctx, lexer, pos, strict, Yield, Await)
    if pn:
        colon = lexer.token_if(pn.after, ":")
        if colon:
            ae = parse_AssignmentExpression(ctx, lexer, colon.span.after, strict, True, Yield, Await)
            if ae:
                return P2_PropertyDefinition_PropertyName_COLON_AssignmentExpression(ctx, strict, [pn, colon, ae])
    md = parse_MethodDefinition(ctx, lexer, pos, strict, Yield, Await)
    if md:
        return P2_PropertyDefinition_MethodDefinition(ctx, strict, [md])
    dots = lexer.token_if(pos, "...")
    if dots:
        ae = parse_AssignmentExpression(ctx, lexer, dots.span.after, strict, True, Yield, Await)
        if ae:
            return P2_PropertyDefinition_DOTDOTDOT_AssignmentExpression(ctx, strict, [dots, ae])
    ir = parse_IdentifierReference(ctx, lexer, pos, strict, Yield, Await)
    if ir:
        return P2_PropertyDefinition_IdentifierReference(ctx, strict, [ir])
    return None


# --------======= 𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂𝓝𝓪𝓶𝓮 =======--------
# Syntax
#   PropertyName :
#       LiteralPropertyName
#       ComputedPropertyName
#


class P2_PropertyName(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "PropertyName", strict, children)


class P2_PropertyName_LiteralPropertyName(P2_PropertyName):
    # PropertyName : LiteralPropertyName
    @property
    def LiteralPropertyName(self):
        return self.children[0]

    def ComputedPropertyContains(self, symbol):
        # 12.2.6.2 Static Semantics: ComputedPropertyContains
        #   With parameter symbol.
        #           PropertyName : LiteralPropertyName
        # 1. Return false.
        return False

    def IsComputedPropertyKey(self):
        # 12.2.6.4 Static Semantics: IsComputedPropertyKey
        #           PropertyName : LiteralPropertyName
        # 1. Return false.
        return False


class P2_PropertyName_ComputedPropertyName(P2_PropertyName):
    # PropertyName : ComputedPropertyName
    @property
    def ComputedPropertyName(self):
        return self.children[0]

    def ComputedPropertyContains(self, symbol):
        # 12.2.6.2 Static Semantics: ComputedPropertyContains
        #   With parameter symbol.
        #           PropertyName : ComputedPropertyName
        # 1. Return the result of ComputedPropertyName Contains symbol.
        return self.ComputedPropertyName.Contains(symbol)

    def IsComputedPropertyKey(self):
        # 12.2.6.4 Static Semantics: IsComputedPropertyKey
        #           PropertyName : ComputedPropertyName
        # 1. Return true.
        return True


def parse_PropertyName(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.6 Object Initializer
    # Syntax
    #   PropertyName[Yield, Await] :
    #       LiteralPropertyName
    #       ComputedPropertyName[?Yield, ?Await]
    #
    lpn = parse_LiteralPropertyName(ctx, lexer, pos, strict)
    if lpn:
        return P2_PropertyName_LiteralPropertyName(ctx, strict, [lpn])
    cpn = parse_ComputedPropertyName(ctx, lexer, pos, strict, Yield, Await)
    if cpn:
        return P2_PropertyName_ComputedPropertyName(ctx, strict, [cpn])
    return None


class P2_LiteralPropertyName(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LiteralPropertyName", strict, children)

    def evaluate(self):
        # 12.2.6.7 Runtime Semantics: Evaluation
        # LiteralPropertyName : IdentifierName
        #   1. Return StringValue of IdentifierName.
        # LiteralPropertyName : StringLiteral
        #   1. Return the String value whose code units are the SV of the StringLiteral.
        # LiteralPropertyName : StringLiteral
        #   1. Let nbr be the result of forming the value of the NumericLiteral.
        #   2. Return ! ToString(nbr).

        # ..... all of which are the same thing as PropName.
        return self.PropName()


class P2_LiteralPropertyName_IdentifierName(P2_LiteralPropertyName):
    # LiteralPropertyName : IdentifierName
    @property
    def IdentifierName(self):
        return self.children[0]

    def Contains(self, symbol):
        # 12.2.6.3 Static Semantics: Contains
        #   With parameter symbol.
        # LiteralPropertyName : IdentifierName
        #   1. If symbol is a ReservedWord, return false.
        #   2. If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of
        #      IdentifierName, return true.
        #   3. Return false.
        return symbol not in self.context.lexer_interface.reserved_words and symbol == self.IdentifierName.value

    def PropName(self):
        # 12.2.6.5 Static Semantics: PropName
        # LiteralPropertyName : IdentifierName
        #   1. Return StringValue of IdentifierName.
        return self.IdentifierName.value


class P2_LiteralPropertyName_StringLiteral(P2_LiteralPropertyName):
    # LiteralPropertyName : StringLiteral
    @property
    def StringLiteral(self):
        return self.children[0]

    def PropName(self):
        # 12.2.6.5 Static Semantics: PropName
        #           LiteralPropertyName : StringLiteral
        # 1. Return the String value whose code units are the SV of the StringLiteral.
        return self.StringLiteral.value


class P2_LiteralPropertyName_NumericLiteral(P2_LiteralPropertyName):
    # LiteralPropertyName : NumericLiteral
    @property
    def NumericLiteral(self):
        return self.children[0]

    def PropName(self):
        # 12.2.6.5 Static Semantics: PropName
        #           LiteralPropertyName : StringLiteral
        # 1. Let nbr be the result of forming the value of the NumericLiteral.
        # 2. Return ! ToString(nbr).
        return ToString(self.NumericLiteral.value)


LiteralPropertyConstructors = {
    "IDENTIFIER": P2_LiteralPropertyName_IdentifierName,
    "STRING": P2_LiteralPropertyName_StringLiteral,
    "NUMERIC": P2_LiteralPropertyName_NumericLiteral,
}


def parse_LiteralPropertyName(ctx, lexer, pos, strict):
    # 12.2.6 Object Initializer
    # Syntax
    #   LiteralPropertyName:
    #       IdentifierName
    #       StringLiteral
    #       NumericLiteral
    tok = lexer.token(pos)
    if tok:
        return LiteralPropertyConstructors.get(tok.type, lambda *args: None)(ctx, strict, [tok])
    return None


class P2_ComputedPropertyName(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ComputedPropertyName", strict, children)


class P2_ComputedPropertyName_LBRACKET_AssignmentExpression_RBRACKET(P2_ComputedPropertyName):
    # ComputedPropertyName : [ AssignmentExpression ]
    @property
    def AssignmentExpression(self):
        return self.children[1]

    def PropName(self):
        # 12.2.6.5 Static Semantics: PropName
        # ComputedPropertyName : [ AssignmentExpression ]
        #   1. Return empty.
        return EMPTY

    def evaluate(self):
        # 12.2.6.7 Runtime Semantics: Evaluation
        # ComputedPropertyName : [ AssignmentExpression ]
        #   1. Let exprValue be the result of evaluating AssignmentExpression.
        #   2. Let propName be ? GetValue(exprValue).
        #   3. Return ? ToPropertyKey(propName).
        return ToPropertyKey(GetValue(self.AssignmentExpression.evaluate()))


def parse_ComputedPropertyName(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.6 Object Initializer
    # Syntax
    #   ComputedPropertyName[Yield, Await] :
    #       [ AssignmentExpression[+In, ?Yield, ?Await] ]
    #
    lb = lexer.token_if(pos, "[")
    if lb:
        ae = parse_AssignmentExpression(ctx, lexer, lb.span.after, strict, True, Yield, Await)
        if ae:
            rb = lexer.token_if(ae.after, "]")
            if rb:
                return P2_ComputedPropertyName_LBRACKET_AssignmentExpression_RBRACKET(ctx, strict, [lb, ae, rb])
    return None


class P2_CoverInitializedName(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CoverInitializedName", strict, children)


class P2_CoverInitializedName_IdentifierReference_Initializer(P2_CoverInitializedName):
    # CoverInitializedName : IdentifierReference Initializer
    @property
    def IdentifierReference(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]


def parse_CoverInitializedName(ctx, lexer, pos, strict, Yield, Await):
    # 12.2.6 Object Initializer
    # Syntax
    #   CoverInitializedName[Yield, Await] :
    #       IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]
    #
    ir = parse_IdentifierReference(ctx, lexer, pos, strict, Yield, Await)
    if ir:
        initializer = parse_Initializer(ctx, lexer, ir.after, strict, True, Yield, Await)
        if initializer:
            return P2_CoverInitializedName_IdentifierReference_Initializer(ctx, strict, [ir, initializer])
    return None


class P2_Initializer(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Initializer", strict, children)


class P2_Initializer_EQUALS_AssignmentExpression(P2_Initializer):
    # Initializer : = AssignmentExpression
    @property
    def AssignmentExpression(self):
        return self.children[1]


def parse_Initializer(ctx, lexer, pos, strict, In, Yield, Await):
    # 12.2.6 Object Initializer
    # Syntax
    #   Initializer[In, Yield, Await]:
    #       = AssignmentExpression[?In, ?Yield, ?Await]
    #
    equals = lexer.token_if(pos, "=")
    if equals:
        ae = parse_AssignmentExpression(ctx, lexer, equals.span.after, strict, In, Yield, Await)
        if ae:
            return P2_Initializer_EQUALS_AssignmentExpression(ctx, strict, [equals, ae])
    return None


# 12.2.7 Function Defining Expressions

# See 14.1 for PrimaryExpression:FunctionExpression .
# See 14.4 for PrimaryExpression:GeneratorExpression .
# See 14.6 for PrimaryExpression:ClassExpression .
# See 14.7 for PrimaryExpression:AsyncFunctionExpression .
# See 14.5 for PrimaryExpression:AsyncGeneratorExpression .

# 12.2.8 Regular Expression Literals


# 12.2.9 Template Literals


class P2_TemplateLiteral(ParseNode2):
    def __init__(self, ctx, strict, children, Tagged):
        super().__init__(ctx, "TemplateLiteral", strict, children)
        self.Tagged = Tagged


class P2_TemplateLiteral_NoSubstitutionTemplate(P2_TemplateLiteral):
    # TemplateLiteral : NoSubstitutionTemplate
    @property
    def NoSubstitutionTemplate(self):
        return self.children[0]

    def EarlyErrors(self):
        # 12.2.9.1 Static Semantics: Early Errors
        #   TemplateLiteral : NoSubstitutionTemplate
        # * It is a Syntax Error if the [Tagged] parameter was not set and NoSubstitutionTemplate Contains
        #   NotEscapeSequence.
        return list(
            filter(
                None,
                [
                    not self.Tagged
                    and self.NoSubstitutionTemplate.value.tv is None
                    and self.CreateSyntaxError("Invalid Escape Sequence in template")
                ],
            )
        )

    def TemplateStrings(self, raw):
        # 12.2.9.2 Static Semantics: TemplateStrings
        #   With parameter raw.
        # TemplateLiteral : NoSubstitutionTemplate
        #   1. If raw is false, then
        #       a. Let string be the TV of NoSubstitutionTemplate.
        #   2. Else,
        #       a. Let string be the TRV of NoSubstitutionTemplate.
        #   3. Return a List containing the single element, string.
        nst = self.NoSubstitutionTemplate.value
        return [raw and nst.trv or nst.tv]

    def ArgumentListEvaluation(self):
        # 12.2.9.3 Runtime Semantics: ArgumentListEvaluation
        # TemplateLiteral : NoSubstitutionTemplate
        #   1. Let templateLiteral be this TemplateLiteral.
        #   2. Let siteObj be GetTemplateObject(templateLiteral).
        #   3. Return a List containing the one element which is siteObj.
        return [GetTemplateObject(self)]

    def evaluate(self):
        # 12.2.9.6 Runtime Semantics: Evaluation
        # TemplateLiteral : NoSubstitutionTemplate
        #   1. Return the String value whose code units are the elements of the TV of NoSubstitutionTemplate as
        #      defined in 11.8.6.
        return self.NoSubstitutionTemplate.value.tv


class P2_TemplateLiteral_SubstitutionTemplate(P2_TemplateLiteral):
    # TemplateLiteral : SubstitutionTemplate
    @property
    def SubstitutionTemplate(self):
        return self.children[0]

    def EarlyErrors(self):
        # 12.2.9.1 Static Semantics: Early Errors
        #   TemplateLiteral : SubstitutionTemplate
        # * It is a Syntax Error if the number of elements in the result of TemplateStrings of TemplateLiteral with
        #   argument false is greater than 2^32-1.
        return [
            err
            for err in (
                len(self.TemplateStrings(False)) > 2 ** 32 - 1
                and self.CreateSyntaxError("Too many substitutions in template. (Boy are we impressed.)"),
            )
            if err
        ]


def parse_TemplateLiteral(ctx, lexer, pos, strict, Yield, Await, Tagged):
    # 12.2.9 Template Literals
    # Syntax
    #   TemplateLiteral[Yield, Await, Tagged] :
    #       NoSubstitutionTemplate
    #       SubstitutionTemplate[?Yield, ?Await, ?Tagged]
    #
    nst = lexer.token_if(pos, "NOSUBSTITUTIONTEMPLATE")
    if nst:
        return P2_TemplateLiteral_NoSubstitutionTemplate(ctx, strict, [nst], Tagged)
    st = parse_SubstitutionTemplate(ctx, lexer, pos, strict, Yield, Await, Tagged)
    if st:
        return P2_TemplateLiteral_SubstitutionTemplate(ctx, strict, [st], Tagged)
    return None


class P2_SubstitutionTemplate(ParseNode2):
    def __init__(self, ctx, strict, children, Tagged):
        super().__init__(ctx, "SubstitutionTemplate", strict, children)
        self.Tagged = Tagged


class P2_SubstitutionTemplate_TemplateHead_Expression_TemplateSpans(P2_SubstitutionTemplate):
    # SubstitutionTemplate : TemplateHead Expression TemplateSpans
    @property
    def TemplateHead(self):
        return self.children[0]

    @property
    def Expression(self):
        return self.children[1]

    @property
    def TemplateSpans(self):
        return self.children[2]

    def EarlyErrors(self):
        # 12.2.9.1 Static Semantics: Early Errors
        # SubstitutionTemplate : TemplateHead Expression TemplateSpans
        #   * It is a Syntax Error if the [Tagged] parameter was not set and TemplateHead Contains NotEscapeSequence.
        return list(
            filter(
                None,
                [
                    not self.Tagged
                    and self.TemplateHead.value.tv is None
                    and self.CreateSyntaxError("Invalid Escape Sequence in template")
                ],
            )
        )

    def TemplateStrings(self, raw):
        # 12.2.9.2 Static Semantics: TemplateStrings
        #   With parameter raw.
        # SubstitutionTemplate : TemplateHead Expression TemplateSpans
        #   1. If raw is false, then
        #      a. Let head be the TV of TemplateHead.
        #   2. Else,
        #      a. Let head be the TRV of TemplateHead.
        #   3. Let tail be TemplateStrings of TemplateSpans with argument raw.
        #   4. Return a List containing head followed by the elements, in order, of tail.
        th = self.TemplateHead
        result = [{False: th.value.tv, True: th.value.trv}[raw]]
        result.extend(self.TemplateSpans.TemplateStrings(raw))
        return result

    def ArgumentListEvaluation(self):
        # 12.2.9.3 Runtime Semantics: ArgumentListEvaluation
        #       SubstitutionTemplate : TemplateHead Expression TemplateSpans
        #   1. Let templateLiteral be this TemplateLiteral.
        #   2. Let siteObj be GetTemplateObject(templateLiteral).
        #   3. Let firstSubRef be the result of evaluating Expression.
        #   4. Let firstSub be ? GetValue(firstSubRef).
        #   5. Let restSub be SubstitutionEvaluation of TemplateSpans.
        #   6. ReturnIfAbrupt(restSub).
        #   7. Assert: restSub is a List.
        #   8. Return a List whose first element is siteObj, whose second elements is firstSub, and whose subsequent
        #      elements are the elements of restSub, in order. restSub may contain no elements.
        siteObj = GetTemplateObject(self)
        firstSub = GetValue(self.Expression.evaluate())
        restSub = self.TemplateSpans.SubstitutionEvaluation()
        assert isinstance(restSub, list)
        return [siteObj, firstSub] + restSub

    def evaluate(self):
        # 12.2.9.6 Runtime Semantics: Evaluation
        # SubstitutionTemplate : TemplateHead Expression TemplateSpans
        #   1. Let head be the TV of TemplateHead as defined in 11.8.6.
        #   2. Let subRef be the result of evaluating Expression.
        #   3. Let sub be ? GetValue(subRef).
        #   4. Let middle be ? ToString(sub).
        #   5. Let tail be the result of evaluating TemplateSpans.
        #   6. ReturnIfAbrupt(tail).
        #   7. Return the string-concatenation of head, middle, and tail.
        head = self.TemplateHead.value.tv
        middle = ToString(GetValue(self.Expression.evaluate()))
        tail = self.TemplateSpans.evaluate()
        return f"{head}{middle}{tail}"
        # NOTE 1
        # The string conversion semantics applied to the Expression value are like String.prototype.concat rather than
        # the + operator.


def parse_SubstitutionTemplate(ctx, lexer, pos, strict, Yield, Await, Tagged):
    # 12.2.9 Template Literals
    # Syntax
    #   SubstitutionTemplate[Yield, Await, Tagged] :
    #       TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
    #
    th = lexer.token_if(pos, "TEMPLATEHEAD", goal=lexer.InputElementDiv)
    if th:
        exp = parse_Expression(ctx, lexer, th.span.after, strict, True, Yield, Await)
        if exp:
            ts = parse_TemplateSpans(ctx, lexer, exp.after, strict, Yield, Await, Tagged)
            if ts:
                return P2_SubstitutionTemplate_TemplateHead_Expression_TemplateSpans(
                    ctx, strict, [th, exp, ts], Tagged
                )
    return None


class P2_TemplateSpans(ParseNode2):
    def __init__(self, ctx, strict, children, Tagged):
        super().__init__(ctx, "TemplateSpans", strict, children)
        self.Tagged = Tagged


class P2_TemplateSpans_TemplateTail(P2_TemplateSpans):
    # TemplateSpans : TemplateTail
    @property
    def TemplateTail(self):
        return self.children[0]

    def EarlyErrors(self):
        # 12.2.9.1 Static Semantics: Early Errors
        # TemplateSpans : TemplateTail
        # * It is a Syntax Error if the [Tagged] parameter was not set and TemplateTail Contains NotEscapeSequence.
        return list(
            filter(
                None,
                [
                    not self.Tagged
                    and self.TemplateTail.value.tv is None
                    and self.CreateSyntaxError("Invalid Escape Sequence in template")
                ],
            )
        )

    def TemplateStrings(self, raw):
        # 12.2.9.2 Static Semantics: TemplateStrings
        #   With parameter raw.
        # TemplateSpans : TemplateTail
        #   1. If raw is false, then
        #       a. Let tail be the TV of TemplateTail.
        #   2. Else,
        #       a. Let tail be the TRV of TemplateTail.
        #   3. Return a List containing the single element, tail.
        return [{False: self.TemplateTail.value.tv, True: self.TemplateTail.value.trv}[raw]]

    def SubstitutionEvaluation(self):
        # 12.2.9.5 Runtime Semantics: SubstitutionEvaluation
        # TemplateSpans : TemplateTail
        #   1. Return a new empty List.
        return []

    def evaluate(self):
        # 12.2.9.6 Runtime Semantics: Evaluation
        # TemplateSpans : TemplateTail
        #   1. Let tail be the TV of TemplateTail as defined in 11.8.6.
        #   2. Return the String value consisting of the code units of tail.
        return self.TemplateTail.value.tv


class P2_TemplateSpans_TemplateMiddleList_TemplateTail(P2_TemplateSpans):
    # TemplateSpans : TemplateMiddleList TemplateTail
    @property
    def TemplateMiddleList(self):
        return self.children[0]

    @property
    def TemplateTail(self):
        return self.children[1]

    def TemplateStrings(self, raw):
        # 12.2.9.2 Static Semantics: TemplateStrings
        #   With parameter raw.
        # TemplateSpans : TemplateMiddleList TemplateTail
        #   1. Let middle be TemplateStrings of TemplateMiddleList with argument raw.
        #   2. If raw is false, then
        #       a. Let tail be the TV of TemplateTail.
        #   3. Else,
        #       a. Let tail be the TRV of TemplateTail.
        #   4. Return a List containing the elements, in order, of middle followed by tail.
        result = self.TemplateMiddleList.TemplateStrings(raw)
        result.append({False: self.TemplateTail.value.tv, True: self.TemplateTail.value.trv}[raw])
        return result

    def SubstitutionEvaluation(self):
        # 12.2.9.5 Runtime Semantics: SubstitutionEvaluation
        # TemplateSpans : TemplateMiddleList TemplateTail
        #   1. Return the result of SubstitutionEvaluation of TemplateMiddleList.
        return self.TemplateMiddleList.SubstitutionEvaluation()

    def evaluate(self):
        # 12.2.9.6 Runtime Semantics: Evaluation
        # TemplateSpans : TemplateMiddleList TemplateTail
        #   1. Let head be the result of evaluating TemplateMiddleList.
        #   2. ReturnIfAbrupt(head).
        #   3. Let tail be the TV of TemplateTail as defined in 11.8.6.
        #   4. Return the string-concatenation of head and tail.
        head = self.TemplateMiddleList.evaluate()
        tail = self.TemplateTail.value[0]
        return f"{head}{tail}"


def parse_TemplateSpans(ctx, lexer, pos, strict, Yield, Await, Tagged):
    # 12.2.9 Template Literals
    # Syntax
    #   TemplateSpans[Yield, Await, Tagged] :
    #       TemplateTail
    #       TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail
    #
    tml = parse_TemplateMiddleList(ctx, lexer, pos, strict, Yield, Await, Tagged)
    tt = lexer.token_if(tml.after if tml else pos, "TEMPLATETAIL", goal=lexer.InputElementTemplateTail)
    if tt:
        if tml:
            return P2_TemplateSpans_TemplateMiddleList_TemplateTail(ctx, strict, [tml, tt], Tagged)
        return P2_TemplateSpans_TemplateTail(ctx, strict, [tt], Tagged)
    return None


class P2_TemplateMiddleList(ParseNode2):
    def __init__(self, ctx, strict, children, Tagged):
        super().__init__(ctx, "TemplateMiddleList", strict, children)
        self.Tagged = Tagged

    @property
    def TemplateMiddle(self):
        raise NotImplementedError("Base classes should not be instantiated")

    def EarlyErrors(self):
        # 12.2.9.1 Static Semantics: Early Errors
        #   TemplateMiddleList[Yield, Await, Tagged] :
        #       TemplateMiddle Expression[+In, ?Yield, ?Await]
        #       TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
        # * It is a Syntax Error if the [Tagged] parameter was not set and TemplateMiddle Contains NotEscapeSequence.
        return list(
            filter(
                None,
                [
                    not self.Tagged
                    and self.TemplateMiddle.value.tv is None
                    and self.CreateSyntaxError("Invalid Escape Sequence in template")
                ],
            )
        )


class P2_TemplateMiddleList_TemplateMiddle_Expression(P2_TemplateMiddleList):
    # TemplateMiddleList : TemplateMiddle Expression
    @property
    def TemplateMiddle(self):
        return self.children[0]

    @property
    def Expression(self):
        return self.children[1]

    def TemplateStrings(self, raw):
        # 12.2.9.2 Static Semantics: TemplateStrings
        #   With parameter raw.
        # TemplateMiddleList : TemplateMiddle Expression
        #   1. If raw is false, then
        #       a. Let string be the TV of TemplateMiddle.
        #   2. Else,
        #       a. Let string be the TRV of TemplateMiddle.
        #   3. Return a List containing the single element, string.
        return [{False: self.TemplateMiddle.value.tv, True: self.TemplateMiddle.value.trv}[raw]]

    def SubstitutionEvaluation(self):
        # 12.2.9.5 Runtime Semantics: SubstitutionEvaluation
        # TemplateMiddleList : TemplateMiddle Expression
        #   1. Let subRef be the result of evaluating Expression.
        #   2. Let sub be ? GetValue(subRef).
        #   3. Return a List containing only sub.
        return [GetValue(self.Expression.evaluate())]

    def evaluate(self):
        # 12.2.9.6 Runtime Semantics: Evaluation
        # TemplateMiddleList : TemplateMiddle Expression
        #   1. Let head be the TV of TemplateMiddle as defined in 11.8.6.
        #   2. Let subRef be the result of evaluating Expression.
        #   3. Let sub be ? GetValue(subRef).
        #   4. Let middle be ? ToString(sub).
        #   5. Return the sequence of code units consisting of the code units of head followed by the elements of middle.
        head = self.TemplateMiddle.value.tv
        middle = ToString(GetValue(self.Expression.evaluate()))
        return f"{head}{middle}"
        # NOTE 2
        # The string conversion semantics applied to the Expression value are like String.prototype.concat rather than
        # the + operator.


class P2_TemplateMiddleList_TemplateMiddleList_TemplateMiddle_Expression(P2_TemplateMiddleList):
    # TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
    @property
    def TemplateMiddleList(self):
        return self.children[0]

    @property
    def TemplateMiddle(self):
        return self.children[1]

    @property
    def Expression(self):
        return self.children[2]

    def TemplateStrings(self, raw):
        # 12.2.9.2 Static Semantics: TemplateStrings
        #   With parameter raw.
        # TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
        #   1. Let front be TemplateStrings of TemplateMiddleList with argument raw.
        #   2. If raw is false, then
        #       a. Let last be the TV of TemplateMiddle.
        #   3. Else,
        #       a. Let last be the TRV of TemplateMiddle.
        #   4. Append last as the last element of the List front.
        #   5. Return front.
        result = self.TemplateMiddleList.TemplateStrings(raw)
        result.append({False: self.TemplateMiddle.value.tv, True: self.TemplateMiddle.value.trv}[raw])
        return result

    def SubstitutionEvaluation(self):
        # 12.2.9.5 Runtime Semantics: SubstitutionEvaluation
        # TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
        #   1. Let preceding be the result of SubstitutionEvaluation of TemplateMiddleList.
        #   2. ReturnIfAbrupt(preceding).
        #   3. Let nextRef be the result of evaluating Expression.
        #   4. Let next be ? GetValue(nextRef).
        #   5. Append next as the last element of the List preceding.
        #   6. Return preceding.
        preceding = self.TemplateMiddleList.SubstitutionEvaluation()
        preceding.append(GetValue(self.Expression.evaluate()))
        return preceding

    def evaluate(self):
        # 12.2.9.6 Runtime Semantics: Evaluation
        # TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
        #   1. Let rest be the result of evaluating TemplateMiddleList.
        #   2. ReturnIfAbrupt(rest).
        #   3. Let middle be the TV of TemplateMiddle as defined in 11.8.6.
        #   4. Let subRef be the result of evaluating Expression.
        #   5. Let sub be ? GetValue(subRef).
        #   6. Let last be ? ToString(sub).
        #   7. Return the sequence of code units consisting of the elements of rest followed by the code units of middle followed by the elements of last.
        rest = self.TemplateMiddleList.evaluate()
        middle = self.TemplateMiddle.value.tv
        last = ToString(GetValue(self.Expression.evaluate()))
        return f"{rest}{middle}{last}"
        # NOTE 2
        # The string conversion semantics applied to the Expression value are like String.prototype.concat rather than
        # the + operator.


def parse_TemplateMiddleList(ctx, lexer, pos, strict, Yield, Await, Tagged):
    # 12.2.9 Template Literals
    # Syntax
    #   TemplateMiddleList[Yield, Await, Tagged] :
    #       TemplateMiddle Expression[+In, ?Yield, ?Await]
    #       TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        tm = lexer.token_if(pos, "TEMPLATEMIDDLE", goal=lexer.InputElementTemplateTail)
        if tm:
            exp = parse_Expression(ctx, lexer, tm.span.after, strict, True, Yield, Await)
            if exp:
                if previous:
                    return lambda: parse(
                        exp.after,
                        P2_TemplateMiddleList_TemplateMiddleList_TemplateMiddle_Expression(
                            ctx, strict, [previous, tm, exp], Tagged
                        ),
                    )
                return lambda: parse(
                    exp.after, P2_TemplateMiddleList_TemplateMiddle_Expression(ctx, strict, [tm, exp], Tagged)
                )
        return previous

    return trampoline(lambda: parse(pos))


# 12.2.9.4 Runtime Semantics: GetTemplateObject ( templateLiteral )
def GetTemplateObject(templateLiteral):
    # The abstract operation GetTemplateObject is called with a Parse Node, templateLiteral, as an argument. It
    # performs the following steps:
    #
    #   1. Let rawStrings be TemplateStrings of templateLiteral with argument true.
    #   2. Let realm be the current Realm Record.
    #   3. Let templateRegistry be realm.[[TemplateMap]].
    #   4. For each element e of templateRegistry, do
    #       a. If e.[[Site]] is the same Parse Node as templateLiteral, then
    #           i. Return e.[[Array]].
    #   5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.
    #   6. Let count be the number of elements in the List cookedStrings.
    #   7. Assert: count ≤ 2^32-1.
    #   8. Let template be ! ArrayCreate(count).
    #   9. Let rawObj be ! ArrayCreate(count).
    #   10. Let index be 0.
    #   11. Repeat, while index < count
    #       a. Let prop be ! ToString(index).
    #       b. Let cookedValue be the String value cookedStrings[index].
    #       c. Call template.[[DefineOwnProperty]](prop, PropertyDescriptor { [[Value]]: cookedValue,
    #          [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }).
    #       d. Let rawValue be the String value rawStrings[index].
    #       e. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor { [[Value]]: rawValue, [[Writable]]: false,
    #          [[Enumerable]]: true, [[Configurable]]: false }).
    #       f. Increase index by 1.
    #   12. Perform SetIntegrityLevel(rawObj, "frozen").
    #   13. Call template.[[DefineOwnProperty]]("raw", PropertyDescriptor { [[Value]]: rawObj, [[Writable]]: false,
    #       [[Enumerable]]: false, [[Configurable]]: false }).
    #   14. Perform SetIntegrityLevel(template, "frozen").
    #   15. Append the Record { [[Site]]: templateLiteral, [[Array]]: template } to templateRegistry.
    #   16. Return template.
    rawStrings = templateLiteral.TemplateStrings(True)
    realm = surrounding_agent.running_ec.realm
    templateRegistry = realm.template_map
    for site, array in templateRegistry:
        if site == templateLiteral:
            return array
    cookedStrings = templateLiteral.TemplateStrings(False)
    count = len(cookedStrings)
    assert count <= 2 ** 32 - 1
    template = ArrayCreate(count)
    rawObj = ArrayCreate(count)
    for index in range(count):
        prop = ToString(index)
        cookedValue = cookedStrings[index]
        template.DefineOwnProperty(
            prop, PropertyDescriptor(value=cookedValue, writable=False, enumerable=True, configurable=False)
        )
        rawValue = rawStrings[index]
        rawObj.DefineOwnProperty(
            prop, PropertyDescriptor(value=rawValue, writable=False, enumerable=True, configurable=False)
        )
    SetIntegrityLevel(rawObj, "frozen")
    template.DefineOwnProperty(
        "raw", PropertyDescriptor(value=rawObj, writable=False, enumerable=False, configurable=False)
    )
    SetIntegrityLevel(template, "frozen")
    templateRegistry.append((templateLiteral, template))
    return template
    # NOTE 1
    # The creation of a template object cannot result in an abrupt completion.
    #
    # NOTE 2
    # Each TemplateLiteral in the program code of a realm is associated with a unique template object that is used in
    # the evaluation of tagged Templates (12.2.9.6). The template objects are frozen and the same template object is
    # used each time a specific tagged Template is evaluated. Whether template objects are created lazily upon first
    # evaluation of the TemplateLiteral or eagerly prior to first evaluation is an implementation choice that is not
    # observable to ECMAScript code.
    #
    # NOTE 3
    # Future editions of this specification may define additional non-enumerable properties of template objects.


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.
# d8888   d88P  Y88b     d88P  Y88b
#   888          888          .d88P
#   888        .d88P         8888"
#   888    .od888P"           "Y8b.
#   888   d88P"          888    888
#   888   888"       d8b Y88b  d88P
# 8888888 888888888  Y8P  "Y8888P"
#
# 888                .d888 888           888    888                        888         .d8888b.  d8b      888
# 888               d88P"  888           888    888                        888        d88P  Y88b Y8P      888
# 888               888    888           888    888                        888        Y88b.               888
# 888       .d88b.  888888 888888        8888888888  8888b.  88888b.   .d88888         "Y888b.   888  .d88888  .d88b.
# 888      d8P  Y8b 888    888           888    888     "88b 888 "88b d88" 888            "Y88b. 888 d88" 888 d8P  Y8b
# 888      88888888 888    888    888888 888    888 .d888888 888  888 888  888 888888       "888 888 888  888 88888888
# 888      Y8b.     888    Y88b.         888    888 888  888 888  888 Y88b 888        Y88b  d88P 888 Y88b 888 Y8b.
# 88888888  "Y8888  888     "Y888        888    888 "Y888888 888  888  "Y88888         "Y8888P"  888  "Y88888  "Y8888
#
# 8888888888                                                      d8b
# 888                                                             Y8P
# 888
# 8888888    888  888 88888b.  888d888  .d88b.  .d8888b  .d8888b  888  .d88b.  88888b.  .d8888b
# 888        `Y8bd8P' 888 "88b 888P"   d8P  Y8b 88K      88K      888 d88""88b 888 "88b 88K
# 888          X88K   888  888 888     88888888 "Y8888b. "Y8888b. 888 888  888 888  888 "Y8888b.
# 888        .d8""8b. 888 d88P 888     Y8b.          X88      X88 888 Y88..88P 888  888      X88
# 8888888888 888  888 88888P"  888      "Y8888   88888P'  88888P' 888  "Y88P"  888  888  88888P'
#                     888
#                     888
#                     888
#
#
# 12.3 Left-Hand-Side Expressions
# 12.3.1 Static Semantics
# 12.3.1.1 SS: CoveredCallExpression
# 12.3.1.2 SS: Contains
# 12.3.1.3 SS: IsFunctionDefinition
# 12.3.1.4 SS: IsDestructuring
# 12.3.1.5 SS: IsIdentifierRef
# 12.3.1.6 SS: AssignmentTargetType
# 12.3.2 Property Accessors
# 12.3.2.1 RS: Evaluation
# 12.3.3 The new Operator
# 12.3.3.1 RS: Evaluation
# 12.3.4 Function Calls
# 12.3.4.1 RS: Evaluation
# 12.3.4.2 RS: EvaluateCall ( func, ref, arguments, tailPosition )
# 12.3.5 The super Keyword
# 12.3.5.1 RS: Evaluation
# 12.3.5.2 RS: GetSuperConstructor ( )
# 12.3.5.3 RS: MakeSuperPropertyReference ( actualThis, propertyKey, strict )
# 12.3.6 Argument Lists
# 12.3.6.1 RS: ArgumentListEvaluation
# 12.3.7 Tagged Templates
# 12.3.7.1 RS: Evaluation
# 12.3.8 Meta Properties
# 12.3.8.1 RS: Evaluation
#######################################################################################################################

#####################################################################################
# `·._.·●.._.·●.._.·●..... 12.3 Left-Hand-Side Expressions .....●·._..●·._..●·._.·´ #
#####################################################################################

# --------======= 𝓜𝓮𝓶𝓫𝓮𝓻𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   MemberExpression :
#       PrimaryExpression
#       MemberExpression [ Expression ]
#       MemberExpression . IdentifierName
#       MemberExpression TemplateLiteral
#       SuperProperty
#       MetaProperty
#       new MemberExpression Arguments


class P2_MemberExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "MemberExpression", strict, children)


class P2_MemberExpression_PrimaryExpression(P2_MemberExpression):
    @property
    def PrimaryExpression(self):
        return self.children[0]

    def IsDestructuring(self):
        # 12.3.1.4 Static Semantics: IsDestructuring
        # MemberExpression : PrimaryExpression
        #   1. If PrimaryExpression is either an ObjectLiteral or an ArrayLiteral, return true.
        #   2. Return false.
        return self.PrimaryExpression.Is("ObjectLiteral") or self.PrimaryExpression.Is("ArrayLiteral")

    @cached_property
    def IsStringLiteral(self):
        return self.PrimaryExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.PrimaryExpression.HasUseStrict


class P2_MemberExpression_base(P2_MemberExpression):
    def IsFunctionDefinition(self):
        # 12.3.1.3 Static Semantics: IsFunctionDefinition
        # MemberExpression : MemberExpression [ Expression ]
        # MemberExpression : MemberExpression . IdentifierName
        # MemberExpression : MemberExpression TemplateLiteral
        # MemberExpression : SuperProperty
        # MemberExpression : MetaProperty
        # MemberExpression : new MemberExpression Arguments
        #   1. Return false.
        return False

    def IsDestructuring(self):
        # 12.3.1.4 Static Semantics: IsDestructuring
        # MemberExpression : MemberExpression [ Expression ]
        # MemberExpression : MemberExpression . IdentifierName
        # MemberExpression : MemberExpression TemplateLiteral
        # MemberExpression : SuperProperty
        # MemberExpression : MetaProperty
        # MemberExpression : new MemberExpression Arguments
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.3.1.5 Static Semantics: IsIdentifierRef
        # MemberExpression : MemberExpression [ Expression ]
        # MemberExpression : MemberExpression . IdentifierName
        # MemberExpression : MemberExpression TemplateLiteral
        # MemberExpression : SuperProperty
        # MemberExpression : MetaProperty
        # MemberExpression : new MemberExpression Arguments
        #   1. Return false.
        return False


class P2_MemberExpression_MemberExpression_LBRACKET_Expression_RBRACKET(P2_MemberExpression_base):
    @property
    def MemberExpression(self):
        return self.children[0]

    @property
    def Expression(self):
        return self.children[2]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # MemberExpression : MemberExpression [ Expression ]
    #   1. Return simple.
    AssignmentTargetType = SIMPLE

    def evaluate(self):
        # 12.3.2.1 Runtime Semantics: Evaluation
        # MemberExpression : MemberExpression [ Expression ]
        #   1. Let baseReference be the result of evaluating MemberExpression.
        #   2. Let baseValue be ? GetValue(baseReference).
        #   3. Let propertyNameReference be the result of evaluating Expression.
        #   4. Let propertyNameValue be ? GetValue(propertyNameReference).
        #   5. Let bv be ? RequireObjectCoercible(baseValue).
        #   6. Let propertyKey be ? ToPropertyKey(propertyNameValue).
        #   7. If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be
        #      false.
        #   8. Return a value of type Reference whose base value component is bv, whose referenced name component is
        #      propertyKey, and whose strict reference flag is strict.
        return MemberBracketCore(self, self.MemberExpression.evaluate())


def MemberBracketCore(pn, baseReference):
    baseValue = GetValue(baseReference)
    propertyNameReference = pn.Expression.evaluate()
    propertyNameValue = GetValue(propertyNameReference)
    bv = RequireObjectCoercible(baseValue)
    propertyKey = ToPropertyKey(propertyNameValue)
    return Reference(bv, propertyKey, pn.strict)


class P2_MemberExpression_MemberExpression_PERIOD_IdentifierName(P2_MemberExpression_base):
    @property
    def MemberExpression(self):
        return self.children[0]

    @property
    def IdentifierName(self):
        return self.children[2]

    def Contains(self, symbol):
        # 12.3.1.2 Static Semantics: Contains
        #   With parameter symbol.
        # MemberExpression : MemberExpression . IdentifierName
        #   1. If MemberExpression Contains symbol is true, return true.
        #   2. If symbol is a ReservedWord, return false.
        #   3. If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of
        #      IdentifierName, return true.
        #   4. Return false.
        return self.MemberExpression.Contains(symbol) or (
            symbol not in self.context.lexer_interface.reserved_words and symbol == self.IdentifierName.value
        )

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # MemberExpression : MemberExpression . IdentifierName
    #   1. Return simple.
    AssignmentTargetType = SIMPLE

    def evaluate(self):
        # 12.3.2.1 Runtime Semantics: Evaluation
        # MemberExpression : MemberExpression . IdentifierName
        #   1. Let baseReference be the result of evaluating MemberExpression.
        #   2. Let baseValue be ? GetValue(baseReference).
        #   3. Let bv be ? RequireObjectCoercible(baseValue).
        #   4. Let propertyNameString be StringValue of IdentifierName.
        #   5. If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be
        #      false.
        #   6. Return a value of type Reference whose base value component is bv, whose referenced name component is
        #      propertyNameString, and whose strict reference flag is strict.
        return MemberDotEvaluation(self, self.MemberExpression.evaluate())


def MemberDotEvaluation(pn, baseReference):
    baseValue = GetValue(baseReference)
    bv = RequireObjectCoercible(baseValue)
    propertyNameString = pn.IdentifierName.value
    return Reference(bv, propertyNameString, pn.strict)


class P2_MemberExpression_MemberExpression_TemplateLiteral(P2_MemberExpression_base):
    @property
    def MemberExpression(self):
        return self.children[0]

    @property
    def TemplateLiteral(self):
        return self.children[1]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # MemberExpression : MemberExpression TemplateLiteral
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.3.7.1 Runtime Semantics: Evaluation
        # MemberExpression : MemberExpression TemplateLiteral
        #   1. Let tagRef be the result of evaluating MemberExpression.
        #   2. Let tagFunc be ? GetValue(tagRef).
        #   3. Let thisCall be this MemberExpression.
        #   4. Let tailCall be IsInTailPosition(thisCall).
        #   5. Return ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall).
        tagRef = self.MemberExpression.evaluate()
        tagFunc = GetValue(tagRef)
        tailCall = IsInTailPosition(self)
        return EvaluateCall(tagFunc, tagRef, self.TemplateLiteral, tailCall)


class P2_MemberExpression_SuperProperty(P2_MemberExpression_base):
    @property
    def SuperProperty(self):
        return self.children[0]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # MemberExpression : SuperProperty
    #   1. Return simple.
    AssignmentTargetType = SIMPLE


class P2_MemberExpression_MetaProperty(P2_MemberExpression):
    @property
    def MetaProperty(self):
        return self.children[0]


class P2_MemberExpression_NEW_MemberExpression_Arguments(P2_MemberExpression_base):
    @property
    def MemberExpression(self):
        return self.children[1]

    @property
    def Arguments(self):
        return self.children[2]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # MemberExpression : new MemberExpression Arguments
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.3.3.1 Runtime Semantics: Evaluation
        # MemberExpression: new MemberExpression Arguments
        #   1. Return ? EvaluateNew(MemberExpression, Arguments).
        return EvaluateNew(self.MemberExpression, self.Arguments)


def parse_MemberExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   MemberExpression[Yield, Await] :
    #       PrimaryExpression[?Yield, ?Await]
    #       MemberExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
    #       MemberExpression[?Yield, ?Await] . IdentifierName
    #       MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
    #       SuperProperty[?Yield, ?Await]
    #       MetaProperty
    #       new MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            pe = parse_PrimaryExpression(ctx, lexer, pos, strict, Yield, Await)
            if pe:
                return lambda: parse(pe.after, P2_MemberExpression_PrimaryExpression(ctx, strict, [pe]))
            sp = parse_SuperProperty(ctx, lexer, pos, strict, Yield, Await)
            if sp:
                return lambda: parse(sp.after, P2_MemberExpression_SuperProperty(ctx, strict, [sp]))
            mp = parse_MetaProperty(ctx, lexer, pos, strict)
            if mp:
                return lambda: parse(mp.after, P2_MemberExpression_MetaProperty(ctx, strict, [mp]))
            new_tok = lexer.id_if(pos, "new")
            if new_tok:
                me = parse_MemberExpression(ctx, lexer, new_tok.span.after, strict, Yield, Await)
                if me:
                    args = parse_Arguments(ctx, lexer, me.after, strict, Yield, Await)
                    if args:
                        return lambda: parse(
                            args.after,
                            P2_MemberExpression_NEW_MemberExpression_Arguments(ctx, strict, [new_tok, me, args]),
                        )
        else:
            lb = lexer.token_if(pos, "[")
            if lb:
                exp = parse_Expression(ctx, lexer, lb.span.after, strict, True, Yield, Await)
                if exp:
                    rb = lexer.token_if(exp.after, "]")
                    if rb:
                        return lambda: parse(
                            rb.span.after,
                            P2_MemberExpression_MemberExpression_LBRACKET_Expression_RBRACKET(
                                ctx, strict, [previous, lb, exp, rb]
                            ),
                        )
            dot = lexer.token_if(pos, ".")
            if dot:
                ident = lexer.token_if(dot.span.after, "IDENTIFIER")
                if ident:
                    return lambda: parse(
                        ident.span.after,
                        P2_MemberExpression_MemberExpression_PERIOD_IdentifierName(
                            ctx, strict, [previous, dot, ident]
                        ),
                    )
            tl = parse_TemplateLiteral(ctx, lexer, pos, strict, Yield, Await, True)
            if tl:
                return lambda: parse(
                    tl.after, P2_MemberExpression_MemberExpression_TemplateLiteral(ctx, strict, [previous, tl])
                )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓢𝓾𝓹𝓮𝓻𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂 =======--------
# Syntax
#   SuperProperty :
#       super [ Expression ]
#       super . IdentifierName


class P2_SuperProperty(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "SuperProperty", strict, children)


class P2_SuperProperty_SUPER_LBRACKET_Expression_RBRACKET(P2_SuperProperty):
    @property
    def Expression(self):
        return self.children[2]

    def evaluate(self):
        # 12.3.5.1 Runtime Semantics: Evaluation
        # SuperProperty : super [ Expression ]
        #   1. Let env be GetThisEnvironment().
        #   2. Let actualThis be ? env.GetThisBinding().
        #   3. Let propertyNameReference be the result of evaluating Expression.
        #   4. Let propertyNameValue be ? GetValue(propertyNameReference).
        #   5. Let propertyKey be ? ToPropertyKey(propertyNameValue).
        #   6. If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be
        #      false.
        #   7. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).
        actualThis = GetThisEnvironment().GetThisBinding()
        propertyKey = ToPropertyKey(GetValue(self.Expression.evaluate()))
        return MakeSuperPropertyReference(actualThis, propertyKey, self.strict)


class P2_SuperProperty_SUPER_PERIOD_IdentifierName(P2_SuperProperty):
    @property
    def IdentifierName(self):
        return self.children[2]

    def Contains(self, symbol):
        # 12.3.1.2 Static Semantics: Contains
        #   With parameter symbol.
        # SuperProperty : super . IdentifierName
        #   1. If symbol is the ReservedWord super, return true.
        #   2. If symbol is a ReservedWord, return false.
        #   3. If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of
        #      IdentifierName, return true.
        #   4. Return false.
        return symbol == "super" or (
            symbol not in self.context.lexer_interface.reserved_words and symbol == self.IdentifierName.value
        )

    def evaluate(self):
        # 12.3.5.1 Runtime Semantics: Evaluation
        # SuperProperty : super . IdentifierName
        #   1. Let env be GetThisEnvironment().
        #   2. Let actualThis be ? env.GetThisBinding().
        #   3. Let propertyKey be StringValue of IdentifierName.
        #   4. If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be
        #      false.
        #   5. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).
        actualThis = GetThisEnvironment().GetThisBinding()
        propertyKey = self.IdentifierName.value
        return MakeSuperPropertyReference(actualThis, propertyKey, self.strict)


def parse_SuperProperty(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   SuperProperty[Yield, Await] :
    #       super [ Expression[+In, ?Yield, ?Await] ]
    #       super . IdentifierName
    #
    super = lexer.id_if(pos, "super")
    if super:
        lb = lexer.token_if(super.span.after, "[")
        if lb:
            exp = parse_Expression(ctx, lexer, lb.span.after, strict, True, Yield, Await)
            if exp:
                rb = lexer.token_if(exp.after, "]")
                if rb:
                    return P2_SuperProperty_SUPER_LBRACKET_Expression_RBRACKET(ctx, strict, [super, lb, exp, rb])
        else:
            dot = lexer.token_if(super.span.after, ".")
            if dot:
                ident = lexer.token_if(dot.span.after, "IDENTIFIER")
                if ident:
                    return P2_SuperProperty_SUPER_PERIOD_IdentifierName(ctx, strict, [super, dot, ident])
    return None


# --------======= 𝓜𝓮𝓽𝓪𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂 =======--------
# Syntax
#   MetaProperty:
#       NewTarget


class P2_MetaProperty(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "MetaProperty", strict, children)


class P2_MetaProperty_NewTarget(P2_MetaProperty):
    @property
    def NewTarget(self):
        return self.children[0]


def parse_MetaProperty(ctx, lexer, pos, strict):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   MetaProperty:
    #       NewTarget
    #
    nt = parse_NewTarget(ctx, lexer, pos, strict)
    if nt:
        return P2_MetaProperty_NewTarget(ctx, strict, [nt])
    return None


# --------======= 𝓝𝓮𝔀𝓣𝓪𝓻𝓰𝓮𝓽 =======--------
# Syntax
#   NewTarget :
#       new . target


class P2_NewTarget(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "NewTarget", strict, children)


class P2_NewTarget_NEW_PERIOD_TARGET(P2_NewTarget):
    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # NewTarget : new . target
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.3.8.1 Runtime Semantics: Evaluation
        # NewTarget : new . target
        #   1. Return GetNewTarget().
        return GetNewTarget()


def parse_NewTarget(ctx, lexer, pos, strict):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   NewTarget :
    #       new . target
    #
    new_tok = lexer.id_if(pos, "new")
    if new_tok:
        dot = lexer.token_if(new_tok.span.after, ".")
        if dot:
            target = lexer.id_if(dot.span.after, "target")
            if target:
                return P2_NewTarget_NEW_PERIOD_TARGET(ctx, strict, [new_tok, dot, target])
    return None


# --------======= 𝓝𝓮𝔀𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   NewExpression :
#       MemberExpression
#       new NewExpression


class P2_NewExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "NewExpression", strict, children)


class P2_NewExpression_MemberExpression(P2_NewExpression):
    @property
    def MemberExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.MemberExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.MemberExpression.HasUseStrict


class P2_NewExpression_NEW_NewExpression(P2_NewExpression):
    @property
    def NewExpression(self):
        return self.children[1]

    def IsFunctionDefinition(self):
        # 12.3.1.3 Static Semantics: IsFunctionDefinition
        # NewExpression : new NewExpression
        #   1. Return false.
        return False

    def IsDestructuring(self):
        # 12.3.1.4 Static Semantics: IsDestructuring
        # NewExpression : new NewExpression
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.3.1.5 Static Semantics: IsIdentifierRef
        # NewExpression : new NewExpression
        #   1. Return false.
        return False

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # NewExpression : new NewExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.3.3.1 Runtime Semantics: Evaluation
        # NewExpression : new NewExpression
        #   1. Return ? EvaluateNew(NewExpression, empty).
        return EvaluateNew(self.NewExpression, EMPTY)


def parse_NewExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   NewExpression[Yield, Await] :
    #       MemberExpression[?Yield, ?Await]
    #       new NewExpression[?Yield, ?Await]
    #
    me = parse_MemberExpression(ctx, lexer, pos, strict, Yield, Await)
    if me:
        return P2_NewExpression_MemberExpression(ctx, strict, [me])
    new_tok = lexer.id_if(pos, "new")
    if new_tok:
        ne = parse_NewExpression(ctx, lexer, new_tok.span.after, strict, Yield, Await)
        if ne:
            return P2_NewExpression_NEW_NewExpression(ctx, strict, [new_tok, ne])
    return None


# 12.3.3.1.1 Runtime Semantics: EvaluateNew ( constructExpr, arguments )
def EvaluateNew(constructExpr, arguments):
    # The abstract operation EvaluateNew with arguments constructExpr, and arguments performs the following steps:
    #
    #   1. Assert: constructExpr is either a NewExpression or a MemberExpression.
    #   2. Assert: arguments is either empty or an Arguments.
    #   3. Let ref be the result of evaluating constructExpr.
    #   4. Let constructor be ? GetValue(ref).
    #   5. If arguments is empty, let argList be a new empty List.
    #   6. Else,
    #      a. Let argList be ArgumentListEvaluation of arguments.
    #      b. ReturnIfAbrupt(argList).
    #   7. If IsConstructor(constructor) is false, throw a TypeError exception.
    #   8. Return ? Construct(constructor, argList).
    assert constructExpr.name in ["NewExpression", "MemberExpression"]
    assert arguments == EMPTY or arguments.name == "Arguments"
    ref = constructExpr.evaluate()
    constructor = GetValue(ref)
    if arguments == EMPTY:
        argList = []
    else:
        argList = arguments.ArgumentListEvaluation()
    if not IsConstructor(constructor):
        raise ESTypeError(f"{GetReferencedName(ref)} is not a constructor")
    return Construct(constructor, argList)


# --------======= 𝓒𝓪𝓵𝓵𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   CallExpression :
#       CoverCallExpressionAndAsyncArrowHead
#       SuperCall
#       CallExpression Arguments
#       CallExpression [ Expression ]
#       CallExpression . IdentifierName
#       CallExpression TemplateLiteral


class P2_CallExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CallExpression", strict, children)


class P2_CallExpression_CoverCallExpressionAndAsyncArrowHead(P2_CallExpression):
    def __init__(self, ctx, strict, children, Yield, Await):
        super().__init__(ctx, strict, children)
        # These need to be saved for potential future cover-parse
        self.Yield = Yield
        self.Await = Await

    @property
    def CoverCallExpressionAndAsyncArrowHead(self):
        return self.children[0]

    @property
    def CallMemberExpression(self):
        if not hasattr(self, "_call_member_expression"):
            self._call_member_expression = self.CoverCallExpressionAndAsyncArrowHead.covering(
                parse_CallMemberExpression, self.strict, self.Yield, self.Await
            )
        return self._call_member_expression

    def CoveredCallExpression(self):
        # 12.3.1.1 Static Semantics: CoveredCallExpression
        # CallExpression : CoverCallExpressionAndAsyncArrowHead
        #   1. Return the CallMemberExpression that is covered by CoverCallExpressionAndAsyncArrowHead.
        return self.CallMemberExpression

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # CallExpression : CoverCallExpressionAndAsyncArrowHead
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.3.4.1 Runtime Semantics: Evaluation
        # CallExpression : CoverCallExpressionAndAsyncArrowHead
        #   1. Let expr be CoveredCallExpression of CoverCallExpressionAndAsyncArrowHead.
        #   2. Let memberExpr be the MemberExpression of expr.
        #   3. Let arguments be the Arguments of expr.
        #   4. Let ref be the result of evaluating memberExpr.
        #   5. Let func be ? GetValue(ref).
        #   6. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is "eval",
        #      then
        #      a. If SameValue(func, %eval%) is true, then
        #         i. Let argList be ? ArgumentListEvaluation of arguments.
        #         ii. If argList has no elements, return undefined.
        #         iii. Let evalText be the first element of argList.
        #         iv. If the source code matching this CallExpression is strict mode code, let strictCaller be true.
        #             Otherwise let strictCaller be false.
        #         v. Let evalRealm be the current Realm Record.
        #         vi. Perform ? HostEnsureCanCompileStrings(evalRealm, evalRealm).
        #         vii. Return ? PerformEval(evalText, evalRealm, strictCaller, true).
        #   7. Let thisCall be this CallExpression.
        #   8. Let tailCall be IsInTailPosition(thisCall).
        #   9. Return ? EvaluateCall(func, ref, arguments, tailCall).
        # A CallExpression evaluation that executes step 6.a.vii is a direct eval.
        expr = self.CoveredCallExpression()
        memberExpr = expr.MemberExpression
        arguments = expr.Arguments
        ref = memberExpr.evaluate()
        func = GetValue(ref)
        if isinstance(ref, Reference) and not IsPropertyReference(ref) and GetReferencedName(ref) == "eval":
            if SameValue(func, surrounding_agent.running_ec.realm.intrinsics["%eval%"]):
                argList = arguments.ArgumentListEvaluation()
                if len(argList) == 0:
                    return None
                evalText = argList[0]
                strictCaller = self.strict
                evalRealm = surrounding_agent.running_ec.realm
                HostEnsureCanCompileStrings(evalRealm, evalRealm)
                return PerformEval(evalText, evalRealm, strictCaller, True)
        # thisCall = self
        tailCall = False  # IsInTailPosition(thisCall)
        return EvaluateCall(func, ref, arguments, tailCall)


class P2_CallExpression_SuperCall(P2_CallExpression):
    @property
    def SuperCall(self):
        return self.children[0]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # CallExpression : SuperCall
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_CallExpression_CallExpression_Arguments(P2_CallExpression):
    @property
    def CallExpression(self):
        return self.children[0]

    @property
    def Arguments(self):
        return self.children[1]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # CallExpression : CallExpression Arguments
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.3.4.1 Runtime Semantics: Evaluation
        #           CallExpression : CallExpression Arguments
        # 1. Let ref be the result of evaluating CallExpression.
        # 2. Let func be ? GetValue(ref).
        # 3. Let thisCall be this CallExpression.
        # 4. Let tailCall be IsInTailPosition(thisCall).
        # 5. Return ? EvaluateCall(func, ref, Arguments, tailCall).
        ref = self.CallExpression.evaluate()
        func = GetValue(ref)
        thisCall = self.CallExpression
        tailCall = IsInTailPosition(thisCall)
        return EvaluateCall(func, ref, self.Arguments, tailCall)


# 12.3.4.2 Runtime Semantics: EvaluateCall ( func, ref, arguments, tailPosition )
def EvaluateCall(func, ref, arguments, tailPosition):
    # The abstract operation EvaluateCall takes as arguments a value func, a value ref, a Parse Node arguments, and a
    # Boolean argument tailPosition. It performs the following steps:
    #
    # 1. If Type(ref) is Reference, then
    #    a. If IsPropertyReference(ref) is true, then
    #       i. Let thisValue be GetThisValue(ref).
    #    b. Else the base of ref is an Environment Record,
    #       i. Let refEnv be GetBase(ref).
    #       ii. Let thisValue be refEnv.WithBaseObject().
    # 2. Else Type(ref) is not Reference,
    #    a. Let thisValue be undefined.
    # 3. Let argList be ArgumentListEvaluation of arguments.
    # 4. ReturnIfAbrupt(argList).
    # 5. If Type(func) is not Object, throw a TypeError exception.
    # 6. If IsCallable(func) is false, throw a TypeError exception.
    # 7. If tailPosition is true, perform PrepareForTailCall().
    # 8. Let result be Call(func, thisValue, argList).
    # 9. Assert: If tailPosition is true, the above call will not return here, but instead evaluation will continue as
    #    if the following return has already occurred.
    # 10. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.
    # 11. Return result.
    if isinstance(ref, Reference):
        if IsPropertyReference(ref):
            thisValue = GetThisValue(ref)
        else:
            refEnv = GetBase(ref)
            thisValue = refEnv.WithBaseObject()
    else:
        thisValue = None
    argList = arguments.ArgumentListEvaluation()
    if not isObject(func):
        raise ESTypeError(f"Not a function: {ref.name}")
    if not IsCallable(func):
        raise ESTypeError(f"Not a function: {ref.name}")
    if tailPosition:
        PrepareForTailCall()
    result = Call(func, thisValue, argList)
    # assert not tailPosition
    # assert (isinstance(result, Completion) and (result.ctype != CompletionType.NORMAL or isEcmaValue(result.value))) or isEcmaValue(result)
    return result


class P2_CallExpression_CallExpression_LBRACKET_Expression_RBRACKET(P2_CallExpression):
    @property
    def CallExpression(self):
        return self.children[0]

    @property
    def Expression(self):
        return self.children[2]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # CallExpression : CallExpression [ Expression ]
    #   1. Return simple.
    AssignmentTargetType = SIMPLE

    def evaluate(self):
        # 12.3.2.1 Runtime Semantics: Evaluation
        # Is evaluated in exactly the same manner as MemberExpression:MemberExpression[Expression] except that the
        # contained CallExpression is evaluated in step 1.
        return MemberBracketCore(self, self.CallExpression.evaluate())


class P2_CallExpression_CallExpression_PERIOD_IdentifierName(P2_CallExpression):
    @property
    def CallExpression(self):
        return self.children[0]

    @property
    def IdentifierName(self):
        return self.children[2]

    def Contains(self, symbol):
        # 12.3.1.2 Static Semantics: Contains
        #   With parameter symbol.
        # CallExpression : CallExpression . IdentifierName
        #   1. If CallExpression Contains symbol is true, return true.
        #   2. If symbol is a ReservedWord, return false.
        #   3. If symbol is an Identifier and StringValue of symbol is the same value as the StringValue of
        #      IdentifierName, return true.
        #   4. Return false.
        return self.CallExpression.Contains(symbol) or (
            symbol not in self.context.lexer_interface.reserved_words and symbol == self.IdentifierName.value
        )

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # CallExpression : CallExpression . IdentifierName
    #   1. Return simple.
    AssignmentTargetType = SIMPLE

    def evaluate(self):
        # 12.3.2.1 Runtime Semantics: Evaluation
        # Is evaluated in exactly the same manner as MemberExpression:MemberExpression.IdentifierName except that the
        # contained CallExpression is evaluated in step 1.
        return MemberDotEvaluation(self, self.CallExpression.evaluate())


class P2_CallExpression_CallExpression_TemplateLiteral(P2_CallExpression):
    @property
    def CallExpression(self):
        return self.children[0]

    @property
    def TemplateLiteral(self):
        return self.children[1]

    # 12.3.1.6 Static Semantics: AssignmentTargetType
    # CallExpression : CallExpression TemplateLiteral
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.3.7.1 Runtime Semantics: Evaluation
        # CallExpression : CallExpression TemplateLiteral
        #   1. Let tagRef be the result of evaluating CallExpression.
        #   2. Let tagFunc be ? GetValue(tagRef).
        #   3. Let thisCall be this CallExpression.
        #   4. Let tailCall be IsInTailPosition(thisCall).
        #   5. Return ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall).
        tagRef = self.CallExpression.evaluate()
        tagFunc = GetValue(tagRef)
        tailCall = IsInTailPosition(self)
        return EvaluateCall(tagFunc, tagRef, self.TemplateLiteral, tailCall)


def parse_CallExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   CallExpression[Yield, Await] :
    #       CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]
    #       SuperCall[?Yield, ?Await]
    #       CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    #       CallExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]
    #       CallExpression[?Yield, ?Await] . IdentifierName
    #       CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
    def parse(pos, previous=None):
        if previous is None:
            cceaaah = parse_CoverCallExpressionAndAsyncArrowHead(ctx, lexer, pos, strict, Yield, Await)
            if cceaaah:
                return lambda: parse(
                    cceaaah.after,
                    P2_CallExpression_CoverCallExpressionAndAsyncArrowHead(ctx, strict, [cceaaah], Yield, Await),
                )
            sc = parse_SuperCall(ctx, lexer, pos, strict, Yield, Await)
            if sc:
                return lambda: parse(sc.after, P2_CallExpression_SuperCall(ctx, strict, [sc]))
        else:
            args = parse_Arguments(ctx, lexer, pos, strict, Yield, Await)
            if args:
                return lambda: parse(
                    args.after, P2_CallExpression_CallExpression_Arguments(ctx, strict, [previous, args])
                )
            lb = lexer.token_if(pos, "[")
            if lb:
                exp = parse_Expression(ctx, lexer, lb.span.after, strict, True, Yield, Await)
                if exp:
                    rb = lexer.token_if(exp.after, "]")
                    if rb:
                        return lambda: parse(
                            rb.span.after,
                            P2_CallExpression_CallExpression_LBRACKET_Expression_RBRACKET(
                                ctx, strict, [previous, lb, exp, rb]
                            ),
                        )
            dot = lexer.token_if(pos, ".")
            if dot:
                ident = lexer.token_if(dot.span.after, "IDENTIFIER")
                if ident:
                    return lambda: parse(
                        ident.span.after,
                        P2_CallExpression_CallExpression_PERIOD_IdentifierName(ctx, strict, [previous, dot, ident]),
                    )
            tl = parse_TemplateLiteral(ctx, lexer, pos, strict, Yield, Await, True)
            if tl:
                return lambda: parse(
                    tl.after, P2_CallExpression_CallExpression_TemplateLiteral(ctx, strict, [previous, tl])
                )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓢𝓾𝓹𝓮𝓻𝓒𝓪𝓵𝓵 =======--------
# Syntax
#   SuperCall :
#       super Arguments


class P2_SuperCall(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "SuperCall", strict, children)


class P2_SuperCall_SUPER_Arguments(P2_SuperCall):
    @property
    def Arguments(self):
        return self.children[1]

    def evaluate(self):
        # 12.3.5.1 Runtime Semantics: Evaluation
        # SuperCall : super Arguments
        #   1. Let newTarget be GetNewTarget().
        #   2. Assert: Type(newTarget) is Object.
        #   3. Let func be ? GetSuperConstructor().
        #   4. Let argList be ArgumentListEvaluation of Arguments.
        #   5. ReturnIfAbrupt(argList).
        #   6. Let result be ? Construct(func, argList, newTarget).
        #   7. Let thisER be GetThisEnvironment().
        #   8. Return ? thisER.BindThisValue(result).
        newTarget = GetNewTarget()
        assert isObject(newTarget)
        func = GetSuperConstructor()
        argList = self.Arguments.ArgumentListEvaluation()
        result = Construct(func, argList, newTarget)
        return GetThisEnvironment().BindThisValue(result)


def parse_SuperCall(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   SuperCall[Yield, Await] :
    #       super Arguments[?Yield, ?Await]
    super = lexer.id_if(pos, "super")
    if super:
        args = parse_Arguments(ctx, lexer, super.span.after, strict, Yield, Await)
        if args:
            return P2_SuperCall_SUPER_Arguments(ctx, strict, [super, args])
    return None


# 12.3.5.2 Runtime Semantics: GetSuperConstructor ( )
def GetSuperConstructor():
    # The abstract operation GetSuperConstructor performs the following steps:
    #
    #   1. Let envRec be GetThisEnvironment().
    #   2. Assert: envRec is a function Environment Record.
    #   3. Let activeFunction be envRec.[[FunctionObject]].
    #   4. Assert: activeFunction is an ECMAScript function object.
    #   5. Let superConstructor be ! activeFunction.[[GetPrototypeOf]]().
    #   6. If IsConstructor(superConstructor) is false, throw a TypeError exception.
    #   7. Return superConstructor.
    envRec = GetThisEnvironment()
    assert isinstance(envRec, FunctionEnvironmentRecord)
    activeFunction = envRec.function_object
    assert isinstance(activeFunction, JSFunction)
    superConstructor = activeFunction.GetPrototypeOf()
    if not IsConstructor(superConstructor):
        raise ESTypeError("super not a constructor")
    return superConstructor


# 12.3.5.3 Runtime Semantics: MakeSuperPropertyReference ( actualThis, propertyKey, strict )
def MakeSuperPropertyReference(actualThis, propertyKey, strict):
    # The abstract operation MakeSuperPropertyReference with arguments actualThis, propertyKey, and strict performs the
    # following steps:
    #
    #   1. Let env be GetThisEnvironment().
    #   2. Assert: env.HasSuperBinding() is true.
    #   3. Let baseValue be ? env.GetSuperBase().
    #   4. Let bv be ? RequireObjectCoercible(baseValue).
    #   5. Return a value of type Reference that is a Super Reference whose base value component is bv, whose
    #      referenced name component is propertyKey, whose thisValue component is actualThis, and whose strict
    #      reference flag is strict.
    env = GetThisEnvironment()
    assert env.HasSuperBinding()
    baseValue = env.GetSuperBase()
    bv = RequireObjectCoercible(baseValue)
    return SuperReference(bv, propertyKey, strict, actualThis)


# --------======= 𝓐𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼 =======--------
# Syntax
#   Arguments :
#       ( )
#       ( ArgumentList )
#       ( ArgumentList , )

# 12.3.6 Argument Lists
# NOTE
# The evaluation of an argument list produces a List of values.


class P2_Arguments(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Arguments", strict, children)


class P2_Arguments_LPAREN_RPAREN(P2_Arguments):
    def ArgumentListEvaluation(self):
        # 12.3.6.1 Runtime Semantics: ArgumentListEvaluation
        #           Arguments : ( )
        # 1. Return a new empty List.
        return []


class P2_Arguments_LPAREN_ArgumentList_RPAREN(P2_Arguments):
    @property
    def ArgumentList(self):
        return self.children[1]


class P2_Arguments_LPAREN_ArgumentList_COMMA_RPAREN(P2_Arguments):
    @property
    def ArgumentList(self):
        return self.children[1]


def parse_Arguments(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   Arguments[Yield, Await] :
    #       ( )
    #       ( ArgumentList[?Yield, ?Await] )
    #       ( ArgumentList[?Yield, ?Await] , )
    #
    lp = lexer.token_if(pos, "(")
    if lp:
        rp1 = lexer.token_if(lp.span.after, ")")
        if rp1:
            return P2_Arguments_LPAREN_RPAREN(ctx, strict, [lp, rp1])
        al = parse_ArgumentList(ctx, lexer, lp.span.after, strict, Yield, Await)
        if al:
            rp2 = lexer.token_if(al.after, ")")
            if rp2:
                return P2_Arguments_LPAREN_ArgumentList_RPAREN(ctx, strict, [lp, al, rp2])
            comma = lexer.token_if(al.after, ",")
            if comma:
                rp3 = lexer.token_if(comma.span.after, ")")
                if rp3:
                    return P2_Arguments_LPAREN_ArgumentList_COMMA_RPAREN(ctx, strict, [lp, al, comma, rp3])
    return None


# --------======= 𝓐𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   ArgumentList:
#       AssignmentExpression
#       ... AssignmentExpression
#       ArgumentList , AssignmentExpression
#       ArgumentList , ... AssignmentExpression


class P2_ArgumentList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ArgumentList", strict, children)


class P2_ArgumentList_AssignmentExpression(P2_ArgumentList):
    @property
    def AssignmentExpression(self):
        return self.children[0]

    def ArgumentListEvaluation(self):
        # 12.3.6.1 Runtime Semantics: ArgumentListEvaluation
        # ArgumentList : AssignmentExpression
        #   1. Let ref be the result of evaluating AssignmentExpression.
        #   2. Let arg be ? GetValue(ref).
        #   3. Return a List whose sole item is arg.
        return [GetValue(self.AssignmentExpression.evaluate())]


class P2_ArgumentList_DOTDOTDOT_AssignmentExpression(P2_ArgumentList):
    @property
    def AssignmentExpression(self):
        return self.children[1]

    def ArgumentListEvaluation(self):
        # 12.3.6.1 Runtime Semantics: ArgumentListEvaluation
        # ArgumentList : ... AssignmentExpression
        #   1. Let list be a new empty List.
        #   2. Let spreadRef be the result of evaluating AssignmentExpression.
        #   3. Let spreadObj be ? GetValue(spreadRef).
        #   4. Let iteratorRecord be ? GetIterator(spreadObj).
        #   5. Repeat,
        #      a. Let next be ? IteratorStep(iteratorRecord).
        #      b. If next is false, return list.
        #      c. Let nextArg be ? IteratorValue(next).
        #      d. Append nextArg as the last element of list.
        lst = []
        iteratorRecord = GetIterator(GetValue(self.AssignmentExpression.evaluate()))
        while 1:
            nxt = IteratorStep(iteratorRecord)
            if not nxt:
                return lst
            lst.append(IteratorValue(nxt))


class P2_ArgumentList_ArgumentList_COMMA_AssignmentExpression(P2_ArgumentList):
    @property
    def ArgumentList(self):
        return self.children[0]

    @property
    def AssignmentExpression(self):
        return self.children[2]

    def ArgumentListEvaluation(self):
        # 12.3.6.1 Runtime Semantics: ArgumentListEvaluation
        # ArgumentList : ArgumentList , AssignmentExpression
        #   1. Let precedingArgs be ArgumentListEvaluation of ArgumentList.
        #   2. ReturnIfAbrupt(precedingArgs).
        #   3. Let ref be the result of evaluating AssignmentExpression.
        #   4. Let arg be ? GetValue(ref).
        #   5. Append arg to the end of precedingArgs.
        #   6. Return precedingArgs.
        precedingArgs = self.ArgumentList.ArgumentListEvaluation()
        precedingArgs.append(GetValue(self.AssignmentExpression.evaluate()))
        return precedingArgs


class P2_ArgumentList_ArgumentList_COMMA_DOTDOTDOT_AssignmentExpression(P2_ArgumentList):
    @property
    def ArgumentList(self):
        return self.children[0]

    @property
    def AssignmentExpression(self):
        return self.children[3]

    def ArgumentListEvaluation(self):
        # 12.3.6.1 Runtime Semantics: ArgumentListEvaluation
        # ArgumentList : ArgumentList , ... AssignmentExpression
        # 1. Let precedingArgs be ArgumentListEvaluation of ArgumentList.
        # 2. ReturnIfAbrupt(precedingArgs).
        # 3. Let spreadRef be the result of evaluating AssignmentExpression.
        # 4. Let iteratorRecord be ? GetIterator(? GetValue(spreadRef)).
        # 5. Repeat,
        #    a. Let next be ? IteratorStep(iteratorRecord).
        #    b. If next is false, return precedingArgs.
        #    c. Let nextArg be ? IteratorValue(next).
        #    d. Append nextArg as the last element of precedingArgs.
        precedingArgs = self.ArgumentList.ArgumentListEvaluation()
        iteratorRecord = GetIterator(GetValue(self.AssignmentExpression.evaluate()))
        while 1:
            nxt = IteratorStep(iteratorRecord)
            if not nxt:
                return precedingArgs
            precedingArgs.append(IteratorValue(nxt))


def parse_ArgumentList(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   ArgumentList[Yield, Await]:
    #       AssignmentExpression[+In, ?Yield, ?Await]
    #       ... AssignmentExpression[+In, ?Yield, ?Await]
    #       ArgumentList[?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await]
    #       ArgumentList[?Yield, ?Await] , ... AssignmentExpression[+In, ?Yield, ?Await]
    def parse(pos, previous=None):
        if previous is None:
            ae1 = parse_AssignmentExpression(ctx, lexer, pos, strict, True, Yield, Await)
            if ae1:
                return lambda: parse(ae1.after, P2_ArgumentList_AssignmentExpression(ctx, strict, [ae1]))
            dots1 = lexer.token_if(pos, "...")
            if dots1:
                ae2 = parse_AssignmentExpression(ctx, lexer, dots1.span.after, strict, True, Yield, Await)
                if ae2:
                    return lambda: parse(
                        ae2.after, P2_ArgumentList_DOTDOTDOT_AssignmentExpression(ctx, strict, [dots1, ae2])
                    )
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                ae3 = parse_AssignmentExpression(ctx, lexer, comma.span.after, strict, True, Yield, Await)
                if ae3:
                    return lambda: parse(
                        ae3.after,
                        P2_ArgumentList_ArgumentList_COMMA_AssignmentExpression(ctx, strict, [previous, comma, ae3]),
                    )
                dots2 = lexer.token_if(comma.span.after, "...")
                if dots2:
                    ae4 = parse_AssignmentExpression(ctx, lexer, dots2.span.after, strict, True, Yield, Await)
                    if ae4:
                        return lambda: parse(
                            ae4.after,
                            P2_ArgumentList_ArgumentList_COMMA_DOTDOTDOT_AssignmentExpression(
                                ctx, strict, [previous, comma, dots2, ae4]
                            ),
                        )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓛𝓮𝓯𝓽𝓗𝓪𝓷𝓭𝓢𝓲𝓭𝓮𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   LeftHandSideExpression :
#       NewExpression
#       CallExpression


class P2_LeftHandSideExpression(ParseNode2):
    def __init__(self, ctx, strict, children, Yield, Await):
        super().__init__(ctx, "LeftHandSideExpression", strict, children)
        # Sometimes needed for covering check
        self.Yield = Yield
        self.Await = Await

    @property
    def AssignmentPattern(self):
        return self.covering("AssignmentPattern", parse_AssignmentPattern)

    def covering(self, symbol, parse_fcn):
        membername = f"_{symbol}"
        if not hasattr(self, membername):
            setattr(self, membername, super().covering(parse_fcn, self.strict, self.Yield, self.Await))
        return getattr(self, membername)


class P2_LeftHandSideExpression_NewExpression(P2_LeftHandSideExpression):
    @property
    def NewExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.NewExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.NewExpression.HasUseStrict


class P2_LeftHandSideExpression_CallExpression(P2_LeftHandSideExpression):
    @property
    def CallExpression(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.3.1.3 Static Semantics: IsFunctionDefinition
        # LeftHandSideExpression : CallExpression
        #   1. Return false.
        return False

    def IsDestructuring(self):
        # 12.3.1.4 Static Semantics: IsDestructuring
        # LeftHandSideExpression : CallExpression
        #   1. Return false.
        return False

    def IsIdentifierRef(self):
        # 12.3.1.5 Static Semantics: IsIdentifierRef
        # LeftHandSideExpression : CallExpression
        #   1. Return false.
        return False


def parse_LeftHandSideExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   LeftHandSideExpression[Yield, Await] :
    #       NewExpression[?Yield, ?Await]
    #       CallExpression[?Yield, ?Await]
    #
    ce = parse_CallExpression(ctx, lexer, pos, strict, Yield, Await)
    if ce:
        return P2_LeftHandSideExpression_CallExpression(ctx, strict, [ce], Yield, Await)
    ne = parse_NewExpression(ctx, lexer, pos, strict, Yield, Await)
    if ne:
        return P2_LeftHandSideExpression_NewExpression(ctx, strict, [ne], Yield, Await)
    return None


# --------======= 𝓒𝓪𝓵𝓵𝓜𝓮𝓶𝓫𝓮𝓻𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   CallMemberExpression :
#       MemberExpression Arguments


class P2_CallMemberExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CallMemberExpression", strict, children)


class P2_CallMemberExpression_MemberExpression_Arguments(P2_CallMemberExpression):
    @property
    def MemberExpression(self):
        return self.children[0]

    @property
    def Arguments(self):
        return self.children[1]


def parse_CallMemberExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.3 Left-Hand-Side Expressions
    # Syntax
    #   CallMemberExpression[Yield, Await] :
    #       MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    #
    me = parse_MemberExpression(ctx, lexer, pos, strict, Yield, Await)
    if me:
        args = parse_Arguments(ctx, lexer, me.after, strict, Yield, Await)
        if args:
            return P2_CallMemberExpression_MemberExpression_Arguments(ctx, strict, [me, args])
    return None


#######################################################################################################################
#
#  d888    .d8888b.          d8888      888     888               888          888
# d8888   d88P  Y88b        d8P888      888     888               888          888
#   888          888       d8P 888      888     888               888          888
#   888        .d88P      d8P  888      888     888 88888b.   .d88888  8888b.  888888  .d88b.
#   888    .od888P"      d88   888      888     888 888 "88b d88" 888     "88b 888    d8P  Y8b
#   888   d88P"          8888888888     888     888 888  888 888  888 .d888888 888    88888888
#   888   888"       d8b       888      Y88b. .d88P 888 d88P Y88b 888 888  888 Y88b.  Y8b.
# 8888888 888888888  Y8P       888       "Y88888P"  88888P"   "Y88888 "Y888888  "Y888  "Y8888
#                                                   888
#                                                   888
#                                                   888
#
# 8888888888                                                      d8b
# 888                                                             Y8P
# 888
# 8888888    888  888 88888b.  888d888  .d88b.  .d8888b  .d8888b  888  .d88b.  88888b.  .d8888b
# 888        `Y8bd8P' 888 "88b 888P"   d8P  Y8b 88K      88K      888 d88""88b 888 "88b 88K
# 888          X88K   888  888 888     88888888 "Y8888b. "Y8888b. 888 888  888 888  888 "Y8888b.
# 888        .d8""8b. 888 d88P 888     Y8b.          X88      X88 888 Y88..88P 888  888      X88
# 8888888888 888  888 88888P"  888      "Y8888   88888P'  88888P' 888  "Y88P"  888  888  88888P'
#                     888
#                     888
#                     888
#
#######################################################################################################################
# 12.4 Update Expressions
# 12.4.1 SS: Early Errors
# 12.4.2 SS: IsFunctionDefinition
# 12.4.3 SS: AssignmentTargetType
# 12.4.4 Postfix Increment Operator
# 12.4.4.1 RS: Evaluation
# 12.4.5 Postfix Decrement Operator
# 12.4.5.1 RS: Evaluation
# 12.4.6 Prefix Increment Operator
# 12.4.6.1 RS: Evaluation
# 12.4.7 Prefix Decrement Operator
# 12.4.7.1 RS: Evaluation
#######################################################################################################################


#############################################################################
# `·._.·●.._.·●.._.·●..... 12.4 Update Expressions .....●·._..●·._..●·._.·´ #
#############################################################################

# --------======= 𝓤𝓹𝓭𝓪𝓽𝓮𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   UpdateExpression :
#       LeftHandSideExpression
#       LeftHandSideExpression [no LineTerminator here] ++
#       LeftHandSideExpression [no LineTerminator here] --
#       ++ UnaryExpression
#       -- UnaryExpression


class P2_UpdateExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "UpdateExpression", strict, children)


class P2_UpdateExpression_LeftHandSideExpression(P2_UpdateExpression):
    @property
    def LeftHandSideExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.LeftHandSideExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.LeftHandSideExpression.HasUseStrict


class P2_UpdateExpression_NotFallThru(P2_UpdateExpression):
    def IsFunctionDefinition(self):
        # 12.4.2 Static Semantics: IsFunctionDefinition
        # UpdateExpression : LeftHandSideExpression ++
        # UpdateExpression : LeftHandSideExpression --
        # UpdateExpression : ++ UnaryExpression
        # UpdateExpression : -- UnaryExpression
        #   1. Return false.
        return False

    # 12.4.3 Static Semantics: AssignmentTargetType
    # UpdateExpression : LeftHandSideExpression ++
    # UpdateExpression : LeftHandSideExpression --
    # UpdateExpression : ++ UnaryExpression
    # UpdateExpression : -- UnaryExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_UpdateExpression_Post(P2_UpdateExpression_NotFallThru):
    @property
    def LeftHandSideExpression(self):
        raise NotImplementedError("Base classes should not be directly instantiated")

    def EarlyErrors(self):
        # 12.4.1 Static Semantics: Early Errors
        # UpdateExpression : LeftHandSideExpression ++
        # UpdateExpression : LeftHandSideExpression --
        #   * It is an early Syntax Error if AssignmentTargetType of LeftHandSideExpression is not simple.
        return list(
            filter(
                None,
                [
                    self.LeftHandSideExpression.AssignmentTargetType != SIMPLE
                    and self.CreateSyntaxError("Invalid Reference for postfix update")
                ],
            )
        )


class P2_UpdateExpression_Pre(P2_UpdateExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        raise NotImplementedError("Base classes should not be directly instantiated")

    def EarlyErrors(self):
        # 12.4.1 Static Semantics: Early Errors
        # UpdateExpression : ++ UnaryExpression
        # UpdateExpression : -- UnaryExpression
        #   * It is an early Syntax Error if AssignmentTargetType of UnaryExpression is not simple.
        return list(
            filter(
                None,
                [
                    self.UnaryExpression.AssignmentTargetType != SIMPLE
                    and self.CreateSyntaxError("Invalid Reference for prefix update")
                ],
            )
        )


class P2_UpdateExpression_LeftHandSideExpression_PLUSPLUS(P2_UpdateExpression_Post):
    @property
    def LeftHandSideExpression(self):
        return self.children[0]

    # 12.4.4 Postfix Increment Operator
    def evaluate(self):
        # 12.4.4.1 Runtime Semantics: Evaluation
        # UpdateExpression : LeftHandSideExpression ++
        #   1. Let lhs be the result of evaluating LeftHandSideExpression.
        #   2. Let oldValue be ? ToNumber(? GetValue(lhs)).
        #   3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).
        #   4. Perform ? PutValue(lhs, newValue).
        #   5. Return oldValue.
        lhs = self.LeftHandSideExpression.evaluate()
        oldValue = ToNumber(GetValue(lhs))
        PutValue(lhs, oldValue + 1)
        return oldValue


class P2_UpdateExpression_LeftHandSideExpression_MINUSMINUS(P2_UpdateExpression_Post):
    @property
    def LeftHandSideExpression(self):
        return self.children[0]

    # 12.4.5 Postfix Decrement Operator
    def evaluate(self):
        # 12.4.5.1 Runtime Semantics: Evaluation
        #           UpdateExpression : LeftHandSideExpression --
        # 1. Let lhs be the result of evaluating LeftHandSideExpression.
        # 2. Let oldValue be ? ToNumber(? GetValue(lhs)).
        # 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).
        # 4. Perform ? PutValue(lhs, newValue).
        # 5. Return oldValue.
        lhs = self.LeftHandSideExpression.evaluate()
        oldValue = GetValue(lhs)
        oldValue = ToNumber(oldValue)
        PutValue(lhs, oldValue - 1)
        return oldValue


class P2_UpdateExpression_PLUSPLUS_UnaryExpression(P2_UpdateExpression_Pre):
    @property
    def UnaryExpression(self):
        return self.children[1]

    # 12.4.6 Prefix Increment Operator
    def evaluate(self):
        # 12.4.6.1 Runtime Semantics: Evaluation
        #           UpdateExpression : ++ UnaryExpression
        # 1. Let expr be the result of evaluating UnaryExpression.
        # 2. Let oldValue be ? ToNumber(? GetValue(expr)).
        # 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).
        # 4. Perform ? PutValue(expr, newValue).
        # 5. Return newValue.
        expr = self.UnaryExpression.evaluate()
        oldValue = GetValue(expr)
        oldValue = ToNumber(oldValue)
        newValue = oldValue + 1
        PutValue(expr, newValue)
        return newValue


class P2_UpdateExpression_MINUSMINUS_UnaryExpression(P2_UpdateExpression_Pre):
    @property
    def UnaryExpression(self):
        return self.children[1]

    # 12.4.7 Prefix Decrement Operator
    def evaluate(self):
        # 12.4.7.1 Runtime Semantics: Evaluation
        #           UpdateExpression : -- UnaryExpression
        # 1. Let expr be the result of evaluating UnaryExpression.
        # 2. Let oldValue be ? ToNumber(? GetValue(expr)).
        # 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).
        # 4. Perform ? PutValue(expr, newValue).
        # 5. Return newValue.
        expr = self.UnaryExpression.evaluate()
        oldValue = GetValue(expr)
        oldValue = ToNumber(oldValue)
        newValue = oldValue - 1
        PutValue(expr, newValue)
        return newValue


def parse_UpdateExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.4 Update Expressions
    # Syntax
    #   UpdateExpression[Yield, Await]:
    #       LeftHandSideExpression[?Yield, ?Await]
    #       LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++
    #       LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] --
    #       ++ UnaryExpression[?Yield, ?Await]
    #       -- UnaryExpression[?Yield, ?Await]
    #
    lhs = parse_LeftHandSideExpression(ctx, lexer, pos, strict, Yield, Await)
    if lhs:
        plusplus = lexer.token_if(lhs.after, "++", prior_newline_allowed=False)
        if plusplus:
            return P2_UpdateExpression_LeftHandSideExpression_PLUSPLUS(ctx, strict, [lhs, plusplus])
        minusminus = lexer.token_if(lhs.after, "--", prior_newline_allowed=False)
        if minusminus:
            return P2_UpdateExpression_LeftHandSideExpression_MINUSMINUS(ctx, strict, [lhs, minusminus])
        return P2_UpdateExpression_LeftHandSideExpression(ctx, strict, [lhs])
    plusplus = lexer.token_if(pos, "++")
    if plusplus:
        ue = parse_UnaryExpression(ctx, lexer, plusplus.span.after, strict, Yield, Await)
        if ue:
            return P2_UpdateExpression_PLUSPLUS_UnaryExpression(ctx, strict, [plusplus, ue])
    else:
        minusminus = lexer.token_if(pos, "--")
        if minusminus:
            ue = parse_UnaryExpression(ctx, lexer, minusminus.span.after, strict, Yield, Await)
            if ue:
                return P2_UpdateExpression_MINUSMINUS_UnaryExpression(ctx, strict, [minusminus, ue])
    return None


#######################################################################################################################
#
#  d888    .d8888b.      888888888      888     888
# d8888   d88P  Y88b     888            888     888
#   888          888     888            888     888
#   888        .d88P     8888888b.      888     888 88888b.   8888b.  888d888 888  888
#   888    .od888P"           "Y88b     888     888 888 "88b     "88b 888P"   888  888
#   888   d88P"                 888     888     888 888  888 .d888888 888     888  888
#   888   888"       d8b Y88b  d88P     Y88b. .d88P 888  888 888  888 888     Y88b 888
# 8888888 888888888  Y8P  "Y8888P"       "Y88888P"  888  888 "Y888888 888      "Y88888
#                                                                                  888
#                                                                             Y8b d88P
#                                                                              "Y88P"
#  .d88888b.                                     888
# d88P" "Y88b                                    888
# 888     888                                    888
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
# 888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#             888
#             888
#             888
#
#######################################################################################################################
# 12.5 Unary Operators
# 12.5.1 SS: IsFunctionDefinition
# 12.5.2 SS: AssignmentTargetType
# 12.5.3 The delete Operator
# 12.5.3.1 SS: Early Errors
# 12.5.3.2 RS: Evaluation
# 12.5.4 The void Operator
# 12.5.4.1 RS: Evaluation
# 12.5.5 The typeof Operator
# 12.5.5.1 RS: Evaluation
# 12.5.6 Unary + Operator
# 12.5.6.1 RS: Evaluation
# 12.5.7 Unary - Operator
# 12.5.7.1 RS: Evaluation
# 12.5.8 Bitwise NOT Operator ( ~ )
# 12.5.8.1 RS: Evaluation
# 12.5.9 Logical NOT Operator ( ! )
# 12.5.9.1 RS: Evaluation
#######################################################################################################################

##########################################################################
# `·._.·●.._.·●.._.·●..... 12.5 Unary Operators .....●·._..●·._..●·._.·´ #
##########################################################################

# --------======= 𝓤𝓷𝓪𝓻𝔂𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   UnaryExpression :
#       UpdateExpression
#       delete UnaryExpression
#       void UnaryExpression
#       typeof UnaryExpression
#       + UnaryExpression
#       - UnaryExpression
#       ~ UnaryExpression
#       ! UnaryExpression
#       AwaitExpression


class P2_UnaryExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "UnaryExpression", strict, children)


class P2_UnaryExpression_UpdateExpression(P2_UnaryExpression):
    @property
    def UpdateExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.UpdateExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.UpdateExpression.HasUseStrict


class P2_UnaryExpression_NotFallThru(P2_UnaryExpression):
    def IsFunctionDefinition(self):
        # 12.5.1 Static Semantics: IsFunctionDefinition
        # UnaryExpression : delete UnaryExpression
        # UnaryExpression : void UnaryExpression
        # UnaryExpression : typeof UnaryExpression
        # UnaryExpression : + UnaryExpression
        # UnaryExpression : - UnaryExpression
        # UnaryExpression : ~ UnaryExpression
        # UnaryExpression : ! UnaryExpression
        # UnaryExpression : AwaitExpression
        #   1. Return false.
        return False

    # 12.5.2 Static Semantics: AssignmentTargetType
    # UnaryExpression : delete UnaryExpression
    # UnaryExpression : void UnaryExpression
    # UnaryExpression : typeof UnaryExpression
    # UnaryExpression : + UnaryExpression
    # UnaryExpression : - UnaryExpression
    # UnaryExpression : ~ UnaryExpression
    # UnaryExpression : ! UnaryExpression
    # UnaryExpression : AwaitExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_UnaryExpression_DELETE_UnaryExpression(P2_UnaryExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        return self.children[1]

    def EarlyErrors(self):
        # 12.5.3.1 Static Semantics: Early Errors
        # UnaryExpression : delete UnaryExpression
        #   * It is a Syntax Error if the UnaryExpression is contained in strict mode code and the derived
        #     UnaryExpression is PrimaryExpression : IdentifierReference .
        #   * It is a Syntax Error if the derived UnaryExpression is
        #     PrimaryExpression:CoverParenthesizedExpressionAndArrowParameterList and
        #     CoverParenthesizedExpressionAndArrowParameterList ultimately derives a phrase that, if used in place of
        #     UnaryExpression, would produce a Syntax Error according to these rules. This rule is recursively applied.
        # NOTE
        # The last rule means that expressions such as delete (((foo))) produce early errors because of recursive
        # application of the first rule.
        errs = []
        if self.strict:
            # --> I'm pretty sure the only way this would happen is exactly the example they give.
            #
            UnaryExpression = self.children[1]
            p = UnaryExpression
            while 1:
                if len(p.children) != 1 or not isinstance(p.children[0], ParseNode2):
                    break
                if p.name == "PrimaryExpression":
                    if p.children[0].name == "IdentifierReference":
                        errs.append(CreateSyntaxError("Delete of an unqualified identifier in strict mode."))
                        break
                    if (
                        p.children[0].name == "CoverParenthesizedExpressionAndArrowParameterList"
                        and len(p.children[0].children) == 3
                        and p.children[0].children[1].name == "Expression"
                    ):
                        p = p.children[0].children[1]
                        continue
                p = p.children[0]
        return errs

    def evaluate(self):
        # 12.5.3.2 Runtime Semantics: Evaluation
        # UnaryExpression : delete UnaryExpression
        #   1. Let ref be the result of evaluating UnaryExpression.
        #   2. ReturnIfAbrupt(ref).
        #   3. If Type(ref) is not Reference, return true.
        #   4. If IsUnresolvableReference(ref) is true, then
        #       a. Assert: IsStrictReference(ref) is false.
        #       b. Return true.
        #   5. If IsPropertyReference(ref) is true, then
        #       a. If IsSuperReference(ref) is true, throw a ReferenceError exception.
        #       b. Let baseObj be ! ToObject(GetBase(ref)).
        #       c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).
        #       d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.
        #       e. Return deleteStatus.
        #   6. Else ref is a Reference to an Environment Record binding,
        #       a. Let bindings be GetBase(ref).
        #       b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).
        ref = self.UnaryExpression.evaluate()
        if not isinstance(ref, Reference):
            return True
        if IsUnresolvableReference(ref):
            assert not IsStrictReference(ref)
            return True
        if IsPropertyReference(ref):
            if IsSuperReference(ref):
                raise ESReferenceError("Can't delete super references")
            baseObj = ToObject(GetBase(ref))
            deleteStatus = baseObj.Delete(GetReferencedName(ref))
            if not deleteStatus and IsStrictReference(ref):
                raise ESTypeError(f"Couldn't delete {GetReferencedName(ref)!r}.")
            return deleteStatus
        bindings = GetBase(ref)
        return bindings.DeleteBinding(GetReferencedName(ref))
        # NOTE
        # When a delete operator occurs within strict mode code, a SyntaxError exception is thrown if its
        # UnaryExpression is a direct reference to a variable, function argument, or function name. In addition, if a
        # delete operator occurs within strict mode code and the property to be deleted has the attribute
        # { [[Configurable]]: false }, a TypeError exception is thrown.


class P2_UnaryExpression_VOID_UnaryExpression(P2_UnaryExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        return self.children[1]

    def evaluate(self):
        # 12.5.4.1 Runtime Semantics: Evaluation
        #           UnaryExpression : void UnaryExpression
        # 1. Let expr be the result of evaluating UnaryExpression.
        # 2. Perform ? GetValue(expr).
        # 3. Return undefined.
        # NOTE
        # GetValue must be called even though its value is not used because it may have observable side-effects.
        GetValue(self.UnaryExpression.evaluate())
        return None


class P2_UnaryExpression_TYPEOF_UnaryExpression(P2_UnaryExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        return self.children[1]

    def evaluate(self):
        # 12.5.5.1 Runtime Semantics: Evaluation
        #           UnaryExpression : typeof UnaryExpression
        # 1. Let val be the result of evaluating UnaryExpression.
        # 2. If Type(val) is Reference, then
        #   a. If IsUnresolvableReference(val) is true, return "undefined".
        # 3. Set val to ? GetValue(val).
        # 4. Return a String according to Table 35.
        #
        # Table 35: typeof Operator Results
        # +----------------------------------------------------------+-------------------------------------------------
        # | Type of val                                              | Result
        # +----------------------------------------------------------+-------------------------------------------------
        # | Undefined                                                | "undefined"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Null                                                     | "object"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Boolean                                                  | "boolean"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Number                                                   | "number"
        # +----------------------------------------------------------+-------------------------------------------------
        # | String                                                   | "string"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Symbol                                                   | "symbol"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Object (ordinary and does not implement [[Call]])        | "object"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Object (standard exotic and does not implement [[Call]]) | "object"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Object (implements [[Call]])                             | "function"
        # +----------------------------------------------------------+-------------------------------------------------
        # | Object (non-standard exotic and does not                 | Implementation-defined. Must not be "undefined",
        # | implement [[Call]])                                      | "boolean", "function", "number", "symbol", or
        # |                                                          | "string".
        # +----------------------------------------------------------+-------------------------------------------------
        # NOTE
        # Implementations are discouraged from defining new typeof result values for non-standard exotic objects. If
        # possible "object" should be used for such objects.
        val = self.UnaryExpression.evaluate()
        if isinstance(val, Reference) and IsUnresolvableReference(val):
            return "undefined"
        val = GetValue(val)
        type_matrix = [
            (isUndefined, "undefined"),
            (isNull, "object"),
            (isBoolean, "boolean"),
            (isNumber, "number"),
            (isString, "string"),
            (isSymbol, "symbol"),
            (lambda x: isObject(x) and not hasattr(x, "Call"), "object"),
            (isObject, "function"),
        ]
        return next(result for check, result in type_matrix if check(val))


class P2_UnaryExpression_PLUS_UnaryExpression(P2_UnaryExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        return self.children[1]

    # 12.5.6 Unary + Operator
    # NOTE
    # The unary + operator converts its operand to Number type.
    def evaluate(self):
        # 12.5.6.1 Runtime Semantics: Evaluation
        #           UnaryExpression : + UnaryExpression
        # 1. Let expr be the result of evaluating UnaryExpression.
        # 2. Return ? ToNumber(? GetValue(expr)).
        return ToNumber(GetValue(self.UnaryExpression.evaluate()))


class P2_UnaryExpression_MINUS_UnaryExpression(P2_UnaryExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        return self.children[1]

    # 12.5.7 Unary - Operator
    # NOTE
    # The unary - operator converts its operand to Number type and then negates it. Negating +0 produces -0, and
    # negating -0 produces +0.
    def evaluate(self):
        # 12.5.7.1 Runtime Semantics: Evaluation
        #           UnaryExpression : - UnaryExpression
        # 1. Let expr be the result of evaluating UnaryExpression.
        # 2. Let oldValue be ? ToNumber(? GetValue(expr)).
        # 3. If oldValue is NaN, return NaN.
        # 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite
        #    sign.
        return -ToNumber(GetValue(self.UnaryExpression.evaluate()))


class P2_UnaryExpression_TILDE_UnaryExpression(P2_UnaryExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        return self.children[1]

    # 12.5.8 Bitwise NOT Operator ( ~ )
    def evaluate(self):
        # 12.5.8.1 Runtime Semantics: Evaluation
        #           UnaryExpression : ~ UnaryExpression
        # 1. Let expr be the result of evaluating UnaryExpression.
        # 2. Let oldValue be ? ToInt32(? GetValue(expr)).
        # 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.
        return ToInt32(~ToInt32(GetValue(self.UnaryExpression.evaluate())))


class P2_UnaryExpression_BANG_UnaryExpression(P2_UnaryExpression_NotFallThru):
    @property
    def UnaryExpression(self):
        return self.children[1]

    # 12.5.9 Logical NOT Operator ( ! )
    def evaluate(self):
        # 12.5.9.1 Runtime Semantics: Evaluation
        #           UnaryExpression : ! UnaryExpression
        # 1. Let expr be the result of evaluating UnaryExpression.
        # 2. Let oldValue be ToBoolean(? GetValue(expr)).
        # 3. If oldValue is true, return false.
        # 4. Return true.
        return not ToBoolean(GetValue(self.UnaryExpression.evaluate()))


class P2_UnaryExpression_AwaitExpression(P2_UnaryExpression_NotFallThru):
    @property
    def AwaitExpression(self):
        return self.children[0]


def parse_UnaryExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.5 Unary Operators
    # Syntax
    #   UnaryExpression[Yield, Await] :
    #       UpdateExpression[?Yield, ?Await]
    #       delete UnaryExpression[?Yield, ?Await]
    #       void UnaryExpression[?Yield, ?Await]
    #       typeof UnaryExpression[?Yield, ?Await]
    #       + UnaryExpression[?Yield, ?Await]
    #       - UnaryExpression[?Yield, ?Await]
    #       ~ UnaryExpression[?Yield, ?Await]
    #       ! UnaryExpression[?Yield, ?Await]
    #       [+Await]AwaitExpression[?Yield]
    #
    ue = parse_UpdateExpression(ctx, lexer, pos, strict, Yield, Await)
    if ue:
        return P2_UnaryExpression_UpdateExpression(ctx, strict, [ue])
    if Await:
        ae = parse_AwaitExpression(ctx, lexer, pos, strict, Yield)
        if ae:
            return P2_UnaryExpression_AwaitExpression(ctx, strict, [ae])
    tok = lexer.token(pos)
    if tok and (
        (tok.type == "IDENTIFIER" and tok.value in ("delete", "void", "typeof"))
        or (tok.type in ("+", "-", "~", "!"))
    ):
        une = parse_UnaryExpression(ctx, lexer, tok.span.after, strict, Yield, Await)
        une_class = {
            "delete": P2_UnaryExpression_DELETE_UnaryExpression,
            "void": P2_UnaryExpression_VOID_UnaryExpression,
            "typeof": P2_UnaryExpression_TYPEOF_UnaryExpression,
            "+": P2_UnaryExpression_PLUS_UnaryExpression,
            "-": P2_UnaryExpression_MINUS_UnaryExpression,
            "~": P2_UnaryExpression_TILDE_UnaryExpression,
            "!": P2_UnaryExpression_BANG_UnaryExpression,
        }
        if une:
            return une_class[tok.value if tok.type == "IDENTIFIER" else tok.type](ctx, strict, [tok, une])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.
# d8888   d88P  Y88b     d88P  Y88b
#   888          888     888
#   888        .d88P     888d888b.
#   888    .od888P"      888P "Y88b
#   888   d88P"          888    888
#   888   888"       d8b Y88b  d88P
# 8888888 888888888  Y8P  "Y8888P"
#
#
#
# 8888888888                                                       888    d8b          888    d8b
# 888                                                              888    Y8P          888    Y8P
# 888                                                              888                 888
# 8888888    888  888 88888b.   .d88b.  88888b.   .d88b.  88888b.  888888 888  8888b.  888888 888  .d88b.  88888b.
# 888        `Y8bd8P' 888 "88b d88""88b 888 "88b d8P  Y8b 888 "88b 888    888     "88b 888    888 d88""88b 888 "88b
# 888          X88K   888  888 888  888 888  888 88888888 888  888 888    888 .d888888 888    888 888  888 888  888
# 888        .d8""8b. 888 d88P Y88..88P 888  888 Y8b.     888  888 Y88b.  888 888  888 Y88b.  888 Y88..88P 888  888
# 8888888888 888  888 88888P"   "Y88P"  888  888  "Y8888  888  888  "Y888 888 "Y888888  "Y888 888  "Y88P"  888  888
#                     888
#                     888
#                     888
#  .d88888b.                                     888
# d88P" "Y88b                                    888
# 888     888                                    888
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"
# 888     888 888  888 88888888 888     .d888888 888    888  888 888
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888
#             888
#             888
#             888
#
#######################################################################################################################
# 12.6 Exponentiation Operator
# 12.6.1 SS: IsFunctionDefinition
# 12.6.2 SS: AssignmentTargetType
# 12.6.3 RS: Evaluation
# 12.6.4 Applying the ** Operator
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.6 Exponentiation Operator .....●·._..●·._..●·._.·´   #
####################################################################################

# --------======= 𝓔𝔁𝓹𝓸𝓷𝓮𝓷𝓽𝓲𝓪𝓽𝓲𝓸𝓷𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   ExponentiationExpression :
#       UnaryExpression
#       UpdateExpression ** ExponentiationExpression


class P2_ExponentiationExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ExponentiationExpression", strict, children)


class P2_ExponentiationExpression_UnaryExpression(P2_ExponentiationExpression):
    @property
    def UnaryExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.UnaryExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.UnaryExpression.HasUseStrict


class P2_ExponentiationExpression_UpdateExpression_STARSTAR_ExponentiationExpression(P2_ExponentiationExpression):
    @property
    def UpdateExpression(self):
        return self.children[0]

    @property
    def ExponentiationExpression(self):
        return self.children[2]

    def IsFunctionDefinition(self):
        # 12.6.1 Static Semantics: IsFunctionDefinition
        # ExponentiationExpression : UpdateExpression ** ExponentiationExpression
        #   1. Return false.
        return False

    # 12.6.2 Static Semantics: AssignmentTargetType
    # ExponentiationExpression : UpdateExpression ** ExponentiationExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.6.3 Runtime Semantics: Evaluation
        # ExponentiationExpression : UpdateExpression ** ExponentiationExpression
        #   1. Let left be the result of evaluating UpdateExpression.
        #   2. Let leftValue be ? GetValue(left).
        #   3. Let right be the result of evaluating ExponentiationExpression.
        #   4. Let rightValue be ? GetValue(right).
        #   5. Let base be ? ToNumber(leftValue).
        #   6. Let exponent be ? ToNumber(rightValue).
        #   7. Return the result of Applying the ** operator with base and exponent as specified in 12.6.4.
        leftValue = GetValue(self.UpdateExpression.evaluate())
        rightValue = GetValue(self.ExponentiationExpression.evaluate())
        return ExponentiationOperation(leftValue, rightValue)


def parse_ExponentiationExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.6 Exponentiation Operator
    # Syntax
    #   ExponentiationExpression[Yield, Await] :
    #       UnaryExpression[?Yield, ?Await]
    #       UpdateExpression[?Yield, ?Await] ** ExponentiationExpression[?Yield, ?Await]
    #
    # (There's a shift/reduce conflict here. Choose in favor of shift: try the second line first.)
    #
    # @@@ UnaryExpressions and UpdateExpressions are very nearly the same. Most expressions will fit
    # in either category. In addition, most expressions do not use exponentiation. Therefore, this
    # function parses most expressions twice. :sadface: We need to do something to re-use what we
    # did in parse_UpdateExpression so that we don't repeat all the work in parse_UnaryExpression.
    upe = parse_UpdateExpression(ctx, lexer, pos, strict, Yield, Await)
    if upe:
        stars = lexer.token_if(upe.after, "**")
        if stars:
            ee = parse_ExponentiationExpression(ctx, lexer, stars.span.after, strict, Yield, Await)
            if ee:
                return P2_ExponentiationExpression_UpdateExpression_STARSTAR_ExponentiationExpression(
                    ctx, strict, [upe, stars, ee]
                )
    unary = parse_UnaryExpression(ctx, lexer, pos, strict, Yield, Await)
    if unary:
        return P2_ExponentiationExpression_UnaryExpression(ctx, strict, [unary])
    return None


def prep_for_math(lval, rval):
    # Converts args to Number values, in preparation for math.
    lnum = ToNumber(lval)  # 1. Let lnum be ? ToNumber(lval).
    rnum = ToNumber(rval)  # 2. Let rnum be ? ToNumber(rval).
    return (lnum, rnum)  # 3. Return (lnum, rnum)


# 12.6.4 Applying the ** Operator
# Returns an implementation-dependent approximation of the result of raising base to the power exponent.
#
#   * If exponent is NaN, the result is NaN.
#   * If exponent is +0, the result is 1, even if base is NaN.
#   * If exponent is -0, the result is 1, even if base is NaN.
#   * If base is NaN and exponent is nonzero, the result is NaN.
#   * If abs(base) > 1 and exponent is +∞, the result is +∞.
#   * If abs(base) > 1 and exponent is -∞, the result is +0.
#   * If abs(base) is 1 and exponent is +∞, the result is NaN.
#   * If abs(base) is 1 and exponent is -∞, the result is NaN.
#   * If abs(base) < 1 and exponent is +∞, the result is +0.
#   * If abs(base) < 1 and exponent is -∞, the result is +∞.
#   * If base is +∞ and exponent > 0, the result is +∞.
#   * If base is +∞ and exponent < 0, the result is +0.
#   * If base is -∞ and exponent > 0 and exponent is an odd integer, the result is -∞.
#   * If base is -∞ and exponent > 0 and exponent is not an odd integer, the result is +∞.
#   * If base is -∞ and exponent < 0 and exponent is an odd integer, the result is -0.
#   * If base is -∞ and exponent < 0 and exponent is not an odd integer, the result is +0.
#   * If base is +0 and exponent > 0, the result is +0.
#   * If base is +0 and exponent < 0, the result is +∞.
#   * If base is -0 and exponent > 0 and exponent is an odd integer, the result is -0.
#   * If base is -0 and exponent > 0 and exponent is not an odd integer, the result is +0.
#   * If base is -0 and exponent < 0 and exponent is an odd integer, the result is -∞.
#   * If base is -0 and exponent < 0 and exponent is not an odd integer, the result is +∞.
#   * If base < 0 and base is finite and exponent is finite and exponent is not an integer, the result is NaN.
#
# NOTE   | The result of base ** exponent when base is 1 or -1 and exponent is +Infinity or -Infinity differs from
#        | IEEE 754-2008. The first edition of ECMAScript specified a result of NaN for this operation, whereas later
#        | versions of IEEE 754-2008 specified 1. The historical ECMAScript behaviour is preserved for compatibility
#        | reasons.


def ExponentiationOperation(lval, rval):
    lnum, rnum = prep_for_math(lval, rval)
    return (
        math.nan
        if (
            (abs(lnum) == 1.0 and abs(rnum) == math.inf)
            or (lnum < 0.0 and math.isfinite(lnum) and math.isfinite(rnum) and math.floor(rnum) != rnum)
        )
        else lnum ** rnum
    )


#######################################################################################################################
#
#  d888    .d8888b.      8888888888
# d8888   d88P  Y88b           d88P
#   888          888          d88P
#   888        .d88P         d88P
#   888    .od888P"       88888888
#   888   d88P"            d88P
#   888   888"       d8b  d88P
# 8888888 888888888  Y8P d88P
#
#
#
# 888b     d888          888 888    d8b          888 d8b                   888    d8b
# 8888b   d8888          888 888    Y8P          888 Y8P                   888    Y8P
# 88888b.d88888          888 888                 888                       888
# 888Y88888P888 888  888 888 888888 888 88888b.  888 888  .d8888b  8888b.  888888 888 888  888  .d88b.
# 888 Y888P 888 888  888 888 888    888 888 "88b 888 888 d88P"        "88b 888    888 888  888 d8P  Y8b
# 888  Y8P  888 888  888 888 888    888 888  888 888 888 888      .d888888 888    888 Y88  88P 88888888
# 888   "   888 Y88b 888 888 Y88b.  888 888 d88P 888 888 Y88b.    888  888 Y88b.  888  Y8bd8P  Y8b.
# 888       888  "Y88888 888  "Y888 888 88888P"  888 888  "Y8888P "Y888888  "Y888 888   Y88P    "Y8888
#                                       888
#                                       888
#                                       888
#  .d88888b.                                     888
# d88P" "Y88b                                    888
# 888     888                                    888
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
# 888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#             888
#             888
#             888
#
#######################################################################################################################
# 12.7 Multiplicative Operators
# 12.7.1 SS: IsFunctionDefinition
# 12.7.2 SS: AssignmentTargetType
# 12.7.3 RS: Evaluation
# 12.7.3.1 Applying the * Operator
# 12.7.3.2 Applying the / Operator
# 12.7.3.3 Applying the % Operator
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.7 Multiplicative Operators .....●·._..●·._..●·._.·´  #
####################################################################################

# --------======= 𝓜𝓾𝓵𝓽𝓲𝓹𝓵𝓲𝓬𝓪𝓽𝓲𝓿𝓮𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   MultiplicativeExpression :
#       ExponentiationExpression
#       MultiplicativeExpression MultiplicativeOperator ExponentiationExpression


class P2_MultiplicativeExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "MultiplicativeExpression", strict, children)


class P2_MultiplicativeExpression_ExponentiationExpression(P2_MultiplicativeExpression):
    @property
    def ExponentiationExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.ExponentiationExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.ExponentiationExpression.HasUseStrict


class P2_MultiplicativeExpression_MultiplicativeExpression_MultiplicativeOperator_ExponentiationExpression(
    P2_MultiplicativeExpression
):
    @property
    def MultiplicativeExpression(self):
        return self.children[0]

    @property
    def MultiplicativeOperator(self):
        return self.children[1]

    @property
    def ExponentiationExpression(self):
        return self.children[2]

    def IsFunctionDefinition(self):
        # 12.7.1 Static Semantics: IsFunctionDefinition
        #       MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
        #   1. Return false.
        return False

    # 12.7.2 Static Semantics: AssignmentTargetType
    #       MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.7.3 Runtime Semantics: Evaluation
        #       MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
        # 1. Let left be the result of evaluating MultiplicativeExpression.
        # 2. Let leftValue be ? GetValue(left).
        # 3. Let right be the result of evaluating ExponentiationExpression.
        # 4. Let rightValue be ? GetValue(right).
        # 5. Let lnum be ? ToNumber(leftValue).
        # 6. Let rnum be ? ToNumber(rightValue).
        # 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in
        #    12.7.3.1, 12.7.3.2, or 12.7.3.3.
        left = self.MultiplicativeExpression.evaluate()
        leftValue = GetValue(left)
        right = self.ExponentiationExpression.evaluate()
        rightValue = GetValue(right)
        return self.MultiplicativeOperator.operation(leftValue, rightValue)


def parse_MultiplicativeExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.7 Multiplicative Operators
    # Syntax
    #   MultiplicativeExpression[Yield, Await] :
    #       ExponentiationExpression[?Yield, ?Await]
    #       MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            ee1 = parse_ExponentiationExpression(ctx, lexer, pos, strict, Yield, Await)
            if ee1:
                return lambda: parse(
                    ee1.after, P2_MultiplicativeExpression_ExponentiationExpression(ctx, strict, [ee1])
                )
        else:
            mo = parse_MultiplicativeOperator(ctx, lexer, pos, strict)
            if mo:
                ee2 = parse_ExponentiationExpression(ctx, lexer, mo.after, strict, Yield, Await)
                if ee2:
                    return lambda: parse(
                        ee2.after,
                        P2_MultiplicativeExpression_MultiplicativeExpression_MultiplicativeOperator_ExponentiationExpression(
                            ctx, strict, [previous, mo, ee2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓜𝓾𝓵𝓽𝓲𝓹𝓵𝓲𝓬𝓪𝓽𝓲𝓿𝓮𝓞𝓹𝓮𝓻𝓪𝓽𝓸𝓻 =======--------
# Syntax
#   MultiplicativeOperator : one of
#       * / %


class P2_MultiplicativeOperator(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "MultiplicativeOperator", strict, children)


class P2_MultiplicativeOperator_MULT(P2_MultiplicativeOperator):
    def operation(self, lval, rval):
        return MultiplyOperation(lval, rval)


class P2_MultiplicativeOperator_DIV(P2_MultiplicativeOperator):
    def operation(self, lval, rval):
        return DivideOperation(lval, rval)


class P2_MultiplicativeOperator_MOD(P2_MultiplicativeOperator):
    def operation(self, lval, rval):
        return ModuloOperation(lval, rval)


def parse_MultiplicativeOperator(context, lexer, pos, strict):
    mult = lexer.token_if(pos, "*", goal=lexer.InputElementDiv)
    if mult:
        return P2_MultiplicativeOperator_MULT(context, strict, [mult])
    div = lexer.token_if(pos, "/", goal=lexer.InputElementDiv)
    if div:
        return P2_MultiplicativeOperator_DIV(context, strict, [div])
    mod = lexer.token_if(pos, "%", goal=lexer.InputElementDiv)
    if mod:
        return P2_MultiplicativeOperator_MOD(context, strict, [mod])
    return None


# 12.7.3.1 Applying the * Operator
# The * MultiplicativeOperator performs multiplication, producing the product of its operands. Multiplication is
# commutative. Multiplication is not always associative in ECMAScript, because of finite precision.
#
# The result of a floating-point multiplication is governed by the rules of IEEE 754-2008 binary double-precision
# arithmetic:
#
#   * If either operand is NaN, the result is NaN.
#   * The sign of the result is positive if both operands have the same sign, negative if the operands have different
#     signs.
#   * Multiplication of an infinity by a zero results in NaN.
#   * Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already
#     stated above.
#   * Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by
#     the rule already stated above.
#   * In the remaining cases, where neither an infinity nor NaN is involved, the product is computed and rounded to the
#     nearest representable value using IEEE 754-2008 round to nearest, ties to even mode. If the magnitude is too
#     large to represent, the result is then an infinity of appropriate sign. If the magnitude is too small to
#     represent, the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual
#     underflow as defined by IEEE 754-2008.


def MultiplyOperation(lval, rval):
    # Do number conversion on the operands, forming lnum and rnum
    lnum, rnum = prep_for_math(lval, rval)
    # Return the result of multiplying lnum and rnum.
    return lnum * rnum


# 12.7.3.2 Applying the / Operator
# The / MultiplicativeOperator performs division, producing the quotient of its operands. The left operand is the
# dividend and the right operand is the divisor. ECMAScript does not perform integer division. The operands and result
# of all division operations are double-precision floating-point numbers. The result of division is determined by the
# specification of IEEE 754-2008 arithmetic:
#
#   * If either operand is NaN, the result is NaN.
#   * The sign of the result is positive if both operands have the same sign, negative if the operands have different
#     signs.
#   * Division of an infinity by an infinity results in NaN.
#   * Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated
#     above.
#   * Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the
#     rule already stated above.
#   * Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated
#     above.
#   * Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the
#     sign determined by the rule already stated above.
#   * Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule
#     already stated above.
#   * In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed and
#     rounded to the nearest representable value using IEEE 754-2008 round to nearest, ties to even mode. If the
#     magnitude is too large to represent, the operation overflows; the result is then an infinity of appropriate sign.
#     If the magnitude is too small to represent, the operation underflows and the result is a zero of the appropriate
#     sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754-2008.


def DivideOperation(lval, rval):
    # Do number conversion on the operands, forming lnum and rnum
    lnum, rnum = prep_for_math(lval, rval)
    # Return the result of dividing lnum and rnum.
    return (
        lnum / rnum
        if rnum != 0.0
        else (math.nan if lnum == 0.0 else (math.copysign(1.0, lnum) * math.copysign(1.0, rnum)) * math.inf)
    )


# 12.7.3.3 Applying the % Operator
# The % MultiplicativeOperator yields the remainder of its operands from an implied division; the left operand is the
# dividend and the right operand is the divisor.
#
# NOTE  | In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts
#       | floating-point operands.
#
# The result of a floating-point remainder operation as computed by the % operator is not the same as the “remainder”
# operation defined by IEEE 754-2008. The IEEE 754-2008 “remainder” operation computes the remainder from a rounding
# division, not a truncating division, and so its behaviour is not analogous to that of the usual integer remainder
# operator. Instead the ECMAScript language defines % on floating-point operations to behave in a manner analogous to
# that of the Java integer remainder operator; this may be compared with the C library function fmod.
#
# The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:
#
#   * If either operand is NaN, the result is NaN.
#   * The sign of the result equals the sign of the dividend.
#   * If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
#   * If the dividend is finite and the divisor is an infinity, the result equals the dividend.
#   * If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.
#   * In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder
#     r from a dividend n and a divisor d is defined by the mathematical relation r = n - (d × q) where q is an integer
#     that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as
#     possible without exceeding the magnitude of the true mathematical quotient of n and d. r is computed and rounded
#     to the nearest representable value using IEEE 754-2008 round to nearest, ties to even mode.


def ModuloOperation(lval, rval):
    # Do number conversion on the operands, forming lnum and rnum
    lnum, rnum = prep_for_math(lval, rval)
    # Return the result of applying the modulo operator to lnum and rnum.
    return lnum % rnum


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.             d8888      888      888 d8b 888    d8b
# d8888   d88P  Y88b     d88P  Y88b           d88888      888      888 Y8P 888    Y8P
#   888          888     Y88b. d88P          d88P888      888      888     888
#   888        .d88P      "Y88888"          d88P 888  .d88888  .d88888 888 888888 888 888  888  .d88b.
#   888    .od888P"      .d8P""Y8b.        d88P  888 d88" 888 d88" 888 888 888    888 888  888 d8P  Y8b
#   888   d88P"          888    888       d88P   888 888  888 888  888 888 888    888 Y88  88P 88888888
#   888   888"       d8b Y88b  d88P      d8888888888 Y88b 888 Y88b 888 888 Y88b.  888  Y8bd8P  Y8b.
# 8888888 888888888  Y8P  "Y8888P"      d88P     888  "Y88888  "Y88888 888  "Y888 888   Y88P    "Y8888
#
#
#
#  .d88888b.                                     888
# d88P" "Y88b                                    888
# 888     888                                    888
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
# 888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#             888
#             888
#             888
#
#######################################################################################################################
# 12.8 Additive Operators
# 12.8.1 SS: IsFunctionDefinition
# 12.8.2 SS: AssignmentTargetType
# 12.8.3 The Addition Operator ( + )
# 12.8.3.1 RS: Evaluation
# 12.8.4 The Subtraction Operator ( - )
# 12.8.4.1 RS: Evaluation
# 12.8.5 Applying the Additive Operators to Numbers
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.8 Additive Operators .....●·._..●·._..●·._.·´  #
####################################################################################

# --------======= 𝓐𝓭𝓭𝓲𝓽𝓲𝓿𝓮𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   AdditiveExpression :
#       MultiplicativeExpression
#       AdditiveExpression + MultiplicativeExpression
#       AdditiveExpression - MultiplicativeExpression
class P2_AdditiveExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AdditiveExpression", strict, children)


class P2_AdditiveExpression_MultiplicativeExpression(P2_AdditiveExpression):
    @property
    def MultiplicativeExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.MultiplicativeExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.MultiplicativeExpression.HasUseStrict


class P2_AdditiveExpression_NotPassThru(P2_AdditiveExpression):
    def IsFunctionDefinition(self):
        # 12.8.1 Static Semantics: IsFunctionDefinition
        # AdditiveExpression : AdditiveExpression + MultiplicativeExpression
        # AdditiveExpression : AdditiveExpression - MultiplicativeExpression
        #   1. Return false.
        return False

    # 12.8.2 Static Semantics: AssignmentTargetType
    # AdditiveExpression : AdditiveExpression + MultiplicativeExpression
    # AdditiveExpression : AdditiveExpression - MultiplicativeExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_AdditiveExpression_AdditiveExpression_PLUS_MultiplicativeExpression(P2_AdditiveExpression_NotPassThru):
    # 12.8.3 The Addition Operator ( + )
    # NOTE  | The addition operator either performs string concatenation or numeric addition.

    @property
    def AdditiveExpression(self):
        return self.children[0]

    @property
    def MultiplicativeExpression(self):
        return self.children[2]

    def evaluate(self):
        # 12.8.3.1 Runtime Semantics: Evaluation
        # AdditiveExpression : AdditiveExpression + MultiplicativeExpression
        #   1. Let lref be the result of evaluating AdditiveExpression.
        #   2. Let lval be ? GetValue(lref).
        #   3. Let rref be the result of evaluating MultiplicativeExpression.
        #   4. Let rval be ? GetValue(rref).
        #   5. Let lprim be ? ToPrimitive(lval).
        #   6. Let rprim be ? ToPrimitive(rval).
        #   7. If Type(lprim) is String or Type(rprim) is String, then
        #     a. Let lstr be ? ToString(lprim).
        #     b. Let rstr be ? ToString(rprim).
        #     c. Return the string-concatenation of lstr and rstr.
        #   8. Let lnum be ? ToNumber(lprim).
        #   9. Let rnum be ? ToNumber(rprim).
        #   10. Return the result of applying the addition operation to lnum and rnum. See the Note below 12.8.5.
        lref = self.AdditiveExpression.evaluate()
        lval = GetValue(lref)
        rref = self.MultiplicativeExpression.evaluate()
        rval = GetValue(rref)
        lprim = ToPrimitive(lval)
        rprim = ToPrimitive(rval)
        if isString(lprim) or isString(rprim):
            lstr = ToString(lprim)
            rstr = ToString(rprim)
            return lstr + rstr
        lnum = ToNumber(lprim)
        rnum = ToNumber(rprim)
        return lnum + rnum
        # NOTE 1    | No hint is provided in the calls to ToPrimitive in steps 5 and 6. All standard objects except
        #           | Date objects handle the absence of a hint as if the hint Number were given; Date objects handle
        #           | the absence of a hint as if the hint String were given. Exotic objects may handle the absence of
        #           | a hint in some other manner.
        # NOTE 2    | Step 7 differs from step 3 of the Abstract Relational Comparison algorithm, by using the
        #           | logical-or operation instead of the logical-and operation.


class P2_AdditiveExpression_AdditiveExpression_MINUS_MultiplicativeExpression(P2_AdditiveExpression_NotPassThru):
    # 12.8.4 The Subtraction Operator ( - )

    @property
    def AdditiveExpression(self):
        return self.children[0]

    @property
    def MultiplicativeExpression(self):
        return self.children[2]

    def evaluate(self):
        # 12.8.4.1 Runtime Semantics: Evaluation
        # 1. Let lref be the result of evaluating AdditiveExpression.
        # 2. Let lval be ? GetValue(lref).
        # 3. Let rref be the result of evaluating MultiplicativeExpression.
        # 4. Let rval be ? GetValue(rref).
        # 5. Let lnum be ? ToNumber(lval).
        # 6. Let rnum be ? ToNumber(rval).
        # 7. Return the result of applying the subtraction operation to lnum and rnum. See the note below 12.8.5.
        lref = self.AdditiveExpression.evaluate()
        lval = GetValue(lref)
        rref = self.MultiplicativeExpression.evaluate()
        rval = GetValue(rref)
        lnum = ToNumber(lval)
        rnum = ToNumber(rval)
        return lnum - rnum


def parse_AdditiveExpression(ctx, lexer, pos, strict, Yield, Await):
    # 12.8 Additive Operators
    # Syntax
    #   AdditiveExpression[Yield, Await] :
    #       MultiplicativeExpression[?Yield, ?Await]
    #       AdditiveExpression[?Yield, ?Await] + MultiplicativeExpression[?Yield, ?Await]
    #       AdditiveExpression[?Yield, ?Await] - MultiplicativeExpression[?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            me1 = parse_MultiplicativeExpression(ctx, lexer, pos, strict, Yield, Await)
            if me1:
                return lambda: parse(me1.after, P2_AdditiveExpression_MultiplicativeExpression(ctx, strict, [me1]))
        else:
            plus = lexer.token_if(pos, "+")
            if plus:
                me2 = parse_MultiplicativeExpression(ctx, lexer, plus.span.after, strict, Yield, Await)
                if me2:
                    return lambda: parse(
                        me2.after,
                        P2_AdditiveExpression_AdditiveExpression_PLUS_MultiplicativeExpression(
                            ctx, strict, [previous, plus, me2]
                        ),
                    )
            else:
                minus = lexer.token_if(pos, "-")
                if minus:
                    me3 = parse_MultiplicativeExpression(ctx, lexer, minus.span.after, strict, Yield, Await)
                    if me3:
                        return lambda: parse(
                            me3.after,
                            P2_AdditiveExpression_AdditiveExpression_MINUS_MultiplicativeExpression(
                                ctx, strict, [previous, minus, me3]
                            ),
                        )
        return previous

    return trampoline(lambda: parse(pos))


# 12.8.5 Applying the Additive Operators to Numbers
#
# The + operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The -
# operator performs subtraction, producing the difference of two numeric operands.
#
# Addition is a commutative operation, but not always associative.
#
# The result of an addition is determined using the rules of IEEE 754-2008 binary double-precision arithmetic:
#
#   * If either operand is NaN, the result is NaN.
#   * The sum of two infinities of opposite sign is NaN.
#   * The sum of two infinities of the same sign is the infinity of that sign.
#   * The sum of an infinity and a finite value is equal to the infinite operand.
#   * sum of two negative zeroes is -0. The sum of two positive zeroes, or of two zeroes of opposite sign, is +0.
#   * sum of a zero and a nonzero finite value is equal to the nonzero operand.
#   * The sum of two nonzero finite values of the same magnitude and opposite sign is +0.
#   * The remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same
#     sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE
#     754-2008 round to nearest, ties to even mode. If the magnitude is too large to represent, the operation overflows
#     and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual
#     underflow as defined by IEEE 754-2008.
#
# NOTE  | The - operator performs subtraction when applied to two operands of numeric type, producing the difference of
#       | its operands; the left operand is the minuend and the right operand is the subtrahend. Given numeric operands
#       | a and b, it is always the case that a-b produces the same result as a+(-b).

#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.      888888b.   d8b 888                  d8b
# d8888   d88P  Y88b     d88P  Y88b     888  "88b  Y8P 888                  Y8P
#   888          888     888    888     888  .88P      888
#   888        .d88P     Y88b. d888     8888888K.  888 888888 888  888  888 888 .d8888b   .d88b.
#   888    .od888P"       "Y888P888     888  "Y88b 888 888    888  888  888 888 88K      d8P  Y8b
#   888   d88P"                 888     888    888 888 888    888  888  888 888 "Y8888b. 88888888
#   888   888"       d8b Y88b  d88P     888   d88P 888 Y88b.  Y88b 888 d88P 888      X88 Y8b.
# 8888888 888888888  Y8P  "Y8888P"      8888888P"  888  "Y888  "Y8888888P"  888  88888P'  "Y8888
#
#
#
#   .d8888b.  888      d8b  .d888 888
#  d88P  Y88b 888      Y8P d88P"  888
#  Y88b.      888          888    888
#   "Y888b.   88888b.  888 888888 888888
#      "Y88b. 888 "88b 888 888    888
#        "888 888  888 888 888    888
#  Y88b  d88P 888  888 888 888    Y88b.
#   "Y8888P"  888  888 888 888     "Y888
#
#
#
#   .d88888b.                                     888
#  d88P" "Y88b                                    888
#  888     888                                    888
#  888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
#  888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
#  888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
#  Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#   "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#              888
#              888
#              888
#
#######################################################################################################################
# 12.9 Bitwise Shift Operators
# 12.9.1 SS: IsFunctionDefinition
# 12.9.2 SS: AssignmentTargetType
# 12.9.3 The Left Shift Operator ( << )
# 12.9.3.1 RS: Evaluation
# 12.9.4 The Signed Right Shift Operator ( >> )
# 12.9.4.1 RS: Evaluation
# 12.9.5 The Unsigned Right Shift Operator ( >>> )
# 12.9.5.1 RS: Evaluation
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.9 Bitwise Shift Operators .....●·._..●·._..●·._.·´   #
####################################################################################

# --------======= 𝓢𝓱𝓲𝓯𝓽𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   ShiftExpression :
#       AdditiveExpression
#       ShiftExpression << AdditiveExpression
#       ShiftExpression >> AdditiveExpression
#       ShiftExpression >>> AdditiveExpression


class P2_ShiftExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ShiftExpression", strict, children)


class P2_ShiftExpression_AdditiveExpression(P2_ShiftExpression):
    @property
    def AdditiveExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.AdditiveExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.AdditiveExpression.HasUseStrict


class P2_ShiftExpression_NotPassThru(P2_ShiftExpression):
    @property
    def ShiftExpression(self):
        return self.children[0]

    @property
    def AdditiveExpression(self):
        return self.children[2]

    @property
    def lval_is_signed(self):
        raise NotImplementedError("Base Class should not be instantiated")

    def operate(self, lnum, shiftcount):
        raise NotImplementedError("Base Class should not be instantiated")

    def IsFunctionDefinition(self):
        # 12.9.1 Static Semantics: IsFunctionDefinition
        # ShiftExpression : ShiftExpression << AdditiveExpression
        # ShiftExpression : ShiftExpression >> AdditiveExpression
        # ShiftExpression : ShiftExpression >>> AdditiveExpression
        #   1. Return false.
        return False

    # 12.9.2 Static Semantics: AssignmentTargetType
    # ShiftExpression : ShiftExpression << AdditiveExpression
    # ShiftExpression : ShiftExpression >> AdditiveExpression
    # ShiftExpression : ShiftExpression >>> AdditiveExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    # --- The first 7 steps are (nearly) common for all 3 productions.
    def evaluate(self):
        # 12.9.3.1 Runtime Semantics: Evaluation
        #   1. Let lref be the result of evaluating ShiftExpression.
        #   2. Let lval be ? GetValue(lref).
        #   3. Let rref be the result of evaluating AdditiveExpression.
        #   4. Let rval be ? GetValue(rref).
        #   5. Let lnum be ? ToInt32(lval), or ? ToUint32(lval), depending.
        #   6. Let rnum be ? ToUint32(rval).
        #   7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute
        #      rnum & 0x1F.
        lref = self.ShiftExpression.evaluate()
        lval = GetValue(lref)
        rref = self.AdditiveExpression.evaluate()
        rval = GetValue(rref)
        lnum = (ToInt32 if self.lval_is_signed else ToUint32)(lval)
        rnum = ToUint32(rval)
        shiftCount = rnum & 0x1F
        return self.operate(lnum, shiftCount)


class P2_ShiftExpression_ShiftExpression_LTLT_AdditiveExpression(P2_ShiftExpression_NotPassThru):
    # 12.9.3 The Left Shift Operator ( << )
    # Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.

    lval_is_signed = True

    def operate(self, lnum, shiftCount):
        # 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.
        return ToInt32(lnum << shiftCount)


class P2_ShiftExpression_ShiftExpression_GTGT_AdditiveExpression(P2_ShiftExpression_NotPassThru):
    # 12.9.4 The Signed Right Shift Operator ( >> )
    # Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right
    # operand.

    lval_is_signed = True

    def operate(self, lnum, shiftCount):
        # 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most
        #    significant bit is propagated. The result is a signed 32-bit integer.
        return lnum >> shiftCount


class P2_ShiftExpression_ShiftExpression_GTGTGT_AdditiveExpression(P2_ShiftExpression_NotPassThru):
    # 12.9.5 The Unsigned Right Shift Operator ( >>> )
    # Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right
    # operand.

    lval_is_signed = False

    def operate(self, lnum, shiftCount):
        # 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are
        #    filled with zero. The result is an unsigned 32-bit integer.
        return lnum >> shiftCount


def parse_ShiftExpression(context, lexer, pos, strict, Yield, Await):
    # 12.9 Bitwise Shift Operators
    # Syntax
    #   ShiftExpression[Yield, Await] :
    #       AdditiveExpression[?Yield, ?Await]
    #       ShiftExpression[?Yield, ?Await] << AdditiveExpression[?Yield, ?Await]
    #       ShiftExpression[?Yield, ?Await] >> AdditiveExpression[?Yield, ?Await]
    #       ShiftExpression[?Yield, ?Await] >>> AdditiveExpression[?Yield, ?Await]
    #
    shift_expression_constructors = {
        "<<": P2_ShiftExpression_ShiftExpression_LTLT_AdditiveExpression,
        ">>": P2_ShiftExpression_ShiftExpression_GTGT_AdditiveExpression,
        ">>>": P2_ShiftExpression_ShiftExpression_GTGTGT_AdditiveExpression,
    }

    def parse(pos, previous=None):
        if previous is None:
            ae1 = parse_AdditiveExpression(context, lexer, pos, strict, Yield, Await)
            if ae1:
                return lambda: parse(ae1.after, P2_ShiftExpression_AdditiveExpression(context, strict, [ae1]))
        else:
            tok = lexer.token(pos)
            if tok and tok.type in ("<<", ">>", ">>>"):
                ae2 = parse_AdditiveExpression(context, lexer, tok.span.after, strict, Yield, Await)
                if ae2:
                    ctor = shift_expression_constructors[tok.type]
                    return lambda: parse(ae2.after, ctor(context, strict, [previous, tok, ae2]))
        return previous

    return trampoline(lambda: parse(pos))


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.
# d8888   d88P  Y88b     d8888   d88P  Y88b
#   888          888       888   888    888
#   888        .d88P       888   888    888
#   888    .od888P"        888   888    888
#   888   d88P"            888   888    888
#   888   888"       d8b   888   Y88b  d88P
# 8888888 888888888  Y8P 8888888  "Y8888P"
#
#
#
# 8888888b.           888          888    d8b                            888
# 888   Y88b          888          888    Y8P                            888
# 888    888          888          888                                   888
# 888   d88P  .d88b.  888  8888b.  888888 888  .d88b.  88888b.   8888b.  888
# 8888888P"  d8P  Y8b 888     "88b 888    888 d88""88b 888 "88b     "88b 888
# 888 T88b   88888888 888 .d888888 888    888 888  888 888  888 .d888888 888
# 888  T88b  Y8b.     888 888  888 Y88b.  888 Y88..88P 888  888 888  888 888
# 888   T88b  "Y8888  888 "Y888888  "Y888 888  "Y88P"  888  888 "Y888888 888
#
#
#
#  .d88888b.                                     888
# d88P" "Y88b                                    888
# 888     888                                    888
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
# 888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#             888
#             888
#             888
#
#######################################################################################################################
# 12.10 Relational Operators
# 12.10.1 SS: IsFunctionDefinition
# 12.10.2 SS: AssignmentTargetType
# 12.10.3 RS: Evaluation
# 12.10.4 RS: InstanceofOperator ( V, target )
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.10 Relational Operators .....●·._..●·._..●·._.·´     #
####################################################################################

# --------======= 𝓡𝓮𝓵𝓪𝓽𝓲𝓸𝓷𝓪𝓵𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   RelationalExpression:
#       ShiftExpression
#       RelationalExpression < ShiftExpression
#       RelationalExpression > ShiftExpression
#       RelationalExpression <= ShiftExpression
#       RelationalExpression >= ShiftExpression
#       RelationalExpression instanceof ShiftExpression
#       RelationalExpression in ShiftExpression


class P2_RelationalExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "RelationalExpression", strict, children)


class P2_RelationalExpression_ShiftExpression(P2_RelationalExpression):
    @property
    def ShiftExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.ShiftExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.ShiftExpression.HasUseStrict


class P2_RelationalExpression_RelationalExpression_OP_ShiftExpression(P2_RelationalExpression):
    @property
    def RelationalExpression(self):
        return self.children[0]

    @property
    def ShiftExpression(self):
        return self.children[2]

    def operate(self, lval, rval):
        raise NotImplementedError("Abstract Class should not be instantiated")

    def IsFunctionDefinition(self):
        # 12.10.1 Static Semantics: IsFunctionDefinition
        # RelationalExpression : RelationalExpression < ShiftExpression
        # RelationalExpression : RelationalExpression > ShiftExpression
        # RelationalExpression : RelationalExpression <= ShiftExpression
        # RelationalExpression : RelationalExpression >= ShiftExpression
        # RelationalExpression : RelationalExpression instanceof ShiftExpression
        # RelationalExpression : RelationalExpression in ShiftExpression
        #   1. Return false.
        return False

    # 12.10.2 Static Semantics: AssignmentTargetType
    # RelationalExpression : RelationalExpression < ShiftExpression
    # RelationalExpression : RelationalExpression > ShiftExpression
    # RelationalExpression : RelationalExpression <= ShiftExpression
    # RelationalExpression : RelationalExpression >= ShiftExpression
    # RelationalExpression : RelationalExpression instanceof ShiftExpression
    # RelationalExpression : RelationalExpression in ShiftExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.10.3 Runtime Semantics: Evaluation
        # -- The first 4 steps are the same for each production
        #   1. Let lref be the result of evaluating RelationalExpression.
        #   2. Let lval be ? GetValue(lref).
        #   3. Let rref be the result of evaluating ShiftExpression.
        #   4. Let rval be ? GetValue(rref).
        #   5+: defer to subclass
        lval = GetValue(self.RelationalExpression.evaluate())
        rval = GetValue(self.ShiftExpression.evaluate())
        return self.operate(lval, rval)


class P2_RelationalExpression_RelationalExpression_LT_ShiftExpression(
    P2_RelationalExpression_RelationalExpression_OP_ShiftExpression
):
    def operate(self, lval, rval):
        # 12.10.3 Runtime Semantics: Evaluation
        # RelationalExpression : RelationalExpression < ShiftExpression
        #   5. Let r be the result of performing Abstract Relational Comparison lval < rval.
        #   6. ReturnIfAbrupt(r).
        #   7. If r is undefined, return false. Otherwise, return r.
        r = AbstractRelationalComparison(lval, rval, True)
        return r or False


class P2_RelationalExpression_RelationalExpression_GT_ShiftExpression(
    P2_RelationalExpression_RelationalExpression_OP_ShiftExpression
):
    def operate(self, lval, rval):
        # 12.10.3 Runtime Semantics: Evaluation
        # RelationalExpression : RelationalExpression > ShiftExpression
        #   5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.
        #   6. ReturnIfAbrupt(r).
        #   7. If r is undefined, return false. Otherwise, return r.
        r = AbstractRelationalComparison(rval, lval, False)
        return r or False


class P2_RelationalExpression_RelationalExpression_LE_ShiftExpression(
    P2_RelationalExpression_RelationalExpression_OP_ShiftExpression
):
    def operate(self, lval, rval):
        # 12.10.3 Runtime Semantics: Evaluation
        # RelationalExpression : RelationalExpression <= ShiftExpression
        #   5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.
        #   6. ReturnIfAbrupt(r).
        #   7. If r is true or undefined, return false. Otherwise, return true.
        r = AbstractRelationalComparison(rval, lval, False)
        return not (r is None or r)


class P2_RelationalExpression_RelationalExpression_GE_ShiftExpression(
    P2_RelationalExpression_RelationalExpression_OP_ShiftExpression
):
    def operate(self, lval, rval):
        # 12.10.3 Runtime Semantics: Evaluation
        # RelationalExpression : RelationalExpression >= ShiftExpression
        #   5. Let r be the result of performing Abstract Relational Comparison lval < rval.
        #   6. ReturnIfAbrupt(r).
        #   7. If r is true or undefined, return false. Otherwise, return true.
        r = AbstractRelationalComparison(lval, rval, True)
        return not (r is None or r)


class P2_RelationalExpression_RelationalExpression_INSTANCEOF_ShiftExpression(
    P2_RelationalExpression_RelationalExpression_OP_ShiftExpression
):
    def operate(self, lval, rval):
        # 12.10.3 Runtime Semantics: Evaluation
        # RelationalExpression : RelationalExpression instanceof ShiftExpression
        #   5. Return ? InstanceofOperator(lval, rval).
        return InstanceofOperator(lval, rval)


class P2_RelationalExpression_RelationalExpression_IN_ShiftExpression(
    P2_RelationalExpression_RelationalExpression_OP_ShiftExpression
):
    def operate(self, lval, rval):
        # 12.10.3 Runtime Semantics: Evaluation
        # RelationalExpression : RelationalExpression in ShiftExpression
        #   5. If Type(rval) is not Object, throw a TypeError exception.
        #   6. Return ? HasProperty(rval, ToPropertyKey(lval)).
        if not isObject(rval):
            raise ESTypeError(f"Cannot use 'in' operator to search for '{ToString(lval)}' in {ToString(rval)}")
        key = ToPropertyKey(lval)
        return HasProperty(rval, key)


def parse_RelationalExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.10 Relational Operators
    # Syntax
    #   RelationalExpression[In, Yield, Await]:
    #       ShiftExpression[?Yield, ?Await]
    #       RelationalExpression[?In, ?Yield, ?Await] < ShiftExpression[?Yield, ?Await]
    #       RelationalExpression[?In, ?Yield, ?Await] > ShiftExpression[?Yield, ?Await]
    #       RelationalExpression[?In, ?Yield, ?Await] <= ShiftExpression[?Yield, ?Await]
    #       RelationalExpression[?In, ?Yield, ?Await] >= ShiftExpression[?Yield, ?Await]
    #       RelationalExpression[?In, ?Yield, ?Await] instanceof ShiftExpression[?Yield, ?Await]
    #       [+In]RelationalExpression[+In, ?Yield, ?Await] in ShiftExpression[?Yield, ?Await]
    relational_constructor = {
        ">": P2_RelationalExpression_RelationalExpression_GT_ShiftExpression,
        "<": P2_RelationalExpression_RelationalExpression_LT_ShiftExpression,
        "<=": P2_RelationalExpression_RelationalExpression_LE_ShiftExpression,
        ">=": P2_RelationalExpression_RelationalExpression_GE_ShiftExpression,
        "instanceof": P2_RelationalExpression_RelationalExpression_INSTANCEOF_ShiftExpression,
        "in": P2_RelationalExpression_RelationalExpression_IN_ShiftExpression,
    }

    def parse(pos, previous=None):
        if previous is None:
            se1 = parse_ShiftExpression(context, lexer, pos, strict, Yield, Await)
            if se1:
                return lambda: parse(se1.after, P2_RelationalExpression_ShiftExpression(context, strict, [se1]))
        else:
            tok = lexer.token(pos)
            if tok and (
                tok.type in (">", "<", ">=", "<=")
                or tok.type == "IDENTIFIER"
                and (tok.value == "instanceof" or (tok.value == "in" and In))
            ):
                se2 = parse_ShiftExpression(context, lexer, tok.span.after, strict, Yield, Await)
                if se2:
                    ctor = relational_constructor[tok.type if tok.type != "IDENTIFIER" else tok.value]
                    return lambda: parse(se2.after, ctor(context, strict, [previous, tok, se2]))
        return previous

    return trampoline(lambda: parse(pos))


# 12.10.4 Runtime Semantics: InstanceofOperator ( V, target )
def InstanceofOperator(V, target):
    # The abstract operation InstanceofOperator(V, target) implements the generic algorithm for determining if ECMAScript value
    # V is an instance of object target either by consulting target's @@hasinstance method or, if absent, determining whether
    # the value of target's prototype property is present in V's prototype chain. This abstract operation performs the
    # following steps:
    #
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let instOfHandler be ? GetMethod(target, @@hasInstance).
    #   3. If instOfHandler is not undefined, then
    #       a. Return ToBoolean(? Call(instOfHandler, target, « V »)).
    #   4. If IsCallable(target) is false, throw a TypeError exception.
    #   5. Return ? OrdinaryHasInstance(target, V).
    if not isObject(target):
        raise ESTypeError("Right-hand side of 'instanceof' is not an object")
    instOfHandler = GetMethod(target, wks_has_instance)
    if instOfHandler is not None:
        return ToBoolean(Call(instOfHandler, target, [V]))
    if not IsCallable(target):
        raise ESTypeError("Right-hand side of 'instanceof' is not callable")
    return OrdinaryHasInstance(target, V)
    # NOTE
    # Steps 4 and 5 provide compatibility with previous editions of ECMAScript that did not use a @@hasInstance method to
    # define the instanceof operator semantics. If an object does not define or inherit @@hasInstance it uses the default
    # instanceof semantics.


#######################################################################################################################
#
#  d888    .d8888b.       d888    d888       8888888888                            888 d8b 888
# d8888   d88P  Y88b     d8888   d8888       888                                   888 Y8P 888
#   888          888       888     888       888                                   888     888
#   888        .d88P       888     888       8888888     .d88888 888  888  8888b.  888 888 888888 888  888
#   888    .od888P"        888     888       888        d88" 888 888  888     "88b 888 888 888    888  888
#   888   d88P"            888     888       888        888  888 888  888 .d888888 888 888 888    888  888
#   888   888"       d8b   888     888       888        Y88b 888 Y88b 888 888  888 888 888 Y88b.  Y88b 888
# 8888888 888888888  Y8P 8888888 8888888     8888888888  "Y88888  "Y88888 "Y888888 888 888  "Y888  "Y88888
#                                                            888                                       888
#                                                            888                                  Y8b d88P
#                                                            888                                   "Y88P"
#   .d88888b.                                     888
#  d88P" "Y88b                                    888
#  888     888                                    888
#  888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
#  888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
#  888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
#  Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#   "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#              888
#              888
#              888
#
#######################################################################################################################
# 12.11 Equality Operators
# 12.11.1 SS: IsFunctionDefinition
# 12.11.2 SS: AssignmentTargetType
# 12.11.3 RS: Evaluation
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.11 Equality Operators .....●·._..●·._..●·._.·´       #
####################################################################################

# --------======= 𝓔𝓺𝓾𝓪𝓵𝓲𝓽𝔂𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   EqualityExpression :
#       RelationalExpression
#       EqualityExpression == RelationalExpression
#       EqualityExpression != RelationalExpression
#       EqualityExpression === RelationalExpression
#       EqualityExpression !== RelationalExpression


class P2_EqualityExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "EqualityExpression", strict, children)


class P2_EqualityExpression_RelationalExpression(P2_EqualityExpression):
    @property
    def RelationalExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.RelationalExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.RelationalExpression.HasUseStrict


class P2_EqualityExpression_EqualityExpression_OP_RelationalExpression(P2_EqualityExpression):
    @property
    def EqualityExpression(self):
        return self.children[0]

    @property
    def RelationalExpression(self):
        return self.children[2]

    def operation(self, lval, rval):
        raise NotImplementedError("Base Class should not be instantiated")

    def IsFunctionDefinition(self):
        # 12.11.1 Static Semantics: IsFunctionDefinition
        # EqualityExpression : EqualityExpression == RelationalExpression
        # EqualityExpression : EqualityExpression != RelationalExpression
        # EqualityExpression : EqualityExpression === RelationalExpression
        # EqualityExpression : EqualityExpression !== RelationalExpression
        #   1. Return false.
        return False

    # 12.11.2 Static Semantics: AssignmentTargetType
    # EqualityExpression : EqualityExpression == RelationalExpression
    # EqualityExpression : EqualityExpression != RelationalExpression
    # EqualityExpression : EqualityExpression === RelationalExpression
    # EqualityExpression : EqualityExpression !== RelationalExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.11.3 Runtime Semantics: Evaluation
        # -- The first four steps are the same for each production
        #   1. Let lref be the result of evaluating EqualityExpression.
        #   2. Let lval be ? GetValue(lref).
        #   3. Let rref be the result of evaluating RelationalExpression.
        #   4. Let rval be ? GetValue(rref).
        #   5-6. Defer to subclasses
        lref = self.EqualityExpression.evaluate()
        lval = GetValue(lref)
        rref = self.RelationalExpression.evaluate()
        rval = GetValue(rref)
        return self.operation(lval, rval)


class P2_EqualityExpression_EqualityExpression_EQEQ_RelationalExpression(
    P2_EqualityExpression_EqualityExpression_OP_RelationalExpression
):
    def operation(self, lval, rval):
        # 12.11.3 Runtime Semantics: Evaluation
        # EqualityExpression : EqualityExpression == RelationalExpression
        #   5. Return the result of performing Abstract Equality Comparison rval == lval.
        return AbstractEqualityComparison(rval, lval)


class P2_EqualityExpression_EqualityExpression_BANGEQ_RelationalExpression(
    P2_EqualityExpression_EqualityExpression_OP_RelationalExpression
):
    def operation(self, lval, rval):
        # 12.11.3 Runtime Semantics: Evaluation
        # EqualityExpression : EqualityExpression != RelationalExpression
        #   5. Let r be the result of performing Abstract Equality Comparison rval == lval.
        #   6. If r is true, return false. Otherwise, return true.
        return not AbstractEqualityComparison(rval, lval)


class P2_EqualityExpression_EqualityExpression_EQEQEQ_RelationalExpression(
    P2_EqualityExpression_EqualityExpression_OP_RelationalExpression
):
    def operation(self, lval, rval):
        # 12.11.3 Runtime Semantics: Evaluation
        # EqualityExpression : EqualityExpression === RelationalExpression
        #   5. Return the result of performing Strict Equality Comparison rval === lval.
        return StrictEqualityComparison(rval, lval)


class P2_EqualityExpression_EqualityExpression_BANGEQEQ_RelationalExpression(
    P2_EqualityExpression_EqualityExpression_OP_RelationalExpression
):
    def operation(self, lval, rval):
        # 12.11.3 Runtime Semantics: Evaluation
        # EqualityExpression : EqualityExpression !== RelationalExpression
        #   5. Let r be the result of performing Strict Equality Comparison rval === lval.
        #   6. If r is true, return false. Otherwise, return true.
        return not StrictEqualityComparison(rval, lval)


def parse_EqualityExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.11 Equality Operators
    # Syntax
    #   EqualityExpression[In, Yield, Await] :
    #       RelationalExpression[?In, ?Yield, ?Await]
    #       EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await]
    #       EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await]
    #       EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await]
    #       EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await]
    #
    equality_constructor = {
        "==": P2_EqualityExpression_EqualityExpression_EQEQ_RelationalExpression,
        "!=": P2_EqualityExpression_EqualityExpression_BANGEQ_RelationalExpression,
        "===": P2_EqualityExpression_EqualityExpression_EQEQEQ_RelationalExpression,
        "!==": P2_EqualityExpression_EqualityExpression_BANGEQEQ_RelationalExpression,
    }

    def parse(pos, previous=None):
        if previous is None:
            re1 = parse_RelationalExpression(context, lexer, pos, strict, In, Yield, Await)
            if re1:
                return lambda: parse(re1.after, P2_EqualityExpression_RelationalExpression(context, strict, [re1]))
        else:
            tok = lexer.token(pos)
            if tok and tok.type in ("==", "!=", "===", "!=="):
                re2 = parse_RelationalExpression(context, lexer, tok.span.after, strict, In, Yield, Await)
                if re2:
                    ctor = equality_constructor[tok.type]
                    return lambda: parse(re2.after, ctor(context, strict, [previous, tok, re2]))
        return previous

    return trampoline(lambda: parse(pos))


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.      888888b.   d8b
# d8888   d88P  Y88b     d8888   d88P  Y88b     888  "88b  Y8P
#   888          888       888          888     888  .88P
#   888        .d88P       888        .d88P     8888888K.  888 88888b.   8888b.  888d888 888  888
#   888    .od888P"        888    .od888P"      888  "Y88b 888 888 "88b     "88b 888P"   888  888
#   888   d88P"            888   d88P"          888    888 888 888  888 .d888888 888     888  888
#   888   888"       d8b   888   888"           888   d88P 888 888  888 888  888 888     Y88b 888
# 8888888 888888888  Y8P 8888888 888888888      8888888P"  888 888  888 "Y888888 888      "Y88888
#                                                                                             888
#                                                                                        Y8b d88P
#                                                                                         "Y88P"
# 888888b.   d8b 888                  d8b
# 888  "88b  Y8P 888                  Y8P
# 888  .88P      888
# 8888888K.  888 888888 888  888  888 888 .d8888b   .d88b.
# 888  "Y88b 888 888    888  888  888 888 88K      d8P  Y8b
# 888    888 888 888    888  888  888 888 "Y8888b. 88888888
# 888   d88P 888 Y88b.  Y88b 888 d88P 888      X88 Y8b.
# 8888888P"  888  "Y888  "Y8888888P"  888  88888P'  "Y8888
#
#
#
#   .d88888b.                                     888
#  d88P" "Y88b                                    888
#  888     888                                    888
#  888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
#  888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
#  888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
#  Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#   "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#              888
#              888
#              888
#
#######################################################################################################################
# 12.12 Binary Bitwise Operators
# 12.12.1 SS: IsFunctionDefinition
# 12.12.2 SS: AssignmentTargetType
# 12.12.3 RS: Evaluation
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.12 Binary Bitwise Operators .....●·._..●·._..●·._.·´ #
####################################################################################


class P2_BitwiseExpression(ParseNode2):
    """This is a mixin class, providing common routines used by the bitwise routines."""

    def operate(self, lnum, rnum):
        raise NotImplementedError("Base Class should not be instantiated")

    def IsFunctionDefinition(self):
        # 12.12.1 Static Semantics: IsFunctionDefinition
        # BitwiseANDExpression : BitwiseANDExpression & EqualityExpression
        # BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression
        # BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression
        #   1. Return false.
        return False

    # 12.12.2 Static Semantics: AssignmentTargetType
    # BitwiseANDExpression : BitwiseANDExpression & EqualityExpression
    # BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression
    # BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    # 12.12.3 Runtime Semantics: Evaluation
    def evaluate(self):
        # The production A:A@B , where @ is one of the bitwise operators in the productions above, is evaluated as follows:
        # 1. Let lref be the result of evaluating A.
        # 2. Let lval be ? GetValue(lref).
        # 3. Let rref be the result of evaluating B.
        # 4. Let rval be ? GetValue(rref).
        # 5. Let lnum be ? ToInt32(lval).
        # 6. Let rnum be ? ToInt32(rval).
        # 7+. Defer to subclasses
        lnum = ToInt32(GetValue(self.children[0].evaluate()))
        rnum = ToInt32(GetValue(self.children[2].evaluate()))
        return self.operate(lnum, rnum)


# --------======= 𝓑𝓲𝓽𝔀𝓲𝓼𝓮𝓐𝓝𝓓𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   BitwiseANDExpression :
#       EqualityExpression
#       BitwiseANDExpression & EqualityExpression


class P2_BitwiseANDExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BitwiseANDExpression", strict, children)


class P2_BitwiseANDExpression_EqualityExpression(P2_BitwiseANDExpression):
    @property
    def EqualityExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.EqualityExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.EqualityExpression.HasUseStrict


class P2_BitwiseANDExpression_BitwiseANDExpression_AMP_EqualityExpression(
    P2_BitwiseANDExpression, P2_BitwiseExpression
):
    @property
    def BitwiseANDExpression(self):
        return self.children[0]

    @property
    def EqualityExpression(self):
        return self.children[2]

    def operate(self, lnum, rnum):
        # 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
        return lnum & rnum


def parse_BitwiseANDExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.12 Binary Bitwise Operators
    # Syntax
    #   BitwiseANDExpression[In, Yield, Await] :
    #       EqualityExpression[?In, ?Yield, ?Await]
    #       BitwiseANDExpression[?In, ?Yield, ?Await] & EqualityExpression[?In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            ee1 = parse_EqualityExpression(context, lexer, pos, strict, In, Yield, Await)
            if ee1:
                return lambda: parse(ee1.after, P2_BitwiseANDExpression_EqualityExpression(context, strict, [ee1]))
        else:
            amp = lexer.token_if(pos, "&")
            if amp:
                ee2 = parse_EqualityExpression(context, lexer, amp.span.after, strict, In, Yield, Await)
                if ee2:
                    return lambda: parse(
                        ee2.after,
                        P2_BitwiseANDExpression_BitwiseANDExpression_AMP_EqualityExpression(
                            context, strict, [previous, amp, ee2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓑𝓲𝓽𝔀𝓲𝓼𝓮𝓧𝓞𝓡𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   BitwiseXORExpression :
#       BitwiseANDExpression
#       BitwiseXORExpression ^ BitwiseANDExpression


class P2_BitwiseXORExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BitwiseXORExpression", strict, children)


class P2_BitwiseXORExpression_BitwiseANDExpression(P2_BitwiseXORExpression):
    @property
    def BitwiseANDExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.BitwiseANDExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.BitwiseANDExpression.HasUseStrict


class P2_BitwiseXORExpression_BitwiseXORExpression_CARET_BitwiseANDExpression(
    P2_BitwiseXORExpression, P2_BitwiseExpression
):
    @property
    def BitwiseXORExpression(self):
        return self.children[0]

    @property
    def BitwiseANDExpression(self):
        return self.children[2]

    def operate(self, lnum, rnum):
        # 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
        return lnum ^ rnum


def parse_BitwiseXORExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.12 Binary Bitwise Operators
    # Syntax
    #   BitwiseXORExpression[In, Yield, Await] :
    #       BitwiseANDExpression[?In, ?Yield, ?Await]
    #       BitwiseXORExpression[?In, ?Yield, ?Await] ^ BitwiseANDExpression[?In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            bae1 = parse_BitwiseANDExpression(context, lexer, pos, strict, In, Yield, Await)
            if bae1:
                return lambda: parse(
                    bae1.after, P2_BitwiseXORExpression_BitwiseANDExpression(context, strict, [bae1])
                )
        else:
            xor = lexer.token_if(pos, "^")
            if xor:
                bae2 = parse_BitwiseANDExpression(context, lexer, xor.span.after, strict, In, Yield, Await)
                if bae2:
                    return lambda: parse(
                        bae2.after,
                        P2_BitwiseXORExpression_BitwiseXORExpression_CARET_BitwiseANDExpression(
                            context, strict, [previous, xor, bae2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓑𝓲𝓽𝔀𝓲𝓼𝓮𝓞𝓡𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   BitwiseORExpression :
#       BitwiseXORExpression
#       BitwiseORExpression | BitwiseXORExpression


class P2_BitwiseORExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BitwiseORExpression", strict, children)


class P2_BitwiseORExpression_BitwiseXORExpression(P2_BitwiseORExpression):
    @property
    def BitwiseXORExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.BitwiseXORExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.BitwiseXORExpression.HasUseStrict


class P2_BitwiseORExpression_BitwiseORExpression_PIPE_BitwiseXORExpression(
    P2_BitwiseORExpression, P2_BitwiseExpression
):
    @property
    def BitwiseORExpression(self):
        return self.children[0]

    @property
    def BitwiseXORExpression(self):
        return self.children[2]

    def operate(self, lnum, rnum):
        # 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
        return lnum | rnum


def parse_BitwiseORExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.12 Binary Bitwise Operators
    # Syntax
    #   BitwiseORExpression[In, Yield, Await] :
    #       BitwiseXORExpression[?In, ?Yield, ?Await]
    #       BitwiseORExpression[?In, ?Yield, ?Await] | BitwiseXORExpression[?In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            bxe1 = parse_BitwiseXORExpression(context, lexer, pos, strict, In, Yield, Await)
            if bxe1:
                return lambda: parse(
                    bxe1.after, P2_BitwiseORExpression_BitwiseXORExpression(context, strict, [bxe1])
                )
        else:
            pipe = lexer.token_if(pos, "|")
            if pipe:
                bxe2 = parse_BitwiseXORExpression(context, lexer, pipe.span.after, strict, In, Yield, Await)
                if bxe2:
                    return lambda: parse(
                        bxe2.after,
                        P2_BitwiseORExpression_BitwiseORExpression_PIPE_BitwiseXORExpression(
                            context, strict, [previous, pipe, bxe2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.      888888b.   d8b
# d8888   d88P  Y88b     d8888   d88P  Y88b     888  "88b  Y8P
#   888          888       888        .d88P     888  .88P
#   888        .d88P       888       8888"      8888888K.  888 88888b.   8888b.  888d888 888  888
#   888    .od888P"        888        "Y8b.     888  "Y88b 888 888 "88b     "88b 888P"   888  888
#   888   d88P"            888   888    888     888    888 888 888  888 .d888888 888     888  888
#   888   888"       d8b   888   Y88b  d88P     888   d88P 888 888  888 888  888 888     Y88b 888
# 8888888 888888888  Y8P 8888888  "Y8888P"      8888888P"  888 888  888 "Y888888 888      "Y88888
#                                                                                             888
#                                                                                        Y8b d88P
#                                                                                         "Y88P"
# 888                        d8b                   888
# 888                        Y8P                   888
# 888                                              888
# 888       .d88b.   .d88b.  888  .d8888b  8888b.  888
# 888      d88""88b d88P"88b 888 d88P"        "88b 888
# 888      888  888 888  888 888 888      .d888888 888
# 888      Y88..88P Y88b 888 888 Y88b.    888  888 888
# 88888888  "Y88P"   "Y88888 888  "Y8888P "Y888888 888
#                        888
#                   Y8b d88P
#                    "Y88P"
#  .d88888b.                                     888
# d88P" "Y88b                                    888
# 888     888                                    888
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
# 888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#             888
#             888
#             888
#
#######################################################################################################################
# 12.13 Binary Logical Operators
# 12.13.1 SS: IsFunctionDefinition
# 12.13.2 SS: AssignmentTargetType
# 12.13.3 RS: Evaluation
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 12.13 Binary Logical Operators .....●·._..●·._..●·._.·´ #
####################################################################################


class P2_LogicalExpression(ParseNode2):
    def IsFunctionDefinition(self):
        # 12.13.1 Static Semantics: IsFunctionDefinition
        # LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
        # LogicalORExpression : LogicalORExpression || LogicalANDExpression
        #   1. Return false.
        return False

    # 12.13.2 Static Semantics: AssignmentTargetType
    # LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
    # LogicalORExpression : LogicalORExpression || LogicalANDExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


# --------======= 𝓛𝓸𝓰𝓲𝓬𝓪𝓵𝓐𝓝𝓓𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   LogicalANDExpression :
#       BitwiseORExpression
#       LogicalANDExpression && BitwiseORExpression


class P2_LogicalANDExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LogicalANDExpression", strict, children)


class P2_LogicalANDExpression_BitwiseORExpression(P2_LogicalANDExpression):
    @property
    def BitwiseORExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.BitwiseORExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.BitwiseORExpression.HasUseStrict


class P2_LogicalANDExpression_LogicalANDExpression_AMPAMP_BitwiseORExpression(
    P2_LogicalANDExpression, P2_LogicalExpression
):
    @property
    def LogicalANDExpression(self):
        return self.children[0]

    @property
    def BitwiseORExpression(self):
        return self.children[2]

    # 12.13.3 Runtime Semantics: Evaluation
    def evaluate(self):
        # 1. Let lref be the result of evaluating LogicalANDExpression.
        lref = self.LogicalANDExpression.evaluate()
        # 2. Let lval be ? GetValue(lref).
        lval = GetValue(lref)
        # 3. Let lbool be ToBoolean(lval).
        lbool = ToBoolean(lval)
        # 4. If lbool is false, return lval.
        if not lbool:
            return lval
        # 5. Let rref be the result of evaluating BitwiseORExpression.
        rref = self.BitwiseORExpression.evaluate()
        # 6. Return ? GetValue(rref).
        return GetValue(rref)


def parse_LogicalANDExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.13 Binary Logical Operators
    # Syntax
    #   LogicalANDExpression[In, Yield, Await] :
    #       BitwiseORExpression[?In, ?Yield, ?Await]
    #       LogicalANDExpression[?In, ?Yield, ?Await] && BitwiseORExpression[?In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            boe1 = parse_BitwiseORExpression(context, lexer, pos, strict, In, Yield, Await)
            if boe1:
                return lambda: parse(
                    boe1.after, P2_LogicalANDExpression_BitwiseORExpression(context, strict, [boe1])
                )
        else:
            amps = lexer.token_if(pos, "&&")
            if amps:
                boe2 = parse_BitwiseORExpression(context, lexer, amps.span.after, strict, In, Yield, Await)
                if boe2:
                    return lambda: parse(
                        boe2.after,
                        P2_LogicalANDExpression_LogicalANDExpression_AMPAMP_BitwiseORExpression(
                            context, strict, [previous, amps, boe2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓛𝓸𝓰𝓲𝓬𝓪𝓵𝓞𝓡𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   LogicalORExpression :
#       LogicalANDExpression
#       LogicalORExpression || LogicalANDExpression


class P2_LogicalORExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LogicalORExpression", strict, children)


class P2_LogicalORExpression_LogicalANDExpression(P2_LogicalORExpression):
    @property
    def LogicalANDExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.LogicalANDExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.LogicalANDExpression.HasUseStrict


class P2_LogicalORExpression_LogicalORExpression_PIPEPIPE_LogicalANDExpression(
    P2_LogicalORExpression, P2_LogicalExpression
):
    @property
    def LogicalORExpression(self):
        return self.children[0]

    @property
    def LogicalANDExpression(self):
        return self.children[2]

    # 12.13.3 Runtime Semantics: Evaluation
    def evaluate(self):
        # 1. Let lref be the result of evaluating LogicalORExpression.
        lref = self.LogicalORExpression.evaluate()
        # 2. Let lval be ? GetValue(lref).
        lval = GetValue(lref)
        # 3. Let lbool be ToBoolean(lval).
        lbool = ToBoolean(lval)
        # 4. If lbool is true, return lval.
        if lbool:
            return lval
        # 5. Let rref be the result of evaluating LogicalANDExpression.
        rref = self.LogicalANDExpression.evaluate()
        # 6. Return ? GetValue(rref).
        return GetValue(rref)


def parse_LogicalORExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.13 Binary Logical Operators
    # Syntax
    #   LogicalORExpression[In, Yield, Await] :
    #       LogicalANDExpression[?In, ?Yield, ?Await]
    #       LogicalORExpression[?In, ?Yield, ?Await] || LogicalANDExpression[?In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            lae1 = parse_LogicalANDExpression(context, lexer, pos, strict, In, Yield, Await)
            if lae1:
                return lambda: parse(
                    lae1.after, P2_LogicalORExpression_LogicalANDExpression(context, strict, [lae1])
                )
        else:
            pipes = lexer.token_if(pos, "||")
            if pipes:
                lae2 = parse_LogicalANDExpression(context, lexer, pipes.span.after, strict, In, Yield, Await)
                if lae2:
                    return lambda: parse(
                        lae2.after,
                        P2_LogicalORExpression_LogicalORExpression_PIPEPIPE_LogicalANDExpression(
                            context, strict, [previous, pipes, lae2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


#######################################################################################################################
#
#  d888    .d8888b.       d888       d8888
# d8888   d88P  Y88b     d8888      d8P888
#   888          888       888     d8P 888
#   888        .d88P       888    d8P  888
#   888    .od888P"        888   d88   888
#   888   d88P"            888   8888888888
#   888   888"       d8b   888         888
# 8888888 888888888  Y8P 8888888       888
#
#
#
#  .d8888b.                         888 d8b 888    d8b                            888
# d88P  Y88b                        888 Y8P 888    Y8P                            888
# 888    888                        888     888                                   888
# 888         .d88b.  88888b.   .d88888 888 888888 888  .d88b.  88888b.   8888b.  888
# 888        d88""88b 888 "88b d88" 888 888 888    888 d88""88b 888 "88b     "88b 888
# 888    888 888  888 888  888 888  888 888 888    888 888  888 888  888 .d888888 888
# Y88b  d88P Y88..88P 888  888 Y88b 888 888 Y88b.  888 Y88..88P 888  888 888  888 888
#  "Y8888P"   "Y88P"  888  888  "Y88888 888  "Y888 888  "Y88P"  888  888 "Y888888 888
#
#
#
#  .d88888b.                                     888                           .d88      .d8888b.              88b.
# d88P" "Y88b                                    888                          d88P"     d88P  Y88b             "Y88b
# 888     888                                    888                         d88P            .d88P               Y88b
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888     888           .d88P"      d8b        888
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"       888           888"        Y8P        888
# 888     888 888  888 88888888 888     .d888888 888    888  888 888         Y88b          888                   d88P
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          Y88b.                    d8b     .d88P
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888           "Y88        888         Y8P     88P"
#             888
#             888
#             888
#
#######################################################################################################################
# 12.14 Conditional Operator ( ? : )
# 12.14.1 SS: IsFunctionDefinition
# 12.14.2 SS: AssignmentTargetType
# 12.14.3 RS: Evaluation
#######################################################################################################################

########################################################################################
# `·._.·●.._.·●.._.·●..... 12.14 Conditional Operator ( ? : ) .....●·._..●·._..●·._.·´ #
########################################################################################

# --------======= 𝓒𝓸𝓷𝓭𝓲𝓽𝓲𝓸𝓷𝓪𝓵𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   ConditionalExpression:
#       LogicalORExpression
#       LogicalORExpression ? AssignmentExpression : AssignmentExpression


class P2_ConditionalExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ConditionalExpression", strict, children)


class P2_ConditionalExpression_LogicalORExpression(P2_ConditionalExpression):
    @property
    def LogicalORExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.LogicalORExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.LogicalORExpression.HasUseStrict


class P2_ConditionalExpression_LogicalORExpression_QUESTION_AssignmentExpression_COLON_AssignmentExpression(
    P2_ConditionalExpression
):
    @property
    def LogicalORExpression(self):
        return self.children[0]

    @property
    def AssignmentExpression1(self):
        return self.children[2]

    @property
    def AssignmentExpression2(self):
        return self.children[4]

    def IsFunctionDefinition(self):
        # 12.14.1 Static Semantics: IsFunctionDefinition
        # ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression
        #   1. Return false.
        return False

    # 12.14.2 Static Semantics: AssignmentTargetType
    # ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    # 12.14.3 Runtime Semantics: Evaluation
    # ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression
    def evaluate(self):
        # 1. Let lref be the result of evaluating LogicalORExpression.
        lref = self.LogicalORExpression.evaluate()
        # 2. Let lval be ToBoolean(? GetValue(lref)).
        lval = GetValue(lref)
        lval = ToBoolean(lval)
        # 3. If lval is true, then
        if lval:
            # a. Let trueRef be the result of evaluating the first AssignmentExpression.
            trueRef = self.AssignmentExpression1.evaluate()
            # b. Return ? GetValue(trueRef).
            return GetValue(trueRef)
        # 4. Else,
        # a. Let falseRef be the result of evaluating the second AssignmentExpression.
        falseRef = self.AssignmentExpression2.evaluate()
        # b. Return ? GetValue(falseRef).
        return GetValue(falseRef)


def parse_ConditionalExpression(context, lexer, pos, strict, In, Yield, Await):
    # 12.14 Conditional Operator ( ? : )
    # Syntax
    #   ConditionalExpression[In, Yield, Await]:
    #       LogicalORExpression[?In, ?Yield, ?Await]
    #       LogicalORExpression[?In, ?Yield, ?Await] ? AssignmentExpression[+In, ?Yield, ?Await] : AssignmentExpression[?In, ?Yield, ?Await]
    #
    loe = parse_LogicalORExpression(context, lexer, pos, strict, In, Yield, Await)
    if loe:
        question = lexer.token_if(loe.after, "?")
        if question:
            ae1 = parse_AssignmentExpression(context, lexer, question.span.after, strict, True, Yield, Await)
            if ae1:
                colon = lexer.token_if(ae1.after, ":")
                if colon:
                    ae2 = parse_AssignmentExpression(context, lexer, colon.span.after, strict, In, Yield, Await)
                    if ae2:
                        return P2_ConditionalExpression_LogicalORExpression_QUESTION_AssignmentExpression_COLON_AssignmentExpression(
                            context, strict, [loe, question, ae1, colon, ae2]
                        )
        return P2_ConditionalExpression_LogicalORExpression(context, strict, [loe])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888   888888888
# d8888   d88P  Y88b     d8888   888
#   888          888       888   888
#   888        .d88P       888   8888888b.
#   888    .od888P"        888        "Y88b
#   888   d88P"            888          888
#   888   888"       d8b   888   Y88b  d88P
# 8888888 888888888  Y8P 8888888  "Y8888P"
#
#
#
#        d8888                   d8b                                                   888
#       d88888                   Y8P                                                   888
#      d88P888                                                                         888
#     d88P 888 .d8888b  .d8888b  888  .d88b.  88888b.  88888b.d88b.   .d88b.  88888b.  888888
#    d88P  888 88K      88K      888 d88P"88b 888 "88b 888 "888 "88b d8P  Y8b 888 "88b 888
#   d88P   888 "Y8888b. "Y8888b. 888 888  888 888  888 888  888  888 88888888 888  888 888
#  d8888888888      X88      X88 888 Y88b 888 888  888 888  888  888 Y8b.     888  888 Y88b.
# d88P     888  88888P'  88888P' 888  "Y88888 888  888 888  888  888  "Y8888  888  888  "Y888
#                                         888
#                                    Y8b d88P
#                                     "Y88P"
#  .d88888b.                                     888
# d88P" "Y88b                                    888
# 888     888                                    888
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 .d8888b
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   88K
# 888     888 888  888 88888888 888     .d888888 888    888  888 888     "Y8888b.
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          X88
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888      88888P'
#             888
#             888
#             888
#
#######################################################################################################################
# 12.15 Assignment Operators
# 12.15.1 SS: Early Errors
# 12.15.2 SS: IsFunctionDefinition
# 12.15.3 SS: AssignmentTargetType
# 12.15.4 RS: Evaluation
# 12.15.5 Destructuring Assignment
# 12.15.5.1 SS: Early Errors
# 12.15.5.2 RS: DestructuringAssignmentEvaluation
# 12.15.5.3 RS: PropertyDestructuringAssignmentEvaluation
# 12.15.5.4 RS: RestDestructuringAssignmentEvaluation
# 12.15.5.5 RS: IteratorDestructuringAssignmentEvaluation
# 12.15.5.6 RS: KeyedDestructuringAssignmentEvaluation
################################################################################
# `·._.·●.._.·●.._.·●..... 12.15 Assignment Operators .....●·._..●·._..●·._.·´ #
################################################################################

# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   AssignmentExpression :
#       ConditionalExpression
#       YieldExpression
#       ArrowFunction
#       AsyncArrowFunction
#       LeftHandSideExpression = AssignmentExpression
#       LeftHandSideExpression AssignmentOperator AssignmentExpression


class P2_AssignmentExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentExpression", strict, children)


class P2_AssignmentExpression_ConditionalExpression(P2_AssignmentExpression):
    @property
    def ConditionalExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.ConditionalExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.ConditionalExpression.HasUseStrict


class P2_AssignmentExpression_YieldExpression(P2_AssignmentExpression):
    @property
    def YieldExpression(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.15.2 Static Semantics: IsFunctionDefinition
        # AssignmentExpression : YieldExpression
        #   1. Return false.
        return False

    # 12.15.3 Static Semantics: AssignmentTargetType
    # AssignmentExpression : YieldExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_AssignmentExpression_ArrowFunction(P2_AssignmentExpression):
    @property
    def ArrowFunction(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.15.2 Static Semantics: IsFunctionDefinition
        # AssignmentExpression : ArrowFunction
        #   1. Return true.
        return True

    # 12.15.3 Static Semantics: AssignmentTargetType
    # AssignmentExpression : ArrowFunction
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_AssignmentExpression_AsyncArrowFunction(P2_AssignmentExpression):
    @property
    def AsyncArrowFunction(self):
        return self.children[0]

    def IsFunctionDefinition(self):
        # 12.15.2 Static Semantics: IsFunctionDefinition
        # AssignmentExpression : AsyncArrowFunction
        #   1. Return true.
        return True

    # 12.15.3 Static Semantics: AssignmentTargetType
    # AssignmentExpression : AsyncArrowFunction
    #   1. Return invalid.
    AssignmentTargetType = INVALID


class P2_AssignmentExpression_LeftHandSideExpression_EQ_AssignmentExpression(P2_AssignmentExpression):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, strict, children)

    @property
    def LeftHandSideExpression(self):
        return self.children[0]

    @property
    def AssignmentExpression(self):
        return self.children[2]

    def EarlyErrors(self):
        # 12.15.1 Static Semantics: Early Errors
        # AssignmentExpression : LeftHandSideExpression = AssignmentExpression
        #   * It is a Syntax Error if LeftHandSideExpression is either an ObjectLiteral or an ArrayLiteral and
        #     LeftHandSideExpression is not covering an AssignmentPattern.
        #   * It is an early Syntax Error if LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral
        #     AssignmentTargetType of LeftHandSideExpression is not simple.
        is_structured = any(self.LeftHandSideExpression.Is(sym) for sym in ("ObjectLiteral", "ArrayLiteral"))
        return list(
            filter(
                None,
                [
                    # [ f(), b ] = [ 1, 2 ];
                    is_structured
                    and not self.LeftHandSideExpression.AssignmentPattern
                    and self.CreateSyntaxError("Invalid destructuring assignment target"),
                    # new f() = 3;
                    not is_structured
                    and self.LeftHandSideExpression.AssignmentTargetType != SIMPLE
                    and self.CreateSyntaxError("Invalid left-hand side in assignment"),
                ],
            )
        )

    def IsFunctionDefinition(self):
        # 12.15.2 Static Semantics: IsFunctionDefinition
        # AssignmentExpression : LeftHandSideExpression = AssignmentExpression
        #   1. Return false.
        return False

    # 12.15.3 Static Semantics: AssignmentTargetType
    # AssignmentExpression : LeftHandSideExpression = AssignmentExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.15.4 Runtime Semantics: Evaluation
        # AssignmentExpression : LeftHandSideExpression = AssignmentExpression
        #   1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
        #       a. Let lref be the result of evaluating LeftHandSideExpression.
        #       b. ReturnIfAbrupt(lref).
        #       c. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then
        #           i. Let rval be the result of performing NamedEvaluation for AssignmentExpression with argument GetReferencedName(lref).
        #       d. Else,
        #           i. Let rref be the result of evaluating AssignmentExpression.
        #           ii. Let rval be ? GetValue(rref).
        #       e. Perform ? PutValue(lref, rval).
        #       f. Return rval.
        #   2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.
        #   3. Let rref be the result of evaluating AssignmentExpression.
        #   4. Let rval be ? GetValue(rref).
        #   5. Perform ? DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.
        #   6. Return rval.
        if not (self.LeftHandSideExpression.Is("ObjectLiteral") or self.LeftHandSideExpression.Is("ArrayLiteral")):
            lref = self.LeftHandSideExpression.evaluate()
            if (
                IsAnonymousFunctionDefinition(self.LeftHandSideExpression)
                and self.LeftHandSideExpression.IsIdentifierRef()
            ):
                rval = self.AssignmentExpression.NamedEvaluation(GetReferencedName(lref))
            else:
                rref = self.AssignmentExpression.evaluate()
                rval = GetValue(rref)
            PutValue(lref, rval)
            return rval
        rref = self.AssignmentExpression.evaluate()
        rval = GetValue(rref)
        self.LeftHandSideExpression.AssignmentPattern.DestructuringAssignmentEvaluation(rval)
        return rval


class P2_AssignmentExpression_LeftHandSideExpression_AssignmentOperator_AssignmentExpression(
    P2_AssignmentExpression
):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, strict, children)

    @property
    def LeftHandSideExpression(self):
        return self.children[0]

    @property
    def AssignmentOperator(self):
        return self.children[1]

    @property
    def AssignmentExpression(self):
        return self.children[2]

    def EarlyErrors(self):
        # 12.15.1 Static Semantics: Early Errors
        # AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
        #   * It is an early Syntax Error if AssignmentTargetType of LeftHandSideExpression is not simple.
        return list(
            filter(
                None,
                [
                    self.LeftHandSideExpression.AssignmentTargetType != SIMPLE
                    and self.CreateSyntaxError("Invalid left-hand side in assignment")
                ],
            )
        )

    def IsFunctionDefinition(self):
        # 12.15.2 Static Semantics: IsFunctionDefinition
        # AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
        #   1. Return false.
        return False

    # 12.15.3 Static Semantics: AssignmentTargetType
    # AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    op_function = {
        "*=": MultiplyOperation,
        "/=": DivideOperation,
        "%=": ModuloOperation,
        "+=": AdditionOperation,
        "-=": SubtractionOperation,
        "<<=": LeftShiftOperation,
        ">>=": RightShiftOperation,
        ">>>=": UnsignedRightShiftOperation,
        "&=": BitwiseANDOperation,
        "|=": BitwiseOROperation,
        "^=": BitwiseXOROperation,
        "**=": ExponentiationOperation,
    }

    def evaluate(self):
        # 12.15.4 Runtime Semantics: Evaluation
        # AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
        #   1. Let lref be the result of evaluating LeftHandSideExpression.
        #   2. Let lval be ? GetValue(lref).
        #   3. Let rref be the result of evaluating AssignmentExpression.
        #   4. Let rval be ? GetValue(rref).
        #   5. Let op be the @ where AssignmentOperator is @=.
        #   6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.
        #   7. Perform ? PutValue(lref, r).
        #   8. Return r.
        lref = self.LeftHandSideExpression.evaluate()
        lval = GetValue(lref)
        rval = GetValue(self.AssignmentExpression.evaluate())
        op = self.op_function[self.AssignmentOperator.value]
        r = op(lval, rval)
        PutValue(lref, r)
        return r
        # NOTE
        # When an assignment occurs within strict mode code, it is a runtime error if lref in step 1.f of the first algorithm
        # or step 7 of the second algorithm it is an unresolvable reference. If it is, a ReferenceError exception is thrown.
        # The LeftHandSideExpression also may not be a reference to a data property with the attribute value
        # { [[Writable]]: false }, to an accessor property with the attribute value { [[Set]]: undefined }, nor to a
        # non-existent property of an object for which the IsExtensible predicate returns the value false. In these cases a
        # TypeError exception is thrown.


def parse_AssignmentExpression(context, lexer, pos, strict, In, Yield, Await):
    #   AssignmentExpression[In, Yield, Await] :
    #       ConditionalExpression[?In, ?Yield, ?Await]
    #       [+Yield]YieldExpression[?In, ?Await]
    #       ArrowFunction[?In, ?Yield, ?Await]
    #       AsyncArrowFunction[?In, ?Yield, ?Await]
    #       LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]
    #       LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
    lhs = parse_LeftHandSideExpression(context, lexer, pos, strict, Yield, Await)
    if lhs:
        # AssignmentOperator: one of  *= /= %= += -= <<= >>= >>>= &= ^= |= **=
        op = lexer.token(lhs.after, goal=lexer.InputElementDiv)
        if op and op.type in ("=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "**="):
            ae = parse_AssignmentExpression(context, lexer, op.span.after, strict, In, Yield, Await)
            if ae:
                ctor = (
                    P2_AssignmentExpression_LeftHandSideExpression_AssignmentOperator_AssignmentExpression,
                    P2_AssignmentExpression_LeftHandSideExpression_EQ_AssignmentExpression,
                )[op.type == "="]
                return ctor(context, strict, [lhs, op, ae])
    aaf = parse_AsyncArrowFunction(context, lexer, pos, strict, In, Yield, Await)
    if aaf:
        return P2_AssignmentExpression_AsyncArrowFunction(context, strict, [aaf])
    af = parse_ArrowFunction(context, lexer, pos, strict, In, Yield, Await)
    if af:
        return P2_AssignmentExpression_ArrowFunction(context, strict, [af])
    if Yield:
        ye = parse_YieldExpression(context, lexer, pos, strict, In, Await)
        if ye:
            return P2_AssignmentExpression_YieldExpression(context, strict, [ye])
    ce = parse_ConditionalExpression(context, lexer, pos, strict, In, Yield, Await)
    if ce:
        return P2_AssignmentExpression_ConditionalExpression(context, strict, [ce])
    return None


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓟𝓪𝓽𝓽𝓮𝓻𝓷 =======--------
# Syntax
#   AssignmentPattern:
#       ObjectAssignmentPattern
#       ArrayAssignmentPattern


class P2_AssignmentPattern(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentPattern", strict, children)


class P2_AssignmentPattern_ObjectAssignmentPattern(P2_AssignmentPattern):
    @property
    def ObjectAssignmentPattern(self):
        return self.children[0]


class P2_AssignmentPattern_ArrayAssignmentPattern(P2_AssignmentPattern):
    @property
    def ArrayAssignmentPattern(self):
        return self.children[0]


def parse_AssignmentPattern(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentPattern[Yield, Await]:
    #       ObjectAssignmentPattern[?Yield, ?Await]
    #       ArrayAssignmentPattern[?Yield, ?Await]
    oap = parse_ObjectAssignmentPattern(context, lexer, pos, strict, Yield, Await)
    if oap:
        return P2_AssignmentPattern_ObjectAssignmentPattern(context, strict, [oap])
    aap = parse_ArrayAssignmentPattern(context, lexer, pos, strict, Yield, Await)
    if aap:
        return P2_AssignmentPattern_ArrayAssignmentPattern(context, strict, [aap])
    return None


# --------======= 𝓞𝓫𝓳𝓮𝓬𝓽𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓟𝓪𝓽𝓽𝓮𝓻𝓷 =======--------
# Syntax
#   ObjectAssignmentPattern:
#       { }
#       { AssignmentRestProperty }
#       { AssignmentPropertyList }
#       { AssignmentPropertyList , AssignmentRestProperty[opt] }


class P2_ObjectAssignmentPattern(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ObjectAssignmentPattern", strict, children)


class P2_ObjectAssignmentPattern_Empty(P2_ObjectAssignmentPattern):
    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ObjectAssignmentPattern : { }
        #   1. Perform ? RequireObjectCoercible(value).
        #   2. Return NormalCompletion(empty).
        RequireObjectCoercible(value)
        return EMPTY


class P2_ObjectAssignmentPattern_AssignmentRestProperty(P2_ObjectAssignmentPattern):
    @property
    def AssignmentRestProperty(self):
        return self.children[1]

    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ObjectAssignmentPattern : { AssignmentRestProperty }
        #   1. Perform ? RequireObjectCoercible(value).
        #   2. Let excludedNames be a new empty List.
        #   3. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestProperty with
        #      value and excludedNames as the arguments.
        RequireObjectCoercible(value)
        return self.AssignmentRestProperty.RestDestructuringAssignmentEvaluation(value, [])


class P2_ObjectAssignmentPattern_AssignmentPropertyList(P2_ObjectAssignmentPattern):
    @property
    def AssignmentPropertyList(self):
        return self.children[1]

    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ObjectAssignmentPattern : { AssignmentPropertyList }
        # ObjectAssignmentPattern : { AssignmentPropertyList , }
        #   1. Perform ? RequireObjectCoercible(value).
        #   2. Perform ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.
        #   3. Return NormalCompletion(empty).
        RequireObjectCoercible(value)
        self.AssignmentPropertyList.PropertyDestructuringAssignmentEvaluation(value)
        return EMPTY


class P2_ObjectAssignmentPattern_AssignmentPropertyList_AssignmentRestProperty(P2_ObjectAssignmentPattern):
    @property
    def AssignmentPropertyList(self):
        return self.children[1]

    @property
    def AssignmentRestProperty(self):
        return self.children[3]

    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ObjectAssignmentPattern : { AssignmentPropertyList , AssignmentRestProperty }
        #   1. Perform ? RequireObjectCoercible(value).
        #   2. Let excludedNames be the result of performing ? PropertyDestructuringAssignmentEvaluation for
        #      AssignmentPropertyList using value as the argument.
        #   3. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestProperty with
        #      value and excludedNames as the arguments.
        RequireObjectCoercible(value)
        excludedNames = self.AssignmentPropertyList.PropertyDestructuringAssignmentEvaluation(value)
        return self.AssignmentRestProperty.RestDestructuringAssignmentEvaluation(value, excludedNames)


def parse_ObjectAssignmentPattern(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   ObjectAssignmentPattern[Yield, Await]:
    #       { }
    #       { AssignmentRestProperty[?Yield, ?Await] }
    #       { AssignmentPropertyList[?Yield, ?Await] }
    #       { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await]opt }
    #
    lcurly = lexer.token_if(pos, "{")
    if lcurly:
        rcurly1 = lexer.token_if(lcurly.span.after, "}")
        if rcurly1:
            return P2_ObjectAssignmentPattern_Empty(context, strict, [lcurly, rcurly1])
        arp1 = parse_AssignmentRestProperty(context, lexer, lcurly.span.after, strict, Yield, Await)
        if arp1:
            rcurly2 = lexer.token_if(arp1.after, "}")
            if rcurly2:
                return P2_ObjectAssignmentPattern_AssignmentRestProperty(context, strict, [lcurly, arp1, rcurly2])
        apl = parse_AssignmentPropertyList(context, lexer, lcurly.span.after, strict, Yield, Await)
        if apl:
            rcurly3 = lexer.token_if(apl.after, "}")
            if rcurly3:
                return P2_ObjectAssignmentPattern_AssignmentPropertyList(context, strict, [lcurly, apl, rcurly3])
            comma = lexer.token_if(apl.after, ",")
            if comma:
                arp2 = parse_AssignmentRestProperty(context, lexer, comma.span.after, strict, Yield, Await)
                rcurly4 = lexer.token_if(arp2.after if arp2 else comma.span.after, "}")
                if rcurly4:
                    if arp2:
                        return P2_ObjectAssignmentPattern_AssignmentPropertyList_AssignmentRestProperty(
                            context, strict, [lcurly, apl, comma, arp2, rcurly4]
                        )
                    return P2_ObjectAssignmentPattern_AssignmentPropertyList(
                        context, strict, [lcurly, apl, comma, rcurly4]
                    )
    return None


# --------======= 𝓐𝓻𝓻𝓪𝔂𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓟𝓪𝓽𝓽𝓮𝓻𝓷 =======--------
# Syntax
#   ArrayAssignmentPattern :
#       [ Elision[opt] AssignmentRestElement[opt] ]
#       [ AssignmentElementList ]
#       [ AssignmentElementList , Elision[opt] AssignmentRestElement[opt] ]
class P2_ArrayAssignmentPattern(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ArrayAssignmentPattern", strict, children)

    @property
    def Elision(self):
        return None

    @property
    def AssignmentRestElement(self):
        return None

    @property
    def AssignmentElementList(self):
        return None


class P2_ArrayAssignmentPattern_Empty(P2_ArrayAssignmentPattern):
    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ArrayAssignmentPattern : [ ]
        #   1. Let iteratorRecord be ? GetIterator(value).
        #   2. Return ? IteratorClose(iteratorRecord, NormalCompletion(empty)).
        iteratorRecord = GetIterator(value)
        IteratorClose(iteratorRecord)
        return EMPTY


class P2_ArrayAssignmentPattern_Elision(P2_ArrayAssignmentPattern):
    @property
    def Elision(self):
        return self.children[1]

    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ArrayAssignmentPattern : [ Elision ]
        #   1. Let iteratorRecord be ? GetIterator(value).
        #   2. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with
        #      iteratorRecord as the argument.
        #   3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
        #   4. Return result.
        iteratorRecord = GetIterator(value)
        try:
            result = self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        finally:
            if not iteratorRecord.Done:
                IteratorClose(iteratorRecord)
        return result


class P2_ArrayAssignmentPattern_Elision_AssignmentRestElement(P2_ArrayAssignmentPattern):
    @property
    def Elision(self):
        return self.children[1]

    @property
    def AssignmentRestElement(self):
        return self.children[2]

    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ArrayAssignmentPattern : [ Elision AssignmentRestElement ]
        #   1. Let iteratorRecord be ? GetIterator(value).
        #   2. If Elision is present, then
        #       a. Let status be the result of performing IteratorDestructuringAssignmentEvaluation of Elision with
        #          iteratorRecord as the argument.
        #       b. If status is an abrupt completion, then
        #           i. Assert: iteratorRecord.[[Done]] is true.
        #           ii. Return Completion(status).
        #   3. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of
        #      AssignmentRestElement with iteratorRecord as the argument.
        #   4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
        #   5. Return result.
        iteratorRecord = GetIterator(value)
        if self.Elision:
            try:
                self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
            except (ESError, ESAbrupt):
                assert iteratorRecord.Done
                raise
        try:
            result = self.AssignmentRestElement.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        finally:
            if not iteratorRecord.Done:
                IteratorClose(iteratorRecord)
        return result


class P2_ArrayAssignmentPattern_AssignmentRestElement(P2_ArrayAssignmentPattern_Elision_AssignmentRestElement):
    Elision = None

    @property
    def AssignmentRestElement(self):
        return self.children[1]


class P2_ArrayAssignmentPattern_AssignmentElementList(P2_ArrayAssignmentPattern):
    @property
    def AssignmentElementList(self):
        return self.children[1]

    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ArrayAssignmentPattern : [ AssignmentElementList ]
        #   1. Let iteratorRecord be ? GetIterator(value).
        #   2. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of
        #      AssignmentElementList using iteratorRecord as the argument.
        #   3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
        #   4. Return result.
        iteratorRecord = GetIterator(value)
        try:
            result = self.AssignmentElementList.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        finally:
            if not iteratorRecord.Done:
                IteratorClose(iteratorRecord)
        return result


class P2_ArrayAssignmentPattern_AssignmentElementList_Elision_AssignmentRestElement(P2_ArrayAssignmentPattern):
    @property
    def AssignmentElementList(self):
        return self.children[1]

    @property
    def Elision(self):
        return self.children[3]

    @property
    def AssignmentRestElement(self):
        return self.children[4]

    def DestructuringAssignmentEvaluation(self, value):
        # 12.15.5.2 Runtime Semantics: DestructuringAssignmentEvaluation
        #   With parameter value.
        # ArrayAssignmentPattern : [ AssignmentElementList , Elision AssignmentRestElement ]
        #   1. Let iteratorRecord be ? GetIterator(value).
        #   2. Let status be the result of performing IteratorDestructuringAssignmentEvaluation of
        #      AssignmentElementList using iteratorRecord as the argument.
        #   3. If status is an abrupt completion, then
        #       a. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, status).
        #       b. Return Completion(status).
        #   4. If Elision is present, then
        #       a. Set status to the result of performing IteratorDestructuringAssignmentEvaluation of Elision with
        #          iteratorRecord as the argument.
        #       b. If status is an abrupt completion, then
        #           i. Assert: iteratorRecord.[[Done]] is true.
        #           ii. Return Completion(status).
        #   5. If AssignmentRestElement is present, then
        #       a. Set status to the result of performing IteratorDestructuringAssignmentEvaluation of
        #          AssignmentRestElement with iteratorRecord as the argument.
        #   6. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, status).
        #   7. Return Completion(status).
        iteratorRecord = GetIterator(value)
        try:
            status = self.AssignmentElementList.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
            if self.Elision:
                status = self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
            if self.AssignmentRestElement:
                status = self.AssignmentRestElement.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        finally:
            if not iteratorRecord.Done:
                IteratorClose(iteratorRecord)
        return status


class P2_ArrayAssignmentPattern_AssignmentElementList_Elision(
    P2_ArrayAssignmentPattern_AssignmentElementList_Elision_AssignmentRestElement
):
    @property
    def AssignmentElementList(self):
        return self.children[1]

    @property
    def Elision(self):
        return self.children[3]

    AssignmentRestElement = None


class P2_ArrayAssignmentPattern_AssignmentElementList_AssignmentRestElement(
    P2_ArrayAssignmentPattern_AssignmentElementList_Elision_AssignmentRestElement
):
    @property
    def AssignmentElementList(self):
        return self.children[1]

    @property
    def AssignmentRestElement(self):
        return self.children[3]

    Elision = None


def parse_ArrayAssignmentPattern(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   ArrayAssignmentPattern[Yield, Await] :
    #       [ Elision[opt] AssignmentRestElement[?Yield, ?Await][opt] ]
    #       [ AssignmentElementList[?Yield, ?Await] ]
    #       [ AssignmentElementList[?Yield, ?Await] , Elision[opt] AssignmentRestElement[?Yield, ?Await][opt] ]
    #
    lbracket = lexer.token_if(pos, "[")
    if lbracket:
        lb_after = lbracket.span.after
        ael = parse_AssignmentElementList(context, lexer, lb_after, strict, Yield, Await)
        ael_after = ael.after if ael else lb_after
        comma = lexer.token_if(ael_after, ",") if ael else None
        comma_after = comma.span.after if comma else ael_after
        elision = parse_Elision(context, lexer, comma_after, strict)
        elision_after = elision.after if elision else comma_after
        are = parse_AssignmentRestElement(context, lexer, elision_after, strict, Yield, Await)
        are_after = are.after if are else elision_after
        rbracket = lexer.token_if(are_after, "]")
        if rbracket:
            children = list(filter(lambda x: x is not None, [lbracket, ael, comma, elision, are, rbracket]))
            # "ael", "elision", and "are" are the potential bits here. They can exist or not in 2^3 = 8 different ways.
            # So the following table is all the functions that might be.
            index = int(ael is not None) * 4 + int(elision is not None) * 2 + int(are is not None)
            # So:
            # 0: [ ]
            # 1: [ are ]
            # 2: [ elision ]
            # 3: [ elision are ]
            # 4: [ ael ] (or [ ael , ])
            # 5: [ ael , are ]
            # 6: [ ael , elision ]
            # 7: [ ael , elision are ]
            ctor = (
                P2_ArrayAssignmentPattern_Empty,
                P2_ArrayAssignmentPattern_AssignmentRestElement,
                P2_ArrayAssignmentPattern_Elision,
                P2_ArrayAssignmentPattern_Elision_AssignmentRestElement,
                P2_ArrayAssignmentPattern_AssignmentElementList,
                P2_ArrayAssignmentPattern_AssignmentElementList_AssignmentRestElement,
                P2_ArrayAssignmentPattern_AssignmentElementList_Elision,
                P2_ArrayAssignmentPattern_AssignmentElementList_Elision_AssignmentRestElement,
            )[index]
            return ctor(context, strict, children)
    return None


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓡𝓮𝓼𝓽𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂 =======--------
# Syntax
#   AssignmentRestProperty :
#       ... DestructuringAssignmentTarget


class P2_AssignmentRestProperty(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentRestProperty", strict, children)


class P2_AssignmentRestProperty_DestructuringAssignmentTarget(P2_AssignmentRestProperty):
    @property
    def DestructuringAssignmentTarget(self):
        return self.children[1]

    def EarlyErrors(self):
        # 12.15.5.1 Static Semantics: Early Errors
        # AssignmentRestProperty : ... DestructuringAssignmentTarget
        #   * It is a Syntax Error if DestructuringAssignmentTarget is an ArrayLiteral or an ObjectLiteral.
        return list(
            filter(
                None,
                [
                    any(
                        self.DestructuringAssignmentTarget.Is(symbol) for symbol in ("ArrayLiteral", "ObjectLiteral")
                    )
                    and self.CreateSyntaxError("Invalid destructuring assignment target")
                ],
            )
        )

    def RestDestructuringAssignmentEvaluation(self, value, excludedNames):
        # 12.15.5.4 Runtime Semantics: RestDestructuringAssignmentEvaluation
        #   With parameters value and excludedNames.
        # AssignmentRestProperty : ... DestructuringAssignmentTarget
        #   1. Let lref be the result of evaluating DestructuringAssignmentTarget.
        #   2. ReturnIfAbrupt(lref).
        #   3. Let restObj be ObjectCreate(%ObjectPrototype%).
        #   4. Perform ? CopyDataProperties(restObj, value, excludedNames).
        #   5. Return PutValue(lref, restObj).
        lref = self.DestructuringAssignmentTarget.evaluate()
        restObj = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
        CopyDataProperties(restObj, value, excludedNames)
        return PutValue(lref, restObj)


def parse_AssignmentRestProperty(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentRestProperty[Yield, Await] :
    #       ... DestructuringAssignmentTarget[?Yield, ?Await]
    dots = lexer.token_if(pos, "...")
    if dots:
        dat = parse_DestructuringAssignmentTarget(context, lexer, dots.span.after, strict, Yield, Await)
        if dat:
            return P2_AssignmentRestProperty_DestructuringAssignmentTarget(context, strict, [dots, dat])
    return None


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   AssignmentPropertyList :
#       AssignmentProperty
#       AssignmentPropertyList , AssignmentProperty


class P2_AssignmentPropertyList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentPropertyList", strict, children)


class P2_AssignmentPropertyList_AssignmentProperty(P2_AssignmentPropertyList):
    @property
    def AssignmentProperty(self):
        return self.children[0]


class P2_AssignmentPropertyList_AssignmentPropertyList_AssignmentProperty(P2_AssignmentPropertyList):
    @property
    def AssignmentPropertyList(self):
        return self.children[0]

    @property
    def AssignmentProperty(self):
        return self.children[2]

    def PropertyDestructuringAssignmentEvaluation(self, value):
        # 12.15.5.3 Runtime Semantics: PropertyDestructuringAssignmentEvaluation
        #   With parameter value.
        # NOTE
        # The following operations collect a list of all destructured property names.
        # AssignmentPropertyList : AssignmentPropertyList , AssignmentProperty
        #   1. Let propertyNames be the result of performing ? PropertyDestructuringAssignmentEvaluation for
        #      AssignmentPropertyList using value as the argument.
        #   2. Let nextNames be the result of performing ? PropertyDestructuringAssignmentEvaluation for
        #      AssignmentProperty using value as the argument.
        #   3. Append each item in nextNames to the end of propertyNames.
        #   4. Return propertyNames.
        propertyNames = self.AssignmentPropertyList.PropertyDestructuringAssignmentEvaluation(value)
        nextNames = self.AssignmentProperty.PropertyDestructuringAssignmentEvaluation(value)
        propertyNames.extend(nextNames)
        return propertyNames


def parse_AssignmentPropertyList(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentPropertyList[Yield, Await] :
    #       AssignmentProperty[?Yield, ?Await]
    #       AssignmentPropertyList[?Yield, ?Await] , AssignmentProperty[?Yield, ?Await]
    def parse(pos, previous=None):
        if previous is None:
            ap1 = parse_AssignmentProperty(context, lexer, pos, strict, Yield, Await)
            if ap1:
                return lambda: parse(ap1.after, P2_AssignmentPropertyList_AssignmentProperty(context, strict, [ap1]))
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                ap2 = parse_AssignmentProperty(context, lexer, comma.span.after, strict, Yield, Await)
                if ap2:
                    return lambda: parse(
                        ap2.after,
                        P2_AssignmentPropertyList_AssignmentPropertyList_AssignmentProperty(
                            context, strict, [previous, comma, ap2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓔𝓵𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   AssignmentElementList :
#       AssignmentElisionElement
#       AssignmentElementList , AssignmentElisionElement


class P2_AssignmentElementList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentElementList", strict, children)


class P2_AssignmentElementList_AssignmentElisionElement(P2_AssignmentElementList):
    @property
    def AssignmentElisionElement(self):
        return self.children[0]


class P2_AssignmentElementList_AssignmentElementList_AssignmentElisionElement(P2_AssignmentElementList):
    @property
    def AssignmentElementList(self):
        return self.children[0]

    @property
    def AssignmentElisionElement(self):
        return self.children[2]

    def IteratorDestructuringAssignmentEvaluation(self, iteratorRecord):
        # 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation
        #   With parameter iteratorRecord.
        # AssignmentElementList : AssignmentElementList , AssignmentElisionElement
        #   1. Perform ? IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the
        #      argument.
        #   2. Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElisionElement
        #      using iteratorRecord as the argument.
        self.AssignmentElementList.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        return self.AssignmentElisionElement.IteratorDestructuringAssignmentEvaluation(iteratorRecord)


def parse_AssignmentElementList(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentElementList[Yield, Await] :
    #       AssignmentElisionElement[?Yield, ?Await]
    #       AssignmentElementList[?Yield, ?Await] , AssignmentElisionElement[?Yield, ?Await]
    def parse(pos, previous=None):
        if previous is None:
            aee1 = parse_AssignmentElisionElement(context, lexer, pos, strict, Yield, Await)
            if aee1:
                return lambda: parse(
                    aee1.after, P2_AssignmentElementList_AssignmentElisionElement(context, strict, [aee1])
                )
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                aee2 = parse_AssignmentElisionElement(context, lexer, comma.span.after, strict, Yield, Await)
                if aee2:
                    return lambda: parse(
                        aee2.after,
                        P2_AssignmentElementList_AssignmentElementList_AssignmentElisionElement(
                            context, strict, [previous, comma, aee2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓔𝓵𝓲𝓼𝓲𝓸𝓷𝓔𝓵𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   AssignmentElisionElement :
#       Elision[opt] AssignmentElement


class P2_AssignmentElisionElement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentElisionElement", strict, children)


class P2_AssignmentElisionElement_Elision_AssignmentElement(P2_AssignmentElisionElement):
    @property
    def Elision(self):
        return self.children[0]

    @property
    def AssignmentElement(self):
        return self.children[1]

    def IteratorDestructuringAssignmentEvaluation(self, iteratorRecord):
        # 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation
        #   With parameter iteratorRecord.
        # AssignmentElisionElement : Elision AssignmentElement
        #   1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
        #   2. Return the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElement with
        #      iteratorRecord as the argument.
        self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        return self.AssignmentElement.IteratorDestructuringAssignmentEvaluation(iteratorRecord)


class P2_AssignmentElisionElement_AssignmentElement(P2_AssignmentElisionElement):
    @property
    def AssignmentElement(self):
        return self.children[0]


def parse_AssignmentElisionElement(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentElisionElement[Yield, Await] :
    #       Elision[opt] AssignmentElement[?Yield, ?Await]
    elision = parse_Elision(context, lexer, pos, strict)
    ae = parse_AssignmentElement(context, lexer, elision.after if elision else pos, strict, Yield, Await)
    if ae:
        children = list(filter(lambda x: x is not None, [elision, ae]))
        ctor = (
            P2_AssignmentElisionElement_AssignmentElement
            if elision is None
            else P2_AssignmentElisionElement_Elision_AssignmentElement
        )
        return ctor(context, strict, children)
    return None


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂 =======--------
# Syntax
#   AssignmentProperty :
#       IdentifierReference Initializer[opt]
#       PropertyName : AssignmentElement


class P2_AssignmentProperty(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentProperty", strict, children)


class P2_AssignmentProperty_IdentifierReference_Initializer(P2_AssignmentProperty):
    @property
    def IdentifierReference(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def EarlyErrors(self):
        # 12.15.5.1 Static Semantics: Early Errors
        # AssignmentProperty : IdentifierReference Initializer
        #   * It is a Syntax Error if AssignmentTargetType of IdentifierReference is not simple.
        return list(
            filter(
                None,
                [
                    self.IdentifierReference.AssignmentTargetType != SIMPLE
                    and self.CreateSyntaxError("Invalid destructuring assignment target")
                ],
            )
        )

    def PropertyDestructuringAssignmentEvaluation(self, value):
        # 12.15.5.3 Runtime Semantics: PropertyDestructuringAssignmentEvaluation
        #   With parameter value.
        # AssignmentProperty : IdentifierReference Initializer
        #   1. Let P be StringValue of IdentifierReference.
        #   2. Let lref be ? ResolveBinding(P).
        #   3. Let v be ? GetV(value, P).
        #   4. If Initializer is present and v is undefined, then
        #       a. Let defaultValue be the result of evaluating Initializer.
        #       b. Set v to ? GetValue(defaultValue).
        #       c. If IsAnonymousFunctionDefinition(Initializer) is true, then
        #           i. Let hasNameProperty be ? HasOwnProperty(v, "name").
        #           ii. If hasNameProperty is false, perform SetFunctionName(v, P).
        #   5. Perform ? PutValue(lref, v).
        #   6. Return a new List containing P.
        P = self.IdentifierReference.StringValue
        lref = ResolveBinding(P, self.strict)
        v = GetV(value, P)
        if self.Initializer and v is None:
            defaultValue = self.Initializer.evaluate()
            v = GetValue(defaultValue)
            if IsAnonymousFunctionDefinition(self.Initializer):
                hasNameProperty = HasOwnProperty(v, "name")
                if not hasNameProperty:
                    SetFunctionName(v, P)
        PutValue(lref, v)
        return [P]


class P2_AssignmentProperty_IdentifierReference(P2_AssignmentProperty_IdentifierReference_Initializer):
    Initializer = None


class P2_AssignmentProperty_PropertyName_AssignmentElement(P2_AssignmentProperty):
    @property
    def PropertyName(self):
        return self.children[0]

    @property
    def AssignmentElement(self):
        return self.children[2]

    def PropertyDestructuringAssignmentEvaluation(self, value):
        # 12.15.5.3 Runtime Semantics: PropertyDestructuringAssignmentEvaluation
        #   With parameter value.
        # AssignmentProperty : PropertyName : AssignmentElement
        #   1. Let name be the result of evaluating PropertyName.
        #   2. ReturnIfAbrupt(name).
        #   3. Perform ? KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.
        #   4. Return a new List containing name.
        name = self.PropertyName.evaluate()
        self.AssignmentElement.KeyedDestructuringAssignmentEvaluation(value, name)
        return [name]


def parse_AssignmentProperty(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentProperty[Yield, Await] :
    #       IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await][opt]
    #       PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await]
    #
    pn = parse_PropertyName(context, lexer, pos, strict, Yield, Await)
    if pn:
        colon = lexer.token_if(pn.after, ":")
        if colon:
            ae = parse_AssignmentElement(context, lexer, colon.span.after, strict, Yield, Await)
            if ae:
                return P2_AssignmentProperty_PropertyName_AssignmentElement(context, strict, [pn, colon, ae])
    ir = parse_IdentifierReference(context, lexer, pos, strict, Yield, Await)
    if ir:
        init = parse_Initializer(context, lexer, ir.after, strict, True, Yield, Await)
        if init:
            return P2_AssignmentProperty_IdentifierReference_Initializer(context, strict, [ir, init])
        return P2_AssignmentProperty_IdentifierReference(context, strict, [ir])
    return None


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓔𝓵𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   AssignmentElement :
#       DestructuringAssignmentTarget Initializer[opt]


class P2_AssignmentElement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentElement", strict, children)


class P2_AssignmentElement_DestructuringAssignmentTarget_Initializer(P2_AssignmentElement):
    @property
    def DestructuringAssignmentTarget(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def IteratorDestructuringAssignmentEvaluation(self, iteratorRecord):
        # 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation
        #   With parameter iteratorRecord.
        # AssignmentElement : DestructuringAssignmentTarget Initializer
        #   1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
        #       a. Let lref be the result of evaluating DestructuringAssignmentTarget.
        #       b. ReturnIfAbrupt(lref).
        #   2. If iteratorRecord.[[Done]] is false, then
        #       a. Let next be IteratorStep(iteratorRecord).
        #       b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #       c. ReturnIfAbrupt(next).
        #       d. If next is false, set iteratorRecord.[[Done]] to true.
        #       e. Else,
        #           i. Let value be IteratorValue(next).
        #           ii. If value is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           iii. ReturnIfAbrupt(value).
        #   3. If iteratorRecord.[[Done]] is true, let value be undefined.
        #   4. If Initializer is present and value is undefined, then
        #       a. Let defaultValue be the result of evaluating Initializer.
        #       b. Let v be ? GetValue(defaultValue).
        #   5. Else, let v be value.
        #   6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
        #       a. Let nestedAssignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
        #       b. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.
        #   7. If Initializer is present and value is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then
        #       a. Let hasNameProperty be ? HasOwnProperty(v, "name").
        #       b. If hasNameProperty is false, perform SetFunctionName(v, GetReferencedName(lref)).
        #   8. Return ? PutValue(lref, v).
        is_structured_literal = self.DestructuringAssignmentTarget.Is(
            "ObjectLiteral"
        ) or self.DestructuringAssignmentTarget.Is("ArrayLiteral")
        if not is_structured_literal:
            lref = self.DestructuringAssignmentTarget.evaluate()
        if not iteratorRecord.Done:
            try:
                nextStep = IteratorStep(iteratorRecord)
                if not nextStep:
                    iteratorRecord.Done = True
                else:
                    value = IteratorValue(nextStep)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
        if iteratorRecord.Done:
            value = None
        if self.Initializer and value is None:
            defaultValue = self.Initializer.evaluate()
            v = GetValue(defaultValue)
        else:
            v = value
        if is_structured_literal:
            nestedAssignmentPattern = self.DestructuringAssignmentTarget.covering("AssignmentPattern")
            return nestedAssignmentPattern.DestructuringAssignmentEvaluation(v)
        if (
            self.Initializer
            and value is None
            and IsAnonymousFunctionDefinition(self.Initializer)
            and self.DestructuringAssignmentTarget.IsIdentifierRef()
        ):
            if not HasOwnProperty(v, "name"):
                SetFunctionName(v, GetReferencedName(lref))
        return PutValue(lref, v)
        # NOTE
        # Left to right evaluation order is maintained by evaluating a DestructuringAssignmentTarget that is not a
        # destructuring pattern prior to accessing the iterator or evaluating the Initializer.

    def KeyedDestructuringAssignmentEvaluation(self, value, propertyName):
        # 12.15.5.6 Runtime Semantics: KeyedDestructuringAssignmentEvaluation
        #   With parameters value and propertyName.
        # AssignmentElement : DestructuringAssignmentTarget Initializer
        #   1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
        #       a. Let lref be the result of evaluating DestructuringAssignmentTarget.
        #       b. ReturnIfAbrupt(lref).
        #   2. Let v be ? GetV(value, propertyName).
        #   3. If Initializer is present and v is undefined, then
        #       a. Let defaultValue be the result of evaluating Initializer.
        #       b. Let rhsValue be ? GetValue(defaultValue).
        #   4. Else, let rhsValue be v.
        #   5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
        #       a. Let assignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
        #       b. Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.
        #   6. If Initializer is present and v is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then
        #       a. Let hasNameProperty be ? HasOwnProperty(rhsValue, "name").
        #       b. If hasNameProperty is false, perform SetFunctionName(rhsValue, GetReferencedName(lref)).
        #   7. Return ? PutValue(lref, rhsValue).
        is_structured_literal = self.DestructuringAssignmentTarget.Is(
            "ObjectLiteral"
        ) or self.DestructuringAssignmentTarget.Is("ArrayLiteral")
        if not is_structured_literal:
            lref = self.DestructuringAssignmentTarget.evaluate()
        v = GetV(value, propertyName)
        if self.Initializer and v is None:
            defaultValue = self.Initializer.evaluate()
            rhsValue = GetValue(defaultValue)
        else:
            rhsValue = v
        if is_structured_literal:
            assignmentPattern = self.DestructuringAssignmentTarget.covering("AssignmentPattern")
            return assignmentPattern.DestructuringAssignmentEvaluation(rhsValue)
        if (
            self.Initializer
            and v is None
            and IsAnonymousFunctionDefinition(self.Initializer)
            and self.DestructuringAssignmentTarget.IsIdentifierRef()
        ):
            if not HasOwnProperty(rhsValue, "name"):
                SetFunctionName(rhsValue, GetReferencedName(lref))
        return PutValue(lref, rhsValue)


class P2_AssignmentElement_DestructuringAssignmentTarget(
    P2_AssignmentElement_DestructuringAssignmentTarget_Initializer
):
    Initializer = None


def parse_AssignmentElement(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentElement[Yield, Await] :
    #       DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await][opt]
    #
    dat = parse_DestructuringAssignmentTarget(context, lexer, pos, strict, Yield, Await)
    if dat:
        init = parse_Initializer(context, lexer, dat.after, strict, True, Yield, Await)
        if init:
            return P2_AssignmentElement_DestructuringAssignmentTarget_Initializer(context, strict, [dat, init])
        return P2_AssignmentElement_DestructuringAssignmentTarget(context, strict, [dat])
    return None


# --------======= 𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓡𝓮𝓼𝓽𝓔𝓵𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   AssignmentRestElement :
#       ... DestructuringAssignmentTarget


class P2_AssignmentRestElement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "AssignmentRestElement", strict, children)


class P2_AssignmentRestElement_DestructuringAssignmentTarget(P2_AssignmentRestElement):
    @property
    def DestructuringAssignmentTarget(self):
        return self.children[1]

    def IteratorDestructuringAssignmentEvaluation(self, iteratorRecord):
        # 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation
        #   With parameter iteratorRecord.
        # AssignmentRestElement : ... DestructuringAssignmentTarget
        #   1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
        #       a. Let lref be the result of evaluating DestructuringAssignmentTarget.
        #       b. ReturnIfAbrupt(lref).
        #   2. Let A be ! ArrayCreate(0).
        #   3. Let n be 0.
        #   4. Repeat, while iteratorRecord.[[Done]] is false,
        #       a. Let next be IteratorStep(iteratorRecord).
        #       b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #       c. ReturnIfAbrupt(next).
        #       d. If next is false, set iteratorRecord.[[Done]] to true.
        #       e. Else,
        #           i. Let nextValue be IteratorValue(next).
        #           ii. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           iii. ReturnIfAbrupt(nextValue).
        #           iv. Let status be CreateDataProperty(A, ! ToString(n), nextValue).
        #           v. Assert: status is true.
        #           vi. Increment n by 1.
        #   5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
        #       a. Return ? PutValue(lref, A).
        #   6. Let nestedAssignmentPattern be the AssignmentPattern that is covered by DestructuringAssignmentTarget.
        #   7. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.
        is_structured_literal = self.DestructuringAssignmentTarget.Is(
            "ObjectLiteral"
        ) or self.DestructuringAssignmentTarget.Is("ArrayLiteral")
        if not is_structured_literal:
            lref = self.DestructuringAssignmentTarget.evaluate()
        A = ArrayCreate(0)
        n = 0
        while not iteratorRecord.Done:
            try:
                next_step = IteratorStep(iteratorRecord)
                if not next_step:
                    iteratorRecord.Done = True
                else:
                    nextValue = IteratorValue(next_step)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            status = CreateDataProperty(A, ToString(n), nextValue)
            assert status
            n += 1
        if not is_structured_literal:
            return PutValue(lref, A)
        nestedAssignmentPattern = self.DestructuringAssignmentTarget.covering("AssignmentPattern")
        return nestedAssignmentPattern.DestructuringAssignmentEvaluation(A)


def parse_AssignmentRestElement(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   AssignmentRestElement[Yield, Await] :
    #       ... DestructuringAssignmentTarget[?Yield, ?Await]
    dots = lexer.token_if(pos, "...")
    if dots:
        dat = parse_DestructuringAssignmentTarget(context, lexer, dots.span.after, strict, Yield, Await)
        if dat:
            return P2_AssignmentRestElement_DestructuringAssignmentTarget(context, strict, [dots, dat])
    return None


# --------======= 𝓓𝓮𝓼𝓽𝓻𝓾𝓬𝓽𝓾𝓻𝓲𝓷𝓰𝓐𝓼𝓼𝓲𝓰𝓷𝓶𝓮𝓷𝓽𝓣𝓪𝓻𝓰𝓮𝓽 =======--------
# Syntax
#   DestructuringAssignmentTarget :
#       LeftHandSideExpression


class P2_DestructuringAssignmentTarget(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "DestructuringAssignmentTarget", strict, children)


class P2_DestructuringAssignmentTarget_LeftHandSideExpression(P2_DestructuringAssignmentTarget):
    @property
    def LeftHandSideExpression(self):
        return self.children[0]

    def EarlyErrors(self):
        # 12.15.5.1 Static Semantics: Early Errors
        # DestructuringAssignmentTarget : LeftHandSideExpression
        #   * It is a Syntax Error if LeftHandSideExpression is either an ObjectLiteral or an ArrayLiteral and if
        #     LeftHandSideExpression is not covering an AssignmentPattern.
        #   * It is a Syntax Error if LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral and
        #     AssignmentTargetType(LeftHandSideExpression) is not simple.
        is_structured_literal = any(self.LeftHandSideExpression.Is(sym) for sym in ("ObjectLiteral", "ArrayLiteral"))
        return list(
            filter(
                None,
                [
                    is_structured_literal
                    and not self.LeftHandSideExpression.AssignmentPattern
                    and self.CreateSyntaxError(f"Invalid Assignment Pattern: {self.LeftHandSideExpression}"),
                    not is_structured_literal
                    and self.LeftHandSideExpression.AssignmentTargetType != SIMPLE
                    and self.CreateSyntaxError(f"Invalid Assignment Target: {self.LeftHandSideExpression}"),
                ],
            )
        )


def parse_DestructuringAssignmentTarget(context, lexer, pos, strict, Yield, Await):
    # 12.15.5 Destructuring Assignment
    # Syntax
    #   DestructuringAssignmentTarget[Yield, Await] :
    #       LeftHandSideExpression[?Yield, ?Await]
    lhs = parse_LeftHandSideExpression(context, lexer, pos, strict, Yield, Await)
    if lhs:
        return P2_DestructuringAssignmentTarget_LeftHandSideExpression(context, strict, [lhs])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.       .d8888b.
# d8888   d88P  Y88b     d8888   d88P  Y88b     d88P  Y88b
#   888          888       888   888            888    888
#   888        .d88P       888   888d888b.      888         .d88b.  88888b.d88b.  88888b.d88b.   8888b.
#   888    .od888P"        888   888P "Y88b     888        d88""88b 888 "888 "88b 888 "888 "88b     "88b
#   888   d88P"            888   888    888     888    888 888  888 888  888  888 888  888  888 .d888888
#   888   888"       d8b   888   Y88b  d88P     Y88b  d88P Y88..88P 888  888  888 888  888  888 888  888
# 8888888 888888888  Y8P 8888888  "Y8888P"       "Y8888P"   "Y88P"  888  888  888 888  888  888 "Y888888
#
#
#
#  .d88888b.                                     888                           .d88             88b.
# d88P" "Y88b                                    888                          d88P"             "Y88b
# 888     888                                    888                         d88P                 Y88b
# 888     888 88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888     888                   888
# 888     888 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"       888                   888
# 888     888 888  888 88888888 888     .d888888 888    888  888 888         Y88b                 d88P
# Y88b. .d88P 888 d88P Y8b.     888     888  888 Y88b.  Y88..88P 888          Y88b.     d8b     .d88P
#  "Y88888P"  88888P"   "Y8888  888     "Y888888  "Y888  "Y88P"  888           "Y88     88P     88P"
#             888                                                                       8P
#             888                                                                       "
#             888
#
#######################################################################################################################
# 12.16 Comma Operator ( , )
# 12.16.1 SS: IsFunctionDefinition
# 12.16.2 SS: AssignmentTargetType
# 12.16.3 RS: Evaluation
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟐.𝟏𝟔 𝓒𝓸𝓶𝓶𝓪 𝓞𝓹𝓮𝓻𝓪𝓽𝓸𝓻 ( , ) .....●·._..●·._..●·._.·´ #
####################################################################################
# 12.16 Comma Operator ( , )

# --------======= 𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   Expression :
#       AssignmentExpression
#       Expression , AssignmentExpression
#
class P2_Expression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Expression", strict, children)


class P2_Expression_AssignmentExpression(P2_Expression):
    # Expression : AssignmentExpression
    @property
    def AssignmentExpression(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.AssignmentExpression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.AssignmentExpression.HasUseStrict


class P2_Expression_Expression_COMMA_AssignmentExpression(P2_Expression):
    # Expression : Expression , AssignmentExpression
    @property
    def Expression(self):
        return self.children[0]

    @property
    def AssignmentExpression(self):
        return self.children[2]

    def IsFunctionDefinition(self):
        # 12.16.1 Static Semantics: IsFunctionDefinition
        # Expression : Expression , AssignmentExpression
        #   1. Return false.
        return False

    # 12.16.2 Static Semantics: AssignmentTargetType
    # Expression : Expression , AssignmentExpression
    #   1. Return invalid.
    AssignmentTargetType = INVALID

    def evaluate(self):
        # 12.16.3 Runtime Semantics: Evaluation
        # Expression : Expression , AssignmentExpression
        #   1. Let lref be the result of evaluating Expression.
        #   2. Perform ? GetValue(lref).
        #   3. Let rref be the result of evaluating AssignmentExpression.
        #   4. Return ? GetValue(rref).
        lref = self.Expression.evaluate()
        GetValue(lref)  # Have to run, thanks to side effect.
        rref = self.AssignmentExpression.evaluate()
        return GetValue(rref)
        # NOTE  | GetValue must be called even though its value is not used because it may have observable
        #       | side-effects.


def parse_Expression(ctx, lexer, pos, strict, In, Yield, Await):
    # 12.16 Comma Operator ( , )
    # Syntax
    #   Expression[In, Yield, Await]:
    #       AssignmentExpression[?In, ?Yield, ?Await]
    #       Expression[?In, ?Yield, ?Await] , AssignmentExpression[?In, ?Yield, ?Await]
    def parse(pos, previous=None):
        if previous is None:
            ae1 = parse_AssignmentExpression(ctx, lexer, pos, strict, In, Yield, Await)
            if ae1:
                return lambda: parse(ae1.after, P2_Expression_AssignmentExpression(ctx, strict, [ae1]))
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                ae2 = parse_AssignmentExpression(ctx, lexer, comma.span.after, strict, In, Yield, Await)
                if ae2:
                    return lambda: parse(
                        ae2.after,
                        P2_Expression_Expression_COMMA_AssignmentExpression(ctx, strict, [previous, comma, ae2]),
                    )
        return previous

    return trampoline(lambda: parse(pos))


#######################################################################################################################
#
#  d888    .d8888b.
# d8888   d88P  Y88b
#   888        .d88P
#   888       8888"
#   888        "Y8b.
#   888   888    888
#   888   Y88b  d88P
# 8888888  "Y8888P"
#
#
#
# 8888888888  .d8888b.  888b     d888        d8888  .d8888b.                   d8b          888
# 888        d88P  Y88b 8888b   d8888       d88888 d88P  Y88b                  Y8P          888
# 888        888    888 88888b.d88888      d88P888 Y88b.                                    888
# 8888888    888        888Y88888P888     d88P 888  "Y888b.    .d8888b 888d888 888 88888b.  888888
# 888        888        888 Y888P 888    d88P  888     "Y88b. d88P"    888P"   888 888 "88b 888
# 888        888    888 888  Y8P  888   d88P   888       "888 888      888     888 888  888 888
# 888        Y88b  d88P 888   "   888  d8888888888 Y88b  d88P Y88b.    888     888 888 d88P Y88b.
# 8888888888  "Y8888P"  888       888 d88P     888  "Y8888P"   "Y8888P 888     888 88888P"   "Y888
#                                                                                  888
#                                                                                  888
#                                                                                  888
# 888
# 888
# 888
# 888       8888b.  88888b.   .d88b.  888  888  8888b.   .d88b.   .d88b.  d8b
# 888          "88b 888 "88b d88P"88b 888  888     "88b d88P"88b d8P  Y8b Y8P
# 888      .d888888 888  888 888  888 888  888 .d888888 888  888 88888888
# 888      888  888 888  888 Y88b 888 Y88b 888 888  888 Y88b 888 Y8b.     d8b
# 88888888 "Y888888 888  888  "Y88888  "Y88888 "Y888888  "Y88888  "Y8888  Y8P
#                                 888                        888
#                            Y8b d88P                   Y8b d88P
#                             "Y88P"                     "Y88P"
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888 .d8888b
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888    88K
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888    "Y8888b.
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.       X88
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888  88888P'
#
#
#
#                        888
#                        888
#                        888
#  8888b.  88888b.   .d88888
#     "88b 888 "88b d88" 888
# .d888888 888  888 888  888
# 888  888 888  888 Y88b 888
# "Y888888 888  888  "Y88888
#
#
#
# 8888888b.                    888                           888    d8b
# 888  "Y88b                   888                           888    Y8P
# 888    888                   888                           888
# 888    888  .d88b.   .d8888b 888  8888b.  888d888  8888b.  888888 888  .d88b.  88888b.  .d8888b
# 888    888 d8P  Y8b d88P"    888     "88b 888P"       "88b 888    888 d88""88b 888 "88b 88K
# 888    888 88888888 888      888 .d888888 888     .d888888 888    888 888  888 888  888 "Y8888b.
# 888  .d88P Y8b.     Y88b.    888 888  888 888     888  888 Y88b.  888 Y88..88P 888  888      X88
# 8888888P"   "Y8888   "Y8888P 888 "Y888888 888     "Y888888  "Y888 888  "Y88P"  888  888  88888P'
#
#######################################################################################################################
# 13 ECMAScript Language: Statements and Declarations
# 13.1 Statement Semantics
# 13.1.1 SS: ContainsDuplicateLabels
# 13.1.2 SS: ContainsUndefinedBreakTarget
# 13.1.3 SS: ContainsUndefinedContinueTarget
# 13.1.4 SS: DeclarationPart
# 13.1.5 SS: VarDeclaredNames
# 13.1.6 SS: VarScopedDeclarations
# 13.1.7 RS: LabelledEvaluation
# 13.1.8 RS: Evaluation
#######################################################################################################################

##################################################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑 𝓔𝓒𝓜𝓐𝓢𝓬𝓻𝓲𝓹𝓽 𝓛𝓪𝓷𝓰𝓾𝓪𝓰𝓮: 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓼 𝓪𝓷𝓭 𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷𝓼 .....●·._..●·._..●·._.·´ #
##################################################################################################################
# 13 ECMAScript Language: Statements and Declarations

# --------======= 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
# Statement :
#   BlockStatement
#   VariableStatement
#   EmptyStatement
#   ExpressionStatement
#   IfStatement
#   BreakableStatement
#   ContinueStatement
#   BreakStatement
#   ReturnStatement
#   WithStatement
#   LabelledStatement
#   ThrowStatement
#   TryStatement
#   DebuggerStatement
class P2_Statement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Statement", strict, children)

    def faux_LexicallyDeclaredNames(self):
        # 13.2.5 Static Semantics: LexicallyDeclaredNames
        # (This is the default implementation.)
        # Statement : BlockStatement
        # Statement : VariableStatement
        # Statement : EmptyStatement
        # Statement : ExpressionStatement
        # Statement : IfStatement
        # Statement : BreakableStatement
        # Statement : ContinueStatement
        # Statement : BreakStatement
        # Statement : ReturnStatement
        # Statement : WithStatement
        # Statement : ThrowStatement
        # Statement : TryStatement
        # Statement : DebuggerStatement
        #   1. Return a new empty List.

        # Implementation Notes:
        #   * This is a "derived" part of the spec. (I.e.: it's me making sense of other parts of the spec.
        #     See 13.2.5.)
        #   * There's a non-default implementation for LexicallyDeclaredNames on Statement:LabelledStatement nodes, the
        #     routine here is esentially the else clause of the StatementListItem:Statement form of
        #     LexicallyDeclaredNames.
        return []

    def faux_LexicallyScopedDeclarations(self):
        # 13.2.6 Static Semantics: LexicallyScopedDeclarations
        # Statement : [not LabelledStatement]
        #   1. Return a new empty List.
        # Implementation Note: Same deal as above.
        return []

    def faux_TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # Statement : [not LabelledStatement]
        #   1. Return VarDeclaredNames of Statement.
        # (This is a derived spec. Source is in StatementListItem:Statement of 13.2.9.)
        return self.VarDeclaredNames()

    def faux_TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # Statement : [not LabelledStatement]
        #   1. Return VarScopedDeclarations of Statement.
        # (This is a derived spec. Source is in StatementListItem:Statement of 13.2.10.)
        return self.VarScopedDeclarations()


class P2_Statement_CannotContainDuplicateLabels:
    # Mixin for nodes that cannot contain duplicate labels
    def ContainsDuplicateLabels(self, labelSet):
        # 13.1.1 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # Statement : VariableStatement
        # Statement : EmptyStatement
        # Statement : ExpressionStatement
        # Statement : ContinueStatement
        # Statement : BreakStatement
        # Statement : ReturnStatement
        # Statement : ThrowStatement
        # Statement : DebuggerStatement
        #   1. Return false.
        return False


class P2_Statement_CannotContainBreak:
    # Mixin for nodes that cannot contain break statements
    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.1.2 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # Statement : VariableStatement
        # Statement : EmptyStatement
        # Statement : ExpressionStatement
        # Statement : ContinueStatement
        # Statement : ReturnStatement
        # Statement : ThrowStatement
        # Statement : DebuggerStatement
        #   1. Return false.
        return False


class P2_Statement_CannotContainContinue:
    # Mixin for nodes that cannot contain continue statements

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.1.3 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # Statement : VariableStatement
        # Statement : EmptyStatement
        # Statement : ExpressionStatement
        # Statement : BreakStatement
        # Statement : ReturnStatement
        # Statement : ThrowStatement
        # Statement : DebuggerStatement
        #   1. Return false.
        return False


class P2_Statement_CannotContainDeclarations:
    # Mixin for nodes that cannot contain declarations

    def VarDeclaredNames(self):
        # 13.1.5 Static Semantics: VarDeclaredNames
        # Statement : EmptyStatement
        # Statement : ExpressionStatement
        # Statement : ContinueStatement
        # Statement : BreakStatement
        # Statement : ReturnStatement
        # Statement : ThrowStatement
        # Statement : DebuggerStatement
        #   1. Return a new empty List.
        return []

    def VarScopedDeclarations(self):
        # 13.1.6 Static Semantics: VarScopedDeclarations
        # Statement : EmptyStatement
        # Statement : ExpressionStatement
        # Statement : ContinueStatement
        # Statement : BreakStatement
        # Statement : ReturnStatement
        # Statement : ThrowStatement
        # Statement : DebuggerStatement
        #   1. Return a new empty List.
        return []


class P2_Statement_BlockStatement(P2_Statement):
    # 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 : 𝓑𝓵𝓸𝓬𝓴𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽
    @property
    def BlockStatement(self):
        return self.children[0]


class P2_Statement_VariableStatement(
    P2_Statement_CannotContainContinue,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement_CannotContainBreak,
    P2_Statement,
):
    # 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 : 𝓥𝓪𝓻𝓲𝓪𝓫𝓵𝓮𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽
    @property
    def VariableStatement(self):
        return self.children[0]


class P2_Statement_EmptyStatement(
    P2_Statement_CannotContainContinue,
    P2_Statement_CannotContainDeclarations,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement_CannotContainBreak,
    P2_Statement,
):
    # 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 : 𝓔𝓶𝓹𝓽𝔂𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽
    @property
    def EmptyStatement(self):
        return self.children[0]


class P2_Statement_ExpressionStatement(
    P2_Statement_CannotContainContinue,
    P2_Statement_CannotContainDeclarations,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement_CannotContainBreak,
    P2_Statement,
):
    # Statement : ExpressionStatement
    @property
    def ExpressionStatement(self):
        return self.children[0]

    @cached_property
    def IsStringLiteral(self):
        return self.ExpressionStatement.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.ExpressionStatement.HasUseStrict


class P2_Statement_IfStatement(P2_Statement):
    # Statement : IfStatement
    @property
    def IfStatement(self):
        return self.children[0]


class P2_Statement_BreakableStatement(P2_Statement):
    # Statement : BreakableStatement
    @property
    def BreakableStatement(self):
        return self.children[0]


class P2_Statement_ContinueStatement(
    P2_Statement_CannotContainDeclarations,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement_CannotContainBreak,
    P2_Statement,
):
    # Statement : ContinueStatement
    @property
    def ContinueStatement(self):
        return self.children[0]


class P2_Statement_BreakStatement(
    P2_Statement_CannotContainContinue,
    P2_Statement_CannotContainDeclarations,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement,
):
    # Statement : BreakStatement
    @property
    def BreakStatement(self):
        return self.children[0]


class P2_Statement_ReturnStatement(
    P2_Statement_CannotContainContinue,
    P2_Statement_CannotContainDeclarations,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement_CannotContainBreak,
    P2_Statement,
):
    # Statement : ReturnStatement
    @property
    def ReturnStatement(self):
        return self.children[0]


class P2_Statement_WithStatement(P2_Statement):
    # Statement : WithStatement
    @property
    def WithStatement(self):
        return self.children[0]


class P2_Statement_LabelledStatement(P2_Statement):
    # Statement : LabelledStatement
    @property
    def LabelledStatement(self):
        return self.children[0]

    def faux_LexicallyDeclaredNames(self):
        # 13.2.5 Static Semantics: LexicallyDeclaredNames
        # Statement : LabelledStatement
        #   1. Return LexicallyDeclaredNames of LabelledStatement.

        # Implementation Notes:
        #   * This is a "derived" part of the spec. (I.e.: it's me making sense of other parts of the spec.
        #     See 13.2.5.)
        #   * There's a default implementation for LexicallyDeclaredNames on Statement nodes, rather than a deferral,
        #     so we need to override it here for labeled statements (which actually do defer).
        return self.LabelledStatement.LexicallyDeclaredNames()

    def faux_LexicallyScopedDeclarations(self):
        # 13.2.6 Static Semantics: LexicallyScopedDeclarations
        # Statement : LabelledStatement
        #   1. Return LexicallyScopedDeclarations of LabelledStatement.
        # (This is a derived spec, as the prior routine is.)
        return self.LabelledStatement.LexicallyScopedDeclarations()

    def faux_TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # Statement : LabelledStatement
        #   1. Return TopLevelVarDeclaredNames of Statement.
        # (This is a derived spec. See the associated clause for StatementListItem:Statement.)
        return self.TopLevelVarDeclaredNames()

    def faux_TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # Statement : LabelledStatement
        #   1. Return TopLevelVarScopedDeclarations of Statement.
        # (This is a derived spec. See the StatementListItem:Statement clause of 13.2.10.)
        return self.TopLevelVarScopedDeclarations()


class P2_Statement_ThrowStatement(
    P2_Statement_CannotContainContinue,
    P2_Statement_CannotContainDeclarations,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement_CannotContainBreak,
    P2_Statement,
):
    # Statement : ThrowStatement
    @property
    def ThrowStatement(self):
        return self.children[0]


class P2_Statement_TryStatement(P2_Statement):
    # Statement : TryStatement
    @property
    def TryStatement(self):
        return self.children[0]


class P2_Statement_DebuggerStatement(
    P2_Statement_CannotContainContinue,
    P2_Statement_CannotContainDeclarations,
    P2_Statement_CannotContainDuplicateLabels,
    P2_Statement_CannotContainBreak,
    P2_Statement,
):
    # Statement : DebuggerStatement
    @property
    def DebuggerStatement(self):
        return self.children[0]


def parse_Statement(ctx, lexer, pos, strict, Yield, Await, Return):
    # 13 ECMAScript Language: Statements and Declarations
    # Syntax
    # Statement[Yield, Await, Return]:
    #   BlockStatement[?Yield, ?Await, ?Return]
    #   VariableStatement[?Yield, ?Await]
    #   EmptyStatement
    #   ExpressionStatement[?Yield, ?Await]
    #   IfStatement[?Yield, ?Await, ?Return]
    #   BreakableStatement[?Yield, ?Await, ?Return]
    #   ContinueStatement[?Yield, ?Await]
    #   BreakStatement[?Yield, ?Await]
    #   [+Return]ReturnStatement[?Yield, ?Await]
    #   WithStatement[?Yield, ?Await, ?Return]
    #   LabelledStatement[?Yield, ?Await, ?Return]
    #   ThrowStatement[?Yield, ?Await]
    #   TryStatement[?Yield, ?Await, ?Return]
    #   DebuggerStatement
    block_statement = parse_BlockStatement(ctx, lexer, pos, strict, Yield, Await, Return)
    if block_statement:
        return P2_Statement_BlockStatement(ctx, strict, [block_statement])
    variable_statement = parse_VariableStatement(ctx, lexer, pos, strict, Yield, Await)
    if variable_statement:
        return P2_Statement_VariableStatement(ctx, strict, [variable_statement])
    empty_statement = parse_EmptyStatement(ctx, lexer, pos, strict)
    if empty_statement:
        return P2_Statement_EmptyStatement(ctx, strict, [empty_statement])
    expression_statement = parse_ExpressionStatement(ctx, lexer, pos, strict, Yield, Await)
    if expression_statement:
        return P2_Statement_ExpressionStatement(ctx, strict, [expression_statement])
    if_statement = parse_IfStatement(ctx, lexer, pos, strict, Yield, Await, Return)
    if if_statement:
        return P2_Statement_IfStatement(ctx, strict, [if_statement])
    breakable_statement = parse_BreakableStatement(ctx, lexer, pos, strict, Yield, Await, Return)
    if breakable_statement:
        return P2_Statement_BreakableStatement(ctx, strict, [breakable_statement])
    continue_statement = parse_ContinueStatement(ctx, lexer, pos, strict, Yield, Await)
    if continue_statement:
        return P2_Statement_ContinueStatement(ctx, strict, [continue_statement])
    break_statement = parse_BreakStatement(ctx, lexer, pos, strict, Yield, Await)
    if break_statement:
        return P2_Statement_BreakStatement(ctx, strict, [break_statement])
    if Return:
        return_statement = parse_ReturnStatement(ctx, lexer, pos, strict, Yield, Await)
        if return_statement:
            return P2_Statement_ReturnStatement(ctx, strict, [return_statement])
    with_statement = parse_WithStatement(ctx, lexer, pos, strict, Yield, Await, Return)
    if with_statement:
        return P2_Statement_WithStatement(ctx, strict, [with_statement])
    labelled_statement = parse_LabelledStatement(ctx, lexer, pos, strict, Yield, Await, Return)
    if labelled_statement:
        return P2_Statement_LabelledStatement(ctx, strict, [labelled_statement])
    throw_statement = parse_ThrowStatement(ctx, lexer, pos, strict, Yield, Await)
    if throw_statement:
        return P2_Statement_ThrowStatement(ctx, strict, [throw_statement])
    try_statement = parse_TryStatement(ctx, lexer, pos, strict, Yield, Await, Return)
    if try_statement:
        return P2_Statement_TryStatement(ctx, strict, [try_statement])
    debugger_statement = parse_DebuggerStatement(ctx, lexer, pos, strict)
    if debugger_statement:
        return P2_Statement_DebuggerStatement(ctx, strict, [debugger_statement])
    return None


# --------======= 𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   Declaration :
#       HoistableDeclaration
#       ClassDeclaration
#       LexicalDeclaration


class P2_Declaration(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Declaration", strict, children)

    def faux_TopLevelLexicallyDeclaredNames(self):
        # 13.2.7 Static Semantics: TopLevelLexicallyDeclaredNames
        # Declaration : [not HoistableDeclaration]
        #   1. Return the BoundNames of Declaration.
        # (This is a derived sequence. See the StatementListItem:Declaration definition of this routine)
        return self.BoundNames()

    def faux_TopLevelLexicallyScopedDeclarations(self):
        # 13.2.8 Static Semantics: TopLevelLexicallyScopedDeclarations
        # Declaration : [not HoistableDeclaration]
        #   1. Return a new List containing Declaration.
        # (This is a derived sequence. See the StatementListItem:Declaration definition of this routine)
        return [self]

    def faux_TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # Declaration : [not HoistableDeclaration]
        #   1. Return a new empty List.
        # (This is a derived sequence. See the StatementListItem:Declaration definition of this routine)
        return []

    def faux_TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # Declaration : [not HoistableDeclaration]
        #   1. Return a new empty List.
        # (This is a derived spec. See the StatementListItem:Declaration clause of 13.2.10.)
        return []


class P2_Declaration_HoistableDeclaration(P2_Declaration):
    @property
    def HoistableDeclaration(self):
        return self.children[0]

    def faux_TopLevelLexicallyDeclaredNames(self):
        # 13.2.7 Static Semantics: TopLevelLexicallyDeclaredNames
        # Declaration : HoistableDeclaration
        #   1. Return « ».
        # (This is a derived sequence. See the StatementListItem:Declaration definition of this routine)
        return []

    def faux_TopLevelLexicallyScopedDeclarations(self):
        # 13.2.8 Static Semantics: TopLevelLexicallyScopedDeclarations
        # Declaration : HoistableDeclaration
        #   1. Return « ».
        # (This is a derived sequence. See the StatementListItem:Declaration definition of this routine)
        return []

    def faux_TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # Declaration : HoistableDeclaration
        #   1. Return the BoundNames of HoistableDeclaration.
        # (This is a derived sequence. See the StatementListItem:Declaration definition of this routine)
        return self.HoistableDeclaration.BoundNames()

    def faux_TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # Declaration : HoistableDeclaration
        #   1. Let declaration be DeclarationPart of HoistableDeclaration.
        #   2. Return « declaration ».
        # (This is a derived spec. See the StatementListItem:Declaration clause of 13.2.10.)
        return [self.HoistableDeclaration.DeclarationPart()]


class P2_Declaration_ClassDeclaration(P2_Declaration):
    @property
    def ClassDeclaration(self):
        return self.children[0]

    def DeclarationPart(self):
        # 13.1.4 Static Semantics: DeclarationPart
        # Declaration:ClassDeclaration
        #   1. Return ClassDeclaration.
        return self.ClassDeclaration


class P2_Declaration_LexicalDeclaration(P2_Declaration):
    @property
    def LexicalDeclaration(self):
        return self.children[0]

    def DeclarationPart(self):
        # 13.1.4 Static Semantics: DeclarationPart
        # Declaration : LexicalDeclaration
        #   1. Return LexicalDeclaration.
        return self.LexicalDeclaration


def parse_Declaration(context, lexer, pos, strict, Yield, Await):
    # 13 ECMAScript Language: Statements and Declarations
    # Syntax
    #   Declaration[Yield, Await] :
    #       HoistableDeclaration[?Yield, ?Await, ~Default]
    #       ClassDeclaration[?Yield, ?Await, ~Default]
    #       LexicalDeclaration[+In, ?Yield, ?Await]
    hd = parse_HoistableDeclaration(context, lexer, pos, strict, Yield, Await, False)
    if hd:
        return P2_Declaration_HoistableDeclaration(context, strict, [hd])
    cd = parse_ClassDeclaration(context, lexer, pos, strict, Yield, Await, False)
    if cd:
        return P2_Declaration_ClassDeclaration(context, strict, [cd])
    ld = parse_LexicalDeclaration(context, lexer, pos, strict, True, Yield, Await)
    if ld:
        return P2_Declaration_LexicalDeclaration(context, strict, [ld])
    return None


# --------======= 𝓗𝓸𝓲𝓼𝓽𝓪𝓫𝓵𝓮𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   HoistableDeclaration :
#       FunctionDeclaration
#       GeneratorDeclaration
#       AsyncFunctionDeclaration
#       AsyncGeneratorDeclaration


class P2_HoistableDeclaration(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "HoistableDeclaration", strict, children)


class P2_HoistableDeclaration_FunctionDeclaration(P2_HoistableDeclaration):
    @property
    def FunctionDeclaration(self):
        return self.children[0]

    def DeclarationPart(self):
        # 13.1.4 Static Semantics: DeclarationPart
        # HoistableDeclaration : FunctionDeclaration
        #   1. Return FunctionDeclaration.
        return self.FunctionDeclaration


class P2_HoistableDeclaration_GeneratorDeclaration(P2_HoistableDeclaration):
    @property
    def GeneratorDeclaration(self):
        return self.children[0]

    def DeclarationPart(self):
        # 13.1.4 Static Semantics: DeclarationPart
        # HoistableDeclaration:GeneratorDeclaration
        #   1. Return GeneratorDeclaration.
        return self.GeneratorDeclaration

    def evaluate(self):
        # 13.1.8 Runtime Semantics: Evaluation
        # HoistableDeclaration : GeneratorDeclaration
        #   1. Return NormalCompletion(empty).
        return EMPTY


class P2_HoistableDeclaration_AsyncFunctionDeclaration(P2_HoistableDeclaration):
    @property
    def AsyncFunctionDeclaration(self):
        return self.children[0]

    def DeclarationPart(self):
        # 13.1.4 Static Semantics: DeclarationPart
        # HoistableDeclaration : AsyncFunctionDeclaration
        #   1. Return AsyncFunctionDeclaration.
        return self.AsyncFunctionDeclaration

    def evaluate(self):
        # 13.1.8 Runtime Semantics: Evaluation
        # HoistableDeclaration : AsyncFunctionDeclaration
        #   1. Return NormalCompletion(empty).
        return EMPTY


class P2_HoistableDeclaration_AsyncGeneratorDeclaration(P2_HoistableDeclaration):
    @property
    def AsyncGeneratorDeclaration(self):
        return self.children[0]

    def DeclarationPart(self):
        # 13.1.4 Static Semantics: DeclarationPart
        # HoistableDeclaration : AsyncGeneratorDeclaration
        #   1. Return AsyncGeneratorDeclaration.
        return self.AsyncGeneratorDeclaration

    def evaluate(self):
        # 13.1.8 Runtime Semantics: Evaluation
        # HoistableDeclaration : AsyncGeneratorDeclaration
        #   1. Return NormalCompletion(empty).
        return EMPTY


def parse_HoistableDeclaration(context, lexer, pos, strict, Yield, Await, Default):
    # 13 ECMAScript Language: Statements and Declarations
    # Syntax
    #   HoistableDeclaration[Yield, Await, Default] :
    #       FunctionDeclaration[?Yield, ?Await, ?Default]
    #       GeneratorDeclaration[?Yield, ?Await, ?Default]
    #       AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
    #       AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]
    fd = parse_FunctionDeclaration(context, lexer, pos, strict, Yield, Await, Default)
    if fd:
        return P2_HoistableDeclaration_FunctionDeclaration(context, strict, [fd])
    gd = parse_GeneratorDeclaration(context, lexer, pos, strict, Yield, Await, Default)
    if gd:
        return P2_HoistableDeclaration_GeneratorDeclaration(context, strict, [gd])
    afd = parse_AsyncFunctionDeclaration(context, lexer, pos, strict, Yield, Await, Default)
    if afd:
        return P2_HoistableDeclaration_AsyncFunctionDeclaration(context, strict, [afd])
    agd = parse_AsyncGeneratorDeclaration(context, lexer, pos, strict, Yield, Await, Default)
    if agd:
        return P2_HoistableDeclaration_AsyncGeneratorDeclaration(context, strict, [agd])
    return None


# --------======= 𝓑𝓻𝓮𝓪𝓴𝓪𝓫𝓵𝓮𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   BreakableStatement :
#       IterationStatement
#       SwitchStatement


class P2_BreakableStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BreakableStatement", strict, children)


class P2_BreakableStatement_IterationStatement(P2_BreakableStatement):
    @property
    def IterationStatement(self):
        return self.children[0]

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.1.3 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # BreakableStatement : IterationStatement
        #   1. Let newIterationSet be a copy of iterationSet with all the elements of labelSet appended.
        #   2. Return ContainsUndefinedContinueTarget of IterationStatement with arguments newIterationSet and « ».
        newIterationSet = iterationSet.copy()
        newIterationSet.extend(labelSet)
        return self.IterationStatement.ContainsUndefinedContinueTarget(newIterationSet, [])

    def LabelledEvaluation(self, labelSet):
        # 13.1.7 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        #           BreakableStatement : IterationStatement
        # 1. Let stmtResult be the result of performing LabelledEvaluation of IterationStatement with argument labelSet.
        # 2. If stmtResult.[[Type]] is break, then
        #     a. If stmtResult.[[Target]] is empty, then
        #        i. If stmtResult.[[Value]] is empty, set stmtResult to undefined)
        #       ii. Else, set stmtResult to stmtResult.[[Value]])
        # 3. Return Completion(stmtResult).
        try:
            stmtResult = self.IterationStatement.LabelledEvaluation(labelSet)
        except ESBreak as abrupt:
            if abrupt.completion.target != EMPTY:
                raise
            stmtResult = abrupt.completion.value if abrupt.completion.value != EMPTY else None
        return stmtResult

    def evaluate(self):
        # 13.1.8 Runtime Semantics: Evaluation
        #           BreakableStatement : IterationStatement
        # 1. Let newLabelSet be a new empty List.
        # 2. Return the result of performing LabelledEvaluation of this BreakableStatement with argument newLabelSet.
        return self.LabelledEvaluation([])


class P2_BreakableStatement_SwitchStatement(P2_BreakableStatement):
    @property
    def SwitchStatement(self):
        return self.children[0]

    def LabelledEvaluation(self, labelSet):
        # 13.1.7 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        #           BreakableStatement : SwitchStatement
        # 1. Let stmtResult be the result of evaluating SwitchStatement.
        # 2. If stmtResult.[[Type]] is break, then
        #    a. If stmtResult.[[Target]] is empty, then
        #       i. If stmtResult.[[Value]] is empty, set stmtResult to NormalCompletion(undefined).
        #      ii. Else, set stmtResult to NormalCompletion(stmtResult.[[Value]]).
        # 3. Return Completion(stmtResult).
        try:
            stmtResult = self.SwitchStatement.evaluate()
        except ESBreak as abrupt:
            if abrupt.completion.target != EMPTY:
                raise
            stmtResult = abrupt.completion.value if abrupt.completion.value != EMPTY else None
        return stmtResult

    def evaluate(self):
        # 13.1.8 Runtime Semantics: Evaluation
        #           BreakableStatement : SwitchStatement
        # 1. Let newLabelSet be a new empty List.
        # 2. Return the result of performing LabelledEvaluation of this BreakableStatement with argument newLabelSet.
        return self.LabelledEvaluation([])


def parse_BreakableStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13 ECMAScript Language: Statements and Declarations
    # Syntax
    #   BreakableStatement[Yield, Await, Return] :
    #       IterationStatement[?Yield, ?Await, ?Return]
    #       SwitchStatement[?Yield, ?Await, ?Return]
    its = parse_IterationStatement(context, lexer, pos, strict, Yield, Await, Return)
    if its:
        return P2_BreakableStatement_IterationStatement(context, strict, [its])
    ss = parse_SwitchStatement(context, lexer, pos, strict, Yield, Await, Return)
    if ss:
        return P2_BreakableStatement_SwitchStatement(context, strict, [ss])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.      888888b.   888                   888
# d8888   d88P  Y88b     d88P  Y88b     888  "88b  888                   888
#   888        .d88P            888     888  .88P  888                   888
#   888       8888"           .d88P     8888888K.  888  .d88b.   .d8888b 888  888
#   888        "Y8b.      .od888P"      888  "Y88b 888 d88""88b d88P"    888 .88P
#   888   888    888     d88P"          888    888 888 888  888 888      888888K
#   888   Y88b  d88P d8b 888"           888   d88P 888 Y88..88P Y88b.    888 "88b
# 8888888  "Y8888P"  Y8P 888888888      8888888P"  888  "Y88P"   "Y8888P 888  888
#
#######################################################################################################################
# 13.2 Block
# 13.2.1 SS: Early Errors
# 13.2.2 SS: ContainsDuplicateLabels
# 13.2.3 SS: ContainsUndefinedBreakTarget
# 13.2.4 SS: ContainsUndefinedContinueTarget
# 13.2.5 SS: LexicallyDeclaredNames
# 13.2.6 SS: LexicallyScopedDeclarations
# 13.2.7 SS: TopLevelLexicallyDeclaredNames
# 13.2.8 SS: TopLevelLexicallyScopedDeclarations
# 13.2.9 SS: TopLevelVarDeclaredNames
# 13.2.10 SS: TopLevelVarScopedDeclarations
# 13.2.11 SS: VarDeclaredNames
# 13.2.12 SS: VarScopedDeclarations
# 13.2.13 RS: Evaluation
# 13.2.14 RS: BlockDeclarationInstantiation ( code, env )
#######################################################################################################################

#################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑.𝟐 𝓑𝓵𝓸𝓬𝓴 .....●·._..●·._..●·._.·´ #
#################################################################
# 13.2 Block

# --------======= 𝓑𝓵𝓸𝓬𝓴𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   BlockStatement[Yield, Await, Return] :
#       Block[?Yield, ?Await, ?Return]


class P2_BlockStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BlockStatement", strict, children)


class P2_BlockStatement_Block(P2_BlockStatement):
    @property
    def Block(self):
        return self.children[0]


def parse_BlockStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13.2 Block
    # Syntax
    #   BlockStatement[Yield, Await, Return] :
    #       Block[?Yield, ?Await, ?Return]
    block = parse_Block(context, lexer, pos, strict, Yield, Await, Return)
    if block:
        return P2_BlockStatement_Block(context, strict, [block])
    return None


# --------======= 𝓑𝓵𝓸𝓬𝓴 =======--------
# Syntax
#   Block :
#       { StatementList[opt] }


class P2_Block(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Block", strict, children)


class P2_Block_Empty(P2_Block):
    def ContainsDuplicateLabels(self, labelSet):
        # 13.2.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # Block : { }
        #   1. Return false.
        return False

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.2.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # Block : { }
        #   1. Return false.
        return False

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.2.3 Static Semantics: ContainsUndefinedContinueTarget
        # Block : { }
        #   1. Return false.
        return False

    def LexicallyDeclaredNames(self):
        # 13.2.3 Static Semantics: LexicallyDeclaredNames
        # Block : { }
        #   1. Return a new empty List.
        return []

    def TopLevelLexicallyScopedDeclarations(self):
        # 13.2.8 Static Semantics: TopLevelLexicallyScopedDeclarations
        # Block : { }
        #   1. Return a new empty List.
        return []

    def TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # Block : { }
        #   1. Return a new empty List.
        return []

    def TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # Block : { }
        #   1. Return a new empty List.
        return []

    def VarDeclaredNames(self):
        # 13.2.11 Static Semantics: VarDeclaredNames
        # Block : { }
        #   1. Return a new empty List.
        return []

    def VarScopedDeclarations(self):
        # 13.2.12 Static Semantics: VarScopedDeclarations
        # Block : { }
        #   1. Return a new empty List.
        return []

    def evaluate(self):
        # 13.2.13 Runtime Semantics: Evaluation
        # Block : { }
        #   1. Return NormalCompletion(empty).
        return EMPTY


class P2_Block_StatementList(P2_Block):
    @property
    def StatementList(self):
        return self.children[1]

    def EarlyErrors(self):
        # 13.2.1 Static Semantics: Early Errors
        # Block : { StatementList }
        #   * It is a Syntax Error if the LexicallyDeclaredNames of StatementList contains any duplicate entries.
        #   * It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList also occurs in the
        #     VarDeclaredNames of StatementList.
        ldn = self.StatementList.LexicallyDeclaredNames()
        ldn_set = set(ldn)
        return list(
            filter(
                None,
                [
                    len(ldn) != len(ldn_set)
                    and self.CreateSyntaxError("Duplicate names dectected in the Lexically Declared Names list"),
                    not ldn_set.isdisjoint(set(self.StatementList.VarDeclaredNames()))
                    and self.CreateSyntaxError("Name clash between Lexically Declared Names and Var Declared Names"),
                ],
            )
        )

    def evaluate(self):
        # 13.2.13 Runtime Semantics: Evaluation
        # Block : { StatementList }
        #   1. Let oldEnv be the running execution context's LexicalEnvironment.
        #   2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
        #   3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).
        #   4. Set the running execution context's LexicalEnvironment to blockEnv.
        #   5. Let blockValue be the result of evaluating StatementList.
        #   6. Set the running execution context's LexicalEnvironment to oldEnv.
        #   7. Return blockValue.
        # NOTE 1
        # No matter how control leaves the Block the LexicalEnvironment is always restored to its former state.
        oldEnv = surrounding_agent.running_ec.lexical_environment
        blockEnv = NewDeclarativeEnvironment(oldEnv)
        BlockDeclarationInstantiation(self.StatementList, blockEnv)
        surrounding_agent.running_ec.lexical_environment = blockEnv
        try:
            return self.StatementList.evaluate()
        finally:
            surrounding_agent.running_ec.lexical_environment = oldEnv


def parse_Block(context, lexer, pos, strict, Yield, Await, Return):
    # 13.2 Block
    # Syntax
    #   Block[Yield, Await, Return] :
    #       { StatementList[?Yield, ?Await, ?Return][opt] }
    lcurly = lexer.token_if(pos, "{")
    if lcurly:
        sl = parse_StatementList(context, lexer, lcurly.span.after, strict, False, Yield, Await, Return)
        rcurly = lexer.token_if(sl.after if sl else lcurly.span.after, "}")
        if rcurly:
            if sl:
                return P2_Block_StatementList(context, strict, [lcurly, sl, rcurly])
            return P2_Block_Empty(context, strict, [lcurly, rcurly])
    return None


# --------======= 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   StatementList :
#       StatementListItem
#       StatementList StatementListItem
#
class P2_StatementList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "StatementList", strict, children)


class P2_StatementList_StatementListItem(P2_StatementList):
    # 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 : 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽𝓘𝓽𝓮𝓶
    @property
    def StatementListItem(self):
        return self.children[0]


class P2_StatementList_StatementList_StatementListItem(P2_StatementList):
    # 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 : 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽𝓘𝓽𝓮𝓶
    @property
    def StatementList(self):
        return self.children[0]

    @property
    def StatementListItem(self):
        return self.children[1]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.2.2 StatementList : StatementList StatementListItem
        #    1. Let hasDuplicates be ContainsDuplicateLabels of StatementList with argument labelSet.
        #    2. If hasDuplicates is true, return true.
        #    3. Return ContainsDuplicateLabels of StatementListItem with argument labelSet.
        return self.StatementList.ContainsDuplicateLabels(
            labelSet
        ) or self.StatementListItem.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.2.3 StatementList : StatementList StatementListItem
        #    1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of StatementList with argument labelSet.
        #    2. If hasUndefinedLabels is true, return true.
        #    3. Return ContainsUndefinedBreakTarget of StatementListItem with argument labelSet.
        return self.StatementList.ContainsUndefinedBreakTarget(
            labelSet
        ) or self.StatementListItem.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.2.4 StatementList : StatementList StatementListItem
        #    1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and « ».
        #    2. If hasUndefinedLabels is true, return true.
        #    3. Return ContainsUndefinedContinueTarget of StatementListItem with arguments iterationSet and « ».
        return self.StatementList.ContainsUndefinedContinueTarget(
            iterationSet, []
        ) or self.StatementListItem.ContainsUndefinedContinueTarget(iterationSet, [])

    def LexicallyDeclaredNames(self):
        # 13.2.5 StatementList : StatementList StatementListItem
        #    1. Let names be LexicallyDeclaredNames of StatementList.
        #    2. Append to names the elements of the LexicallyDeclaredNames of StatementListItem.
        #    3. Return names.
        return self.StatementList.LexicallyDeclaredNames() + self.StatementListItem.LexicallyDeclaredNames()

    def LexicallyScopedDeclarations(self):
        # 13.2.6 StatementList : StatementList StatementListItem
        #    1. Let declarations be LexicallyScopedDeclarations of StatementList.
        #    2. Append to declarations the elements of the LexicallyScopedDeclarations of StatementListItem.
        #    3. Return declarations.
        return (
            self.StatementList.LexicallyScopedDeclarations() + self.StatementListItem.LexicallyScopedDeclarations()
        )

    def TopLevelLexicallyDeclaredNames(self):
        # 13.2.7 Static Semantics: TopLevelLexicallyDeclaredNames
        # StatementList : StatementList StatementListItem
        #   1. Let names be TopLevelLexicallyDeclaredNames of StatementList.
        #   2. Append to names the elements of the TopLevelLexicallyDeclaredNames of StatementListItem.
        #   3. Return names.
        names = self.StatementList.TopLevelLexicallyDeclaredNames()
        names.extend(self.StatementListItem.TopLevelLexicallyDeclaredNames())
        return names

    def TopLevelLexicallyScopedDeclarations(self):
        # 13.2.8 Static Semantics: TopLevelLexicallyScopedDeclarations
        # StatementList : StatementList StatementListItem
        #   1. Let declarations be TopLevelLexicallyScopedDeclarations of StatementList.
        #   2. Append to declarations the elements of the TopLevelLexicallyScopedDeclarations of StatementListItem.
        #   3. Return declarations.
        declarations = self.StatementList.TopLevelLexicallyScopedDeclarations()
        declarations.extend(self.StatementListItem.TopLevelLexicallyScopedDeclarations())
        return declarations

    def TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # StatementList : StatementList StatementListItem
        #   1. Let names be TopLevelVarDeclaredNames of StatementList.
        #   2. Append to names the elements of the TopLevelVarDeclaredNames of StatementListItem.
        #   3. Return names.
        names = self.StatementList.TopLevelVarDeclaredNames()
        names.extend(self.StatementListItem.TopLevelVarDeclaredNames())
        return names

    def TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # StatementList : StatementList StatementListItem
        #   1. Let declarations be TopLevelVarScopedDeclarations of StatementList.
        #   2. Append to declarations the elements of the TopLevelVarScopedDeclarations of StatementListItem.
        #   3. Return declarations.
        declarations = self.StatementList.TopLevelVarScopedDeclarations()
        declarations.extend(self.StatementListItem.TopLevelVarScopedDeclarations())
        return declarations

    def VarDeclaredNames(self):
        # 13.2.11 Static Semantics: VarDeclaredNames
        # StatementList : StatementList StatementListItem
        #   1. Let names be VarDeclaredNames of StatementList.
        #   2. Append to names the elements of the VarDeclaredNames of StatementListItem.
        #   3. Return names.
        names = self.StatementList.VarDeclaredNames()
        names.extend(self.StatementListItem.VarDeclaredNames())
        return names

    def VarScopedDeclarations(self):
        # 13.2.12 Static Semantics: VarScopedDeclarations
        # StatementList : StatementList StatementListItem
        #   1. Let declarations be VarScopedDeclarations of StatementList.
        #   2. Append to declarations the elements of the VarScopedDeclarations of StatementListItem.
        #   3. Return declarations.
        declarations = self.StatementList.VarScopedDeclarations()
        declarations.extend(self.StatementListItem.VarScopedDeclarations())
        return declarations

    def evaluate(self):
        # 13.2.13 Runtime Semantics: Evaluation
        # StatementList : StatementList StatementListItem
        #   1. Let sl be the result of evaluating StatementList.
        #   2. ReturnIfAbrupt(sl).
        #   3. Let s be the result of evaluating StatementListItem.
        #   4. Return Completion(UpdateEmpty(s, sl)).
        sl = self.StatementList.evaluate()
        try:
            s = self.StatementListItem.evaluate()
        except ESAbrupt as err:
            c = err.completion
            raise type(err)(UpdateEmpty(c.value, sl), c.target)
        return UpdateEmpty(s, sl)

    def LeadingStrings(self):
        more, strings = self.StatementList.LeadingStrings()
        if more:
            more, additional = self.StatementListItem.LeadingStrings()
            strings.extend(additional)
        return (more, strings)


def parse_StatementList(ctx, lexer, pos, strict, dp_active, Yield, Await, Return):
    # 13.2 Block
    # Syntax
    #   StatementList[Yield, Await, Return] :
    #       StatementListItem[?Yield, ?Await, ?Return]
    #       StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]
    def parse(pos, strict, dp_active, collected=None):
        sli = parse_StatementListItem(ctx, lexer, pos, strict, Yield, Await, Return)
        if not sli:
            return collected
        dp_active = dp_active and sli.IsStringLiteral
        use_strict = dp_active and sli.HasUseStrict
        strict = strict or use_strict
        if collected is None:
            return lambda: parse(
                sli.after, strict, dp_active, P2_StatementList_StatementListItem(ctx, strict, [sli])
            )
        # Tail recursion replaced by a thunk; please use trampoline.
        return lambda: parse(
            sli.after,
            strict,
            dp_active,
            P2_StatementList_StatementList_StatementListItem(ctx, strict, [collected, sli]),
        )

    return trampoline(lambda: parse(pos, strict, dp_active))


# --------======= 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽𝓘𝓽𝓮𝓶 =======--------
# Syntax
#   StatementListItem :
#       Statement
#       Declaration
#
class P2_StatementListItem(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "StatementListItem", strict, children)


class P2_StatementListItem_Statement(P2_StatementListItem):
    # 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽𝓘𝓽𝓮𝓶 : 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽
    @property
    def Statement(self):
        return self.children[0]

    def LexicallyDeclaredNames(self):
        # 13.2.5 Static Semantics: LexicallyDeclaredNames
        # StatementListItem : Statement
        #   1. If Statement is Statement : LabelledStatement , return LexicallyDeclaredNames of LabelledStatement.
        #   2. Return a new empty List.
        #
        # Implementation Note: This checking the type of my children is a silly way of handling the functionality here.
        # Really what's going on is a different LexicallyDeclaredNames routine for Statement:LabelledStatement from the
        # rest of the Statement productions. Instead of doing an if statement here, checking the type of the child,
        # let's just use object inheritance to do the job for us and avoid the type checking and if statements
        # altogether.
        #
        # Still, the fact that the spec didn't specifiy things one level down in the parse tree is a bit worrysome, and
        # I wonder if I missed something. So stuff gets renamed at this point with a "faux_" prefix, so that I know I
        # won't have a strange name clash resulting in bugs I'll never find.
        return self.Statement.faux_LexicallyDeclaredNames()

    def LexicallyScopedDeclarations(self):
        # 13.2.6 Static Semantics: LexicallyScopedDeclarations
        # StatementListItem : Statement
        #   1. If Statement is Statement:LabelledStatement , return LexicallyScopedDeclarations of LabelledStatement.
        #   2. Return a new empty List.
        #
        # Implementation Note: See above. This is the same deal.
        return self.Statement.faux_LexicallyScopedDeclarations()

    def TopLevelLexicallyDeclaredNames(self):
        # 13.2.7 Static Semantics: TopLevelLexicallyDeclaredNames
        # StatementListItem : Statement
        #   1. Return a new empty List.
        return []

    def TopLevelLexicallyScopedDeclarations(self):
        # 13.2.8 Static Semantics: TopLevelLexicallyScopedDeclarations
        # StatementListItem : Statement
        #   1. Return a new empty List.
        return []

    def TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # StatementListItem : Statement
        #   1. If Statement is Statement:LabelledStatement , return TopLevelVarDeclaredNames of Statement.
        #   2. Return VarDeclaredNames of Statement.
        return self.Statement.faux_TopLevelVarDeclaredNames()

    def TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # StatementListItem : Statement
        #   1. If Statement is Statement:LabelledStatement , return TopLevelVarScopedDeclarations of Statement.
        #   2. Return VarScopedDeclarations of Statement.
        return self.Statement.faux_TopLevelVarScopedDeclarations()

    def LeadingStrings(self):
        expression_statement_parent = self.Statement.Derived(P2_Statement_ExpressionStatement)
        if expression_statement_parent is not None:
            expression_statement = expression_statement_parent.ExpressionStatement
            string_literal = expression_statement.Expression.Derived(P2_Literal_StringLiteral)
            if string_literal is not None:
                return (True, [string_literal.matched_source()])
        return (False, [])

    @cached_property
    def IsStringLiteral(self):
        return self.Statement.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.Statement.HasUseStrict

    def evaluate(self):
        print(f"STATEMENT: {self.Statement}")
        return self.Statement.evaluate()


class P2_StatementListItem_Declaration(P2_StatementListItem):
    # 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽𝓘𝓽𝓮𝓶 : 𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷
    @property
    def Declaration(self):
        return self.children[0]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.2.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # StatementListItem : Declaration
        #   1. Return false.
        return False

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.2.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        #           StatementListItem : Declaration
        # 1. Return false.
        return False

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.2.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #           StatementListItem : Declaration
        # 1. Return false.
        return False

    def LexicallyDeclaredNames(self):
        # 13.2.5 Static Semantics: LexicallyDeclaredNames
        #           StatementListItem : Declaration
        # 1. Return the BoundNames of Declaration.
        return self.Declaration.BoundNames()

    def LexicallyScopedDeclarations(self):
        # 13.2.6 Static Semantics: LexicallyScopedDeclarations
        #           StatementListItem : Declaration
        # 1. Return a new List containing DeclarationPart of Declaration.
        return [self.Declaration.DeclarationPart()]

    def TopLevelLexicallyDeclaredNames(self):
        # 13.2.7 Static Semantics: TopLevelLexicallyDeclaredNames
        # StatementListItem : Declaration
        #   1. If Declaration is Declaration : HoistableDeclaration , then
        #      a. Return « ».
        #   2. Return the BoundNames of Declaration.
        return self.Declaration.faux_TopLevelLexicallyDeclaredNames()

    def TopLevelLexicallyScopedDeclarations(self):
        # 13.2.8 Static Semantics: TopLevelLexicallyScopedDeclarations
        # StatementListItem : Declaration
        #   1. If Declaration is Declaration:HoistableDeclaration , then
        #      a. Return « ».
        #   2. Return a new List containing Declaration.
        return self.Declaration.faux_TopLevelLexicallyScopedDeclarations()

    def TopLevelVarDeclaredNames(self):
        # 13.2.9 Static Semantics: TopLevelVarDeclaredNames
        # StatementListItem : Declaration
        #   1. If Declaration is Declaration:HoistableDeclaration , then
        #      a. Return the BoundNames of HoistableDeclaration.
        #   2. Return a new empty List.
        return self.Declaration.faux_TopLevelVarDeclaredNames()

    def TopLevelVarScopedDeclarations(self):
        # 13.2.10 Static Semantics: TopLevelVarScopedDeclarations
        # StatementListItem : Declaration
        #   1. If Declaration is Declaration:HoistableDeclaration , then
        #      a. Let declaration be DeclarationPart of HoistableDeclaration.
        #      b. Return « declaration ».
        #   2. Return a new empty List.
        return self.Declaration.faux_TopLevelVarScopedDeclarations()

    def VarDeclaredNames(self):
        # 13.2.11 Static Semantics: VarDeclaredNames
        # StatementListItem : Declaration
        #   1. Return a new empty List.
        return []

    def VarScopedDeclarations(self):
        # 13.2.12 Static Semantics: VarScopedDeclarations
        # StatementListItem : Declaration
        #   1. Return a new empty List.
        return []

    def LeadingStrings(self):
        return (False, [])

    def evaluate(self):
        print(f"DECLARATION: {self.Declaration}")
        return self.Declaration.evaluate()


def parse_StatementListItem(ctx, lexer, pos, strict, Yield, Await, Return):
    # 13.2 Block
    # Syntax
    #   StatementListItem[Yield, Await, Return]:
    #       Statement[?Yield, ?Await, ?Return]
    #       Declaration[?Yield, ?Await]
    stmt = parse_Statement(ctx, lexer, pos, strict, Yield, Await, Return)
    if stmt:
        return P2_StatementListItem_Statement(ctx, strict, [stmt])
    decl = parse_Declaration(ctx, lexer, pos, strict, Yield, Await)
    if decl:
        return P2_StatementListItem_Declaration(ctx, strict, [decl])
    return None


# 13.2.14 Runtime Semantics: BlockDeclarationInstantiation ( code, env )
def BlockDeclarationInstantiation(code, env):
    # BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node
    # corresponding to the body of the block. env is the Lexical Environment in which bindings are to be created.
    # NOTE
    # When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings for each
    # block scoped variable, constant, function, or class declared in the block are instantiated in the Environment
    # Record.
    #
    #   1. Let envRec be env's EnvironmentRecord.
    #   2. Assert: envRec is a declarative Environment Record.
    #   3. Let declarations be the LexicallyScopedDeclarations of code.
    #   4. For each element d in declarations, do
    #       a. For each element dn of the BoundNames of d, do
    #           i. If IsConstantDeclaration of d is true, then
    #               1. Perform ! envRec.CreateImmutableBinding(dn, true).
    #           ii. Else,
    #               1. Perform ! envRec.CreateMutableBinding(dn, false).
    #       b. If d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then
    #           i. Let fn be the sole element of the BoundNames of d.
    #           ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.
    #           iii. Perform envRec.InitializeBinding(fn, fo).
    envRec = env.environment_record
    assert isinstance(envRec, DeclarativeEnvironmentRecord)
    declarations = code.LexicallyScopedDeclarations()
    for d in declarations:
        for dn in d.BoundNames():
            if d.IsConstantDeclaration():
                envRec.CreateImmutableBinding(dn, True)
            else:
                envRec.CreateMutableBinding(dn, False)
        if d.name in [
            "FunctionDeclaration",
            "GeneratorDeclaration",
            "AsyncFunctionDeclaration",
            "AsyncGeneratorDeclaration",
        ]:
            fn = d.BoundNames()[0]
            fo = d.InstantiateFunctionObject(env)
            envRec.InitializeBinding(fn, fo)


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.
# d8888   d88P  Y88b     d88P  Y88b
#   888        .d88P          .d88P
#   888       8888"          8888"
#   888        "Y8b.          "Y8b.
#   888   888    888     888    888
#   888   Y88b  d88P d8b Y88b  d88P
# 8888888  "Y8888P"  Y8P  "Y8888P"
#
# 8888888b.                    888                           888    d8b
# 888  "Y88b                   888                           888    Y8P
# 888    888                   888                           888
# 888    888  .d88b.   .d8888b 888  8888b.  888d888  8888b.  888888 888  .d88b.  88888b.  .d8888b
# 888    888 d8P  Y8b d88P"    888     "88b 888P"       "88b 888    888 d88""88b 888 "88b 88K
# 888    888 88888888 888      888 .d888888 888     .d888888 888    888 888  888 888  888 "Y8888b.
# 888  .d88P Y8b.     Y88b.    888 888  888 888     888  888 Y88b.  888 Y88..88P 888  888      X88
# 8888888P"   "Y8888   "Y8888P 888 "Y888888 888     "Y888888  "Y888 888  "Y88P"  888  888  88888P'
#
#                        888     888    888
#                        888     888    888
#                        888     888    888
#  8888b.  88888b.   .d88888     888888 88888b.   .d88b.
#     "88b 888 "88b d88" 888     888    888 "88b d8P  Y8b
# .d888888 888  888 888  888     888    888  888 88888888
# 888  888 888  888 Y88b 888     Y88b.  888  888 Y8b.
# "Y888888 888  888  "Y88888      "Y888 888  888  "Y8888
#
# 888     888                  d8b          888      888
# 888     888                  Y8P          888      888
# 888     888                               888      888
# Y88b   d88P  8888b.  888d888 888  8888b.  88888b.  888  .d88b.
#  Y88b d88P      "88b 888P"   888     "88b 888 "88b 888 d8P  Y8b
#   Y88o88P   .d888888 888     888 .d888888 888  888 888 88888888
#    Y888P    888  888 888     888 888  888 888 d88P 888 Y8b.
#     Y8P     "Y888888 888     888 "Y888888 88888P"  888  "Y8888
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#######################################################################################################################
# 13.3 Declarations and the Variable Statement
# 13.3.1 Let and Const Declarations
# 13.3.1.1 SS: Early Errors
# 13.3.1.2 SS: BoundNames
# 13.3.1.3 SS: IsConstantDeclaration
# 13.3.1.4 RS: Evaluation
# 13.3.2 Variable Statement
# 13.3.2.1 SS: BoundNames
# 13.3.2.2 SS: VarDeclaredNames
# 13.3.2.3 SS: VarScopedDeclarations
# 13.3.2.4 RS: Evaluation
# 13.3.3 Destructuring Binding Patterns
# 13.3.3.1 SS: BoundNames
# 13.3.3.2 SS: ContainsExpression
# 13.3.3.3 SS: HasInitializer
# 13.3.3.4 SS: IsSimpleParameterList
# 13.3.3.5 RS: BindingInitialization
# 13.3.3.6 RS: PropertyBindingInitialization
# 13.3.3.7 RS: RestBindingInitialization
# 13.3.3.8 RS: IteratorBindingInitialization
# 13.3.3.9 RS: KeyedBindingInitialization
#######################################################################################################################

########################################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑.𝟑 𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷𝓼 𝓪𝓷𝓭 𝓽𝓱𝓮 𝓥𝓪𝓻𝓲𝓪𝓫𝓵𝓮 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 .....●·._..●·._..●·._.·´ #
########################################################################################################
# 13.3 Declarations and the Variable Statement

# --------======= 𝓛𝓮𝔁𝓲𝓬𝓪𝓵𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   LexicalDeclaration :
#       LetOrConst BindingList ;


class P2_LexicalDeclaration(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LexicalDeclaration", strict, children)


class P2_LexicalDeclaration_LetOrConst_BindingList(P2_LexicalDeclaration):
    @property
    def LetOrConst(self):
        return self.children[0]

    @property
    def BindingList(self):
        return self.children[1]

    def EarlyErrors(self):
        # 13.3.1.1 Static Semantics: Early Errors
        # LexicalDeclaration : LetOrConst BindingList ;
        #   * It is a Syntax Error if the BoundNames of BindingList contains "let".
        #   * It is a Syntax Error if the BoundNames of BindingList contains any duplicate entries.
        # LexicalBinding : BindingIdentifier Initializer
        #   * It is a Syntax Error if Initializer is not present and IsConstantDeclaration of the LexicalDeclaration
        #     containing this LexicalBinding is true.
        bn = self.BindingList.BoundNames()
        return list(
            filter(
                None,
                chain(
                    [
                        "let" in bn and self.CreateSyntaxError("let is disallowed as a lexically bound name"),
                        self.IsConstantDeclaration()
                        and self.BindingList.IsMissingInitializers()
                        and self.CreateSyntaxError("Missing initializer in const declaration"),
                    ],
                    (
                        self.CreateSyntaxError(f"Identifier '{name}' has already been declared")
                        for name, count in Counter(bn).items()
                        if count > 1
                    ),
                ),
            )
        )

    def BoundNames(self):
        # 13.3.1.2 Static Semantics: BoundNames
        # LexicalDeclaration : LetOrConst BindingList ;
        #   1. Return the BoundNames of BindingList.
        return self.BindingList.BoundNames()

    def IsConstantDeclaration(self):
        # 13.3.1.3 Static Semantics: IsConstantDeclaration
        # LexicalDeclaration : LetOrConst BindingList ;
        #   1. Return IsConstantDeclaration of LetOrConst.
        return self.LetOrConst.IsConstantDeclaration()

    def evaluate(self):
        # 13.3.1.4 Runtime Semantics: Evaluation
        # LexicalDeclaration : LetOrConst BindingList ;
        #   1. Let next be the result of evaluating BindingList.
        #   2. ReturnIfAbrupt(next).
        #   3. Return NormalCompletion(empty).
        self.BindingList.evaluate()
        return EMPTY


def parse_LexicalDeclaration(context, lexer, pos, strict, In, Yield, Await):
    # 13.3.1 Let and Const Declarations
    # Syntax
    #   LexicalDeclaration[In, Yield, Await] :
    #       LetOrConst BindingList[?In, ?Yield, ?Await] ;
    loc = parse_LetOrConst(context, lexer, pos, strict)
    if loc:
        bl = parse_BindingList(context, lexer, loc.after, strict, In, Yield, Await)
        if bl:
            semi = lexer.token_asi(bl.after)
            if semi:
                return P2_LexicalDeclaration_LetOrConst_BindingList(context, strict, [loc, bl, semi])
    return None


# --------======= 𝓛𝓮𝓽𝓞𝓻𝓒𝓸𝓷𝓼𝓽 =======--------
# Syntax
#   LetOrConst :
#       let
#       const


class P2_LetOrConst(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LetOrConst", strict, children)


class P2_LetOrConst_Let(P2_LetOrConst):
    def IsConstantDeclaration(self):
        # 13.3.1.3 Static Semantics: IsConstantDeclaration
        # LetOrConst : let
        #   1. Return false.
        return False


class P2_LetOrConst_Const(P2_LetOrConst):
    def IsConstantDeclaration(self):
        # 13.3.1.3 Static Semantics: IsConstantDeclaration
        # LetOrConst : const
        #   1. Return true.
        return True


def parse_LetOrConst(context, lexer, pos, strict):
    # 13.3.1 Let and Const Declarations
    # Syntax
    #   LetOrConst :
    #       let
    #       const
    Let = lexer.id_if(pos, "let")
    if Let:
        return P2_LetOrConst_Let(context, strict, [Let])
    Const = lexer.id_if(pos, "const")
    if Const:
        return P2_LetOrConst_Const(context, strict, [Const])
    return None


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   BindingList :
#       LexicalBinding
#       BindingList , LexicalBinding


class P2_BindingList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingList", strict, children)


class P2_BindingList_LexicalBinding(P2_BindingList):
    @property
    def LexicalBinding(self):
        return self.children[0]


class P2_BindingList_BindingList_LexicalBinding(P2_BindingList):
    @property
    def BindingList(self):
        return self.children[0]

    @property
    def LexicalBinding(self):
        return self.children[2]

    def IsMissingInitializers(self):
        return self.LexicalBinding.IsMissingInitializers() or self.BindingList.IsMissingInitializers()

    def BoundNames(self):
        # 13.3.1.2 Static Semantics: BoundNames
        # BindingList : BindingList , LexicalBinding
        #   1. Let names be the BoundNames of BindingList.
        #   2. Append to names the elements of the BoundNames of LexicalBinding.
        #   3. Return names.
        return self.BindingList.BoundNames() + self.LexicalBinding.BoundNames()

    def evaluate(self):
        # 13.3.1.4 Runtime Semantics: Evaluation
        # BindingList : BindingList , LexicalBinding
        #   1. Let next be the result of evaluating BindingList.
        #   2. ReturnIfAbrupt(next).
        #   3. Return the result of evaluating LexicalBinding.
        self.BindingList.evaluate()
        return self.LexicalBinding.evaluate()


def parse_BindingList(context, lexer, pos, strict, In, Yield, Await):
    # 13.3.1 Let and Const Declarations
    # Syntax
    #   BindingList[In, Yield, Await] :
    #       LexicalBinding[?In, ?Yield, ?Await]
    #       BindingList[?In, ?Yield, ?Await] , LexicalBinding[?In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            lb1 = parse_LexicalBinding(context, lexer, pos, strict, In, Yield, Await)
            if lb1:
                return lambda: parse(lb1.after, P2_BindingList_LexicalBinding(context, strict, [lb1]))
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                lb2 = parse_LexicalBinding(context, lexer, comma.span.after, strict, In, Yield, Await)
                if lb2:
                    return lambda: parse(
                        lb2.after, P2_BindingList_BindingList_LexicalBinding(context, strict, [previous, comma, lb2])
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓛𝓮𝔁𝓲𝓬𝓪𝓵𝓑𝓲𝓷𝓭𝓲𝓷𝓰 =======--------
# Syntax
#   LexicalBinding :
#       BindingIdentifier
#       BindingIdentifier Initializer
#       BindingPattern Initializer


class P2_LexicalBinding(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LexicalBinding", strict, children)


class P2_LexicalBinding_BindingIdentifier(P2_LexicalBinding):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    def IsMissingInitializers(self):
        return True

    def evaluate(self):
        # 13.3.1.4 Runtime Semantics: Evaluation
        # LexicalBinding : BindingIdentifier
        #   1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).
        #   2. Return InitializeReferencedBinding(lhs, undefined).
        # NOTE
        # A static semantics rule ensures that this form of LexicalBinding never occurs in a const declaration.
        lhs = ResolveBinding(self.BindingIdentifier.StringValue, self.strict)
        return InitializeReferencedBinding(lhs, None)


class P2_LexicalBinding_BindingIdentifier_Initializer(P2_LexicalBinding):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def IsMissingInitializers(self):
        return False

    def BoundNames(self):
        # 13.3.1.2 Static Semantics: BoundNames
        # LexicalBinding : BindingIdentifier Initializer
        #   1. Return the BoundNames of BindingIdentifier.
        return self.BindingIdentifier.BoundNames()

    def evaluate(self):
        # 13.3.1.4 Runtime Semantics: Evaluation
        # LexicalBinding : BindingIdentifier Initializer
        #   1. Let bindingId be StringValue of BindingIdentifier.
        #   2. Let lhs be ResolveBinding(bindingId).
        #   3. If IsAnonymousFunctionDefinition(Initializer) is true, then
        #       a. Let value be the result of performing NamedEvaluation for Initializer with argument bindingId.
        #   4. Else,
        #       a. Let rhs be the result of evaluating Initializer.
        #       b. Let value be ? GetValue(rhs).
        #   5. Return InitializeReferencedBinding(lhs, value).
        bindingId = self.BindingIdentifier.StringValue
        lhs = ResolveBinding(bindingId, self.strict)
        value = (
            self.Initializer.NamedEvaluation(bindingId)
            if IsAnonymousFunctionDefinition(self.Initializer)
            else GetValue(self.Initializer.evaluate())
        )
        return InitializeReferencedBinding(lhs, value)


class P2_LexicalBinding_BindingPattern_Initializer(P2_LexicalBinding):
    @property
    def BindingPattern(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def IsMissingInitializers(self):
        return False

    def BoundNames(self):
        # 13.3.1.2 Static Semantics: BoundNames
        # LexicalBinding : BindingPattern Initializer
        #   1. Return the BoundNames of BindingPattern.
        return self.BindingPattern.BoundNames()

    def evaluate(self):
        # 13.3.1.4 Runtime Semantics: Evaluation
        # LexicalBinding : BindingPattern Initializer
        #   1. Let rhs be the result of evaluating Initializer.
        #   2. Let value be ? GetValue(rhs).
        #   3. Let env be the running execution context's LexicalEnvironment.
        #   4. Return the result of performing BindingInitialization for BindingPattern using value and env as the
        #      arguments.
        value = GetValue(self.Initializer.evaluate())
        env = surrounding_agent.running_ec.lexical_environment
        return self.BindingPattern.BindingInitialization(value, env)


def parse_LexicalBinding(context, lexer, pos, strict, In, Yield, Await):
    # 13.3.1 Let and Const Declarations
    # Syntax
    #   LexicalBinding[In, Yield, Await] :
    #       BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await][opt]
    #       BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
    bi = parse_BindingIdentifier(context, lexer, pos, strict, Yield, Await)
    if bi:
        init1 = parse_Initializer(context, lexer, bi.after, strict, In, Yield, Await)
        if init1:
            return P2_LexicalBinding_BindingIdentifier_Initializer(context, strict, [bi, init1])
        return P2_LexicalBinding_BindingIdentifier(context, strict, [bi])
    bp = parse_BindingPattern(context, lexer, pos, strict, Yield, Await)
    if bp:
        init2 = parse_Initializer(context, lexer, bp.after, strict, In, Yield, Await)
        if init2:
            return P2_LexicalBinding_BindingPattern_Initializer(context, strict, [bp, init2])
    return None


# --------======= 𝓥𝓪𝓻𝓲𝓪𝓫𝓵𝓮𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   VariableStatement :
#       var VariableDeclarationList ;


class P2_VariableStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "VariableStatement", strict, children)


class P2_VariableStatement_VariableDeclarationList(P2_VariableStatement):
    @property
    def VariableDeclarationList(self):
        return self.children[1]

    def VarDeclaredNames(self):
        # 13.3.2.2 Static Semantics: VarDeclaredNames
        # VariableStatement : var VariableDeclarationList ;
        #   1. Return BoundNames of VariableDeclarationList.
        return self.VariableDeclarationList.BoundNames()

    def evaluate(self):
        # 13.3.2.4 Runtime Semantics: Evaluation
        # VariableStatement : varVariableDeclarationList ;
        #   1. Let next be the result of evaluating VariableDeclarationList.
        #   2. ReturnIfAbrupt(next).
        #   3. Return NormalCompletion(empty).
        self.VariableDeclarationList.evaluate()
        return EMPTY


def parse_VariableStatement(context, lexer, pos, strict, Yield, Await):
    # 13.3.2 Variable Statement
    # Syntax
    #   VariableStatement[Yield, Await] :
    #       var VariableDeclarationList[+In, ?Yield, ?Await] ;
    #
    var = lexer.id_if(pos, "var")
    if var:
        vdl = parse_VariableDeclarationList(context, lexer, var.span.after, strict, True, Yield, Await)
        if vdl:
            semi = lexer.token_asi(vdl.after)
            if semi:
                return P2_VariableStatement_VariableDeclarationList(context, strict, [var, vdl, semi])
    return None


# --------======= 𝓥𝓪𝓻𝓲𝓪𝓫𝓵𝓮𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   VariableDeclarationList :
#       VariableDeclaration
#       VariableDeclarationList , VariableDeclaration


class P2_VariableDeclarationList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "VariableDeclarationList", strict, children)


class P2_VariableDeclarationList_VariableDeclaration(P2_VariableDeclarationList):
    @property
    def VariableDeclaration(self):
        return self.children[0]

    def VarScopedDeclarations(self):
        # 13.3.2.3 Static Semantics: VarScopedDeclarations
        # VariableDeclarationList : VariableDeclaration
        #   1. Return a new List containing VariableDeclaration.
        return [self.VariableDeclaration]


class P2_VariableDeclarationList_VariableDeclarationList_VariableDeclaration(P2_VariableDeclarationList):
    @property
    def VariableDeclarationList(self):
        return self.children[0]

    @property
    def VariableDeclaration(self):
        return self.children[2]

    def BoundNames(self):
        # 13.3.2.1 Static Semantics: BoundNames
        # VariableDeclarationList : VariableDeclarationList , VariableDeclaration
        #   1. Let names be BoundNames of VariableDeclarationList.
        #   2. Append to names the elements of BoundNames of VariableDeclaration.
        #   3. Return names.
        return self.VariableDeclarationList.BoundNames() + self.VariableDeclaration.BoundNames()

    def VarScopedDeclarations(self):
        # 13.3.2.3 Static Semantics: VarScopedDeclarations
        # VariableDeclarationList : VariableDeclarationList , VariableDeclaration
        #   1. Let declarations be VarScopedDeclarations of VariableDeclarationList.
        #   2. Append VariableDeclaration to declarations.
        #   3. Return declarations.
        return self.VariableDeclarationList.VarScopedDeclarations() + [self.VariableDeclaration]

    def evaluate(self):
        # 13.3.2.4 Runtime Semantics: Evaluation
        # VariableDeclarationList : VariableDeclarationList , VariableDeclaration
        #   1. Let next be the result of evaluating VariableDeclarationList.
        #   2. ReturnIfAbrupt(next).
        #   3. Return the result of evaluating VariableDeclaration.
        self.VariableDeclarationList.evaluate()
        return self.VariableDeclaration.evaluate()


def parse_VariableDeclarationList(context, lexer, pos, strict, In, Yield, Await):
    # 13.3.2 Variable Statement
    # Syntax
    #   VariableDeclarationList[In, Yield, Await] :
    #       VariableDeclaration[?In, ?Yield, ?Await]
    #       VariableDeclarationList[?In, ?Yield, ?Await] , VariableDeclaration[?In, ?Yield, ?Await]
    #
    def parse(pos, previous=None):
        if previous is None:
            vd1 = parse_VariableDeclaration(context, lexer, pos, strict, In, Yield, Await)
            if vd1:
                return lambda: parse(
                    vd1.after, P2_VariableDeclarationList_VariableDeclaration(context, strict, [vd1])
                )
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                vd2 = parse_VariableDeclaration(context, lexer, comma.span.after, strict, In, Yield, Await)
                if vd2:
                    return lambda: parse(
                        vd2.after,
                        P2_VariableDeclarationList_VariableDeclarationList_VariableDeclaration(
                            context, strict, [previous, comma, vd2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓥𝓪𝓻𝓲𝓪𝓫𝓵𝓮𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   VariableDeclaration :
#       BindingIdentifier
#       BindingIdentifier Initializer
#       BindingPattern Initializer


class P2_VariableDeclaration(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "VariableDeclaration", strict, children)


class P2_VariableDeclaration_BindingIdentifier(P2_VariableDeclaration):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    def evaluate(self):
        # 13.3.2.4 Runtime Semantics: Evaluation
        # VariableDeclaration : BindingIdentifier
        #   1. Return NormalCompletion(empty).
        return EMPTY


class P2_VariableDeclaration_BindingIdentifier_Initializer(P2_VariableDeclaration):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def BoundNames(self):
        # 13.3.2.1 Static Semantics: BoundNames
        #   VariableDeclaration : BindingIdentifier Initializer
        #   1. Return the BoundNames of BindingIdentifier.
        return self.BindingIdentifier.BoundNames()

    def evaluate(self):
        # 13.3.2.4 Runtime Semantics: Evaluation
        #       VariableDeclaration : BindingIdentifier Initializer
        #   1. Let bindingId be StringValue of BindingIdentifier.
        #   2. Let lhs be ? ResolveBinding(bindingId).
        #   3. If IsAnonymousFunctionDefinition(Initializer) is true, then
        #       a. Let value be the result of performing NamedEvaluation for Initializer with argument bindingId.
        #   4. Else,
        #       a. Let rhs be the result of evaluating Initializer.
        #       b. Let value be ? GetValue(rhs).
        #   5. Return ? PutValue(lhs, value).
        bindingId = self.BindingIdentifier.StringValue
        lhs = ResolveBinding(bindingId, self.strict)
        value = (
            self.Initializer.NamedEvaluation(bindingId)
            if IsAnonymousFunctionDefinition(self.Initializer)
            else GetValue(self.Initializer.evaluate())
        )
        return PutValue(lhs, value)


class P2_VariableDeclaration_BindingPattern_Initializer(P2_VariableDeclaration):
    @property
    def BindingPattern(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def BoundNames(self):
        # 13.3.2.1 Static Semantics: BoundNames
        # VariableDeclaration : BindingPattern Initializer
        #   1. Return the BoundNames of BindingPattern.
        return self.BindingPattern.BoundNames()

    def evaluate(self):
        # 13.3.2.4 Runtime Semantics: Evaluation
        # VariableDeclaration : BindingPattern Initializer
        #   1. Let rhs be the result of evaluating Initializer.
        #   2. Let rval be ? GetValue(rhs).
        #   3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined
        #      as arguments.
        rhs = self.Initializer.evaluate()
        rval = GetValue(rhs)
        return self.BindingPattern.BindingInitialization(rval, None)


def parse_VariableDeclaration(context, lexer, pos, strict, In, Yield, Await):
    # 13.3.2 Variable Statement
    # Syntax
    #   VariableDeclaration[In, Yield, Await] :
    #       BindingIdentifier[?Yield, ?Await]
    #       BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
    #       BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
    bi = parse_BindingIdentifier(context, lexer, pos, strict, Yield, Await)
    if bi:
        init1 = parse_Initializer(context, lexer, bi.after, strict, In, Yield, Await)
        if init1:
            return P2_VariableDeclaration_BindingIdentifier_Initializer(context, strict, [bi, init1])
        return P2_VariableDeclaration_BindingIdentifier(context, strict, [bi])
    bp = parse_BindingPattern(context, lexer, pos, strict, Yield, Await)
    if bp:
        init2 = parse_Initializer(context, lexer, bp.after, strict, In, Yield, Await)
        if init2:
            return P2_VariableDeclaration_BindingPattern_Initializer(context, strict, [bp, init2])
    return None


# @@@ Next up: 13.3.3.6
# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓟𝓪𝓽𝓽𝓮𝓻𝓷 =======--------
# Syntax
#   BindingPattern :
#       ObjectBindingPattern
#       ArrayBindingPattern


class P2_BindingPattern(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingPattern", strict, children)


class P2_BindingPattern_ObjectBindingPattern(P2_BindingPattern):
    @property
    def ObjectBindingPattern(self):
        return self.children[0]

    def BindingInitialization(self, value, environment):
        # 13.3.3.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        # BindingPattern : ObjectBindingPattern
        #   1. Perform ? RequireObjectCoercible(value).
        #   2. Return the result of performing BindingInitialization for ObjectBindingPattern using value and
        #      environment as arguments.
        RequireObjectCoercible(value)
        return self.ObjectBindingPattern.BindingInitialization(value, environment)


class P2_BindingPattern_ArrayBindingPattern(P2_BindingPattern):
    @property
    def ArrayBindingPattern(self):
        return self.children[0]

    def BindingInitialization(self, value, environment):
        # 13.3.3.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        # BindingPattern : ArrayBindingPattern
        #   1. Let iteratorRecord be ? GetIterator(value).
        #   2. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment
        #      as arguments.
        #   3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
        #   4. Return result.
        iteratorRecord = GetIterator(value)
        try:
            result = self.ArrayBindingPattern.IteratorBindingInitialization(iteratorRecord, environment)
        finally:
            if not iteratorRecord.Done:
                IteratorClose(iteratorRecord)
        return result


def parse_BindingPattern(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingPattern[Yield, Await] :
    #       ObjectBindingPattern[?Yield, ?Await]
    #       ArrayBindingPattern[?Yield, ?Await]
    obp = parse_ObjectBindingPattern(context, lexer, pos, strict, Yield, Await)
    if obp:
        return P2_BindingPattern_ObjectBindingPattern(context, strict, [obp])
    abp = parse_ArrayBindingPattern(context, lexer, pos, strict, Yield, Await)
    if abp:
        return P2_BindingPattern_ArrayBindingPattern(context, strict, [abp])
    return None


# --------======= 𝓞𝓫𝓳𝓮𝓬𝓽𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓟𝓪𝓽𝓽𝓮𝓻𝓷 =======--------
# Syntax
#   ObjectBindingPattern:
#       { }
#       { BindingRestProperty }
#       { BindingPropertyList }
#       { BindingPropertyList , BindingRestProperty[opt] }


class P2_ObjectBindingPattern(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ObjectBindingPattern", strict, children)


class P2_ObjectBindingPattern_Empty(P2_ObjectBindingPattern):
    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # ObjectBindingPattern : { }
        #   1. Return a new empty List.
        return []

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # ObjectBindingPattern : { }
        #   1. Return false.
        return False

    def BindingInitialization(self, value, environment):
        # 13.3.3.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        # ObjectBindingPattern : { }
        #   1. Return NormalCompletion(empty).
        return EMPTY


class P2_ObjectBindingPattern_BindingRestProperty(P2_ObjectBindingPattern):
    @property
    def BindingRestProperty(self):
        return self.children[1]

    def BindingInitialization(self, value, environment):
        # 13.3.3.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        # ObjectBindingPattern : { BindingRestProperty }
        #   1. Let excludedNames be a new empty List.
        #   2. Return the result of performing RestBindingInitialization of BindingRestProperty with value,
        #      environment, and excludedNames as the arguments.
        return self.BindingRestProperty.RestBindingInitialization(value, environment, [])


class P2_ObjectBindingPattern_BindingPropertyList(P2_ObjectBindingPattern):
    @property
    def BindingPropertyList(self):
        return self.children[1]

    def BindingInitialization(self, value, environment):
        # 13.3.3.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        # ObjectBindingPattern : { BindingPropertyList }
        # ObjectBindingPattern : { BindingPropertyList , }
        #   1. Perform ? PropertyBindingInitialization for BindingPropertyList using value and environment as the
        #      arguments.
        #   2. Return NomalCompletion(empty).
        self.BindingPropertyList.PropertyBindingInitialization(value, environment)
        return EMPTY


class P2_ObjectBindingPattern_BindingPropertyList_BindingRestProperty(P2_ObjectBindingPattern):
    @property
    def BindingPropertyList(self):
        return self.children[1]

    @property
    def BindingRestProperty(self):
        return self.children[3]

    def BindingInitialization(self, value, environment):
        # 13.3.3.5 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        # ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
        #   1. Let excludedNames be the result of performing ? PropertyBindingInitialization of BindingPropertyList
        #      using value and environment as arguments.
        #   2. Return the result of performing RestBindingInitialization of BindingRestProperty with value,
        #      environment, and excludedNames as the arguments.
        excludedNames = self.BindingPropertyList.PropertyBindingInitialization(value, environment)
        return self.BindingRestProperty.RestBindingInitialization(value, environment, excludedNames)

    def BoundNames(self):
        return self.BindingPropertyList.BoundNames() + self.BindingRestProperty.BoundNames()

    def ContainsExpression(self):
        return self.BindingPropertyList.ContainsExpression() or self.BindingRestProperty.ContainsExpression()


def parse_ObjectBindingPattern(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   ObjectBindingPattern[Yield, Await]:
    #       { }
    #       { BindingRestProperty[?Yield, ?Await] }
    #       { BindingPropertyList[?Yield, ?Await] }
    #       { BindingPropertyList[?Yield, ?Await] , BindingRestProperty[?Yield, ?Await][opt] }
    #
    lc = lexer.token_if(pos, "{")
    if lc:
        bpl = parse_BindingPropertyList(context, lexer, lc.span.after, strict, Yield, Await)
        if bpl:
            comma = lexer.token_if(bpl.after, ",")
            if comma:
                brp1 = parse_BindingRestProperty(context, lexer, comma.span.after, strict, Yield, Await)
                rc1 = lexer.token_if(brp1.after if brp1 else comma.span.after, "}")
                if rc1:
                    if brp1:
                        return P2_ObjectBindingPattern_BindingPropertyList_BindingRestProperty(
                            context, strict, [lc, bpl, comma, brp1, rc1]
                        )
                    return P2_ObjectBindingPattern_BindingPropertyList(context, strict, [lc, bpl, comma, rc1])
            else:
                rc2 = lexer.token_if(bpl.after, "}")
                if rc2:
                    return P2_ObjectBindingPattern_BindingPropertyList(context, strict, [lc, bpl, rc2])
        else:
            brp2 = parse_BindingRestProperty(context, lexer, lc.span.after, strict, Yield, Await)
            rc3 = lexer.token_if(brp2.after if brp2 else lc.span.after, "}")
            if rc3:
                if brp2:
                    return P2_ObjectBindingPattern_BindingRestProperty(context, strict, [lc, brp2, rc3])
                return P2_ObjectBindingPattern_Empty(context, strict, [lc, rc3])
    return None


# --------======= 𝓐𝓻𝓻𝓪𝔂𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓟𝓪𝓽𝓽𝓮𝓻𝓷 =======--------
# Syntax
#   ArrayBindingPattern :
#       [ Elision[opt] BindingRestElement[opt] ]
#       [ BindingElementList ]
#       [ BindingElementList , Elision[opt] BindingRestElement[opt] ]


class P2_ArrayBindingPattern(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ArrayBindingPattern", strict, children)

    BindingElementList = None
    BindingRestElement = None
    Elision = None

    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # ArrayBindingPattern : [ Elision ]
        #   1. Return a new empty List.
        # ArrayBindingPattern : [ Elision BindingRestElement ]
        #   1. Return the BoundNames of BindingRestElement.
        # ArrayBindingPattern : [ BindingElementList , Elision ]
        #   1. Return the BoundNames of BindingElementList.
        # ArrayBindingPattern : [ BindingElementList , Elision BindingRestElement ]
        #   1. Let names be BoundNames of BindingElementList.
        #   2. Append to names the elements of BoundNames of BindingRestElement.
        #   3. Return names.
        return reduce(
            operator.concat,
            (node.BoundNames() for node in (self.BindingElementList, self.BindingRestElement) if node),
            [],
        )

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # ArrayBindingPattern : [ Elision ]
        #   1. Return false.
        # ArrayBindingPattern : [ Elision BindingRestElement ]
        #   1. Return ContainsExpression of BindingRestElement.
        # ArrayBindingPattern : [ BindingElementList , Elision ]
        #   1. Return ContainsExpression of BindingElementList.
        # ArrayBindingPattern : [ BindingElementList , Elision BindingRestElement ]
        #   1. Let has be ContainsExpression of BindingElementList.
        #   2. If has is true, return true.
        #   3. Return ContainsExpression of BindingRestElement.
        return any(node.ContainsExpression() for node in (self.BindingElementList, self.BindingRestElement) if node)


class P2_ArrayBindingPattern_Empty(P2_ArrayBindingPattern):
    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ ]
        #       1. Return NormalCompletion(empty).
        return EMPTY


class P2_ArrayBindingPattern_Elision(P2_ArrayBindingPattern):
    @property
    def Elision(self):
        return self.children[1]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ Elision ]
        #       1. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with
        #          iteratorRecord as the argument.
        return self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)


class P2_ArrayBindingPattern_BindingRestElement(P2_ArrayBindingPattern):
    @property
    def BindingRestElement(self):
        return self.children[1]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ BindingRestElement ]
        #       1. Return the result of performing IteratorBindingInitialization for BindingRestElement with
        #          iteratorRecord and environment as arguments.
        return self.BindingRestElement.IteratorBindingInitialization(iteratorRecord, environment)


class P2_ArrayBindingPattern_Elision_BindingRestElement(P2_ArrayBindingPattern):
    @property
    def Elision(self):
        return self.children[1]

    @property
    def BindingRestElement(self):
        return self.children[2]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ Elision BindingRestElement ]
        #       1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
        #       2. Return the result of performing IteratorBindingInitialization for BindingRestElement with
        #          iteratorRecord and environment as arguments.
        self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        return self.BindingRestElement.IteratorBindingInitialization(iteratorRecord, environment)


class P2_ArrayBindingPattern_BindingElementList(P2_ArrayBindingPattern):
    @property
    def BindingElementList(self):
        return self.children[1]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ BindingElementList ]
        #       1. Return the result of performing IteratorBindingInitialization for BindingElementList with
        #          iteratorRecord and environment as arguments.
        return self.BindingElementList.IteratorBindingInitialization(iteratorRecord, environment)


class P2_ArrayBindingPattern_BindingElementList_Elision(P2_ArrayBindingPattern):
    @property
    def BindingElementList(self):
        return self.children[1]

    @property
    def Elision(self):
        return self.children[3]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ BindingElementList , Elision ]
        #       1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment
        #          as arguments.
        #       2. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with
        #          iteratorRecord as the argument.
        self.BindingElementList.IteratorBindingInitialization(iteratorRecord, environment)
        return self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)


class P2_ArrayBindingPattern_BindingElementList_BindingRestElement(P2_ArrayBindingPattern):
    @property
    def BindingElementList(self):
        return self.children[1]

    @property
    def BindingRestElement(self):
        return self.children[3]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ BindingElementList , BindingRestElement ]
        #       1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment
        #          as arguments.
        #       2. Return the result of performing IteratorBindingInitialization for BindingRestElement with
        #          iteratorRecord and environment as arguments.
        self.BindingElementList.IteratorBindingInitialization(iteratorRecord, environment)
        return self.BindingRestElement.IteratorBindingInitialization(iteratorRecord, environment)


class P2_ArrayBindingPattern_BindingElementList_Elision_BindingRestElement(P2_ArrayBindingPattern):
    @property
    def BindingElementList(self):
        return self.children[1]

    @property
    def Elision(self):
        return self.children[3]

    @property
    def BindingRestElement(self):
        return self.children[4]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # ArrayBindingPattern : [ BindingElementList , Elision BindingRestElement ]
        #       1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment
        #          as arguments.
        #       2. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
        #       3. Return the result of performing IteratorBindingInitialization for BindingRestElement with
        #          iteratorRecord and environment as arguments.
        self.BindingElementList.IteratorBindingInitialization(iteratorRecord, environment)
        self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        return self.BindingRestElement.IteratorBindingInitialization(iteratorRecord, environment)


def parse_ArrayBindingPattern(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   ArrayBindingPattern[Yield, Await] :
    #       [ Elision[opt] BindingRestElement[?Yield, ?Await][opt] ]
    #       [ BindingElementList[?Yield, ?Await] ]
    #       [ BindingElementList[?Yield, ?Await] , Elision[opt] BindingRestElement[?Yield, ?Await][opt] ]

    # @@@ I think this erroneously allows [ BindingElementList BindingRestElement ]
    # (I.e.: no comma). Need to make a test for that.
    lb = lexer.token_if(pos, "[")
    if lb:
        bel = parse_BindingElementList(context, lexer, lb.span.after, strict, Yield, Await)
        comma = lexer.token_if(bel.after, ",") if bel else None
        elision = parse_Elision(
            context, lexer, comma.span.after if comma else bel.after if bel else lb.span.after, strict
        )
        bre = parse_BindingRestElement(
            context,
            lexer,
            elision.after if elision else comma.span.after if comma else bel.after if bel else lb.span.after,
            strict,
            Yield,
            Await,
        )
        rb = lexer.token_if(
            bre.after
            if bre
            else elision.after
            if elision
            else comma.span.after
            if comma
            else bel.after
            if bel
            else lb.span.after,
            "]",
        )
        if rb:
            children = list(filter(lambda x: x is not None, (lb, bel, comma, elision, bre, rb)))
            idx = 4 * int(bre is not None) + 2 * int(elision is not None) + int(bel is not None)
            ctor = [
                P2_ArrayBindingPattern_Empty,  # 000
                P2_ArrayBindingPattern_BindingElementList,  # 001
                P2_ArrayBindingPattern_Elision,  # 010
                P2_ArrayBindingPattern_BindingElementList_Elision,  # 011
                P2_ArrayBindingPattern_BindingRestElement,  # 100
                P2_ArrayBindingPattern_BindingElementList_BindingRestElement,  # 101
                P2_ArrayBindingPattern_Elision_BindingRestElement,  # 110
                P2_ArrayBindingPattern_BindingElementList_Elision_BindingRestElement,  # 111
            ][idx]
            return ctor(context, strict, children)
    return None


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓡𝓮𝓼𝓽𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂 =======--------
# Syntax
#   BindingRestProperty :
#       ... BindingIdentifier


class P2_BindingRestProperty(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingRestProperty", strict, children)


class P2_BindingRestProperty_BindingIdentifier(P2_BindingRestProperty):
    @property
    def BindingIdentifier(self):
        return self.children[1]

    def RestBindingInitialization(self, value, environment, excludedNames):
        # 13.3.3.7 Runtime Semantics: RestBindingInitialization
        #       With parameters value, environment, and excludedNames.
        # BindingRestProperty : ... BindingIdentifier
        #       1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).
        #       2. Let restObj be ObjectCreate(%ObjectPrototype%).
        #       3. Perform ? CopyDataProperties(restObj, value, excludedNames).
        #       4. If environment is undefined, return PutValue(lhs, restObj).
        #       5. Return InitializeReferencedBinding(lhs, restObj).
        lhs = ResolveBinding(self.BindingIdentifier.StringValue, self.strict, environment)
        restObj = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
        CopyDataProperties(restObj, value, excludedNames)
        if environment is None:
            return PutValue(lhs, restObj)
        return InitializeReferencedBinding(lhs, restObj)


def parse_BindingRestProperty(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingRestProperty[Yield, Await] :
    #       ... BindingIdentifier[?Yield, ?Await]
    #
    dots = lexer.token_if(pos, "...")
    if dots:
        bi = parse_BindingIdentifier(context, lexer, dots.span.after, strict, Yield, Await)
        if bi:
            return P2_BindingRestProperty_BindingIdentifier(context, strict, [dots, bi])
    return None


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   BindingPropertyList :
#       BindingProperty
#       BindingPropertyList , BindingProperty


class P2_BindingPropertyList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingPropertyList", strict, children)


class P2_BindingPropertyList_BindingProperty(P2_BindingPropertyList):
    @property
    def BindingProperty(self):
        return self.children[0]


class P2_BindingPropertyList_BindingPropertyList_BindingProperty(P2_BindingPropertyList):
    @property
    def BindingPropertyList(self):
        return self.children[0]

    @property
    def BindingProperty(self):
        return self.children[2]

    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # BindingPropertyList : BindingPropertyList , BindingProperty
        #   1. Let names be BoundNames of BindingPropertyList.
        #   2. Append to names the elements of BoundNames of BindingProperty.
        #   3. Return names.
        return self.BindingPropertyList.BoundNames() + self.BindingProperty.BoundNames()

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # BindingPropertyList : BindingPropertyList , BindingProperty
        #   1. Let has be ContainsExpression of BindingPropertyList.
        #   2. If has is true, return true.
        #   3. Return ContainsExpression of BindingProperty.
        return self.BindingPropertyList.ContainsExpression() or self.BindingProperty.ContainsExpression()

    def PropertyBindingInitialization(self, value, environment):
        # 13.3.3.6 Runtime Semantics: PropertyBindingInitialization
        #   With parameters value and environment.
        #
        # NOTE
        # These collect a list of all bound property names rather than just empty completion.
        #
        # BindingPropertyList : BindingPropertyList , BindingProperty
        #       1. Let boundNames be the result of performing ? PropertyBindingInitialization for BindingPropertyList
        #          using value and environment as arguments.
        #       2. Let nextNames be the result of performing ? PropertyBindingInitialization for BindingProperty using
        #          value and environment as arguments.
        #       3. Append each item in nextNames to the end of boundNames.
        #       4. Return boundNames.
        boundNames = self.BindingPropertyList.PropertyBindingInitialization(value, environment)
        nextNames = self.BindingProperty.PropertyBindingInitialization(value, environment)
        return boundNames + nextNames


def parse_BindingPropertyList(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingPropertyList[Yield, Await] :
    #       BindingProperty[?Yield, ?Await]
    #       BindingPropertyList[?Yield, ?Await] , BindingProperty[?Yield, ?Await]
    def parse(pos, previous=None):
        if previous is None:
            bp1 = parse_BindingProperty(context, lexer, pos, strict, Yield, Await)
            if bp1:
                return lambda: parse(bp1.after, P2_BindingPropertyList_BindingProperty(context, strict, [bp1]))
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                bp2 = parse_BindingProperty(context, lexer, comma.span.after, strict, Yield, Await)
                if bp2:
                    return lambda: parse(
                        bp2.after,
                        P2_BindingPropertyList_BindingPropertyList_BindingProperty(
                            context, strict, [previous, comma, bp2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓔𝓵𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   BindingElementList :
#       BindingElisionElement
#       BindingElementList , BindingElisionElement


class P2_BindingElementList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingElementList", strict, children)


class P2_BindingElementList_BindingElisionElement(P2_BindingElementList):
    @property
    def BindingElisionElement(self):
        return self.children[0]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # BindingElementList : BindingElisionElement
        #       1. Return the result of performing IteratorBindingInitialization for BindingElisionElement with
        #          iteratorRecord and environment as arguments.
        return self.BindingElisionElement.IteratorBindingInitialization(iteratorRecord, environment)


class P2_BindingElementList_BindingElementList_BindingElisionElement(P2_BindingElementList):
    @property
    def BindingElementList(self):
        return self.children[0]

    @property
    def BindingElisionElement(self):
        return self.children[2]

    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # BindingElementList : BindingElementList , BindingElisionElement
        #   1. Let names be BoundNames of BindingElementList.
        #   2. Append to names the elements of BoundNames of BindingElisionElement.
        #   3. Return names.
        return self.BindingElementList.BoundNames() + self.BindingElisionElement.BoundNames()

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # BindingElementList : BindingElementList , BindingElisionElement
        #   1. Let has be ContainsExpression of BindingElementList.
        #   2. If has is true, return true.
        #   3. Return ContainsExpression of BindingElisionElement.
        return self.BindingElementList.ContainsExpression() or self.BindingElisionElement.ContainsExpression()

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # BindingElementList : BindingElementList , BindingElisionElement
        #       1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment
        #          as arguments.
        #       2. Return the result of performing IteratorBindingInitialization for BindingElisionElement using
        #          iteratorRecord and environment as arguments.
        self.BindingElementList.IteratorBindingInitialization(iteratorRecord, environment)
        return self.BindingElisionElement.IteratorBindingInitialization(iteratorRecord, environment)


def parse_BindingElementList(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingElementList[Yield, Await] :
    #       BindingElisionElement[?Yield, ?Await]
    #       BindingElementList[?Yield, ?Await] , BindingElisionElement[?Yield, ?Await]
    def parse(pos, previous=None):
        if previous is None:
            bp1 = parse_BindingElisionElement(context, lexer, pos, strict, Yield, Await)
            if bp1:
                return lambda: parse(bp1.after, P2_BindingElementList_BindingElisionElement(context, strict, [bp1]))
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                bp2 = parse_BindingElisionElement(context, lexer, comma.span.after, strict, Yield, Await)
                if bp2:
                    return lambda: parse(
                        bp2.after,
                        P2_BindingElementList_BindingElementList_BindingElisionElement(
                            context, strict, [previous, comma, bp2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓔𝓵𝓲𝓼𝓲𝓸𝓷𝓔𝓵𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   BindingElisionElement :
#       Elision[opt] BindingElement


class P2_BindingElisionElement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingElisionElement", strict, children)


class P2_BindingElisionElement_BindingElement(P2_BindingElisionElement):
    @property
    def BindingElement(self):
        return self.children[0]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #       With parameters iteratorRecord and environment.
        # BindingElisionElement : BindingElement
        #       1. Return the result of performing IteratorBindingInitialization of BindingElement with iteratorRecord
        #          and environment as the arguments.
        return self.BindingElement.IteratorBindingInitialization(iteratorRecord, environment)


class P2_BindingElisionElement_Elision_BindingElement(P2_BindingElisionElement):
    @property
    def Elision(self):
        return self.children[0]

    @property
    def BindingElement(self):
        return self.children[1]

    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # BindingElisionElement : Elision BindingElement
        #   1. Return BoundNames of BindingElement.
        return self.BindingElement.BoundNames()

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # BindingElisionElement: Elsision BindingElement
        #   1. Return ContainsExpression of BindingElement.
        return self.BindingElement.ContainsExpression()

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #       With parameters iteratorRecord and environment.
        # BindingElisionElement: Elision BindingElement
        #       1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
        #       2. Return the result of performing IteratorBindingInitialization of BindingElement with iteratorRecord
        #          and environment as the arguments.
        self.Elision.IteratorDestructuringAssignmentEvaluation(iteratorRecord)
        return self.BindingElement.IteratorBindingInitialization(iteratorRecord, environment)


def parse_BindingElisionElement(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingElisionElement[Yield, Await] :
    #       Elision[opt] BindingElement[?Yield, ?Await]
    elision = parse_Elision(context, lexer, pos, strict)
    be = parse_BindingElement(context, lexer, elision.after if elision else pos, strict, Yield, Await)
    if be:
        if elision:
            return P2_BindingElisionElement_Elision_BindingElement(context, strict, [elision, be])
        return P2_BindingElisionElement_BindingElement(context, strict, [be])
    return None


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂 =======--------
# Syntax
#   BindingProperty :
#       SingleNameBinding
#       PropertyName : BindingElement


class P2_BindingProperty(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingProperty", strict, children)


class P2_BindingProperty_SingleNameBinding(P2_BindingProperty):
    @property
    def SingleNameBinding(self):
        return self.children[0]

    def PropertyBindingInitialization(self, value, environment):
        # 13.3.3.6 Runtime Semantics: PropertyBindingInitialization
        #   With parameters value and environment.
        # BindingProperty : SingleNameBinding
        #   1. Let name be the string that is the only element of BoundNames of SingleNameBinding.
        #   2. Perform ? KeyedBindingInitialization for SingleNameBinding using value, environment, and name as
        #      the arguments.
        #   3. Return a new List containing name.
        name = self.SingleNameBinding.BoundNames()[0]
        self.SingleNameBinding.KeyedBindingInitialization(value, environment, name)
        return [name]


class P2_BindingProperty_PropertyName_BindingElement(P2_BindingProperty):
    @property
    def PropertyName(self):
        return self.children[0]

    @property
    def BindingElement(self):
        return self.children[2]

    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # BindingProperty : PropertyName : BindingElement
        #   1. Return the BoundNames of BindingElement.
        return self.BindingElement.BoundNames()

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # BindingProperty : PropertyName : BindingElement
        #   1. Let has be IsComputedPropertyKey of PropertyName.
        #   2. If has is true, return true.
        #   3. Return ContainsExpression of BindingElement.
        return self.PropertyName.IsComputedPropertyKey() or self.BindingElement.ContainsExpression()

    def PropertyBindingInitialization(self, value, environment):
        # 13.3.3.6 Runtime Semantics: PropertyBindingInitialization
        #   With parameters value and environment.
        # BindingProperty : PropertyName : BindingElement
        #   1. Let P be the result of evaluating PropertyName.
        #   2. ReturnIfAbrupt(P).
        #   3. Perform ? KeyedBindingInitialization of BindingElement with value, environment, and P as the arguments.
        #   4. Return a new List containing P.
        P = self.PropertyName.evaluate()
        self.BindingElement.KeyedBindingInitialization(value, environment, P)
        return [P]


def parse_BindingProperty(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingProperty[Yield, Await] :
    #       SingleNameBinding[?Yield, ?Await]
    #       PropertyName[?Yield, ?Await] : BindingElement[?Yield, ?Await]
    #
    # Have to do SingleNameBinding last, because it starts off the same as PropertyName.
    pn = parse_PropertyName(context, lexer, pos, strict, Yield, Await)
    if pn:
        colon = lexer.token_if(pn.after, ":")
        if colon:
            be = parse_BindingElement(context, lexer, colon.span.after, strict, Yield, Await)
            if be:
                return P2_BindingProperty_PropertyName_BindingElement(context, strict, [pn, colon, be])
    snb = parse_SingleNameBinding(context, lexer, pos, strict, Yield, Await)
    if snb:
        return P2_BindingProperty_SingleNameBinding(context, strict, [snb])
    return None


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓔𝓵𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   BindingElement :
#       SingleNameBinding
#       BindingPattern Initializer[opt]


class P2_BindingElement(ParseNode2):
    # ----------------------- 𝑩𝒊𝒏𝒅𝒊𝒏𝒈𝑬𝒍𝒆𝒎𝒆𝒏𝒕 -----------------------
    """Parse node for any BindingElement production

    This node may correspond to one of the following productions:
        BindingElement : SingleNameBinding
        BindingElement : BindingPattern
        BindingElement : BindingPattern Initializer
    """

    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingElement", strict, children)


class P2_BindingElement_SingleNameBinding(P2_BindingElement):
    # ----------------------- 𝑩𝒊𝒏𝒅𝒊𝒏𝒈𝑬𝒍𝒆𝒎𝒆𝒏𝒕 : 𝑺𝒊𝒏𝒈𝒍𝒆𝑵𝒂𝒎𝒆𝑩𝒊𝒏𝒅𝒊𝒏𝒈 -----------------------
    """Parse Node for the "BindingElement : SingleNameBinding" production"""

    @property
    def SingleNameBinding(self):
        return self.children[0]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # BindingElement : SingleNameBinding
        #       1. Return the result of performing IteratorBindingInitialization for SingleNameBinding with
        #          iteratorRecord and environment as the arguments.
        return self.SingleNameBinding.IteratorBindingInitialization(iteratorRecord, environment)


class P2_BindingElement_BindingPattern(P2_BindingElement):
    # ----------------------- 𝑩𝒊𝒏𝒅𝒊𝒏𝒈𝑬𝒍𝒆𝒎𝒆𝒏𝒕 : 𝑩𝒊𝒏𝒅𝒊𝒏𝒈𝑷𝒂𝒕𝒕𝒆𝒓𝒏 -----------------------
    """Parse Node for the "BindingElement : BindingPattern" production"""

    @property
    def BindingPattern(self):
        return self.children[0]

    def HasInitializer(self):
        # 13.3.3.3 Static Semantics: HasInitializer
        # BindingElement : BindingPattern
        #   1. Return false.
        return False

    def IsSimpleParameterList(self):
        # 13.3.3.4 Static Semantics: IsSimpleParameterList
        # BindingElement : BindingPattern
        #   1. Return false.
        return False

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # BindingElement : BindingPattern
        #       1. If iteratorRecord.[[Done]] is false, then
        #          a. Let next be IteratorStep(iteratorRecord).
        #          b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #          c. ReturnIfAbrupt(next).
        #          d. If next is false, set iteratorRecord.[[Done]] to true.
        #          e. Else,
        #             i. Let v be IteratorValue(next).
        #            ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           iii. ReturnIfAbrupt(v).
        #       2. If iteratorRecord.[[Done]] is true, let v be undefined.
        #       3. Return the result of performing BindingInitialization of BindingPattern with v and environment as
        #          the arguments.)
        if not iteratorRecord.Done:
            try:
                next = IteratorStep(iteratorRecord)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            if not next:
                iteratorRecord.Done = True
            else:
                try:
                    v = IteratorValue(next)
                except (ESError, ESAbrupt):
                    iteratorRecord.Done = True
                    raise
        if iteratorRecord.Done:
            v = None
        return self.BindingPattern.BindingInitialization(v, environment)

    def KeyedBindingInitialization(self, value, environment, propertyName):
        # 13.3.3.9 Runtime Semantics: KeyedBindingInitialization
        #   With parameters value, environment, and propertyName.
        # BindingElement : BindingPattern
        #   1. Let v be ? GetV(value, propertyName).
        #   2. Return the result of performing BindingInitialization for BindingPattern passing v and environment
        #      as arguments.
        v = GetV(value, propertyName)
        return self.BindingPattern.BindingInitialization(v, environment)


class P2_BindingElement_BindingPattern_Initializer(P2_BindingElement):
    # ----------------------- 𝑩𝒊𝒏𝒅𝒊𝒏𝒈𝑬𝒍𝒆𝒎𝒆𝒏𝒕 : 𝑩𝒊𝒏𝒅𝒊𝒏𝒈𝑷𝒂𝒕𝒕𝒆𝒓𝒏 𝑰𝒏𝒊𝒕𝒊𝒂𝒍𝒊𝒛𝒆𝒓 -----------------------
    """Parse Node for the "BindingElement : BindingPattern Initializer" production"""

    @property
    def BindingPattern(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # BindingElement : BindingPattern Initializer
        #   1. Return the BoundNames of BindingPattern.
        return self.BindingPattern.BoundNames()

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # BindingElement : BindingPattern Initializer
        #   1. Return true.
        return True

    def HasInitializer(self):
        # 13.3.3.3 Static Semantics: HasInitializer
        # BindingElement : BindingPattern Initializer
        #   1. Return true.
        return True

    def IsSimpleParameterList(self):
        # 13.3.3.4 Static Semantics: IsSimpleParameterList
        # BindingElement : BindingPattern Initializer
        #   1. Return false.
        return False

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # BindingElement : BindingPattern Initializer
        #       1. If iteratorRecord.[[Done]] is false, then
        #          a. Let next be IteratorStep(iteratorRecord).
        #          b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #          c. ReturnIfAbrupt(next).
        #          d. If next is false, set iteratorRecord.[[Done]] to true.
        #          e. Else,
        #             i. Let v be IteratorValue(next).
        #            ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           iii. ReturnIfAbrupt(v).
        #       2. If iteratorRecord.[[Done]] is true, let v be undefined.
        #       3. If v is undefined, then
        #          a. Let defaultValue be the result of evaluating Initializer.
        #          b. Set v to ? GetValue(defaultValue).
        #       4. Return the result of performing BindingInitialization of BindingPattern with v and environment as
        #          the arguments.)
        if not iteratorRecord.Done:
            try:
                next = IteratorStep(iteratorRecord)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            if not next:
                iteratorRecord.Done = True
            else:
                try:
                    v = IteratorValue(next)
                except (ESError, ESAbrupt):
                    iteratorRecord.Done = True
                    raise
        if iteratorRecord.Done:
            v = None
        if v is None:
            defaultValue = self.Initializer.evaluate()
            v = GetValue(defaultValue)
        return self.BindingPattern.BindingInitialization(v, environment)

    def KeyedBindingInitialization(self, value, environment, propertyName):
        # 13.3.3.9 Runtime Semantics: KeyedBindingInitialization
        #   With parameters value, environment, and propertyName.
        # BindingElement : BindingPattern Initializer
        #   1. Let v be ? GetV(value, propertyName).
        #   2. If v is undefined, then
        #      a. Let defaultValue be the result of evaluating Initializer.
        #      b. Set v to ? GetValue(defaultValue).
        #   3. Return the result of performing BindingInitialization for BindingPattern passing v and environment
        #      as arguments.
        v = GetV(value, propertyName)
        if v is None:
            defaultValue = self.Initializer.evaluate()
            v = GetValue(defaultValue)
        return self.BindingPattern.BindingInitialization(v, environment)


def parse_BindingElement(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingElement[Yield, Await] :
    #       SingleNameBinding[?Yield, ?Await]
    #       BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await][opt]
    snb = parse_SingleNameBinding(context, lexer, pos, strict, Yield, Await)
    if snb:
        return P2_BindingElement_SingleNameBinding(context, strict, [snb])
    bp = parse_BindingPattern(context, lexer, pos, strict, Yield, Await)
    if bp:
        init = parse_Initializer(context, lexer, bp.after, strict, True, Yield, Await)
        if init:
            return P2_BindingElement_BindingPattern_Initializer(context, strict, [bp, init])
        return P2_BindingElement_BindingPattern(context, strict, [bp])
    return None


# --------======= 𝓢𝓲𝓷𝓰𝓵𝓮𝓝𝓪𝓶𝓮𝓑𝓲𝓷𝓭𝓲𝓷𝓰 =======--------
# Syntax
#   SingleNameBinding :
#       BindingIdentifier Initializer[opt]


class P2_SingleNameBinding(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "SingleNameBinding", strict, children)


class P2_SingleNameBinding_BindingIdentifier(P2_SingleNameBinding):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # SingleNameBinding : BindingIdentifier
        #   1. Return false.
        return False

    def HasInitializer(self):
        # 13.3.3.3 Static Semantics: HasInitializer
        # SingleNameBinding : BindingIdentifier
        #   1. Return false.
        return False

    def IsSimpleParameterList(self):
        # 13.3.3.4 Static Semantics: IsSimpleParameterList
        # SingleNameBinding : BindingIdentifier
        #   1. Return true.
        return True

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # SingleNameBinding : BindingIdentifier
        #   1. Let bindingId be StringValue of BindingIdentifier.
        #   2. Let lhs be ? ResolveBinding(bindingId, environment).
        #   3. If iteratorRecord.[[Done]] is false, then
        #       a. Let next be IteratorStep(iteratorRecord).
        #       b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #       c. ReturnIfAbrupt(next).
        #       d. If next is false, set iteratorRecord.[[Done]] to true.
        #       e. Else,
        #           i. Let v be IteratorValue(next).
        #           ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           iii. ReturnIfAbrupt(v).
        #   4. If iteratorRecord.[[Done]] is true, let v be undefined.
        #   5. If environment is undefined, return ? PutValue(lhs, v).
        #   6. Return InitializeReferencedBinding(lhs, v).
        bindingId = self.BindingIdentifier.StringValue
        lhs = ResolveBinding(bindingId, self.strict, environment)
        if not iteratorRecord.Done:
            try:
                next = IteratorStep(iteratorRecord)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            if not next:
                iteratorRecord.Done = True
            else:
                try:
                    v = IteratorValue(next)
                except (ESError, ESAbrupt):
                    iteratorRecord.Done = True
                    raise
        if iteratorRecord.Done:
            v = None
        if environment is None:
            return PutValue(lhs, v)
        return InitializeReferencedBinding(lhs, v)

    def KeyedBindingInitialization(self, value, environment, propertyName):
        # 13.3.3.9 Runtime Semantics: KeyedBindingInitialization
        #   With parameters value, environment, and propertyName.
        # SingleNameBinding : BindingIdentifier
        #   1. Let bindingId be StringValue of BindingIdentifier.
        #   2. Let lhs be ? ResolveBinding(bindingId, environment).
        #   3. Let v be ? GetV(value, propertyName).
        #   4. If environment is undefined, return ? PutValue(lhs, v).
        #   5. Return InitializeReferencedBinding(lhs, v).
        bindingId = self.BindingIdentifier.StringValue
        lhs = ResolveBinding(bindingId, self.strict, environment)
        v = GetV(value, propertyName)
        if environment is None:
            return PutValue(lhs, v)
        return InitializeReferencedBinding(lhs, v)


class P2_SingleNameBinding_BindingIdentifier_Initializer(P2_SingleNameBinding):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    @property
    def Initializer(self):
        return self.children[1]

    def BoundNames(self):
        # 13.3.3.1 Static Semantics: BoundNames
        # SingleNameBinding : BindingIdentifier Initializer
        #   1. Return the BoundNames of BindingIdentifier.
        return self.BindingIdentifier.BoundNames()

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # SingleNameBinding : BindingIdentifier Initializer
        #   1. Return true.
        return True

    def HasInitializer(self):
        # 13.3.3.3 Static Semantics: HasInitializer
        # SingleNameBinding : BindingIdentifier Initializer
        #   1. Return true.
        return True

    def IsSimpleParameterList(self):
        # 13.3.3.4 Static Semantics: IsSimpleParameterList
        # SingleNameBinding : BindingIdentifier Initializer
        #   1. Return false.
        return False

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # SingleNameBinding : BindingIdentifier Initializer
        #       1. Let bindingId be StringValue of BindingIdentifier.
        #       2. Let lhs be ? ResolveBinding(bindingId, environment).
        #       3. If iteratorRecord.[[Done]] is false, then
        #           a. Let next be IteratorStep(iteratorRecord).
        #           b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           c. ReturnIfAbrupt(next).
        #           d. If next is false, set iteratorRecord.[[Done]] to true.
        #           e. Else,
        #               i. Let v be IteratorValue(next).
        #               ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #               iii. ReturnIfAbrupt(v).
        #       4. If iteratorRecord.[[Done]] is true, let v be undefined.
        #       5. If v is undefined, then
        #           a. Let defaultValue be the result of evaluating Initializer.
        #           b. Set v to ? GetValue(defaultValue).
        #           c. If IsAnonymousFunctionDefinition(Initializer) is true, then
        #               i. Let hasNameProperty be ? HasOwnProperty(v, "name").
        #               ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).
        #       6. If environment is undefined, return ? PutValue(lhs, v).
        #       7. Return InitializeReferencedBinding(lhs, v).
        bindingId = self.BindingIdentifier.StringValue
        lhs = ResolveBinding(bindingId, self.strict, environment)
        if not iteratorRecord.Done:
            try:
                next = IteratorStep(iteratorRecord)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            if not next:
                iteratorRecord.Done = True
            else:
                try:
                    v = IteratorValue(next)
                except (ESError, ESAbrupt):
                    iteratorRecord.Done = True
                    raise
        if iteratorRecord.Done:
            v = None
        if v is None:
            defaultValue = self.Initializer.evaluate()
            v = GetValue(defaultValue)
            if IsAnonymousFunctionDefinition(self.Initializer):
                hasNameProperty = HasOwnProperty(v, "name")
                if not hasNameProperty:
                    SetFunctionName(v, bindingId)
        if environment is None:
            return PutValue(lhs, v)
        return InitializeReferencedBinding(lhs, v)

    def KeyedBindingInitialization(self, value, environment, propertyName):
        # 13.3.3.9 Runtime Semantics: KeyedBindingInitialization
        #   With parameters value, environment, and propertyName.
        # SingleNameBinding : BindingIdentifier Initializer
        #       1. Let bindingId be StringValue of BindingIdentifier.
        #       2. Let lhs be ? ResolveBinding(bindingId, environment).
        #       3. Let v be ? GetV(value, propertyName).
        #       4. If v is undefined, then
        #           a. If IsAnonymousFunctionDefinition(Initializer) is true, then
        #               i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.
        #           b. Else,
        #               i. Let defaultValue be the result of evaluating Initializer.
        #               ii. Set v to ? GetValue(defaultValue).
        #       5. If environment is undefined, return ? PutValue(lhs, v).
        #       6. Return InitializeReferencedBinding(lhs, v).
        bindingId = self.BindingIdentifier.StringValue
        lhs = ResolveBinding(bindingId, self.strict, environment)
        v = GetV(value, propertyName)
        if v is None:
            v = (
                self.Initializer.NamedEvaluation(bindingId)
                if IsAnonymousFunctionDefinition(self.Initializer)
                else GetValue(self.Initializer.evaluate())
            )
        return InitializeReferencedBinding(lhs, v) if environment else PutValue(lhs, v)


def parse_SingleNameBinding(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   SingleNameBinding[Yield, Await] :
    #       BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await][opt]
    bi = parse_BindingIdentifier(context, lexer, pos, strict, Yield, Await)
    if bi:
        init = parse_Initializer(context, lexer, bi.after, strict, True, Yield, Await)
        if init:
            return P2_SingleNameBinding_BindingIdentifier_Initializer(context, strict, [bi, init])
        return P2_SingleNameBinding_BindingIdentifier(context, strict, [bi])
    return None


# --------======= 𝓑𝓲𝓷𝓭𝓲𝓷𝓰𝓡𝓮𝓼𝓽𝓔𝓵𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   BindingRestElement[Yield, Await] :
#       ... BindingIdentifier[?Yield, ?Await]
#       ... BindingPattern[?Yield, ?Await]


class P2_BindingRestElement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BindingRestElement", strict, children)


class P2_BindingRestElement_BindingIdentifier(P2_BindingRestElement):
    @property
    def BindingIdentifier(self):
        return self.children[1]

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # BindingRestElement : ... BindingIdentifier
        #   1. Return false.
        return False

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        #       1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).
        #       2. Let A be ! ArrayCreate(0).
        #       3. Let n be 0.
        #       4. Repeat,
        #           a. If iteratorRecord.[[Done]] is false, then
        #               i. Let next be IteratorStep(iteratorRecord).
        #               ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #               iii. ReturnIfAbrupt(next).
        #               iv. If next is false, set iteratorRecord.[[Done]] to true.
        #           b. If iteratorRecord.[[Done]] is true, then
        #               i. If environment is undefined, return ? PutValue(lhs, A).
        #               ii. Return InitializeReferencedBinding(lhs, A).
        #           c. Let nextValue be IteratorValue(next).
        #           d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           e. ReturnIfAbrupt(nextValue).
        #           f. Let status be CreateDataProperty(A, ! ToString(n), nextValue).
        #           g. Assert: status is true.
        #           h. Increment n by 1.
        lhs = ResolveBinding(self.BindingIdentifier.StringValue, self.strict, environment)
        A = ArrayCreate(0)
        n = 0
        while 1:
            if not iteratorRecord.Done:
                try:
                    next = IteratorStep(iteratorRecord)
                except (ESError, ESAbrupt):
                    iteratorRecord.Done = True
                    raise
                if not next:
                    iteratorRecord.Done = True
            if iteratorRecord.Done:
                if environment is None:
                    return PutValue(lhs, A)
                return InitializeReferencedBinding(lhs, A)
            try:
                nextValue = IteratorValue(next)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            status = CreateDataProperty(A, ToString(n), nextValue)
            assert status
            n += 1


class P2_BindingRestElement_BindingPattern(P2_BindingRestElement):
    @property
    def BindingPattern(self):
        return self.children[1]

    def ContainsExpression(self):
        # 13.3.3.2 Static Semantics: ContainsExpression
        # BindingRestElement : ... BindingPattern
        #   1. Return ContainsExpression of BindingPattern.
        return self.BindingPattern.ContainsExpression()

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        #       1. Let A be ! ArrayCreate(0).
        #       2. Let n be 0.
        #       3. Repeat,
        #           a. If iteratorRecord.[[Done]] is false, then
        #               i. Let next be IteratorStep(iteratorRecord).
        #               ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #               iii. ReturnIfAbrupt(next).
        #               iv. If next is false, set iteratorRecord.[[Done]] to true.
        #           b. If iteratorRecord.[[Done]] is true, then
        #               i. Return the result of performing BindingInitialization of BindingPattern with A and
        #                  environment as the arguments.
        #           c. Let nextValue be IteratorValue(next).
        #           d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #           e. ReturnIfAbrupt(nextValue).
        #           f. Let status be CreateDataProperty(A, ! ToString(n), nextValue).
        #           g. Assert: status is true.
        #           h. Increment n by 1.
        A = ArrayCreate(0)
        n = 0
        while 1:
            if not iteratorRecord.Done:
                try:
                    next = IteratorStep(iteratorRecord)
                except (ESError, ESAbrupt):
                    iteratorRecord.Done = True
                    raise
                if not next:
                    iteratorRecord.Done = True
            if iteratorRecord.Done:
                return self.BindingPattern.BindingInitialization(A, environment)
            try:
                nextValue = IteratorValue(next)
            except (ESError, ESAbrupt):
                iteratorRecord.Done = True
                raise
            status = CreateDataProperty(A, ToString(n), nextValue)
            assert status
            n += 1


def parse_BindingRestElement(context, lexer, pos, strict, Yield, Await):
    # 13.3.3 Destructuring Binding Patterns
    # Syntax
    #   BindingRestElement[Yield, Await] :
    #       ... BindingIdentifier[?Yield, ?Await]
    #       ... BindingPattern[?Yield, ?Await]
    dots = lexer.token_if(pos, "...")
    if dots:
        bi = parse_BindingIdentifier(context, lexer, dots.span.after, strict, Yield, Await)
        if bi:
            return P2_BindingRestElement_BindingIdentifier(context, strict, [dots, bi])
        bp = parse_BindingPattern(context, lexer, dots.span.after, strict, Yield, Await)
        if bp:
            return P2_BindingRestElement_BindingPattern(context, strict, [dots, bp])
    return None


#######################################################################################################################
#
#  d888    .d8888b.          d8888      8888888888                        888
# d8888   d88P  Y88b        d8P888      888                               888
#   888        .d88P       d8P 888      888                               888
#   888       8888"       d8P  888      8888888    88888b.d88b.  88888b.  888888 888  888
#   888        "Y8b.     d88   888      888        888 "888 "88b 888 "88b 888    888  888
#   888   888    888     8888888888     888        888  888  888 888  888 888    888  888
#   888   Y88b  d88P d8b       888      888        888  888  888 888 d88P Y88b.  Y88b 888
# 8888888  "Y8888P"  Y8P       888      8888888888 888  888  888 88888P"   "Y888  "Y88888
#                                                                888                  888
#                                                                888             Y8b d88P
#                                                                888              "Y88P"
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#######################################################################################################################
# 13.4 Empty Statement
# 13.4.1 RS: Evaluation
#######################################################################################################################

##############################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑.𝟒 𝓔𝓶𝓹𝓽𝔂 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 .....●·._..●·._..●·._.·´ #
##############################################################################
# 13.4 Empty Statement

# --------======= 𝓔𝓶𝓹𝓽𝔂𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   EmptyStatement :
#       ;
#
class P2_EmptyStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "EmptyStatement", strict, children)


class P2_EmptyStatement_SEMICOLON(P2_EmptyStatement):
    # EmptyStatement : ;

    def evaluate(self):
        # 13.4.1 Runtime Semantics: Evaluation
        # EmptyStatement : ;
        #   1. Return NormalCompletion(empty).
        return EMPTY


def parse_EmptyStatement(ctx, lexer, pos, strict):
    # 13.4 Empty Statement
    # Syntax
    #   EmptyStatement:
    #       ;
    semi = lexer.token_if(pos, ";")
    if semi:
        return P2_EmptyStatement_SEMICOLON(ctx, strict, [semi])
    return None


#######################################################################################################################
#
#  d888    .d8888b.      888888888
# d8888   d88P  Y88b     888
#   888        .d88P     888
#   888       8888"      8888888b.
#   888        "Y8b.          "Y88b
#   888   888    888            888
#   888   Y88b  d88P d8b Y88b  d88P
# 8888888  "Y8888P"  Y8P  "Y8888P"
#
#
#
# 8888888888                                                      d8b
# 888                                                             Y8P
# 888
# 8888888    888  888 88888b.  888d888  .d88b.  .d8888b  .d8888b  888  .d88b.  88888b.
# 888        `Y8bd8P' 888 "88b 888P"   d8P  Y8b 88K      88K      888 d88""88b 888 "88b
# 888          X88K   888  888 888     88888888 "Y8888b. "Y8888b. 888 888  888 888  888
# 888        .d8""8b. 888 d88P 888     Y8b.          X88      X88 888 Y88..88P 888  888
# 8888888888 888  888 88888P"  888      "Y8888   88888P'  88888P' 888  "Y88P"  888  888
#                     888
#                     888
#                     888
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#######################################################################################################################
# 13.5 Expression Statement
# 13.5.1 RS: Evaluation
#######################################################################################################################

##################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑.𝟓 𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 .....●·._..●·._..●·._.·´ #
##################################################################################
# 13.5 Expression Statement

# --------======= 𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   ExpressionStatement :
#       [lookahead ∉ { {, function, async [no LineTerminator here] function,
#                      class, let [ }] Expression ;
#
class P2_ExpressionStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ExpressionStatement", strict, children)


class P2_ExpressionStatement_Expression_SEMICOLON(P2_ExpressionStatement):
    # ExpressionStatement : Expression ;
    @property
    def Expression(self):
        return self.children[0]

    def evaluate(self):
        # 13.5.1 Runtime Semantics: Evaluation
        # ExpressionStatement : Expression ;
        #   1. Let exprRef be the result of evaluating Expression.
        #   2. Return ? GetValue(exprRef).
        return GetValue(self.Expression.evaluate())

    @cached_property
    def IsStringLiteral(self):
        return self.Expression.IsStringLiteral

    @cached_property
    def HasUseStrict(self):
        return self.Expression.HasUseStrict


def parse_ExpressionStatement(ctx, lexer, pos, strict, Yield, Await):
    # 13.5 Expression Statement
    # Syntax
    #   ExpressionStatement[Yield, Await]:
    #       [lookahead ∉ { {, function, async [no LineTerminator here] function,
    #                      class, let [ }] Expression[+In, ?Yield, ?Await] ;
    # NOTE
    # An ExpressionStatement cannot start with a U+007B (LEFT CURLY BRACKET) because that might make it ambiguous with
    # a Block. An ExpressionStatement cannot start with the function or class keywords because that would make it
    # ambiguous with a FunctionDeclaration, a GeneratorDeclaration, or a ClassDeclaration. An ExpressionStatement
    # cannot start with async function because that would make it ambiguous with an AsyncFunctionDeclaration or a
    # AsyncGeneratorDeclaration. An ExpressionStatement cannot start with the two token sequence let [ because that
    # would make it ambiguous with a let LexicalDeclaration whose first LexicalBinding was an ArrayBindingPattern.
    tok1, tok2 = lexer.tokens(pos, 2)
    if tok1 and (
        (tok1.type == "{")
        or (tok1.type == "IDENTIFIER" and (tok1.value in ("function", "class")))
        or (
            tok1.type == "IDENTIFIER"
            and tok1.value == "async"
            and tok2
            and tok2.type == "IDENTIFIER"
            and tok2.value == "function"
            and not tok2.newlines
        )
        or (tok1.type == "IDENTIFIER" and tok1.value == "let" and tok2 and tok2.type == "[")
    ):
        return None

    exp = parse_Expression(ctx, lexer, pos, strict, True, Yield, Await)
    if exp:
        semi = lexer.token_asi(exp.after)
        if semi:
            return P2_ExpressionStatement_Expression_SEMICOLON(ctx, strict, [exp, semi])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.      88888888888 888                   d8b  .d888
# d8888   d88P  Y88b     d88P  Y88b         888     888                   Y8P d88P"
#   888        .d88P     888                888     888                       888
#   888       8888"      888d888b.          888     88888b.   .d88b.      888 888888
#   888        "Y8b.     888P "Y88b         888     888 "88b d8P  Y8b     888 888
#   888   888    888     888    888         888     888  888 88888888     888 888
#   888   Y88b  d88P d8b Y88b  d88P         888     888  888 Y8b.         888 888
# 8888888  "Y8888P"  Y8P  "Y8888P"          888     888  888  "Y8888      888 888
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#######################################################################################################################
# 13.6 The if Statement
# 13.6.1 SS: Early Errors
# 13.6.2 SS: ContainsDuplicateLabels
# 13.6.3 SS: ContainsUndefinedBreakTarget
# 13.6.4 SS: ContainsUndefinedContinueTarget
# 13.6.5 SS: VarDeclaredNames
# 13.6.6 SS: VarScopedDeclarations
# 13.6.7 RS: Evaluation
#######################################################################################################################

##################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑.𝟔 𝓣𝓱𝓮 𝓲𝓯 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 .....●·._..●·._..●·._.·´ #
##################################################################################
# 13.6 The if Statement

# --------======= 𝓘𝓯𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   IfStatement :
#       if ( Expression ) Statement else Statement
#       if ( Expression ) Statement


class P2_IfStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "IfStatement", strict, children)


class P2_IfStatement_Expression_Statement_Statement(P2_IfStatement):
    @property
    def Expression(self):
        return self.children[2]

    @property
    def Statement1(self):
        return self.children[4]

    @property
    def Statement2(self):
        return self.children[6]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.6.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # IfStatement : if ( Expression ) Statement else Statement
        #   1. Let hasDuplicate be ContainsDuplicateLabels of the first Statement with argument labelSet.
        #   2. If hasDuplicate is true, return true.
        #   3. Return ContainsDuplicateLabels of the second Statement with argument labelSet.
        return self.Statement1.ContainsDuplicateLabels(labelSet) or self.Statement2.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.6.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # IfStatement : if ( Expression ) Statement else Statement
        #   1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of the first Statement with argument labelSet.
        #   2. If hasUndefinedLabels is true, return true.
        #   3. Return ContainsUndefinedBreakTarget of the second Statement with argument labelSet.
        return any(stmt.ContainsUndefinedBreakTarget(labelSet) for stmt in (self.Statement1, self.Statement2))

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.6.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # IfStatement : if ( Expression ) Statement else Statement
        #   1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of the first Statement with arguments
        #      iterationSet and « ».
        #   2. If hasUndefinedLabels is true, return true.
        #   3. Return ContainsUndefinedContinueTarget of the second Statement with arguments iterationSet and « ».
        return any(
            stmt.ContainsUndefinedContinueTarget(iterationSet, []) for stmt in (self.Statement1, self.Statement2)
        )

    def VarDeclaredNames(self):
        # 13.6.5 Static Semantics: VarDeclaredNames
        #           IfStatement : if ( Expression ) Statement else Statement
        # 1. Let names be VarDeclaredNames of the first Statement.
        # 2. Append to names the elements of the VarDeclaredNames of the second Statement.
        # 3. Return names.
        names = self.Statement1.VarDeclaredNames()
        names.extend(self.Statement2.VarDeclaredNames())
        return names

    def VarScopedDeclarations(self):
        # 13.6.6 Static Semantics: VarScopedDeclarations
        #           IfStatement : if ( Expression ) Statement else Statement
        # 1. Let declarations be VarScopedDeclarations of the first Statement.
        # 2. Append to declarations the elements of the VarScopedDeclarations of the second Statement.
        # 3. Return declarations.
        declarations = self.Statement1.VarScopedDeclarations()
        declarations.extend(self.Statement2.VarScopedDeclarations())
        return declarations

    def evaluate(self):
        # 13.6.7 Runtime Semantics: Evaluation
        #           IfStatement : if ( Expression ) Statement else Statement
        # 1. Let exprRef be the result of evaluating Expression.
        # 2. Let exprValue be ToBoolean(? GetValue(exprRef)).
        # 3. If exprValue is true, then
        #    a. Let stmtCompletion be the result of evaluating the first Statement.
        # 4. Else,
        #    a. Let stmtCompletion be the result of evaluating the second Statement.
        # 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)).
        exprValue = GetValue(self.Expression.evaluate())
        stmtCompletion = self.Statement1.evaluate() if ToBoolean(exprValue) else self.Statement2.evaluate()
        return UpdateEmpty(stmtCompletion, None)


class P2_IfStatement_Expression_Statement(P2_IfStatement):
    @property
    def Expression(self):
        return self.children[2]

    @property
    def Statement(self):
        return self.children[4]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.6.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        #           IfStatement : if ( Expression ) Statement
        # 1. Return ContainsDuplicateLabels of Statement with argument labelSet.
        return self.Statement.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.6.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        #           IfStatement : if ( Expression ) Statement
        # 1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
        return self.Statement.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.6.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #           IfStatement : if ( Expression ) Statement
        # 1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
        return self.Statement.ContainsUndefinedContinueTarget(iterationSet, [])

    def VarDeclaredNames(self):
        # 13.6.5 Static Semantics: VarDeclaredNames
        #           IfStatement : if ( Expression ) Statement
        # 1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.6.6 Static Semantics: VarScopedDeclarations
        #           IfStatement : if ( Expression ) Statement
        # 1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def evaluate(self):
        # 13.6.7 Runtime Semantics: Evaluation
        #           IfStatement : if ( Expression ) Statement
        # 1. Let exprRef be the result of evaluating Expression.
        # 2. Let exprValue be ToBoolean(? GetValue(exprRef)).
        # 3. If exprValue is false, then
        #    a. Return NormalCompletion(undefined).
        # 4. Else,
        #    a. Let stmtCompletion be the result of evaluating Statement.
        #    b. Return Completion(UpdateEmpty(stmtCompletion, undefined)).
        exprValue = GetValue(self.Expression.evaluate())
        return UpdateEmpty(self.Statement.evaluate(), None) if ToBoolean(exprValue) else None


def parse_IfStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13.6 The if Statement
    # Syntax
    #   IfStatement[Yield, Await, Return] :
    #       if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] else Statement[?Yield, ?Await, ?Return]
    #       if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    if_token = lexer.id_if(pos, "if")
    if if_token:
        lp = lexer.token_if(if_token.span.after, "(")
        if lp:
            exp = parse_Expression(context, lexer, lp.span.after, strict, True, Yield, Await)
            if exp:
                rp = lexer.token_if(exp.after, ")")
                if rp:
                    stmt = parse_Statement(context, lexer, rp.span.after, strict, Yield, Await, Return)
                    if stmt:
                        else_token = lexer.id_if(stmt.after, "else")
                        if else_token:
                            stmt_else = parse_Statement(
                                context, lexer, else_token.span.after, strict, Yield, Await, Return
                            )
                            if stmt_else:
                                return P2_IfStatement_Expression_Statement_Statement(
                                    context, strict, [if_token, lp, exp, rp, stmt, else_token, stmt_else]
                                )
                        return P2_IfStatement_Expression_Statement(context, strict, [if_token, lp, exp, rp, stmt])
    return None


#######################################################################################################################
#
#  d888    .d8888b.      8888888888     8888888 888                              888    d8b
# d8888   d88P  Y88b           d88P       888   888                              888    Y8P
#   888        .d88P          d88P        888   888                              888
#   888       8888"          d88P         888   888888  .d88b.  888d888  8888b.  888888 888  .d88b.  88888b.
#   888        "Y8b.      88888888        888   888    d8P  Y8b 888P"       "88b 888    888 d88""88b 888 "88b
#   888   888    888       d88P           888   888    88888888 888     .d888888 888    888 888  888 888  888
#   888   Y88b  d88P d8b  d88P            888   Y88b.  Y8b.     888     888  888 Y88b.  888 Y88..88P 888  888
# 8888888  "Y8888P"  Y8P d88P           8888888  "Y888  "Y8888  888     "Y888888  "Y888 888  "Y88P"  888  888
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888 .d8888b
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888    88K
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888    "Y8888b.
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.       X88
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888  88888P'
#
#######################################################################################################################
# 13.7 Iteration Statements
# 13.7.1 Semantics
# 13.7.1.1 SS: Early Errors
# 13.7.1.2 RS: LoopContinues ( completion, labelSet )
# 13.7.2 The do-while Statement
# 13.7.2.1 SS: ContainsDuplicateLabels
# 13.7.2.2 SS: ContainsUndefinedBreakTarget
# 13.7.2.3 SS: ContainsUndefinedContinueTarget
# 13.7.2.4 SS: VarDeclaredNames
# 13.7.2.5 SS: VarScopedDeclarations
# 13.7.2.6 RS: LabelledEvaluation
# 13.7.3 The while Statement
# 13.7.3.1 SS: ContainsDuplicateLabels
# 13.7.3.2 SS: ContainsUndefinedBreakTarget
# 13.7.3.3 SS: ContainsUndefinedContinueTarget
# 13.7.3.4 SS: VarDeclaredNames
# 13.7.3.5 SS: VarScopedDeclarations
# 13.7.3.6 RS: LabelledEvaluation
# 13.7.4 The for Statement
# 13.7.4.1 SS: Early Errors
# 13.7.4.2 SS: ContainsDuplicateLabels
# 13.7.4.3 SS: ContainsUndefinedBreakTarget
# 13.7.4.4 SS: ContainsUndefinedContinueTarget
# 13.7.4.5 SS: VarDeclaredNames
# 13.7.4.6 SS: VarScopedDeclarations
# 13.7.4.7 RS: LabelledEvaluation
# 13.7.4.8 RS: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet )
# 13.7.4.9 RS: CreatePerIterationEnvironment ( perIterationBindings )
# 13.7.5 The for-in, for-of, and for-await-of Statements
# 13.7.5.1 SS: Early Errors
# 13.7.5.2 SS: BoundNames
# 13.7.5.3 SS: ContainsDuplicateLabels
# 13.7.5.4 SS: ContainsUndefinedBreakTarget
# 13.7.5.5 SS: ContainsUndefinedContinueTarget
# 13.7.5.6 SS: IsDestructuring
# 13.7.5.7 SS: VarDeclaredNames
# 13.7.5.8 SS: VarScopedDeclarations
# 13.7.5.9 RS: BindingInitialization
# 13.7.5.10 RS: BindingInstantiation
# 13.7.5.11 RS: LabelledEvaluation
# 13.7.5.12 RS: ForIn/OfHeadEvaluation ( TDZnames, expr, iterationKind )
# 13.7.5.13 RS: ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [ , iteratorKind ] )
# 13.7.5.14 RS: Evaluation
# 13.7.5.15 EnumerateObjectProperties ( O )
#######################################################################################################################

##################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑.𝟕 𝓘𝓽𝓮𝓻𝓪𝓽𝓲𝓸𝓷 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓼 .....●·._..●·._..●·._.·´ #
##################################################################################
# 13.7 Iteration Statements

# --------======= 𝓘𝓽𝓮𝓻𝓪𝓽𝓲𝓸𝓷𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   IterationStatement:
#       do Statement while ( Expression ) ;
#       while ( Expression ) Statement
#       for ( ; ; ) Statement
#       for ( ; ; Expression ) Statement
#       for ( ; Expression ; ) Statement
#       for ( ; Expression ; Expression ) Statement
#       for ( Expression ; ; ) Statement
#       for ( Expression ; ; Expression ) Statement
#       for ( Expression ; Expression ; ) Statement
#       for ( Expression ; Expression ; Expression ) Statement
#       for ( var VariableDeclarationList ; ; ) Statement
#       for ( var VariableDeclarationList ; ; Expression ) Statement
#       for ( var VariableDeclarationList ; Expression ; ) Statement
#       for ( var VariableDeclarationList ; Expression ; Expression ) Statement
#       for ( LexicalDeclaration ; ) Statement
#       for ( LexicalDeclaration Expression ; ) Statement
#       for ( LexicalDeclaration ; Expression ) Statement
#       for ( LexicalDeclaration Expression ; Expression ) Statement
#       for ( LeftHandSideExpression in Expression ) Statement
#       for ( var ForBinding in Expression ) Statement
#       for ( ForDeclaration in Expression ) Statement
#       for ( LeftHandSideExpression of AssignmentExpression ) Statement
#       for ( var ForBinding of AssignmentExpression ) Statement
#       for ( ForDeclaration of AssignmentExpression ) Statement
#       for await ( LeftHandSideExpression of AssignmentExpression ) Statement
#       for await ( var ForBinding of AssignmentExpression ) Statement
#       for await ( ForDeclaration of AssignmentExpression ) Statement


class P2_IterationStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "IterationStatement", strict, children)

    contains_unenclosed_continue = False
    contains_unenclosed_break = False


class P2_IterationStatement_DO_Statement_WHILE_Expression(P2_IterationStatement):
    @property
    def Statement(self):
        return self.children[1]

    @property
    def Expression(self):
        return self.children[4]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.7.2.1 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        #           IterationStatement : do Statement while ( Expression ) ;
        # 1. Return ContainsDuplicateLabels of Statement with argument labelSet.
        return self.Statement.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.7.2.2 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        #           IterationStatement : do Statement while ( Expression ) ;
        # 1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
        return self.Statement.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.7.2.3 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #           IterationStatement : do Statement while ( Expression ) ;
        # 1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
        return self.Statement.ContainsUndefinedContinueTarget(iterationSet, [])

    def VarDeclaredNames(self):
        # 13.7.2.4 Static Semantics: VarDeclaredNames
        #           IterationStatement : do Statement while ( Expression ) ;
        # 1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.7.2.5 Static Semantics: VarScopedDeclarations
        #           IterationStatement : do Statement while ( Expression ) ;
        # 1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.7.2.6 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        #           IterationStatement : do Statement while ( Expression ) ;
        # 1. Let V be undefined.
        # 2. Repeat,
        #    a. Let stmtResult be the result of evaluating Statement.
        #    b. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).
        #    c. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].
        #    d. Let exprRef be the result of evaluating Expression.
        #    e. Let exprValue be ? GetValue(exprRef).
        #    f. If ToBoolean(exprValue) is false, return NormalCompletion(V).
        V = None
        while 1:
            try:
                stmtResult = self.Statement.evaluate()
            except ESAbrupt as abrupt:
                c = abrupt.completion
                if not LoopContinues(c, labelSet):
                    raise type(abrupt)(value=UpdateEmpty(c.value, V), target=c.target)
                stmtResult = c.value
            if stmtResult != EMPTY:
                V = stmtResult
            exprValue = GetValue(self.Expression.evaluate())
            if not ToBoolean(exprValue):
                return V


class P2_IterationStatement_WHILE_Expression_Statement(P2_IterationStatement):
    @property
    def Expression(self):
        return self.children[2]

    @property
    def Statement(self):
        return self.children[4]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.7.3.1 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        #           IterationStatement : while ( Expression ) Statement
        # 1. Return ContainsDuplicateLabels of Statement with argument labelSet.
        return self.Statement.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.7.3.2 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        #           IterationStatement : while ( Expression ) Statement
        # 1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
        return self.Statement.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.7.3.3 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #           IterationStatement : while ( Expression ) Statement
        # 1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
        return self.Statement.ContainsUndefinedContinueTarget(iterationSet, [])

    def VarDeclaredNames(self):
        # 13.7.3.4 Static Semantics: VarDeclaredNames
        #           IterationStatement : while ( Expression ) Statement
        # 1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.7.3.5 Static Semantics: VarScopedDeclarations
        #           IterationStatement : while ( Expression ) Statement
        # 1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.7.3.6 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        #           IterationStatement : while ( Expression ) Statement
        # 1. Let V be undefined.
        # 2. Repeat,
        #    a. Let exprRef be the result of evaluating Expression.
        #    b. Let exprValue be ? GetValue(exprRef).
        #    c. If ToBoolean(exprValue) is false, return NormalCompletion(V).
        #    d. Let stmtResult be the result of evaluating Statement.
        #    e. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).
        #    f. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].
        V = None
        while 1:
            exprValue = GetValue(self.Expression.evaluate())
            if not ToBoolean(exprValue):
                return V
            try:
                stmtResult = self.Statement.evaluate()
            except ESAbrupt as abrupt:
                c = abrupt.completion
                if not LoopContinues(c, labelSet):
                    raise type(abrupt)(value=UpdateEmpty(c.value, V), target=c.target)
                stmtResult = c.value
            if stmtResult != EMPTY:
                V = stmtResult


def LoopContinues(completion, labelSet):
    # 13.7.1.2 Runtime Semantics: LoopContinues ( completion, labelSet )
    # The abstract operation LoopContinues with arguments completion and labelSet is defined by the following steps:
    #
    # 1. If completion.[[Type]] is normal, return true.
    # 2. If completion.[[Type]] is not continue, return false.
    # 3. If completion.[[Target]] is empty, return true.
    # 4. If completion.[[Target]] is an element of labelSet, return true.
    # 5. Return false.
    # NOTE
    # Within the Statement part of an IterationStatement a ContinueStatement may be used to begin a new iteration.
    return completion.ctype == CompletionType.NORMAL or (
        completion.ctype == CompletionType.CONTINUE and (completion.target == EMPTY or completion.target in labelSet)
    )


class P2_IterationStatement_For_Expressions(P2_IterationStatement):
    @property
    def Statement(self):
        raise NotImplementedError("Base classes cannot be instantiated")

    # This is for the for statements with simple-ish expresions (no "in" or "of")
    def ContainsDuplicateLabels(self, labelSet):
        # 13.7.4.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        #       IterationStatement :
        #           for ( Expression[opt] ; Expression[opt] ; Expression[opt] ) Statement
        #           for ( var VariableDeclarationList ; Expression[opt] ; Expression[opt] ) Statement
        #           for ( LexicalDeclaration Expression[opt] ; Expression[opt] ) Statement
        # 1. Return ContainsDuplicateLabels of Statement with argument labelSet.
        return self.Statement.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.7.4.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        #       IterationStatement :
        #           for ( Expression[opt] ; Expression[opt] ; Expression[opt] ) Statement
        #           for ( var VariableDeclarationList ; Expression[opt] ; Expression[opt] ) Statement
        #           for ( LexicalDeclaration Expression[opt] ; Expression[opt] ) Statement
        # 1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
        return self.Statement.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.7.4.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #       IterationStatement :
        #           for ( Expression[opt] ; Expression[opt] ; Expression[opt] ) Statement
        #           for ( var VariableDeclarationList ; Expression[opt] ; Expression[opt] ) Statement
        #           for ( LexicalDeclaration Expression[opt] ; Expression[opt] ) Statement
        # 1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
        return self.Statement.ContainsUndefinedContinueTarget(iterationSet, [])

    def VarDeclaredNames(self):
        # 13.7.4.5 Static Semantics: VarDeclaredNames
        # IterationStatement : for ( Expression ; Expression ; Expression ) Statement
        # IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement
        #   1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.7.4.6 Static Semantics: VarScopedDeclarations
        # IterationStatement : for ( Expression ; Expression ; Expression ) Statement
        # IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement
        #   1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()


class P2_IterationStatement_FOR_ExpressionInit_ExpressionTest_ExpressionInc_Statement(
    P2_IterationStatement_For_Expressions
):
    @property
    def ExpressionInit(self):
        return self.children[2]

    @property
    def ExpressionTest(self):
        return self.children[4]

    @property
    def ExpressionInc(self):
        return self.children[6]

    @property
    def Statement(self):
        return self.children[8]

    def LabelledEvaluation(self, labelSet):
        # 13.7.4.7 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        #           IterationStatement : for ( Expression ; Expression ; Expression ) Statement
        # 1. If the first Expression is present, then
        #    a. Let exprRef be the result of evaluating the first Expression.
        #    b. Perform ? GetValue(exprRef).
        # 1. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).
        if self.ExpressionInit:
            GetValue(self.ExpressionInit.evaluate())
        return ForBodyEvaluation(self.ExpressionTest, self.ExpressionInc, self.Statement, [], labelSet)


class P2_IterationStatement_FOR_VAR_VariableDeclarationList_ExpressionTest_ExpressionInc_Statement(
    P2_IterationStatement_For_Expressions
):
    @property
    def VariableDeclarationList(self):
        return self.children[3]

    @property
    def ExpressionTest(self):
        return self.children[5]

    @property
    def ExpressionInc(self):
        return self.children[7]

    @property
    def Statement(self):
        return self.children[9]

    def VarDeclaredNames(self):
        # 13.7.4.5 Static Semantics: VarDeclaredNames
        #           IterationStatement : for ( var VariableDeclarationList ; Expression ; Expression ) Statement
        # 1. Let names be BoundNames of VariableDeclarationList.
        # 2. Append to names the elements of the VarDeclaredNames of Statement.
        # 3. Return names.
        names = self.VariableDeclarationList.BoundNames()
        names.extend(self.Statement.VarDeclaredNames())
        return names

    def VarScopedDeclarations(self):
        # 13.7.4.6 Static Semantics: VarScopedDeclarations
        #           IterationStatement : for ( var VariableDeclarationList ; Expression ; Expression ) Statement
        # 1. Let declarations be VarScopedDeclarations of VariableDeclarationList.
        # 2. Append to declarations the elements of the VarScopedDeclarations of Statement.
        # 3. Return declarations.
        declarations = self.VariableDeclarationList.VarScopedDeclarations()
        declarations.extend(self.Statement.VarScopedDeclarations())
        return declarations

    def LabelledEvaluation(self, labelSet):
        # 13.7.4.7 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        #           IterationStatement : for ( var VariableDeclarationList ; Expression ; Expression ) Statement
        # 1. Let varDcl be the result of evaluating VariableDeclarationList.
        # 2. ReturnIfAbrupt(varDcl).
        # 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).
        self.VariableDeclarationList.evaluate()
        return ForBodyEvaluation(self.ExpressionTest, self.ExpressionInc, self.Statement, [], labelSet)


class P2_IterationStatement_FOR_LexicalDeclaration_ExpressionTest_ExpressionInc_Statement(
    P2_IterationStatement_For_Expressions
):
    @property
    def LexicalDeclaration(self):
        return self.children[2]

    @property
    def ExpressionTest(self):
        return self.children[3]

    @property
    def ExpressionInc(self):
        return self.children[5]

    @property
    def Statement(self):
        return self.children[7]

    def EarlyErrors(self):
        # 13.7.4.1 Static Semantics: Early Errors
        # IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement
        # * It is a Syntax Error if any element of the BoundNames of LexicalDeclaration also occurs in the
        #   VarDeclaredNames of Statement.
        lex_set = set(self.LexicalDeclaration.BoundNames())
        var_set = set(self.Statement.VarDeclaredNames())
        if not lex_set.isdisjoint(var_set):
            dups = lex_set.intersection(var_set)
            return [self.CreateSyntaxError(f"Identifier '{dups.pop()}' has already been declared")]
        return []

    def LabelledEvaluation(self, labelSet):
        # 13.7.4.7 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement
        #   1. Let oldEnv be the running execution context's LexicalEnvironment.
        #   2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).
        #   3. Let loopEnvRec be loopEnv's EnvironmentRecord.
        #   4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.
        #   5. Let boundNames be the BoundNames of LexicalDeclaration.
        #   6. For each element dn of boundNames, do
        #       a. If isConst is true, then
        #           i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).
        #       b. Else,
        #           i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).
        #   7. Set the running execution context's LexicalEnvironment to loopEnv.
        #   8. Let forDcl be the result of evaluating LexicalDeclaration.
        #   9. If forDcl is an abrupt completion, then
        #       a. Set the running execution context's LexicalEnvironment to oldEnv.
        #       b. Return Completion(forDcl).
        #   10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».
        #   11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).
        #   12. Set the running execution context's LexicalEnvironment to oldEnv.
        #   13. Return Completion(bodyResult).
        oldEnv = surrounding_agent.running_ec.lexical_environment
        loopEnv = NewDeclarativeEnvironment(oldEnv)
        loopEnvRec = loopEnv.environment_record
        isConst = self.LexicalDeclaration.IsConstantDeclaration()
        boundNames = self.LexicalDeclaration.BoundNames()
        for dn in boundNames:
            if isConst:
                loopEnvRec.CreateImmutableBinding(dn, True)
            else:
                loopEnvRec.CreateMutableBinding(dn, False)
        surrounding_agent.running_ec.lexical_environment = loopEnv
        try:
            self.LexicalDeclaration.evaluate()
            if not isConst:
                perIterationLets = boundNames
            else:
                perIterationLets = []
            return ForBodyEvaluation(
                self.ExpressionTest, self.ExpressionInc, self.Statement, perIterationLets, labelSet
            )
        finally:
            surrounding_agent.running_ec.lexical_environment = oldEnv


class P2_IterationStatement_FOR_in_of(P2_IterationStatement):
    @property
    def Statement(self):
        raise NotImplementedError("Abstract classes cannot be instantiated")

    # Common routines for these productions:
    #           for ( [lookahead ∉ { let [ }] LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           for ( var ForBinding[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           for ( ForDeclaration[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           for ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           for ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           for ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           [+Await] for await ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           [+Await] for await ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           [+Await] for await ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    def ContainsDuplicateLabels(self, labelSet):
        # 13.7.5.3 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        #   1. Return ContainsDuplicateLabels of Statement with argument labelSet.
        return self.Statement.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.7.5.4 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        #   1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
        return self.Statement.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.7.5.5 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #   1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
        return self.Statement.ContainsUndefinedContinueTarget(iterationSet, [])


class P2_IterationStatement_FOR_in_of_LeftHandSideExpression(P2_IterationStatement_FOR_in_of):
    @property
    def LeftHandSideExpression(self):
        raise NotImplementedError("Abstract classes cannot be instantiated")

    # Common routines for these productions:
    #           for ( [lookahead ∉ { let [ }] LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           for ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #           [+Await] for await ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    def EarlyErrors(self):
        # 13.7.5.1 Static Semantics: Early Errors
        # IterationStatement:
        #       for ( LeftHandSideExpression in Expression ) Statement
        #       for ( LeftHandSideExpression of AssignmentExpression ) Statement
        #       for await ( LeftHandSideExpression of AssignmentExpression ) Statement
        #
        # * It is a Syntax Error if LeftHandSideExpression is either an ObjectLiteral or an ArrayLiteral and if
        #   LeftHandSideExpression is not covering an AssignmentPattern.
        #
        # If LeftHandSideExpression is either an ObjectLiteral or an ArrayLiteral and if LeftHandSideExpression is
        # covering an AssignmentPattern then the following rules are not applied. Instead, the Early Error rules for
        # AssignmentPattern are used.
        #
        # * It is a Syntax Error if IsValidSimpleAssignmentTarget of LeftHandSideExpression is false.
        # * It is a Syntax Error if the LeftHandSideExpression is
        #   CoverParenthesizedExpressionAndArrowParameterList : ( Expression ) and Expression derives a phrase that
        #   would produce a Syntax Error according to these rules if that phrase were substituted for
        #   LeftHandSideExpression. This rule is recursively applied.
        #
        # NOTE
        # The last rule means that the other rules are applied even if parentheses surround Expression.
        return self.EarlyErrors_LHS(self.LeftHandSideExpression)

    def EarlyErrors_LHS(self, lhs):
        if lhs.Is("ObjectLiteral") or lhs.Is("ArrayLiteral"):
            assignment_pattern = lhs.AssignmentPattern
            if not assignment_pattern:
                return [CreateSyntaxError('Not a valid lhs for "in" or "of" iteration')]
            return assignment_pattern.EarlyErrors()
        if not lhs.IsValidSimpleAssignmentTarget():
            return [CreateSyntaxError('Not a valid lhs for "in" or "of" iteration')]
        cpe = lhs.Derived(P2_CoverParenthesizedExpressionAndArrowParameterList_LPAREN_Expression_RPAREN)
        if cpe:
            return self.EarlyErrors_LHS(cpe.Expression)
        return []


class P2_IterationStatement_FOR_LeftHandSideExpression_IN_Expression_Statement(P2_IterationStatement_FOR_in_of):
    @property
    def LeftHandSideExpression(self):
        return self.children[2]

    @property
    def Expression(self):
        return self.children[4]

    @property
    def Statement(self):
        return self.children[6]

    def VarDeclaredNames(self):
        # 13.7.5.7 Static Semantics: VarDeclaredNames
        # IterationStatement : for ( LeftHandSideExpression in Expression ) Statement
        #   1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.7.5.8 Static Semantics: VarScopedDeclarations
        # IterationStatement : for ( LeftHandSideExpression in Expression ) Statement
        #   1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.7.5.11 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # IterationStatement : for ( LeftHandSideExpression in Expression ) Statement
        #   1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        #   2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet).
        keyResult = ForInOfHeadEvaluation([], self.Expression, ENUMERATE)
        return ForInOfBodyEvaluation(
            self.LeftHandSideExpression, self.Statement, keyResult, ENUMERATE, ASSIGNMENT, labelSet
        )


class P2_IterationStatement_FOR_VAR_ForBinding_IN_Expression_Statement(P2_IterationStatement_FOR_in_of):
    @property
    def ForBinding(self):
        return self.children[3]

    @property
    def Expression(self):
        return self.children[5]

    @property
    def Statement(self):
        return self.children[7]

    def VarDeclaredNames(self):
        # 13.7.5.7 Static Semantics: VarDeclaredNames
        # IterationStatement : for ( var ForBinding in Expression ) Statement
        #   1. Let names be the BoundNames of ForBinding.
        #   2. Append to names the elements of the VarDeclaredNames of Statement.
        #   3. Return names.
        names = self.ForBinding.BoundNames()
        names.extend(self.Statement.VarDeclaredNames())
        return names

    def VarScopedDeclarations(self):
        # 13.7.5.8 Static Semantics: VarScopedDeclarations
        # IterationStatement : for ( var ForBinding in Expression ) Statement
        #   1. Let declarations be a List containing ForBinding.
        #   2. Append to declarations the elements of the VarScopedDeclarations of Statement.
        #   3. Return declarations.
        declarations = [self.ForBinding]
        declarations.extend(self.Statement.VarScopedDeclarations())
        return declarations

    def LabelledEvaluation(self, labelSet):
        # 13.7.5.11 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # IterationStatement : for ( var ForBinding in Expression ) Statement
        #   1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        #   2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet).
        keyResult = ForInOfHeadEvaluation([], self.Expression, ENUMERATE)
        return ForInOfBodyEvaluation(self.ForBinding, self.Statement, keyResult, ENUMERATE, VARBINDING, labelSet)


class P2_IterationStatement_FOR_in_of_ForDeclaration(P2_IterationStatement_FOR_in_of):
    @property
    def ForDeclaration(self):
        raise NotImplementedError("Abstract classes cannot be instantiated")

    def EarlyErrors(self):
        # IterationStatement : for ( ForDeclaration in Expression ) Statement
        # IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement
        # IterationStatement : for await ( ForDeclaration of AssignmentExpression ) Statement
        #   * It is a Syntax Error if the BoundNames of ForDeclaration contains "let".
        #   * It is a Syntax Error if any element of the BoundNames of ForDeclaration also occurs in the VarDeclaredNames of Statement.
        #   * It is a Syntax Error if the BoundNames of ForDeclaration contains any duplicate entries.
        errs = []
        bound_names = self.ForDeclaration.BoundNames()
        if "let" in bound_names:
            errs.append(CreateSyntaxError("'let' not allowed as an identifier in this context"))
        if len(bound_names) != len(set(bound_names)):
            errs.append(CreateSyntaxError("duplicate identifier names not allowed"))
        if not set(bound_names).isdisjoint(set(self.Statement.VarDeclaredNames())):
            errs.append(CreateSyntaxError("for statement identifiers duplicated in statement body"))
        return errs


class P2_IterationStatement_FOR_ForDeclaration_IN_Expression_Statement(
    P2_IterationStatement_FOR_in_of_ForDeclaration
):
    @property
    def ForDeclaration(self):
        return self.children[2]

    @property
    def Expression(self):
        return self.children[4]

    @property
    def Statement(self):
        return self.children[6]

    def VarDeclaredNames(self):
        # 13.7.5.7 Static Semantics: VarDeclaredNames
        # IterationStatement : for ( ForDeclaration in Expression ) Statement
        #   1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.7.5.8 Static Semantics: VarScopedDeclarations
        # IterationStatement : for ( ForDeclaration in Expression ) Statement
        #   1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.7.5.11 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # IterationStatement : for ( ForDeclaration in Expression ) Statement
        #   1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).
        #   2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet).
        keyResult = ForInOfHeadEvaluation(self.ForDeclaration.BoundNames(), self.Expression, ENUMERATE)
        return ForInOfBodyEvaluation(
            self.ForDeclaration, self.Statement, keyResult, ENUMERATE, LEXICALBINDING, labelSet
        )


class P2_IterationStatement_FOR_LeftHandSideExpression_OF_AssignmentExpression_Statement(
    P2_IterationStatement_FOR_in_of
):
    @property
    def LeftHandSideExpression(self):
        return self.children[2]

    @property
    def AssignmentExpression(self):
        return self.children[4]

    @property
    def Statement(self):
        return self.children[6]

    def VarDeclaredNames(self):
        # 13.7.5.7 Static Semantics: VarDeclaredNames
        # IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement
        #   1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.7.5.8 Static Semantics: VarScopedDeclarations
        # IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement
        #   1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.7.5.11 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement
        #   1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        #   2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet).
        keyResult = ForInOfHeadEvaluation([], self.AssignmentExpression, ITERATE)
        return ForInOfBodyEvaluation(
            self.LeftHandSideExpression, self.Statement, keyResult, ITERATE, ASSIGNMENT, labelSet
        )


class P2_IterationStatement_FOR_VAR_ForBinding_OF_AssignmentExpression_Statement(P2_IterationStatement_FOR_in_of):
    @property
    def ForBinding(self):
        return self.children[3]

    @property
    def AssignmentExpression(self):
        return self.children[5]

    @property
    def Statement(self):
        return self.children[7]

    def VarDeclaredNames(self):
        # 13.7.5.7 Static Semantics: VarDeclaredNames
        # IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement
        #   1. Let names be the BoundNames of ForBinding.
        #   2. Append to names the elements of the VarDeclaredNames of Statement.
        #   3. Return names.
        names = self.ForBinding.BoundNames()
        names.extend(self.Statement.VarDeclaredNames())
        return names

    def VarScopedDeclarations(self):
        # 13.7.5.8 Static Semantics: VarScopedDeclarations
        # IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement
        #   1. Let declarations be a List containing ForBinding.
        #   2. Append to declarations the elements of the VarScopedDeclarations of Statement.
        #   3. Return declarations.
        declarations = [self.ForBinding]
        declarations.extend(self.Statement.VarScopedDeclarations())
        return declarations

    def LabelledEvaluation(self, labelSet):
        # 13.7.5.11 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement
        #   1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        #   2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet).
        keyResult = ForInOfHeadEvaluation([], self.AssignmentExpression, ITERATE)
        return ForInOfBodyEvaluation(self.ForBinding, self.Statement, keyResult, ITERATE, VARBINDING, labelSet)


class P2_IterationStatement_FOR_ForDeclaration_OF_AssignmentExpression_Statement(
    P2_IterationStatement_FOR_in_of_ForDeclaration
):
    @property
    def ForDeclaration(self):
        return self.children[2]

    @property
    def AssignmentExpression(self):
        return self.children[4]

    @property
    def Statement(self):
        return self.children[6]

    def VarDeclaredNames(self):
        # 13.7.5.7 Static Semantics: VarDeclaredNames
        # IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement
        #   1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.7.5.8 Static Semantics: VarScopedDeclarations
        # IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement
        #   1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.7.5.11 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement
        #   1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).
        #   2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet).
        keyResult = ForInOfHeadEvaluation(self.ForDeclaration.BoundNames(), self.AssignmentExpression, ITERATE)
        return ForInOfBodyEvaluation(
            self.ForDeclaration, self.Statement, keyResult, ITERATE, LEXICALBINDING, labelSet
        )


class P2_IterationStatement_FOR_AWAIT_LeftHandSideExpression_OF_AssignmentExpression_Statement(
    P2_IterationStatement_FOR_in_of
):
    @property
    def LeftHandSideExpression(self):
        return self.children[3]

    @property
    def AssignmentExpression(self):
        return self.children[5]

    @property
    def Statement(self):
        return self.children[7]


class P2_IterationStatement_FOR_AWAIT_VAR_ForBinding_OF_AssignmentExpression_Statement(
    P2_IterationStatement_FOR_in_of
):
    @property
    def ForBinding(self):
        return self.children[4]

    @property
    def AssignmentExpression(self):
        return self.children[6]

    @property
    def Statement(self):
        return self.children[8]


class P2_IterationStatement_FOR_AWAIT_ForDeclaration_OF_AssignmentExpression_Statement(
    P2_IterationStatement_FOR_in_of_ForDeclaration
):
    @property
    def ForDeclaration(self):
        return self.children[3]

    @property
    def AssignmentExpression(self):
        return self.children[5]

    @property
    def Statement(self):
        return self.children[7]


def parse_IterationStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13.7 Iteration Statements
    # Syntax
    #   IterationStatement[Yield, Await, Return]:
    #       do Statement[?Yield, ?Await, ?Return] while ( Expression[+In, ?Yield, ?Await] ) ;
    #       while ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       for ( [lookahead ∉ { let [ }]Expression[~In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
    #       for ( var VariableDeclarationList[~In, ?Yield, ?Await] ; Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
    #       for ( LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]opt ; Expression[+In, ?Yield, ?Await]opt ) Statement[?Yield, ?Await, ?Return]
    #       for ( [lookahead ∉ { let [ }]LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       for ( var ForBinding[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       for ( ForDeclaration[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       for ( [lookahead ≠ let]LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       for ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       for ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       [+Await] for await ( [lookahead ≠ let]LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       [+Await] for await ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #       [+Await] for await ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #
    do_token = lexer.id_if(pos, "do")
    if do_token:
        stmt1 = parse_Statement(context, lexer, do_token.span.after, strict, Yield, Await, Return)
        if stmt1:
            while_token1 = lexer.id_if(stmt1.after, "while")
            if while_token1:
                lp1 = lexer.token_if(while_token1.span.after, "(")
                if lp1:
                    exp1 = parse_Expression(context, lexer, lp1.span.after, strict, True, Yield, Await)
                    if exp1:
                        rp1 = lexer.token_if(exp1.after, ")")
                        if rp1:
                            semi = lexer.token_asi(rp1.span.after, do_while=True)
                            if semi:
                                return P2_IterationStatement_DO_Statement_WHILE_Expression(
                                    context, strict, [do_token, stmt1, while_token1, lp1, exp1, rp1, semi]
                                )
    while_token2 = lexer.id_if(pos, "while")
    if while_token2:
        lp2 = lexer.token_if(while_token2.span.after, "(")
        if lp2:
            exp2 = parse_Expression(context, lexer, lp2.span.after, strict, True, Yield, Await)
            if exp2:
                rp2 = lexer.token_if(exp2.after, ")")
                if rp2:
                    stmt2 = parse_Statement(context, lexer, rp2.span.after, strict, Yield, Await, Return)
                    if stmt2:
                        return P2_IterationStatement_WHILE_Expression_Statement(
                            context, strict, [while_token2, lp2, exp2, rp2, stmt2]
                        )
    for_token = lexer.id_if(pos, "for")
    if for_token:
        lp3 = lexer.token_if(for_token.span.after, "(")
        if lp3:
            # Three-expression style:
            exp_init = None
            lookahead = lexer.token(lp3.span.after)
            if not (
                lookahead
                and (((lookahead.type == "IDENTIFIER") and (lookahead.value == "let")) or (lookahead.type == "["))
            ):
                exp_init = parse_Expression(context, lexer, lp3.span.after, strict, False, Yield, Await)
            semi2 = lexer.token_if(exp_init.after if exp_init else lp3.span.after, ";")
            if semi2:
                exp_test = parse_Expression(context, lexer, semi2.span.after, strict, True, Yield, Await)
                semi3 = lexer.token_if(exp_test.after if exp_test else semi2.span.after, ";")
                if semi3:
                    exp_inc = parse_Expression(context, lexer, semi3.span.after, strict, True, Yield, Await)
                    rp3 = lexer.token_if(exp_inc.after if exp_inc else semi3.span.after, ")")
                    if rp3:
                        stmt3 = parse_Statement(context, lexer, rp3.span.after, strict, Yield, Await, Return)
                        if stmt3:
                            return P2_IterationStatement_FOR_ExpressionInit_ExpressionTest_ExpressionInc_Statement(
                                context,
                                strict,
                                [for_token, lp3, exp_init, semi2, exp_test, semi3, exp_inc, rp3, stmt3],
                            )
            # VariableDeclarationList style:
            var_token = lexer.id_if(lp3.span.after, "var")
            if var_token:
                vdl = parse_VariableDeclarationList(
                    context, lexer, var_token.span.after, strict, False, Yield, Await
                )
                if vdl:
                    semi4 = lexer.token_if(vdl.after, ";")
                    if semi4:
                        exp_test2 = parse_Expression(context, lexer, semi4.span.after, strict, True, Yield, Await)
                        semi5 = lexer.token_if(exp_test2.after if exp_test2 else semi4.span.after, ";")
                        if semi5:
                            exp_inc2 = parse_Expression(context, lexer, semi5.span.after, strict, True, Yield, Await)
                            rp4 = lexer.token_if(exp_inc2.after if exp_inc2 else semi5.span.after, ")")
                            if rp4:
                                stmt4 = parse_Statement(context, lexer, rp4.span.after, strict, Yield, Await, Return)
                                if stmt4:
                                    return P2_IterationStatement_FOR_VAR_VariableDeclarationList_ExpressionTest_ExpressionInc_Statement(
                                        context,
                                        strict,
                                        [
                                            for_token,
                                            lp3,
                                            var_token,
                                            vdl,
                                            semi4,
                                            exp_test2,
                                            semi5,
                                            exp_inc2,
                                            rp4,
                                            stmt4,
                                        ],
                                    )

            # LexicalDeclaration style:
            ld = parse_LexicalDeclaration(context, lexer, lp3.span.after, strict, False, Yield, Await)
            if ld:
                exp_test_ld = parse_Expression(context, lexer, ld.after, strict, True, Yield, Await)
                semi_ld = lexer.token_if(exp_test_ld.after if exp_test_ld else ld.after, ";")
                if semi_ld:
                    exp_inc_ld = parse_Expression(context, lexer, semi_ld.span.after, strict, True, Yield, Await)
                    rp_ld = lexer.token_if(exp_inc_ld.after if exp_inc_ld else semi_ld.span.after, ")")
                    if rp_ld:
                        stmt_ld = parse_Statement(context, lexer, rp_ld.span.after, strict, Yield, Await, Return)
                        if stmt_ld:
                            return P2_IterationStatement_FOR_LexicalDeclaration_ExpressionTest_ExpressionInc_Statement(
                                context,
                                strict,
                                [for_token, lp3, ld, exp_test_ld, semi_ld, exp_inc_ld, rp_ld, stmt_ld],
                            )

            # LHS IN Expr style:
            lookahead = lexer.token(lp3.span.after)
            if not (
                lookahead
                and (((lookahead.type == "IDENTIFIER") and (lookahead.value == "let")) or (lookahead.type == "["))
            ):
                lhs = parse_LeftHandSideExpression(context, lexer, lp3.span.after, strict, Yield, Await)
                if lhs:
                    in_token = lexer.id_if(lhs.after, "in")
                    if in_token:
                        exp_lhs_in = parse_Expression(
                            context, lexer, in_token.span.after, strict, True, Yield, Await
                        )
                        if exp_lhs_in:
                            rp_lhs_in = lexer.token_if(exp_lhs_in.after, ")")
                            if rp_lhs_in:
                                stmt_lhs_in = parse_Statement(
                                    context, lexer, rp_lhs_in.span.after, strict, Yield, Await, Return
                                )
                                if stmt_lhs_in:
                                    return P2_IterationStatement_FOR_LeftHandSideExpression_IN_Expression_Statement(
                                        context,
                                        strict,
                                        [for_token, lp3, lhs, in_token, exp_lhs_in, rp_lhs_in, stmt_lhs_in],
                                    )

            # ForBinding IN Expr style
            var_fb = lexer.id_if(lp3.span.after, "var")
            if var_fb:
                fb = parse_ForBinding(context, lexer, var_fb.span.after, strict, Yield, Await)
                if fb:
                    in_fb = lexer.id_if(fb.after, "in")
                    if in_fb:
                        exp_fb = parse_Expression(context, lexer, in_fb.span.after, strict, True, Yield, Await)
                        if exp_fb:
                            rp_fb = lexer.token_if(exp_fb.after, ")")
                            if rp_fb:
                                stmt_fb = parse_Statement(
                                    context, lexer, rp_fb.span.after, strict, Yield, Await, Return
                                )
                                if stmt_fb:
                                    return P2_IterationStatement_FOR_VAR_ForBinding_IN_Expression_Statement(
                                        context, strict, [for_token, lp3, var_fb, fb, in_fb, exp_fb, rp_fb, stmt_fb]
                                    )

            # ForDeclaration IN Expr style
            fd = parse_ForDeclaration(context, lexer, lp3.span.after, strict, Yield, Await)
            if fd:
                in_fd = lexer.id_if(fd.after, "in")
                if in_fd:
                    exp_fd = parse_Expression(context, lexer, in_fd.span.after, strict, True, Yield, Await)
                    if exp_fd:
                        rp_fd = lexer.token_if(exp_fd.after, ")")
                        if rp_fd:
                            stmt_fd = parse_Statement(context, lexer, rp_fd.span.after, strict, Yield, Await, Return)
                            if stmt_fd:
                                return P2_IterationStatement_FOR_ForDeclaration_IN_Expression_Statement(
                                    context, strict, [for_token, lp3, fd, in_fd, exp_fd, rp_fd, stmt_fd]
                                )

            # LHS OF Expression style
            lookahead = lexer.token(lp3.span.after)
            if not (lookahead and lookahead.type == "IDENTIFIER" and lookahead.value == "let"):
                lhs_of = parse_LeftHandSideExpression(context, lexer, lp3.span.after, strict, Yield, Await)
                if lhs_of:
                    of_lhs = lexer.id_if(lhs_of.after, "of")
                    if of_lhs:
                        ae_lhs = parse_AssignmentExpression(
                            context, lexer, of_lhs.span.after, strict, True, Yield, Await
                        )
                        if ae_lhs:
                            rp_lhs_of = lexer.token_if(ae_lhs.after, ")")
                            if rp_lhs_of:
                                stmt_lhs_of = parse_Statement(
                                    context, lexer, rp_lhs_of.span.after, strict, Yield, Await, Return
                                )
                                if stmt_lhs_of:
                                    return P2_IterationStatement_FOR_LeftHandSideExpression_OF_AssignmentExpression_Statement(
                                        context,
                                        strict,
                                        [for_token, lp3, lhs_of, of_lhs, ae_lhs, rp_lhs_of, stmt_lhs_of],
                                    )

            # ForBinding OF Expression style
            var_fb_of = lexer.id_if(lp3.span.after, "var")
            if var_fb_of:
                fb_of = parse_ForBinding(context, lexer, var_fb_of.span.after, strict, Yield, Await)
                if fb_of:
                    of_fb = lexer.id_if(fb_of.after, "of")
                    if of_fb:
                        ae_fb_of = parse_AssignmentExpression(
                            context, lexer, of_fb.span.after, strict, True, Yield, Await
                        )
                        if ae_fb_of:
                            rp_fb_of = lexer.token_if(ae_fb_of.after, ")")
                            if rp_fb_of:
                                stmt_fb_of = parse_Statement(
                                    context, lexer, rp_fb_of.span.after, strict, Yield, Await, Return
                                )
                                if stmt_fb_of:
                                    return P2_IterationStatement_FOR_VAR_ForBinding_OF_AssignmentExpression_Statement(
                                        context,
                                        strict,
                                        [for_token, lp3, var_fb_of, fb_of, of_fb, ae_fb_of, rp_fb_of, stmt_fb_of],
                                    )

            # ForDeclaration OF Expression style
            fd_of = parse_ForDeclaration(context, lexer, lp3.span.after, strict, Yield, Await)
            if fd_of:
                of_fd = lexer.id_if(fd_of.after, "of")
                if of_fd:
                    ae_fd = parse_AssignmentExpression(context, lexer, of_fd.span.after, strict, True, Yield, Await)
                    if ae_fd:
                        rp_fd = lexer.token_if(ae_fd.after, ")")
                        if rp_fd:
                            stmt_fd = parse_Statement(context, lexer, rp_fd.span.after, strict, Yield, Await, Return)
                            if stmt_fd:
                                return P2_IterationStatement_FOR_ForDeclaration_OF_AssignmentExpression_Statement(
                                    context, strict, [for_token, lp3, fd_of, of_fd, ae_fd, rp_fd, stmt_fd]
                                )
        if Await:
            await_token = lexer.id_if(lp3.span.after, "await")
            if await_token:
                lp4 = lexer.token_if(await_token.span.after, "(")
                if lp4:
                    await_paren = lp4.span.after

                    # await LHS of AssignmentExpression
                    lookahead_await = lexer.token(await_paren)
                    if not (
                        lookahead_await and lookahead_await.type == "IDENTIFIER" and lookahead_await.value == "let"
                    ):
                        lhs_await = parse_LeftHandSideExpression(context, lexer, await_paren, strict, Yield, True)
                        if lhs_await:
                            of_lhs_await = lexer.id_if(lhs_await.after, "of")
                            if of_lhs_await:
                                ae_lhs_await = parse_AssignmentExpression(
                                    context, lexer, of_lhs_await.span.after, strict, True, Yield, True
                                )
                                if ae_lhs_await:
                                    rp_lhs_await = lexer.token_if(ae_lhs_await.after, ")")
                                    if rp_lhs_await:
                                        stmt_lhs_await = parse_Statement(
                                            context, lexer, rp_lhs_await.span.after, strict, Yield, True, Return
                                        )
                                        if stmt_lhs_await:
                                            return P2_IterationStatement_FOR_AWAIT_LeftHandSideExpression_OF_AssignmentExpression_Statement(
                                                context,
                                                strict,
                                                [
                                                    for_token,
                                                    await_token,
                                                    lp4,
                                                    lhs_await,
                                                    of_lhs_await,
                                                    ae_lhs_await,
                                                    rp_lhs_await,
                                                    stmt_lhs_await,
                                                ],
                                            )

                    # await for var forbinding of expression
                    var_fb_await = lexer.id_if(await_paren, "var")
                    if var_fb_await:
                        fb_await = parse_ForBinding(context, lexer, var_fb_await.span.after, strict, Yield, True)
                        if fb_await:
                            of_fb_await = lexer.id_if(fb_await.after, "of")
                            if of_fb_await:
                                ae_fb_await = parse_AssignmentExpression(
                                    context, lexer, of_fb_await.span.after, strict, True, Yield, True
                                )
                                if ae_fb_await:
                                    rp_fb_await = lexer.token_if(ae_fb_await.after, ")")
                                    if rp_fb_await:
                                        stmt_fb_await = parse_Statement(
                                            context, lexer, rp_fb_await.span.after, strict, Yield, True, Return
                                        )
                                        if stmt_fb_await:
                                            return P2_IterationStatement_FOR_AWAIT_VAR_ForBinding_OF_AssignmentExpression_Statement(
                                                context,
                                                strict,
                                                [
                                                    for_token,
                                                    await_token,
                                                    lp4,
                                                    var_fb_await,
                                                    fb_await,
                                                    of_fb_await,
                                                    ae_fb_await,
                                                    rp_fb_await,
                                                    stmt_fb_await,
                                                ],
                                            )

                    # await for fordeclaration of expression
                    fd_await = parse_ForDeclaration(context, lexer, await_paren, strict, Yield, True)
                    if fd_await:
                        of_fd_await = lexer.id_if(fd_await.after, "of")
                        if of_fd_await:
                            ae_fd_await = parse_AssignmentExpression(
                                context, lexer, of_fd_await.span.after, strict, True, Yield, True
                            )
                            if ae_fd_await:
                                rp_fd_await = lexer.token_if(ae_fd_await.after, ")")
                                if rp_fd_await:
                                    stmt_fd_await = parse_Statement(
                                        context, lexer, rp_fd_await.span.after, strict, Yield, True, Return
                                    )
                                    if stmt_fd_await:
                                        return P2_IterationStatement_FOR_AWAIT_ForDeclaration_OF_AssignmentExpression_Statement(
                                            context,
                                            strict,
                                            [
                                                for_token,
                                                await_token,
                                                lp4,
                                                fd_await,
                                                of_fd_await,
                                                ae_fd_await,
                                                rp_fd_await,
                                                stmt_fd_await,
                                            ],
                                        )
    return None


# 13.7.4.8 Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet )
def ForBodyEvaluation(test, increment, stmt, perIterationBindings, labelSet):
    # The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and
    # labelSet is performed as follows:
    #
    # 1. Let V be undefined.
    # 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).
    # 3. Repeat,
    #    a. If test is not [empty], then
    #       i. Let testRef be the result of evaluating test.
    #      ii. Let testValue be ? GetValue(testRef).
    #     iii. If ToBoolean(testValue) is false, return NormalCompletion(V).
    #    b. Let result be the result of evaluating stmt.
    #    c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).
    #    d. If result.[[Value]] is not empty, set V to result.[[Value]].
    #    e. Perform ? CreatePerIterationEnvironment(perIterationBindings).
    #    f. If increment is not [empty], then
    #       i. Let incRef be the result of evaluating increment.
    #      ii. Perform ? GetValue(incRef).
    V = None
    CreatePerIterationEnvironment(perIterationBindings)
    while 1:
        if test:
            testValue = GetValue(test.evaluate())
            if not ToBoolean(testValue):
                return V
        try:
            result = stmt.evaluate()
        except ESAbrupt as abrupt:
            c = abrupt.completion
            if not LoopContinues(c, labelSet):
                raise type(abrupt)(value=UpdateEmpty(c.value, V), target=c.target)
            result = c.value
        if result != EMPTY:
            V = result
        CreatePerIterationEnvironment(perIterationBindings)
        if increment:
            GetValue(increment.evaluate())


# 13.7.4.9 Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings )
def CreatePerIterationEnvironment(perIterationBindings):
    # The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows:
    #
    # 1. If perIterationBindings has any elements, then
    #    a. Let lastIterationEnv be the running execution context's LexicalEnvironment.
    #    b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.
    #    c. Let outer be lastIterationEnv's outer environment reference.
    #    d. Assert: outer is not null.
    #    e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).
    #    f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.
    #    g. For each element bn of perIterationBindings, do
    #       i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).
    #      ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).
    #     iii. Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).
    #    h. Set the running execution context's LexicalEnvironment to thisIterationEnv.
    # 2. Return undefined.
    if perIterationBindings:
        lastIterationEnv = surrounding_agent.running_ec.lexical_environment
        lastIterationEnvRec = lastIterationEnv.environment_record
        outer = lastIterationEnv.outer
        assert outer and not isNull(outer)
        thisIterationEnv = NewDeclarativeEnvironment(outer)
        thisIterationEnvRec = thisIterationEnv.environment_record
        for bn in perIterationBindings:
            thisIterationEnvRec.CreateMutableBinding(bn, False)
            lastValue = lastIterationEnvRec.GetBindingValue(bn, True)
            thisIterationEnvRec.InitializeBinding(bn, lastValue)
        surrounding_agent.running_ec.lexical_environment = thisIterationEnv
    return None


# 13.7.5.12 Runtime Semantics: ForIn/OfHeadEvaluation ( TDZnames, expr, iterationKind )
def ForInOfHeadEvaluation(TDZnames, expr, iterationKind):
    # The abstract operation ForIn/OfHeadEvaluation is called with arguments TDZnames, expr, and iterationKind. The
    # value of iterationKind is either enumerate, iterate, or async-iterate.
    #
    #   1. Let oldEnv be the running execution context's LexicalEnvironment.
    #   2. If TDZnames is not an empty List, then
    #       a. Assert: TDZnames has no duplicate entries.
    #       b. Let TDZ be NewDeclarativeEnvironment(oldEnv).
    #       c. Let TDZEnvRec be TDZ's EnvironmentRecord.
    #       d. For each string name in TDZnames, do
    #           i. Perform ! TDZEnvRec.CreateMutableBinding(name, false).
    #       e. Set the running execution context's LexicalEnvironment to TDZ.
    #   3. Let exprRef be the result of evaluating expr.
    #   4. Set the running execution context's LexicalEnvironment to oldEnv.
    #   5. Let exprValue be ? GetValue(exprRef).
    #   6. If iterationKind is enumerate, then
    #       a. If exprValue is undefined or null, then
    #           i. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.
    #       b. Let obj be ! ToObject(exprValue).
    #       c. Return ? EnumerateObjectProperties(obj).
    #   7. Else,
    #       a. Assert: iterationKind is iterate.
    #       b. If iterationKind is async-iterate, let iteratorHint be async.
    #       c. Else, let iteratorHint be sync.
    #       d. Return ? GetIterator(exprValue, iteratorHint).
    oldEnv = surrounding_agent.running_ec.lexical_environment
    if TDZnames:
        assert len(TDZnames) == len(set(TDZnames))
        TDZ = NewDeclarativeEnvironment(oldEnv)
        TDZEnvRec = TDZ.environment_record
        for name in TDZnames:
            TDZEnvRec.CreateMutableBinding(name, False)
        surrounding_agent.running_ec.lexical_environment = TDZ
    exprRef = expr.evaluate()
    surrounding_agent.running_ec.lexical_environment = oldEnv
    exprValue = GetValue(exprRef)
    if iterationKind == ENUMERATE:
        if exprValue is None or isNull(exprValue):
            raise ESBreak()
        obj = ToObject(exprValue)
        return EnumerateObjectProperties(obj)
    assert iterationKind in [ITERATE, ASYNC_ITERATE]
    iteratorHint = {ITERATE: SYNC, ASYNC_ITERATE: ASYNC}[iterationKind]
    return GetIterator(exprValue, iteratorHint)


# 13.7.5.13 Runtime Semantics: ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind,
#                                                       labelSet [ , iteratorKind ] )
def ForInOfBodyEvaluation(lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet, iteratorKind=SYNC):
    # The abstract operation ForIn/OfBodyEvaluation is called with arguments lhs, stmt, iteratorRecord, iterationKind,
    # lhsKind, labelSet, and optional argument iteratorKind. The value of lhsKind is either assignment, varBinding or
    # lexicalBinding. The value of iteratorKind is either sync or async.
    #
    #   1. If iteratorKind is not present, set iteratorKind to sync.
    #   2. Let oldEnv be the running execution context's LexicalEnvironment.
    #   3. Let V be undefined.
    #   4. Let destructuring be IsDestructuring of lhs.
    #   5. If destructuring is true and if lhsKind is assignment, then
    #       a. Assert: lhs is a LeftHandSideExpression.
    #       b. Let assignmentPattern be the AssignmentPattern that is covered by lhs.
    #   6. Repeat,
    #       a. Let nextResult be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « »).
    #       b. If iteratorKind is async, then set nextResult to ? Await(nextResult).
    #       c. If Type(nextResult) is not Object, throw a TypeError exception.
    #       x. Let _done_ be ? IteratorComplete(_nextResult_).
    #       y. If _done_ is *true*, return NormalCompletion(_V_).
    #       d. Let nextValue be ? IteratorValue(nextResult).
    #       e. If lhsKind is either assignment or varBinding, then
    #           i. If destructuring is false, then
    #               1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)
    #       f. Else,
    #           i. Assert: lhsKind is lexicalBinding.
    #           ii. Assert: lhs is a ForDeclaration.
    #           iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).
    #           iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.
    #           v. Set the running execution context's LexicalEnvironment to iterationEnv.
    #           vi. If destructuring is false, then
    #               1. Assert: lhs binds a single name.
    #               2. Let lhsName be the sole element of BoundNames of lhs.
    #               3. Let lhsRef be ! ResolveBinding(lhsName).
    #       g. If destructuring is false, then
    #           i. If lhsRef is an abrupt completion, then
    #               1. Let status be lhsRef.
    #           ii. Else if lhsKind is lexicalBinding, then
    #               1. Let status be InitializeReferencedBinding(lhsRef, nextValue).
    #           iii. Else,
    #               1. Let status be PutValue(lhsRef, nextValue).
    #       h. Else,
    #           i. If lhsKind is assignment, then
    #               1. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.
    #           ii. Else if lhsKind is varBinding, then
    #               1. Assert: lhs is a ForBinding.
    #               2. Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.
    #           iii. Else,
    #               1. Assert: lhsKind is lexicalBinding.
    #               2. Assert: lhs is a ForDeclaration.
    #               3. Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.
    #       i. If status is an abrupt completion, then
    #           i. Set the running execution context's LexicalEnvironment to oldEnv.
    #           ii. If iteratorKind is async, return ? AsyncIteratorClose(iteratorRecord, status).
    #           iii. If iterationKind is enumerate, then
    #               1. Return status.
    #           iv. Else,
    #               1. Assert: iterationKind is iterate.
    #               2. Return ? IteratorClose(iteratorRecord, status).
    #       j. Let result be the result of evaluating stmt.
    #       k. Set the running execution context's LexicalEnvironment to oldEnv.
    #       l. If LoopContinues(result, labelSet) is false, then
    #           i. If iterationKind is enumerate, then
    #               1. Return Completion(UpdateEmpty(result, V)).
    #           ii. Else,
    #               1. Assert: iterationKind is iterate.
    #               2. Set status to UpdateEmpty(result, V).
    #               3. If iteratorKind is async, return ? AsyncIteratorClose(iteratorRecord, status).
    #               4. Return ? IteratorClose(iteratorRecord, status).
    #       m. If result.[[Value]] is not empty, set V to result.[[Value]].
    oldEnv = surrounding_agent.running_ec.lexical_environment
    V = None
    destructuring = lhs.IsDestructuring()
    if destructuring and lhsKind == ASSIGNMENT:
        assert lhs.Is("LeftHandSideExpression")
        assignmentPattern = lhs.AssignmentPattern
    while 1:
        nextResult = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [])
        if iteratorKind == ASYNC:
            nextResult = Await(nextResult)
        if not isObject(nextResult):
            raise ESTypeError("Iterator result not an object")
        if IteratorComplete(nextResult):
            return V
        nextValue = IteratorValue(nextResult)
        try:
            if lhsKind in (ASSIGNMENT, VARBINDING):
                if not destructuring:
                    lhsRef = lhs.evaluate()
            else:
                assert lhsKind == LEXICALBINDING
                assert lhs.Is("ForDeclaration")
                iterationEnv = NewDeclarativeEnvironment(oldEnv)
                lhs.BindingInstantiation(iterationEnv)
                surrounding_agent.running_ec.lexical_environment = iterationEnv
                if not destructuring:
                    bn = lhs.BoundNames()
                    assert len(bn) == 1
                    lhsName = bn[0]
                    lhsRef = ResolveBinding(lhsName, lhs.strict)
            if not destructuring:
                if lhsKind == LEXICALBINDING:
                    InitializeReferencedBinding(lhsRef, nextValue)
                else:
                    PutValue(lhsRef, nextValue)
            else:
                if lhsKind == ASSIGNMENT:
                    assignmentPattern.DestructuringAssignmentEvaluation(nextValue)
                elif lhsKind == VARBINDING:
                    assert lhs.Is("ForBinding")
                    lhs.BindingInitialization(nextValue, None)
                else:
                    assert lhsKind == LEXICALBINDING
                    assert lhs.Is("ForDeclaration")
                    lhs.BindingInitialization(nextValue, iterationEnv)
        except (ESError, ESAbrupt) as err:
            surrounding_agent.running_ec.lexical_environment = oldEnv
            if iteratorKind == ASYNC:
                return AsyncIteratorClose(iteratorRecord, err)
            if iterationKind == ENUMERATE:
                raise
            assert iterationKind == ITERATE
            IteratorClose(iteratorRecord)
            raise
        try:
            result = stmt.evaluate()
        except ESAbrupt as abrupt:
            c = abrupt.completion
            if not LoopContinues(c, labelSet):
                if iterationKind == ITERATE:
                    if iteratorKind == ASYNC:
                        return AsyncIteratorClose(iteratorRecord, abrupt)
                    IteratorClose(iteratorRecord)
                raise type(abrupt)(value=UpdateEmpty(c.value, V), target=c.target)
        finally:
            surrounding_agent.running_ec.lexical_environment = oldEnv
        if result != EMPTY:
            V = result


# 13.7.5.15 EnumerateObjectProperties ( O )
def EnumerateObjectProperties(O):
    # When the abstract operation EnumerateObjectProperties is called with argument O, the following steps are taken:
    #
    #   1. Assert: Type(O) is Object.
    #   2. Return an Iterator object (25.1.1.2) whose next method iterates over all the String-valued keys of
    #      enumerable properties of O. The iterator object is never directly accessible to ECMAScript code. The
    #      mechanics and order of enumerating the properties is not specified but must conform to the rules specified
    #      below.
    #
    # The iterator's throw and return methods are null and are never invoked. The iterator's next method processes
    # object properties to determine whether the property key should be returned as an iterator value. Returned
    # property keys do not include keys that are Symbols. Properties of the target object may be deleted during
    # enumeration. A property that is deleted before it is processed by the iterator's next method is ignored. If new
    # properties are added to the target object during enumeration, the newly added properties are not guaranteed to be
    # processed in the active enumeration. A property name will be returned by the iterator's next method at most once
    # in any enumeration.
    #
    # Enumerating the properties of the target object includes enumerating properties of its prototype, and the
    # prototype of the prototype, and so on, recursively; but a property of a prototype is not processed if it has the
    # same name as a property that has already been processed by the iterator's next method. The values of
    # [[Enumerable]] attributes are not considered when determining if a property of a prototype object has already
    # been processed. The enumerable property names of prototype objects must be obtained by invoking
    # EnumerateObjectProperties passing the prototype object as the argument. EnumerateObjectProperties must obtain the
    # own property keys of the target object by calling its [[OwnPropertyKeys]] internal method. Property attributes of
    # the target object must be obtained by calling its [[GetOwnProperty]] internal method.
    assert isObject(O)

    def py_enum_props(obj):
        visited = set()
        for key in obj.OwnPropertyKeys():
            if isString(key):
                desc = obj.GetOwnProperty(key)
                if desc:
                    visited.add(key)
                    if desc.enumerable:
                        yield key
        proto = obj.GetPrototypeOf()
        if proto and not isNull(proto):
            for propkey in py_enum_props(proto):
                if propkey not in visited:
                    yield propkey

    iterator_obj = ObjectCreate(
        surrounding_agent.running_ec.realm.intrinsics["%IteratorPrototype%"], ["python_iter"]
    )
    iterator_obj.python_iter = py_enum_props(O)

    def enum_next(this_value, new_target, *_):
        done = False
        try:
            val = next(this_value.python_iter)
        except StopIteration:
            done = True
            val = None
        return CreateIterResultObject(val, done)

    next_fcn = CreateBuiltinFunction(enum_next, [])
    return IteratorRecord(Iterator=iterator_obj, NextMethod=next_fcn, Done=False)


# --------======= 𝓕𝓸𝓻𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   ForDeclaration :
#       LetOrConst ForBinding


class P2_ForDeclaration(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ForDeclaration", strict, children)


class P2_ForDeclaration_LetOrConst_ForBinding(P2_ForDeclaration):
    @property
    def LetOrConst(self):
        return self.children[0]

    @property
    def ForBinding(self):
        return self.children[1]

    def BoundNames(self):
        # 13.7.5.2 Static Semantics: BoundNames
        #           ForDeclaration : LetOrConst ForBinding
        # 1. Return the BoundNames of ForBinding.
        return self.ForBinding.BoundNames()

    def IsDestructuring(self):
        # 13.7.5.6 Static Semantics: IsDestructuring
        #           ForDeclaration : LetOrConstForBinding
        # 1. Return IsDestructuring of ForBinding.
        return self.ForBinding.IsDestructuring()

    def BindingInitialization(self, value, environment):
        # 13.7.5.9 Runtime Semantics: BindingInitialization
        #   With parameters value and environment.
        #
        # NOTE
        # undefined is passed for environment to indicate that a PutValue operation should be used to assign the
        # initialization value. This is the case for var statements and the formal parameter lists of some non-strict
        # functions (see 9.2.15). In those cases a lexical binding is hoisted and preinitialized prior to evaluation of
        # its initializer.
        #
        #           ForDeclaration : LetOrConst ForBinding
        # 1. Return the result of performing BindingInitialization for ForBinding passing value and environment as the
        #    arguments.
        return self.ForBinding.BindingInitialization(value, environment)

    def BindingInstantiation(self, environment):
        # 13.7.5.10 Runtime Semantics: BindingInstantiation
        #   With parameter environment.
        #           ForDeclaration : LetOrConst ForBinding
        # 1. Let envRec be environment's EnvironmentRecord.
        # 2. Assert: envRec is a declarative Environment Record.
        # 3. For each element name of the BoundNames of ForBinding, do
        #    a. If IsConstantDeclaration of LetOrConst is true, then
        #       i. Perform ! envRec.CreateImmutableBinding(name, true).
        #    b. Else,
        #       i. Perform ! envRec.CreateMutableBinding(name, false).
        envRec = environment.environment_record
        assert isinstance(envRec, DeclarativeEnvironmentRecord)
        for name in self.ForBinding.BoundNames():
            if self.LetOrConst.IsConstantDeclaration():
                envRec.CreateImmutableBinding(name, True)
            else:
                envRec.CreateMutableBinding(name, False)


def parse_ForDeclaration(context, lexer, pos, strict, Yield, Await):
    # 13.7 Iteration Statements
    # Syntax
    #   ForDeclaration[Yield, Await] :
    #       LetOrConst ForBinding[?Yield, ?Await]
    loc = parse_LetOrConst(context, lexer, pos, strict)
    if loc:
        fb = parse_ForBinding(context, lexer, loc.after, strict, Yield, Await)
        if fb:
            return P2_ForDeclaration_LetOrConst_ForBinding(context, strict, [loc, fb])
    return None


# --------======= 𝓕𝓸𝓻𝓑𝓲𝓷𝓭𝓲𝓷𝓰 =======--------
# Syntax
#   ForBinding :
#       BindingIdentifier
#       BindingPattern


class P2_ForBinding(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ForBinding", strict, children)


class P2_ForBinding_BindingIdentifier(P2_ForBinding):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    def IsDestructuring(self):
        # 13.7.5.6 Static Semantics: IsDestructuring
        #           ForBinding : BindingIdentifier
        # 1. Return false.
        return False

    def evaluate(self):
        # 13.7.5.14 Runtime Semantics: Evaluation
        #           ForBinding : BindingIdentifier
        # 1. Let bindingId be StringValue of BindingIdentifier.
        # 2. Return ? ResolveBinding(bindingId).
        return ResolveBinding(self.BindingIdentifier.StringValue, self.strict)


class P2_ForBinding_BindingPattern(P2_ForBinding):
    @property
    def BindingPattern(self):
        return self.children[0]

    def IsDestructuring(self):
        # 13.7.5.6 Static Semantics: IsDestructuring
        #           ForBinding : BindingPattern
        # 1. Return true.
        return True


def parse_ForBinding(context, lexer, pos, strict, Yield, Await):
    # 13.7 Iteration Statements
    # Syntax
    #   ForBinding[Yield, Await] :
    #       BindingIdentifier[?Yield, ?Await]
    #       BindingPattern[?Yield, ?Await]
    bi = parse_BindingIdentifier(context, lexer, pos, strict, Yield, Await)
    if bi:
        return P2_ForBinding_BindingIdentifier(context, strict, [bi])
    bp = parse_BindingPattern(context, lexer, pos, strict, Yield, Await)
    if bp:
        return P2_ForBinding_BindingPattern(context, strict, [bp])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.      88888888888 888
# d8888   d88P  Y88b     d88P  Y88b         888     888
#   888        .d88P     Y88b. d88P         888     888
#   888       8888"       "Y88888"          888     88888b.   .d88b.
#   888        "Y8b.     .d8P""Y8b.         888     888 "88b d8P  Y8b
#   888   888    888     888    888         888     888  888 88888888
#   888   Y88b  d88P d8b Y88b  d88P         888     888  888 Y8b.
# 8888888  "Y8888P"  Y8P  "Y8888P"          888     888  888  "Y8888
#
#
#
#                            888    d8b
#                            888    Y8P
#                            888
#  .d8888b  .d88b.  88888b.  888888 888 88888b.  888  888  .d88b.
# d88P"    d88""88b 888 "88b 888    888 888 "88b 888  888 d8P  Y8b
# 888      888  888 888  888 888    888 888  888 888  888 88888888
# Y88b.    Y88..88P 888  888 Y88b.  888 888  888 Y88b 888 Y8b.
#  "Y8888P  "Y88P"  888  888  "Y888 888 888  888  "Y88888  "Y8888
#
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#######################################################################################################################
# 13.8 The continue Statement
# 13.8.1 SS: Early Errors
# 13.8.2 SS: ContainsUndefinedContinueTarget
# 13.8.3 RS: Evaluation
#######################################################################################################################

####################################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟑.𝟖 𝓣𝓱𝓮 𝓬𝓸𝓷𝓽𝓲𝓷𝓾𝓮 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 .....●·._..●·._..●·._.·´ #
####################################################################################
# 13.8 The continue Statement

# --------======= 𝓒𝓸𝓷𝓽𝓲𝓷𝓾𝓮𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   ContinueStatement :
#       continue ;
#       continue LabelIdentifier ;


class P2_ContinueStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ContinueStatement", strict, children)

    def EarlyErrors(self):
        # 13.8.1 Static Semantics: Early Errors
        #           ContinueStatement : continue ;
        #           ContinueStatement : continue LabelIdentifier ;
        #  * It is a Syntax Error if this ContinueStatement is not nested, directly or indirectly (but not crossing
        #    function boundaries), within an IterationStatement.
        # ... I'm not actually sure how to test that. Probably need to add a marker function to the __init__ function
        # of IterationStatement that scans children for continues, and doesn't enter functions.
        return []

    contains_unenclosed_continue = True


class P2_ContinueStatement_CONTINUE(P2_ContinueStatement):
    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.8.2 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #           ContinueStatement : continue;
        # 1. Return false.
        return False

    def evaluate(self):
        # 13.8.3 Runtime Semantics: Evaluation
        #           ContinueStatement : continue ;
        # 1. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: empty }.
        raise ESContinue


class P2_ContinueStatement_CONTINUE_LabelIdentifier(P2_ContinueStatement):
    @property
    def LabelIdentifier(self):
        return self.children[1]

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.8.2 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        #           ContinueStatement : continue LabelIdentifier ;
        # 1. If the StringValue of LabelIdentifier is not an element of iterationSet, return true.
        # 2. Return false.
        return self.LabelIdentifier.StringValue not in iterationSet

    def evaluate(self):
        # 13.8.3 Runtime Semantics: Evaluation
        #           ContinueStatement : continue LabelIdentifier ;
        # 1. Let label be the StringValue of LabelIdentifier.
        # 2. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: label }.
        raise ESContinue(target=self.LabelIdentifier.StringValue)


def parse_ContinueStatement(context, lexer, pos, strict, Yield, Await):
    # 13.8 The continue Statement
    # Syntax
    #   ContinueStatement[Yield, Await] :
    #       continue ;
    #       continue [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
    #
    continue_token = lexer.id_if(pos, "continue")
    if continue_token:
        after_continue = continue_token.span.after
        peek = lexer.token(after_continue)
        if peek and not peek.newlines:
            li = parse_LabelIdentifier(context, lexer, after_continue, strict, Yield, Await)
            if li:
                semi_li = lexer.token_asi(li.after)
                if semi_li:
                    return P2_ContinueStatement_CONTINUE_LabelIdentifier(
                        context, strict, [continue_token, li, semi_li]
                    )
        semi_plain = lexer.token_asi(after_continue)
        if semi_plain:
            return P2_ContinueStatement_CONTINUE(context, strict, [continue_token, semi_plain])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       .d8888b.      88888888888 888                   888                                888
# d8888   d88P  Y88b     d88P  Y88b         888     888                   888                                888
#   888        .d88P     888    888         888     888                   888                                888
#   888       8888"      Y88b. d888         888     88888b.   .d88b.      88888b.  888d888  .d88b.   8888b.  888  888
#   888        "Y8b.      "Y888P888         888     888 "88b d8P  Y8b     888 "88b 888P"   d8P  Y8b     "88b 888 .88P
#   888   888    888            888         888     888  888 88888888     888  888 888     88888888 .d888888 888888K
#   888   Y88b  d88P d8b Y88b  d88P         888     888  888 Y8b.         888 d88P 888     Y8b.     888  888 888 "88b
# 8888888  "Y8888P"  Y8P  "Y8888P"          888     888  888  "Y8888      88888P"  888      "Y8888  "Y888888 888  888
#
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#######################################################################################################################
# 13.9 The break Statement
# 13.9.1 SS: Early Errors
# 13.9.2 SS: ContainsUndefinedBreakTarget
# 13.9.3 RS: Evaluation
#######################################################################################################################

##############################################################################
# `·._.·●.._.·●.._.·●..... 13.9 The break Statement .....●·._..●·._..●·._.·´ #
##############################################################################
# 13.9 The break Statement

# --------======= 𝓑𝓻𝓮𝓪𝓴𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   BreakStatement:
#       break LabelIdentifier ;
#       break ;


class P2_BreakStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "BreakStatement", strict, children)


class P2_BreakStatement_BREAK_LabelIdentifier(P2_BreakStatement):
    @property
    def LabelIdentifier(self):
        return self.children[1]

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.9.2 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # BreakStatement : break LabelIdentifier ;
        #   1. If the StringValue of LabelIdentifier is not an element of labelSet, return true.
        #   2. Return false.
        return self.LabelIdentifier.StringValue not in labelSet

    def evaluate(self):
        # 13.9.3 Runtime Semantics: Evaluation
        # BreakStatement : break LabelIdentifier ;
        #   1. Let label be the StringValue of LabelIdentifier.
        #   2. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: label }.
        raise ESBreak(target=self.LabelIdentifier.StringValue)


class P2_BreakStatement_BREAK(P2_BreakStatement):
    def EarlyErrors(self):
        # 13.9.1 Static Semantics: Early Errors
        # BreakStatement : break ;
        #   * It is a Syntax Error if this BreakStatement is not nested, directly or indirectly (but not crossing
        #     function boundaries), within an IterationStatement or a SwitchStatement.
        # @@@@@ Implement me!
        return []

    contains_unenclosed_break = True

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.9.2 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # BreakStatement : break ;
        #   1. Return false.
        return False

    def evaluate(self):
        # 13.9.3 Runtime Semantics: Evaluation
        # BreakStatement : break ;
        #   1. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.
        raise ESBreak()


def parse_BreakStatement(context, lexer, pos, strict, Yield, Await):
    # 13.9 The break Statement
    # Sytax
    #   BreakStatement[Yield, Await]:
    #       break [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ;
    #       break ;
    break_token = lexer.id_if(pos, "break")
    if break_token:
        after_break = break_token.span.after
        peek = lexer.token(after_break)
        if peek and not peek.newlines:
            li = parse_LabelIdentifier(context, lexer, after_break, strict, Yield, Await)
            if li:
                semi1 = lexer.token_asi(li.after)
                if semi1:
                    return P2_BreakStatement_BREAK_LabelIdentifier(context, strict, [break_token, li, semi1])
        semi2 = lexer.token_asi(after_break)
        if semi2:
            return P2_BreakStatement_BREAK(context, strict, [break_token, semi2])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.      88888888888 888
# d8888   d88P  Y88b     d8888   d88P  Y88b         888     888
#   888        .d88P       888   888    888         888     888
#   888       8888"        888   888    888         888     88888b.   .d88b.
#   888        "Y8b.       888   888    888         888     888 "88b d8P  Y8b
#   888   888    888       888   888    888         888     888  888 88888888
#   888   Y88b  d88P d8b   888   Y88b  d88P         888     888  888 Y8b.
# 8888888  "Y8888P"  Y8P 8888888  "Y8888P"          888     888  888  "Y8888
#
#
#
#                  888
#                  888
#                  888
# 888d888  .d88b.  888888 888  888 888d888 88888b.
# 888P"   d8P  Y8b 888    888  888 888P"   888 "88b
# 888     88888888 888    888  888 888     888  888
# 888     Y8b.     Y88b.  Y88b 888 888     888  888
# 888      "Y8888   "Y888  "Y88888 888     888  888
#
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#
#######################################################################################################################
# 13.10 The return Statement
# 13.10.1 RS: Evaluation
#######################################################################################################################

################################################################################
# `·._.·●.._.·●.._.·●..... 13.10 The return Statement .....●·._..●·._..●·._.·´ #
################################################################################
# 13.10 The return Statement

# --------======= 𝓡𝓮𝓽𝓾𝓻𝓷𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   ReturnStatement :
#       return ;
#       return Expression ;


class P2_ReturnStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ReturnStatement", strict, children)


class P2_ReturnStatement_RETURN(P2_ReturnStatement):
    def evaluate(self):
        raise ESReturn(value=None)


class P2_ReturnStatement_RETURN_Expression(P2_ReturnStatement):
    @property
    def Expression(self):
        return self.children[1]

    def evaluate(self):
        exprValue = GetValue(self.Expression.evaluate())
        if GetGeneratorKind() == ASYNC:
            exprValue = Await(exprValue)
        raise ESReturn(value=exprValue)


def parse_ReturnStatement(context, lexer, pos, strict, Yield, Await):
    # 13.10 The return Statement
    # Syntax
    #   ReturnStatement[Yield, Await] :
    #       return ;
    #       return [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
    ret = lexer.id_if(pos, "return")
    if ret:
        after_return = ret.span.after
        peek = lexer.token(after_return)
        if peek and not peek.newlines:
            exp = parse_Expression(context, lexer, after_return, strict, True, Yield, Await)
            if exp:
                semi1 = lexer.token_asi(exp.after)
                if semi1:
                    return P2_ReturnStatement_RETURN_Expression(context, strict, [ret, exp, semi1])
        semi2 = lexer.token_asi(after_return)
        if semi2:
            return P2_ReturnStatement_RETURN(context, strict, [ret, semi2])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888    d888       88888888888 888                                 d8b 888    888
# d8888   d88P  Y88b     d8888   d8888           888     888                                 Y8P 888    888
#   888        .d88P       888     888           888     888                                     888    888
#   888       8888"        888     888           888     88888b.   .d88b.      888  888  888 888 888888 88888b.
#   888        "Y8b.       888     888           888     888 "88b d8P  Y8b     888  888  888 888 888    888 "88b
#   888   888    888       888     888           888     888  888 88888888     888  888  888 888 888    888  888
#   888   Y88b  d88P d8b   888     888           888     888  888 Y8b.         Y88b 888 d88P 888 Y88b.  888  888
# 8888888  "Y8888P"  Y8P 8888888 8888888         888     888  888  "Y8888       "Y8888888P"  888  "Y888 888  888
#
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#
#######################################################################################################################
# 13.11 The with Statement
# 13.11.1 SS: Early Errors
# 13.11.2 SS: ContainsDuplicateLabels
# 13.11.3 SS: ContainsUndefinedBreakTarget
# 13.11.4 SS: ContainsUndefinedContinueTarget
# 13.11.5 SS: VarDeclaredNames
# 13.11.6 SS: VarScopedDeclarations
# 13.11.7 RS: Evaluation
#######################################################################################################################

##############################################################################
# `·._.·●.._.·●.._.·●..... 13.11 The with Statement .....●·._..●·._..●·._.·´ #
##############################################################################
# 13.11 The with Statement

# --------======= 𝓦𝓲𝓽𝓱𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   WithStatement :
#       with ( Expression ) Statement


class P2_WithStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "WithStatement", strict, children)


class P2_WithStatement_WITH_Expression_Statement(P2_WithStatement):
    @property
    def Expression(self):
        return self.children[2]

    @property
    def Statement(self):
        return self.children[4]

    def EarlyErrors(self):
        # 13.11.1 Static Semantics: Early Errors
        # WithStatement : with ( Expression ) Statement
        #   * It is a Syntax Error if the code that matches this production is contained in strict mode code.
        #   * It is a Syntax Error if IsLabelledFunction(Statement) is true.
        # NOTE: It is only necessary to apply the second rule if the extension specified in B.3.2 is implemented.
        return list(
            filter(
                None, [self.strict and self.CreateSyntaxError("Strict mode code may not include a with statement")]
            )
        )

    def ContainsDuplicateLabels(self, labelSet):
        # 13.11.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # WithStatement : with ( Expression ) Statement
        #   1. Return ContainsDuplicateLabels of Statement with argument labelSet.
        return self.Statement.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.11.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # WithStatement : with ( Expression ) Statement
        #   1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
        return self.Statement.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.11.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # WithStatement : with ( Expression ) Statement
        #   1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
        return self.Statement.ContainsUndefinedContinueTarget(iterationSet, [])

    def VarDeclaredNames(self):
        # 13.11.5 Static Semantics: VarDeclaredNames
        # WithStatement : with ( Expression ) Statement
        #   1. Return the VarDeclaredNames of Statement.
        return self.Statement.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.11.6 Static Semantics: VarScopedDeclarations
        # WithStatement : with ( Expression ) Statement
        #   1. Return the VarScopedDeclarations of Statement.
        return self.Statement.VarScopedDeclarations()

    def evaluate(self):
        # 13.11.7 Runtime Semantics: Evaluation
        # WithStatement : with ( Expression ) Statement
        #   1. Let val be the result of evaluating Expression.
        #   2. Let obj be ? ToObject(? GetValue(val)).
        #   3. Let oldEnv be the running execution context's LexicalEnvironment.
        #   4. Let newEnv be NewObjectEnvironment(obj, oldEnv).
        #   5. Set the withEnvironment flag of newEnv's EnvironmentRecord to true.
        #   6. Set the running execution context's LexicalEnvironment to newEnv.
        #   7. Let C be the result of evaluating Statement.
        #   8. Set the running execution context's LexicalEnvironment to oldEnv.
        #   9. Return Completion(UpdateEmpty(C, undefined)).
        # NOTE  | No matter how control leaves the embedded Statement, whether normally or by some form of abrupt
        #       | completion or exception, the LexicalEnvironment is always restored to its former state.
        val = self.Expression.evaluate()
        obj = ToObject(GetValue(val))
        oldEnv = surrounding_agent.running_ec.lexical_environment
        newEnv = NewObjectEnvironment(obj, oldEnv)
        newEnv.environment_record.with_environment = True
        surrounding_agent.running_ec.lexical_environment = newEnv
        try:
            C = self.Statement.evaluate()
        finally:
            surrounding_agent.running_ec.lexical_environment = oldEnv
        return UpdateEmpty(C, None)


def parse_WithStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13.11 The with Statement
    # Syntax
    #   WithStatement[Yield, Await, Return] :
    #       with ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]
    #
    with_tok = lexer.id_if(pos, "with")
    if with_tok:
        lp = lexer.token_if(with_tok.span.after, "(")
        if lp:
            exp = parse_Expression(context, lexer, lp.span.after, strict, True, Yield, Await)
            if exp:
                rp = lexer.token_if(exp.after, ")")
                if rp:
                    stmt = parse_Statement(context, lexer, rp.span.after, strict, Yield, Await, Return)
                    if stmt:
                        return P2_WithStatement_WITH_Expression_Statement(
                            context, strict, [with_tok, lp, exp, rp, stmt]
                        )
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.      88888888888 888
# d8888   d88P  Y88b     d8888   d88P  Y88b         888     888
#   888        .d88P       888          888         888     888
#   888       8888"        888        .d88P         888     88888b.   .d88b.
#   888        "Y8b.       888    .od888P"          888     888 "88b d8P  Y8b
#   888   888    888       888   d88P"              888     888  888 88888888
#   888   Y88b  d88P d8b   888   888"               888     888  888 Y8b.
# 8888888  "Y8888P"  Y8P 8888888 888888888          888     888  888  "Y8888
#
#
#
#                        d8b 888             888
#                        Y8P 888             888
#                            888             888
# .d8888b  888  888  888 888 888888  .d8888b 88888b.
# 88K      888  888  888 888 888    d88P"    888 "88b
# "Y8888b. 888  888  888 888 888    888      888  888
#      X88 Y88b 888 d88P 888 Y88b.  Y88b.    888  888
#  88888P'  "Y8888888P"  888  "Y888  "Y8888P 888  888
#
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#
#######################################################################################################################
# 13.12 The switch Statement
# 13.12.1 SS: Early Errors
# 13.12.2 SS: ContainsDuplicateLabels
# 13.12.3 SS: ContainsUndefinedBreakTarget
# 13.12.4 SS: ContainsUndefinedContinueTarget
# 13.12.5 SS: LexicallyDeclaredNames
# 13.12.6 SS: LexicallyScopedDeclarations
# 13.12.7 SS: VarDeclaredNames
# 13.12.8 SS: VarScopedDeclarations
# 13.12.9 RS: CaseBlockEvaluation
# 13.12.10 RS: CaseClauseIsSelected ( C, input )
# 13.12.11 RS: Evaluation
#######################################################################################################################

################################################################################
# `·._.·●.._.·●.._.·●..... 13.12 The switch Statement .....●·._..●·._..●·._.·´ #
################################################################################
# 13.12 The switch Statement

# --------======= 𝓢𝔀𝓲𝓽𝓬𝓱𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   SwitchStatement :
#       switch ( Expression ) CaseBlock


class P2_SwitchStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "SwitchStatement", strict, children)

    contains_unenclosed_break = False


class P2_SwitchStatement_SWITCH_Expression_CaseBlock(P2_SwitchStatement):
    @property
    def Expression(self):
        return self.children[2]

    @property
    def CaseBlock(self):
        return self.children[4]

    def EarlyErrors(self):
        # 13.12.1 Static Semantics: Early Errors
        # SwitchStatement : switch ( Expression ) CaseBlock
        #   * It is a Syntax Error if the LexicallyDeclaredNames of CaseBlock contains any duplicate entries.
        #   * It is a Syntax Error if any element of the LexicallyDeclaredNames of CaseBlock also occurs in the
        #     VarDeclaredNames of CaseBlock.
        ldn = self.CaseBlock.LexicallyDeclaredNames()
        vdn = self.CaseBlock.VarDeclaredNames()
        duplicates = [name for name, count in Counter(ldn).items() if count > 1]
        clashes = set(vdn) & set(ldn)
        return [
            x
            for x in (
                len(duplicates) > 0 and self.CreateSyntaxError(f"Duplicated declarations: {', '.join(duplicates)}"),
                len(clashes) > 0 and self.CreateSyntaxError(f"Duplicated declarations: {', '.join(clashes)}"),
            )
            if x
        ]

    def ContainsDuplicateLabels(self, labelset):
        # 13.12.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # SwitchStatement : switch ( Expression ) CaseBlock
        #   1. Return ContainsDuplicateLabels of CaseBlock with argument labelSet.
        return self.CaseBlock.ContainsDuplicateLabels(labelset)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.12.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # SwitchStatement : switch ( Expression ) CaseBlock
        #   1. Return ContainsUndefinedBreakTarget of CaseBlock with argument labelSet.
        return self.CaseBlock.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.12.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # SwitchStatement : switch ( Expression ) CaseBlock
        #   1. Return ContainsUndefinedContinueTarget of CaseBlock with arguments iterationSet and « ».
        return self.CaseBlock.ContainsUndefinedContinueTarget(iterationSet, [])

    def VarDeclaredNames(self):
        # 13.12.7 Static Semantics: VarDeclaredNames
        # SwitchStatement : switch ( Expression ) CaseBlock
        #   1. Return the VarDeclaredNames of CaseBlock.
        return self.CaseBlock.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.12.8 Static Semantics: VarScopedDeclarations
        # SwitchStatement : switch ( Expression ) CaseBlock
        #   1. Return the VarScopedDeclarations of CaseBlock.
        return self.CaseBlock.VarScopedDeclarations()

    def evaluate(self):
        # 13.12.11 Runtime Semantics: Evaluation
        # SwitchStatement : switch ( Expression ) CaseBlock
        #   1. Let exprRef be the result of evaluating Expression.
        #   2. Let switchValue be ? GetValue(exprRef).
        #   3. Let oldEnv be the running execution context's LexicalEnvironment.
        #   4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
        #   5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).
        #   6. Set the running execution context's LexicalEnvironment to blockEnv.
        #   7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.
        #   8. Set the running execution context's LexicalEnvironment to oldEnv.
        #   9. Return R.
        # NOTE  | No matter how control leaves the SwitchStatement the LexicalEnvironment is always restored to its
        #       | former state.
        switchValue = GetValue(self.Expression.evaluate())
        oldEnv = surrounding_agent.running_ec.lexical_environment
        blockEnv = NewDeclarativeEnvironment(oldEnv)
        BlockDeclarationInstantiation(self.CaseBlock, blockEnv)
        surrounding_agent.running_ec.lexical_environment = blockEnv
        try:
            R = self.CaseBlock.CaseBlockEvaluation(switchValue)
        finally:
            surrounding_agent.running_ec.lexical_environment = oldEnv
        return R


def parse_SwitchStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13.12 The switch Statement
    # Syntax
    #   SwitchStatement[Yield, Await, Return] :
    #       switch ( Expression[+In, ?Yield, ?Await] ) CaseBlock[?Yield, ?Await, ?Return]
    switch_tok = lexer.id_if(pos, "switch")
    if switch_tok:
        lp = lexer.token_if(switch_tok.span.after, "(")
        if lp:
            exp = parse_Expression(context, lexer, lp.span.after, strict, True, Yield, Await)
            if exp:
                rp = lexer.token_if(exp.after, ")")
                if rp:
                    cb = parse_CaseBlock(context, lexer, rp.span.after, strict, Yield, Await, Return)
                    if cb:
                        return P2_SwitchStatement_SWITCH_Expression_CaseBlock(
                            context, strict, [switch_tok, lp, exp, rp, cb]
                        )
    return None


# --------======= 𝓒𝓪𝓼𝓮𝓑𝓵𝓸𝓬𝓴 =======--------
# Syntax
#   CaseBlock :
#       { CaseClauses[opt] }
#       { CaseClauses[opt] DefaultClause CaseClauses[opt] }


class P2_CaseBlock(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CaseBlock", strict, children)

    CaseClausesBefore = None
    DefaultClause = None
    CaseClausesAfter = None


class P2_CaseBlock_EMPTY(P2_CaseBlock):
    def ContainsDuplicateLabels(self, labelset):
        # 13.12.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # CaseBlock : { }
        #   1. Return false.
        return False

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.12.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # CaseBlock : { }
        #   1. Return false.
        return False

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.12.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # CaseBlock : { }
        #   1. Return false.
        return False

    def LexicallyDeclaredNames(self):
        # 13.12.5 Static Semantics: LexicallyDeclaredNames
        # CaseBlock : { }
        #   1. Return a new empty List.
        return []

    def LexicallyScopedDeclarations(self):
        # 13.12.6 Static Semantics: LexicallyScopedDeclarations
        # CaseBlock : { }
        #   1. Return a new empty List.
        return []

    def VarDeclaredNames(self):
        # 13.12.7 Static Semantics: VarDeclaredNames
        # CaseBlock : { }
        #   1. Return a new empty List.
        return []

    def VarScopedDeclarations(self):
        # 13.12.8 Static Semantics: VarScopedDeclarations
        # CaseBlock : { }
        #   1. Return a new empty List.
        return []

    def CaseBlockEvaluation(self, input):
        # 13.12.9Runtime Semantics: CaseBlockEvaluation
        #   With parameter input.
        # CaseBlock : { }
        #   1. Return NormalCompletion(undefined).
        return None


class P2_CaseBlock_HasDefault(P2_CaseBlock):
    def ContainsDuplicateLabels(self, labelset):
        # 13.12.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. If the first CaseClauses is present, then
        #       a. Let hasDuplicates be ContainsDuplicateLabels of the first CaseClauses with argument labelSet.
        #       b. If hasDuplicates is true, return true.
        #   2. Let hasDuplicates be ContainsDuplicateLabels of DefaultClause with argument labelSet.
        #   3. If hasDuplicates is true, return true.
        #   4. If the second CaseClauses is not present, return false.
        #   5. Return ContainsDuplicateLabels of the second CaseClauses with argument labelSet.
        return (
            (self.CaseClausesBefore is not None and self.CaseClausesBefore.ContainsDuplicateLabels(labelset))
            or (self.DefaultClause.ContainsDuplicateLabels(labelset))
            or (self.CaseClausesAfter is not None and self.CaseClausesAfter.ContainsDuplicateLabels(labelset))
        )

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.12.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. If the first CaseClauses is present, then
        #       a. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of the first CaseClauses with argument
        #          labelSet.
        #       b. If hasUndefinedLabels is true, return true.
        #   2. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of DefaultClause with argument labelSet.
        #   3. If hasUndefinedLabels is true, return true.
        #   4. If the second CaseClauses is not present, return false.
        #   5. Return ContainsUndefinedBreakTarget of the second CaseClauses with argument labelSet.
        return (
            (self.CaseClausesBefore is not None and self.CaseClausesBefore.ContainsUndefinedBreakTarget(labelSet))
            or (self.DefaultClause.ContainsUndefinedBreakTarget(labelSet))
            or (self.CaseClausesAfter is not None and self.CaseClausesAfter.ContainsUndefinedBreakTarget(labelSet))
        )

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.12.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. If the first CaseClauses is present, then
        #       a. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of the first CaseClauses with arguments
        #          iterationSet and « ».
        #       b. If hasUndefinedLabels is true, return true.
        #   2. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of DefaultClause with arguments iterationSet
        #      and « ».
        #   3. If hasUndefinedLabels is true, return true.
        #   4. If the second CaseClauses is not present, return false.
        #   5. Return ContainsUndefinedContinueTarget of the second CaseClauses with arguments iterationSet and « ».
        return (
            (
                self.CaseClausesBefore is not None
                and self.CaseClausesBefore.ContainsUndefinedContinueTarget(iterationSet, [])
            )
            or (self.DefaultClause.ContainsUndefinedContinueTarget(iterationSet, []))
            or (
                self.CaseClausesAfter is not None
                and self.CaseClausesAfter.ContainsUndefinedContinueTarget(iterationSet, [])
            )
        )

    def LexicallyDeclaredNames(self):
        # 13.12.5 Static Semantics: LexicallyDeclaredNames
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. If the first CaseClauses is present, let names be the LexicallyDeclaredNames of the first CaseClauses.
        #   2. Else, let names be a new empty List.
        #   3. Append to names the elements of the LexicallyDeclaredNames of the DefaultClause.
        #   4. If the second CaseClauses is not present, return names.
        #   5. Return the result of appending to names the elements of the LexicallyDeclaredNames of the second CaseClauses.
        return (
            (self.CaseClausesBefore.LexicallyDeclaredNames() if self.CaseClausesBefore else [])
            + (self.DefaultClause.LexicallyDeclaredNames())
            + (self.CaseClausesAfter.LexicallyDeclaredNames() if self.CaseClausesAfter else [])
        )

    def LexicallyScopedDeclarations(self):
        # 13.12.6 Static Semantics: LexicallyScopedDeclarations
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. If the first CaseClauses is present, let declarations be the LexicallyScopedDeclarations of the first
        #      CaseClauses.
        #   2. Else, let declarations be a new empty List.
        #   3. Append to declarations the elements of the LexicallyScopedDeclarations of the DefaultClause.
        #   4. If the second CaseClauses is not present, return declarations.
        #   5. Return the result of appending to declarations the elements of the LexicallyScopedDeclarations of the
        #      second CaseClauses.
        return (
            (self.CaseClausesBefore.LexicallyScopedDeclarations() if self.CaseClausesBefore else [])
            + (self.DefaultClause.LexicallyScopedDeclarations())
            + (self.CaseClausesAfter.LexicallyScopedDeclarations() if self.CaseClausesAfter else [])
        )

    def VarDeclaredNames(self):
        # 13.12.7 Static Semantics: VarDeclaredNames
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. If the first CaseClauses is present, let names be the VarDeclaredNames of the first CaseClauses.
        #   2. Else, let names be a new empty List.
        #   3. Append to names the elements of the VarDeclaredNames of the DefaultClause.
        #   4. If the second CaseClauses is not present, return names.
        #   5. Return the result of appending to names the elements of the VarDeclaredNames of the second CaseClauses.
        return (
            (self.CaseClausesBefore.VarDeclaredNames() if self.CaseClausesBefore else [])
            + (self.DefaultClause.VarDeclaredNames())
            + (self.CaseClausesAfter.VarDeclaredNames() if self.CaseClausesAfter else [])
        )

    def VarScopedDeclarations(self):
        # 13.12.8 Static Semantics: VarScopedDeclarations
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. If the first CaseClauses is present, let declarations be the VarScopedDeclarations of the first
        #      CaseClauses.
        #   2. Else, let declarations be a new empty List.
        #   3. Append to declarations the elements of the VarScopedDeclarations of the DefaultClause.
        #   4. If the second CaseClauses is not present, return declarations.
        #   5. Return the result of appending to declarations the elements of the VarScopedDeclarations of the second
        #      CaseClauses.
        return (
            (self.CaseClausesBefore.VarScopedDeclarations() if self.CaseClausesBefore else [])
            + (self.DefaultClause.VarScopedDeclarations())
            + (self.CaseClausesAfter.VarScopedDeclarations() if self.CaseClausesAfter else [])
        )

    def CaseBlockEvaluation(self, input):
        # 13.12.9 Runtime Semantics: CaseBlockEvaluation
        #   With parameter input.
        # CaseBlock : { CaseClauses DefaultClause CaseClauses }
        #   1. Let V be undefined.
        #   2. If the first CaseClauses is present, then
        #       a. Let A be the List of CaseClause items in the first CaseClauses, in source text order.
        #   3. Else,
        #       a. Let A be « ».
        #   4. Let found be false.
        #   5. For each CaseClause C in A, do
        #       a. If found is false, then
        #           i. Set found to ? CaseClauseIsSelected(C, input).
        #       b. If found is true, then
        #           i. Let R be the result of evaluating C.
        #           ii. If R.[[Value]] is not empty, set V to R.[[Value]].
        #           iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        #   6. Let foundInB be false.
        #   7. If the second CaseClauses is present, then
        #       a. Let B be the List of CaseClause items in the second CaseClauses, in source text order.
        #   8. Else,
        #       a. Let B be « ».
        #   9. If found is false, then
        #       a. For each CaseClause C in B, do
        #           i. If foundInB is false, then
        #               1. Set foundInB to ? CaseClauseIsSelected(C, input).
        #           ii. If foundInB is true, then
        #               1. Let R be the result of evaluating CaseClause C.
        #               2. If R.[[Value]] is not empty, set V to R.[[Value]].
        #               3. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        #   10. If foundInB is true, return NormalCompletion(V).
        #   11. Let R be the result of evaluating DefaultClause.
        #   12. If R.[[Value]] is not empty, set V to R.[[Value]].
        #   13. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        #   14. For each CaseClause C in B (NOTE: this is another complete iteration of the second CaseClauses), do
        #       a. Let R be the result of evaluating CaseClause C.
        #       b. If R.[[Value]] is not empty, set V to R.[[Value]].
        #       c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        #   15. Return NormalCompletion(V).
        V = None
        A = self.CaseClausesBefore.flattened() if self.CaseClausesBefore else []
        found = False
        for C in A:
            found = found or C.CaseClauseIsSelected(input)
            if found:
                try:
                    R = C.evaluate()
                    V = UpdateEmpty(R, V)
                except ESAbrupt as err:
                    c = err.completion
                    raise type(err)(UpdateEmpty(c.value, V), c.target)
        foundInB = False
        B = self.CaseClausesAfter.flattened() if self.CaseClausesAfter else []
        if not found:
            for C in B:
                foundInB = foundInB or C.CaseClauseIsSelected(input)
                if foundInB:
                    try:
                        R = C.evaluate()
                        V = UpdateEmpty(R, V)
                    except ESAbrupt as err:
                        c = err.completion
                        raise type(err)(UpdateEmpty(c.value, V), c.target)
        if foundInB:
            return V
        try:
            R = self.DefaultClause.evaluate()
            V = UpdateEmpty(R, V)
        except ESAbrupt as err:
            c = err.completion
            raise type(err)(UpdateEmpty(c.value, V), c.target)
        for C in B:
            try:
                R = C.evaluate()
                V = UpdateEmpty(R, V)
            except ESAbrupt as err:
                c = err.completion
                raise type(err)(UpdateEmpty(c.value, V), c.target)
        return V


class P2_CaseBlock_DefaultClause(P2_CaseBlock_HasDefault):
    @property
    def DefaultClause(self):
        return self.children[1]


class P2_CaseBlock_CaseClauses(P2_CaseBlock):
    @property
    def CaseClausesBefore(self):
        return self.children[1]

    def CaseBlockEvaluation(self, input):
        # 13.12.9 Runtime Semantics: CaseBlockEvaluation
        #   With parameter input.
        # CaseBlock : { CaseClauses }
        #   1. Let V be undefined.
        #   2. Let A be the List of CaseClause items in CaseClauses, in source text order.
        #   3. Let found be false.
        #   4. For each CaseClause C in A, do
        #       a. If found is false, then
        #           i. Set found to ? CaseClauseIsSelected(C, input).
        #       b. If found is true, then
        #           i. Let R be the result of evaluating C.
        #           ii. If R.[[Value]] is not empty, set V to R.[[Value]].
        #           iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        #   5. Return NormalCompletion(V).
        V = None
        A = self.CaseClausesBefore.flattened()
        found = False
        for C in A:
            found = found or C.CaseClauseIsSelected(input)
            if found:
                try:
                    R = C.evaluate()
                except ESAbrupt as abrupt:
                    raise type(abrupt)(UpdateEmpty(abrupt.completion.value, V), abrupt.completion.target)
                V = UpdateEmpty(R, V)
        return V


class P2_CaseBlock_CaseClauses_DefaultClause(P2_CaseBlock_HasDefault):
    @property
    def CaseClausesBefore(self):
        return self.children[1]

    @property
    def DefaultClause(self):
        return self.children[2]


class P2_CaseBlock_DefaultClause_CaseClauses(P2_CaseBlock_HasDefault):
    @property
    def DefaultClause(self):
        return self.children[1]

    @property
    def CaseClausesAfter(self):
        return self.children[2]


class P2_CaseBlock_CaseClauses_DefaultClause_CaseClauses(P2_CaseBlock_HasDefault):
    @property
    def CaseClausesBefore(self):
        return self.children[1]

    @property
    def DefaultClause(self):
        return self.children[2]

    @property
    def CaseClausesAfter(self):
        return self.children[3]


def parse_CaseBlock(context, lexer, pos, strict, Yield, Await, Return):
    # 13.12 The switch Statement
    # Syntax
    #   CaseBlock[Yield, Await, Return] :
    #       { CaseClauses[?Yield, ?Await, ?Return]opt }
    #       { CaseClauses[?Yield, ?Await, ?Return]opt DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]opt }
    lc = lexer.token_if(pos, "{")
    if lc:
        ccb = parse_CaseClauses(context, lexer, lc.span.after, strict, Yield, Await, Return)
        ccb_after = ccb.after if ccb else lc.span.after
        dc = parse_DefaultClause(context, lexer, ccb_after, strict, Yield, Await, Return)
        dc_after = dc.after if dc else ccb_after
        cca = parse_CaseClauses(context, lexer, dc_after, strict, Yield, Await, Return)
        cca_after = cca.after if cca else dc_after
        rc = lexer.token_if(cca_after, "}")
        if rc:
            children = list(filter(None, [lc, ccb, dc, cca, rc]))
            choice_idx = int(ccb is not None) << 2 | int(dc is not None) << 1 | int(cca is not None)
            ctors = [
                P2_CaseBlock_EMPTY,  # 000
                None,  # 001 (can't happen. we'd get 100 instead)
                P2_CaseBlock_DefaultClause,  # 010
                P2_CaseBlock_DefaultClause_CaseClauses,  # 011
                P2_CaseBlock_CaseClauses,  # 100
                None,  # 101 (can't happen. We'd get 100 instead)
                P2_CaseBlock_CaseClauses_DefaultClause,  # 110
                P2_CaseBlock_CaseClauses_DefaultClause_CaseClauses,  # 111
            ]
            return ctors[choice_idx](context, strict, children)
    return None


# --------======= 𝓒𝓪𝓼𝓮𝓒𝓵𝓪𝓾𝓼𝓮𝓼 =======--------
# Syntax
#   CaseClauses :
#       CaseClause
#       CaseClauses CaseClause


class P2_CaseClauses(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CaseClauses", strict, children)

    CaseClause = None
    CaseClauses = None


class P2_CaseClauses_CaseClause(P2_CaseClauses):
    @property
    def CaseClause(self):
        return self.children[0]

    def flattened(self):
        return chain((self.CaseClause,))


class P2_CaseClauses_CaseClauses_CaseClause(P2_CaseClauses):
    @property
    def CaseClauses(self):
        return self.children[0]

    @property
    def CaseClause(self):
        return self.children[1]

    def flattened(self):
        return chain(self.CaseClauses.flattened(), (self.CaseClause,))

    def ContainsDuplicateLabels(self, labelset):
        # 13.12.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # CaseClauses : CaseClauses CaseClause
        #   1. Let hasDuplicates be ContainsDuplicateLabels of CaseClauses with argument labelSet.
        #   2. If hasDuplicates is true, return true.
        #   3. Return ContainsDuplicateLabels of CaseClause with argument labelSet.
        return any(item.ContainsDuplicateLabels(labelset) for item in (self.CaseClauses, self.CaseClause))

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.12.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # CaseClauses : CaseClauses CaseClause
        #   1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of CaseClauses with argument labelSet.
        #   2. If hasUndefinedLabels is true, return true.
        #   3. Return ContainsUndefinedBreakTarget of CaseClause with argument labelSet.
        return any(item.ContainsUndefinedBreakTarget(labelSet) for item in (self.CaseClauses, self.CaseClause))

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.12.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # CaseClauses : CaseClauses CaseClause
        #   1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of CaseClauses with arguments iterationSet and
        #      « ».
        #   2. If hasUndefinedLabels is true, return true.
        #   3. Return ContainsUndefinedContinueTarget of CaseClause with arguments iterationSet and « ».
        return any(
            item.ContainsUndefinedContinueTarget(iterationSet, []) for item in (self.CaseClauses, self.CaseClause)
        )

    def LexicallyDeclaredNames(self):
        # 13.12.5 Static Semantics: LexicallyDeclaredNames
        # CaseClauses : CaseClauses CaseClause
        #   1. Let names be LexicallyDeclaredNames of CaseClauses.
        #   2. Append to names the elements of the LexicallyDeclaredNames of CaseClause.
        #   3. Return names.
        return self.CaseClauses.LexicallyDeclaredNames() + self.CaseClause.LexicallyDeclaredNames()

    def LexicallyScopedDeclarations(self):
        # 13.12.6 Static Semantics: LexicallyScopedDeclarations
        # CaseClauses : CaseClauses CaseClause
        #   1. Let declarations be LexicallyScopedDeclarations of CaseClauses.
        #   2. Append to declarations the elements of the LexicallyScopedDeclarations of CaseClause.
        #   3. Return declarations.
        return self.CaseClauses.LexicallyScopedDeclarations() + self.CaseClause.LexicallyScopedDeclarations()

    def VarDeclaredNames(self):
        # 13.12.7 Static Semantics: VarDeclaredNames
        # CaseClauses : CaseClauses CaseClause
        #   1. Let names be VarDeclaredNames of CaseClauses.
        #   2. Append to names the elements of the VarDeclaredNames of CaseClause.
        #   3. Return names.
        return self.CaseClauses.VarDeclaredNames() + self.CaseClause.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.12.8 Static Semantics: VarScopedDeclarations
        # CaseClauses : CaseClauses CaseClause
        #   1. Let declarations be VarScopedDeclarations of CaseClauses.
        #   2. Append to declarations the elements of the VarScopedDeclarations of CaseClause.
        #   3. Return declarations.
        return self.CaseClauses.VarScopedDeclarations() + self.CaseClause.VarScopedDeclarations()


def parse_CaseClauses(context, lexer, pos, strict, Yield, Await, Return):
    # 13.12 The switch Statement
    # Syntax
    #   CaseClauses[Yield, Await, Return] :
    #       CaseClause[?Yield, ?Await, ?Return]
    #       CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]
    def parse(pos, previous=None):
        cc = parse_CaseClause(context, lexer, pos, strict, Yield, Await, Return)
        if cc:
            if previous is None:
                return lambda: parse(cc.after, P2_CaseClauses_CaseClause(context, strict, [cc]))
            else:
                return lambda: parse(
                    cc.after, P2_CaseClauses_CaseClauses_CaseClause(context, strict, [previous, cc])
                )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓒𝓪𝓼𝓮𝓒𝓵𝓪𝓾𝓼𝓮 =======--------
# Syntax
#   CaseClause :
#       case Expression : StatementList[opt]


class P2_CaseClause(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CaseClause", strict, children)

    StatementList = None
    Expression = None

    def ContainsDuplicateLabels(self, labelset):
        # 13.12.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # CaseClause : case Expression : StatementList
        #   1. If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.
        #   2. Return false.
        return self.StatementList is not None and self.StatementList.ContainsDuplicateLabels(labelset)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.12.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # CaseClause : case Expression : StatementList
        #   1. If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument
        #      labelSet.
        #   2. Return false.
        return self.StatementList is not None and self.StatementList.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.12.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # CaseClause : case Expression : StatementList
        #   1. If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments
        #      iterationSet and « ».
        #   2. Return false.
        return self.StatementList is not None and self.StatementList.ContainsUndefinedContinueTarget(
            iterationSet, []
        )

    def LexicallyDeclaredNames(self):
        # 13.12.5 Static Semantics: LexicallyDeclaredNames
        # CaseClause : case Expression : StatementList
        #   1. If the StatementList is present, return the LexicallyDeclaredNames of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.LexicallyDeclaredNames() if self.StatementList else []

    def LexicallyScopedDeclarations(self):
        # 13.12.6 Static Semantics: LexicallyScopedDeclarations
        # CaseClause : case Expression : StatementList
        #   1. If the StatementList is present, return the LexicallyScopedDeclarations of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.LexicallyScopedDeclarations() if self.StatementList else []

    def VarDeclaredNames(self):
        # 13.12.7 Static Semantics: VarDeclaredNames
        # CaseClause : case Expression : StatementList
        #   1. If the StatementList is present, return the VarDeclaredNames of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.VarDeclaredNames() if self.StatementList else []

    def VarScopedDeclarations(self):
        # 13.12.8 Static Semantics: VarScopedDeclarations
        # CaseClause : case Expression : StatementList
        #   1. If the StatementList is present, return the VarScopedDeclarations of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.VarScopedDeclarations() if self.StatementList else []

    def CaseClauseIsSelected(self, input):
        # 13.12.10 Runtime Semantics: CaseClauseIsSelected ( C, input )
        # The abstract operation CaseClauseIsSelected, given CaseClause C and value input, determines whether C
        # matches input.
        #
        #   1. Assert: C is an instance of the production CaseClause:caseExpression:StatementList .
        #   2. Let exprRef be the result of evaluating the Expression of C.
        #   3. Let clauseSelector be ? GetValue(exprRef).
        #   4. Return the result of performing Strict Equality Comparison input === clauseSelector.
        clauseSelector = GetValue(self.Expression.evaluate())
        return StrictEqualityComparison(input, clauseSelector)


class P2_CaseClause_CASE_Expression_StatementList(P2_CaseClause):
    @property
    def Expression(self):
        return self.children[1]

    @property
    def StatementList(self):
        return self.children[3]

    def evaluate(self):
        # 13.12.11 Runtime Semantics: Evaluation
        # CaseClause : case Expression : StatementList
        #   1. Return the result of evaluating StatementList.
        return self.StatementList.evaluate()


class P2_CaseClause_CASE_Expression(P2_CaseClause):
    @property
    def Expression(self):
        return self.children[1]

    def evaluate(self):
        # 13.12.11 Runtime Semantics: Evaluation
        # CaseClause : case Expression :
        #   1. Return NormalCompletion(empty).
        return EMPTY


def parse_CaseClause(context, lexer, pos, strict, Yield, Await, Return):
    # 13.12 The switch Statement
    # Syntax
    #   CaseClause[Yield, Await, Return] :
    #       case Expression[+In, ?Yield, ?Await] : StatementList[?Yield, ?Await, ?Return]opt
    case = lexer.id_if(pos, "case")
    if case:
        exp = parse_Expression(context, lexer, case.span.after, strict, True, Yield, Await)
        if exp:
            colon = lexer.token_if(exp.after, ":")
            if colon:
                sl = parse_StatementList(context, lexer, colon.span.after, strict, False, Yield, Await, Return)
                if sl:
                    return P2_CaseClause_CASE_Expression_StatementList(context, strict, [case, exp, colon, sl])
                return P2_CaseClause_CASE_Expression(context, strict, [case, exp, colon])
    return None


# --------======= 𝓓𝓮𝓯𝓪𝓾𝓵𝓽𝓒𝓵𝓪𝓾𝓼𝓮 =======--------
# Syntax
#   DefaultClause :
#       default : StatementList
#       default :


class P2_DefaultClause(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "DefaultClause", strict, children)

    StatementList = None

    def ContainsDuplicateLabels(self, labelset):
        # 13.12.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # DefaultClause : default : StatementList
        #   1. If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.
        #   2. Return false.
        return self.StatementList is not None and self.StatementList.ContainsDuplicateLabels(labelset)

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.12.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # DefaultClause : default : StatementList
        #   1. If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument
        #      labelSet.
        #   2. Return false.
        return self.StatementList is not None and self.StatementList.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.12.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # DefaultClause : default : StatementList
        #   1. If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments
        #      iterationSet and « ».
        #   2. Return false.
        return self.StatementList is not None and self.StatementList.ContainsUndefinedContinueTarget(
            iterationSet, []
        )

    def LexicallyDeclaredNames(self):
        # 13.12.5 Static Semantics: LexicallyDeclaredNames
        # DefaultClause : default : StatementList
        #   1. If the StatementList is present, return the LexicallyDeclaredNames of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.LexicallyDeclaredNames() if self.StatementList else []

    def LexicallyScopedDeclarations(self):
        # 13.12.6 Static Semantics: LexicallyScopedDeclarations
        # DefaultClause : default : StatementList
        #   1. If the StatementList is present, return the LexicallyScopedDeclarations of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.LexicallyScopedDeclarations() if self.StatementList else []

    def VarDeclaredNames(self):
        # 13.12.7 Static Semantics: VarDeclaredNames
        # DefaultClause : default : StatementList
        #   1. If the StatementList is present, return the VarDeclaredNames of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.VarDeclaredNames() if self.StatementList else []

    def VarScopedDeclarations(self):
        # 13.12.8 Static Semantics: VarScopedDeclarations
        # DefaultClause : default : StatementList
        #   1. If the StatementList is present, return the VarScopedDeclarations of StatementList.
        #   2. Return a new empty List.
        return self.StatementList.VarScopedDeclarations() if self.StatementList else []


class P2_DefaultClause_DEFAULT(P2_DefaultClause):
    def evaluate(self):
        # 13.12.11 Runtime Semantics: Evaluation
        # DefaultClause : default :
        #   1. Return NormalCompletion(empty).
        return EMPTY


class P2_DefaultClause_DEFAULT_StatementList(P2_DefaultClause):
    @property
    def StatementList(self):
        return self.children[2]

    def evaluate(self):
        # 13.12.11 Runtime Semantics: Evaluation
        # DefaultClause : default : StatementList
        #   1. Return the result of evaluating StatementList.
        return self.StatementList.evaluate()


def parse_DefaultClause(context, lexer, pos, strict, Yield, Await, Return):
    # 13.12 The switch Statement
    # Syntax
    #   DefaultClause[Yield, Await, Return] :
    #       default : StatementList[?Yield, ?Await, ?Return]opt
    default = lexer.id_if(pos, "default")
    if default:
        colon = lexer.token_if(default.span.after, ":")
        if colon:
            sl = parse_StatementList(context, lexer, colon.span.after, strict, False, Yield, Await, Return)
            if sl:
                return P2_DefaultClause_DEFAULT_StatementList(context, strict, [default, colon, sl])
            return P2_DefaultClause_DEFAULT(context, strict, [default, colon])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.      888               888               888 888               888
# d8888   d88P  Y88b     d8888   d88P  Y88b     888               888               888 888               888
#   888        .d88P       888        .d88P     888               888               888 888               888
#   888       8888"        888       8888"      888       8888b.  88888b.   .d88b.  888 888  .d88b.   .d88888
#   888        "Y8b.       888        "Y8b.     888          "88b 888 "88b d8P  Y8b 888 888 d8P  Y8b d88" 888
#   888   888    888       888   888    888     888      .d888888 888  888 88888888 888 888 88888888 888  888
#   888   Y88b  d88P d8b   888   Y88b  d88P     888      888  888 888 d88P Y8b.     888 888 Y8b.     Y88b 888
# 8888888  "Y8888P"  Y8P 8888888  "Y8888P"      88888888 "Y888888 88888P"   "Y8888  888 888  "Y8888   "Y88888
#
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888 .d8888b
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888    88K
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888    "Y8888b.
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.       X88
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888  88888P'
#
#
#
#
#######################################################################################################################
# 13.13 Labelled Statements
# 13.13.1 SS: Early Errors
# 13.13.2 SS: ContainsDuplicateLabels
# 13.13.3 SS: ContainsUndefinedBreakTarget
# 13.13.4 SS: ContainsUndefinedContinueTarget
# 13.13.5 SS: IsLabelledFunction ( stmt )
# 13.13.6 SS: LexicallyDeclaredNames
# 13.13.7 SS: LexicallyScopedDeclarations
# 13.13.8 SS: TopLevelLexicallyDeclaredNames
# 13.13.9 SS: TopLevelLexicallyScopedDeclarations
# 13.13.10 SS: TopLevelVarDeclaredNames
# 13.13.11 SS: TopLevelVarScopedDeclarations
# 13.13.12 SS: VarDeclaredNames
# 13.13.13 SS: VarScopedDeclarations
# 13.13.14 RS: LabelledEvaluation
# 13.13.15 RS: Evaluation
#######################################################################################################################

###############################################################################
# `·._.·●.._.·●.._.·●..... 13.13 Labelled Statements .....●·._..●·._..●·._.·´ #
###############################################################################
# 13.13 Labelled Statements

# --------======= 𝓛𝓪𝓫𝓮𝓵𝓵𝓮𝓭𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   LabelledStatement :
#       LabelIdentifier : LabelledItem


class P2_LabelledStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LabelledStatement", strict, children)


class P2_LabelledStatement_LabelIdentifier_LabelledItem(P2_LabelledStatement):
    @property
    def LabelIdentifier(self):
        return self.children[0]

    @property
    def LabelledItem(self):
        return self.children[2]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.13.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Let label be the StringValue of LabelIdentifier.
        #   2. If label is an element of labelSet, return true.
        #   3. Let newLabelSet be a copy of labelSet with label appended.
        #   4. Return ContainsDuplicateLabels of LabelledItem with argument newLabelSet.
        label = self.LabelIdentifier.StringValue
        return label in labelSet or self.LabelledItem.ContainsDuplicateLabels(labelSet + [label])

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.13.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Let label be the StringValue of LabelIdentifier.
        #   2. Let newLabelSet be a copy of labelSet with label appended.
        #   3. Return ContainsUndefinedBreakTarget of LabelledItem with argument newLabelSet.
        return self.LabelledItem.ContainsUndefinedBreakTarget(labelSet + [self.LabelIdentifier.StringValue])

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.13.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Let label be the StringValue of LabelIdentifier.
        #   2. Let newLabelSet be a copy of labelSet with label appended.
        #   3. Return ContainsUndefinedContinueTarget of LabelledItem with arguments iterationSet and newLabelSet.
        return self.LabelledItem.ContainsUndefinedContinueTarget(
            iterationSet, labelSet + [self.LabelIdentifier.StringValue]
        )

    def LexicallyDeclaredNames(self):
        # 13.13.6 Static Semantics: LexicallyDeclaredNames
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Return the LexicallyDeclaredNames of LabelledItem.
        return self.LabelledItem.LexicallyDeclaredNames()

    def LexicallyScopedDeclarations(self):
        # 13.13.7 Static Semantics: LexicallyScopedDeclarations
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Return the LexicallyScopedDeclarations of LabelledItem.
        return self.LabelledItem.LexicallyScopedDeclarations()

    def TopLevelLexicallyDeclaredNames(self):
        # 13.13.8 Static Semantics: TopLevelLexicallyDeclaredNames
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Return a new empty List.
        return []

    def TopLevelLexicallyScopedDeclarations(self):
        # 13.13.9 Static Semantics: TopLevelLexicallyScopedDeclarations
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Return a new empty List.
        return []

    def TopLevelVarDeclaredNames(self):
        # 13.13.10 Static Semantics: TopLevelVarDeclaredNames
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Return the TopLevelVarDeclaredNames of LabelledItem.
        return self.LabelledItem.TopLevelVarDeclaredNames()

    def TopLevelVarScopedDeclarations(self):
        # 13.13.11 Static Semantics: TopLevelVarScopedDeclarations
        # LabelledStatement : LabelIdentifier : LabelledItem
        # 1. Return the TopLevelVarScopedDeclarations of LabelledItem.
        return self.LabelledItem.TopLevelVarScopedDeclarations()

    def VarDeclaredNames(self):
        # 13.13.12 Static Semantics: VarDeclaredNames
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Return the VarDeclaredNames of LabelledItem.
        return self.LabelledItem.VarDeclaredNames()

    def VarScopedDeclarations(self):
        # 13.13.13 Static Semantics: VarScopedDeclarations
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Return the VarScopedDeclarations of LabelledItem.
        return self.LabelledItem.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.13.14 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Let label be the StringValue of LabelIdentifier.
        #   2. Append label as an element of labelSet.
        #   3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.
        #   4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then
        #       a. Set stmtResult to NormalCompletion(stmtResult.[[Value]]).
        #   5. Return Completion(stmtResult).
        label = self.LabelIdentifier.StringValue
        labelSet.append(label)
        try:
            stmtResult = self.LabelledItem.LabelledEvaluation(labelSet)
        except ESBreak as err:
            if not SameValue(err.completion.target, label):
                raise
            stmtResult = err.completion.value
        return stmtResult

    def evaluate(self):
        # 13.13.15 Runtime Semantics: Evaluation
        # LabelledStatement : LabelIdentifier : LabelledItem
        #   1. Let newLabelSet be a new empty List.
        #   2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.
        return self.LabelledEvaluation([])


def parse_LabelledStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13.13 Labelled Statements
    # Syntax
    #   LabelledStatement[Yield, Await, Return] :
    #       LabelIdentifier[?Yield, ?Await] : LabelledItem[?Yield, ?Await, ?Return]
    ident = parse_LabelIdentifier(context, lexer, pos, strict, Yield, Await)
    if ident:
        colon = lexer.token_if(ident.after, ":")
        if colon:
            item = parse_LabelledItem(context, lexer, colon.span.after, strict, Yield, Await, Return)
            if item:
                return P2_LabelledStatement_LabelIdentifier_LabelledItem(context, strict, [ident, colon, item])
    return None


# --------======= 𝓛𝓪𝓫𝓮𝓵𝓵𝓮𝓭𝓘𝓽𝓮𝓶 =======--------
# Syntax
#   LabelledItem :
#       Statement
#       FunctionDeclaration


class P2_LabelledItem(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "LabelledItem", strict, children)


class P2_LabelledItem_Statement(P2_LabelledItem):
    @property
    def Statement(self):
        return self.children[0]

    def LexicallyDeclaredNames(self):
        # 13.13.6 Static Semantics: LexicallyDeclaredNames
        # LabelledItem : Statement
        #   1. Return a new empty List.
        return []

    def LexicallyScopedDeclarations(self):
        # 13.13.7 Static Semantics: LexicallyScopedDeclarations
        # LabelledItem : Statement
        #   1. Return a new empty List.
        return []

    def TopLevelVarDeclaredNames(self):
        # 13.13.10 Static Semantics: TopLevelVarDeclaredNames
        # LabelledItem : Statement
        #   1. If Statement is Statement:LabelledStatement , return TopLevelVarDeclaredNames of Statement.
        #   2. Return VarDeclaredNames of Statement.
        if isinstance(self.Statement, P2_Statement_LabelledStatement):
            return self.Statement.TopLevelVarDeclaredNames()
        return self.Statement.VarDeclaredNames()

    def TopLevelVarScopedDeclarations(self):
        # 13.13.11 Static Semantics: TopLevelVarScopedDeclarations
        # LabelledItem : Statement
        #   1. If Statement is Statement:LabelledStatement , return TopLevelVarScopedDeclarations of Statement.
        #   2. Return VarScopedDeclarations of Statement.
        if isinstance(self.Statement, P2_Statement_LabelledStatement):
            return self.Statement.TopLevelVarScopedDeclarations()
        return self.Statement.VarScopedDeclarations()

    def LabelledEvaluation(self, labelSet):
        # 13.13.14 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # LabelledItem : Statement
        #   1. If Statement is either a LabelledStatement or a BreakableStatement, then
        #       a. Return LabelledEvaluation of Statement with argument labelSet.
        #   2. Else,
        #       a. Return the result of evaluating Statement.
        if isinstance(self.Statement, (P2_Statement_LabelledStatement, P2_Statement_BreakableStatement)):
            return self.Statement.LabelledEvaluation(labelSet)
        return self.Statement.evaluate()


class P2_LabelledItem_FunctionDeclaration(P2_LabelledItem):
    @property
    def FunctionDeclaration(self):
        return self.children[0]

    def EarlyErrors(self):
        # 13.13.1 Static Semantics: Early Errors
        # LabelledItem : FunctionDeclaration
        #   * It is a Syntax Error if any source text matches this rule.
        return [self.CreateSyntaxError("Function declarations should not be labelled")]

    def ContainsDuplicateLabels(self, labelSet):
        # 13.13.2 Static Semantics: ContainsDuplicateLabels
        #   With parameter labelSet.
        # LabelledItem : FunctionDeclaration
        #   1. Return false.
        return False

    def ContainsUndefinedBreakTarget(self, labelSet):
        # 13.13.3 Static Semantics: ContainsUndefinedBreakTarget
        #   With parameter labelSet.
        # LabelledItem : FunctionDeclaration
        #   1. Return false.
        return False

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        # 13.13.4 Static Semantics: ContainsUndefinedContinueTarget
        #   With parameters iterationSet and labelSet.
        # LabelledItem : FunctionDeclaration
        #   1. Return false.
        return False

    def LexicallyDeclaredNames(self):
        # 13.13.6 Static Semantics: LexicallyDeclaredNames
        # LabelledItem : FunctionDeclaration
        #   1. Return BoundNames of FunctionDeclaration.
        return self.FunctionDeclaration.BoundNames()

    def LexicallyScopedDeclarations(self):
        # 13.13.7 Static Semantics: LexicallyScopedDeclarations
        # LabelledItem : FunctionDeclaration
        #   1. Return a new List containing FunctionDeclaration.
        return [self.FunctionDeclaration]

    def TopLevelVarDeclaredNames(self):
        # 13.13.10 Static Semantics: TopLevelVarDeclaredNames
        # LabelledItem : FunctionDeclaration
        #   1. Return BoundNames of FunctionDeclaration.
        return self.FunctionDeclaration.BoundNames()

    def TopLevelVarScopedDeclarations(self):
        # 13.13.11 Static Semantics: TopLevelVarScopedDeclarations
        # LabelledItem : FunctionDeclaration
        #   1. Return a new List containing FunctionDeclaration.
        return [self.FunctionDeclaration]

    def VarDeclaredNames(self):
        # 13.13.12 Static Semantics: VarDeclaredNames
        # LabelledItem : FunctionDeclaration
        #   1. Return a new empty List.
        return []

    def VarScopedDeclarations(self):
        # 13.13.13 Static Semantics: VarScopedDeclarations
        # LabelledItem : FunctionDeclaration
        #   1. Return a new empty List.
        return []

    def LabelledEvaluation(self, labelSet):
        # 13.13.14 Runtime Semantics: LabelledEvaluation
        #   With parameter labelSet.
        # LabelledItem : FunctionDeclaration
        #   1. Return the result of evaluating FunctionDeclaration.
        return self.FunctionDeclaration.evaluate()


def parse_LabelledItem(context, lexer, pos, strict, Yield, Await, Return):
    # 13.13 Labelled Statements
    # Syntax
    #   LabelledItem[Yield, Await, Return] :
    #       Statement[?Yield, ?Await, ?Return]
    #       FunctionDeclaration[?Yield, ?Await, ~Default]
    stmt = parse_Statement(context, lexer, pos, strict, Yield, Await, Return)
    if stmt:
        return P2_LabelledItem_Statement(context, strict, [stmt])
    fd = parse_FunctionDeclaration(context, lexer, pos, strict, Yield, Await, False)
    if fd:
        return P2_LabelledItem_FunctionDeclaration(context, strict, [fd])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888       d8888      88888888888 888
# d8888   d88P  Y88b     d8888      d8P888          888     888
#   888        .d88P       888     d8P 888          888     888
#   888       8888"        888    d8P  888          888     88888b.   .d88b.
#   888        "Y8b.       888   d88   888          888     888 "88b d8P  Y8b
#   888   888    888       888   8888888888         888     888  888 88888888
#   888   Y88b  d88P d8b   888         888          888     888  888 Y8b.
# 8888888  "Y8888P"  Y8P 8888888       888          888     888  888  "Y8888
#
#
#
# 888    888
# 888    888
# 888    888
# 888888 88888b.  888d888  .d88b.  888  888  888
# 888    888 "88b 888P"   d88""88b 888  888  888
# 888    888  888 888     888  888 888  888  888
# Y88b.  888  888 888     Y88..88P Y88b 888 d88P
#  "Y888 888  888 888      "Y88P"   "Y8888888P"
#
#
#
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#
#######################################################################################################################
# 13.14 The throw Statement
# 13.14.1 RS: Evaluation
#######################################################################################################################

##############################################################################
# `·._.·●.._.·●.._.·●..... 13.14 The throw Statement .....●·._..●·._..●·._.·´ #
##############################################################################
# 13.14 The throw Statement

# --------======= 𝓣𝓱𝓻𝓸𝔀𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   ThrowStatement :
#       throw Expression ;


class P2_ThrowStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ThrowStatement", strict, children)


class P2_ThrowStatement_THROW_Expression(P2_ThrowStatement):
    @property
    def Expression(self):
        return self.children[1]

    def evaluate(self):
        # 13.14.1 Runtime Semantics: Evaluation
        # ThrowStatement : throw Expression ;
        #   1. Let exprRef be the result of evaluating Expression.
        #   2. Let exprValue be ? GetValue(exprRef).
        #   3. Return ThrowCompletion(exprValue).
        exprValue = GetValue(self.Expression.evaluate())
        raise ESError(exprValue)


def parse_ThrowStatement(context, lexer, pos, strict, Yield, Await):
    # 13.14 The throw Statement
    # Syntax
    #   ThrowStatement[Yield, Await] :
    #       throw [no LineTerminator here] Expression[+In, ?Yield, ?Await] ;
    throw_tok = lexer.id_if(pos, "throw")
    if throw_tok:
        peek = lexer.token(throw_tok.span.after)
        if peek and not peek.newlines:
            exp = parse_Expression(context, lexer, throw_tok.span.after, strict, True, Yield, Await)
            if exp:
                semi = lexer.token_asi(exp.after)
                if semi:
                    return P2_ThrowStatement_THROW_Expression(context, strict, [throw_tok, exp, semi])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888   888888888      88888888888 888                   888
# d8888   d88P  Y88b     d8888   888                888     888                   888
#   888        .d88P       888   888                888     888                   888
#   888       8888"        888   8888888b.          888     88888b.   .d88b.      888888 888d888 888  888
#   888        "Y8b.       888        "Y88b         888     888 "88b d8P  Y8b     888    888P"   888  888
#   888   888    888       888          888         888     888  888 88888888     888    888     888  888
#   888   Y88b  d88P d8b   888   Y88b  d88P         888     888  888 Y8b.         Y88b.  888     Y88b 888
# 8888888  "Y8888P"  Y8P 8888888  "Y8888P"          888     888  888  "Y8888       "Y888 888      "Y88888
#                                                                                                     888
#                                                                                                Y8b d88P
#                                                                                                 "Y88P"
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#
#######################################################################################################################
# 13.15 The try Statement
# 13.15.1 SS: Early Errors
# 13.15.2 SS: ContainsDuplicateLabels
# 13.15.3 SS: ContainsUndefinedBreakTarget
# 13.15.4 SS: ContainsUndefinedContinueTarget
# 13.15.5 SS: VarDeclaredNames
# 13.15.6 SS: VarScopedDeclarations
# 13.15.7 RS: CatchClauseEvaluation
# 13.15.8 RS: Evaluation
#######################################################################################################################

############################################################################
# `·._.·●.._.·●.._.·●..... 13.15 The try Statement .....●·._..●·._..●·._.·´ #
############################################################################
# 13.15 The try Statement

# --------======= 𝓣𝓻𝔂𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   TryStatement[Yield, Await, Return] :
#       try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
#       try Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
#       try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]


class P2_TryStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "TryStatement", strict, children)


class P2_TryStatement_TRY_Block_Catch(P2_TryStatement):
    @property
    def Block(self):
        return self.children[1]

    @property
    def Catch(self):
        return self.children[2]

    Finally = None

    def ContainsDuplicateLabels(self, labelSet):
        return any(pn.ContainsDuplicateLabels(labelSet) for pn in (self.Block, self.Catch))

    def ContainsUndefinedBreakTarget(self, labelSet):
        return any(pn.ContainsUndefinedBreakTarget(labelSet) for pn in (self.Block, self.Catch))

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        return any(pn.ContainsUndefinedContinueTarget(iterationSet, []) for pn in (self.Block, self.Catch))

    def VarDeclaredNames(self):
        res = []
        for pn in (self.Block, self.Catch):
            res.extend(pn.VarDeclaredNames())
        return res

    def VarScopedDeclarations(self):
        res = []
        for pn in (self.Block, self.Catch):
            res.extend(pn.VarScopedDeclarations())
        return res

    def evaluate(self):
        # 13.15.8 Runtime Semantics: Evaluation
        # TryStatement : try Block Catch
        #   1. Let B be the result of evaluating Block.
        #   2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].
        #   3. Else, let C be B.
        #   4. Return Completion(UpdateEmpty(C, undefined)).
        try:
            C = self.Block.evaluate()
        except ESError as err:
            C = self.Catch.CatchClauseEvaluation(err.ecma_object)
        return UpdateEmpty(C, None)


class P2_TryStatement_TRY_Block_Finally(P2_TryStatement):
    @property
    def Block(self):
        return self.children[1]

    @property
    def Finally(self):
        return self.children[2]

    Catch = None

    def ContainsDuplicateLabels(self, labelSet):
        return any(pn.ContainsDuplicateLabels(labelSet) for pn in (self.Block, self.Finally))

    def ContainsUndefinedBreakTarget(self, labelSet):
        return any(pn.ContainsUndefinedBreakTarget(labelSet) for pn in (self.Block, self.Finally))

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        return any(pn.ContainsUndefinedContinueTarget(iterationSet, []) for pn in (self.Block, self.Finally))

    def VarDeclaredNames(self):
        res = []
        for pn in (self.Block, self.Finally):
            res.extend(pn.VarDeclaredNames())
        return res

    def VarScopedDeclarations(self):
        res = []
        for pn in (self.Block, self.Finally):
            res.extend(pn.VarScopedDeclarations())
        return res

    def evaluate(self):
        # 13.15.8 Runtime Semantics: Evaluation
        # TryStatement : try Block Finally
        #   1. Let B be the result of evaluating Block.
        #   2. Let F be the result of evaluating Finally.
        #   3. If F.[[Type]] is normal, set F to B.
        #   4. Return Completion(UpdateEmpty(F, undefined)).
        try:
            B = self.Block.evaluate()
        finally:
            self.Finally.evaluate()
        return UpdateEmpty(B, None)


class P2_TryStatement_TRY_Block_Catch_Finally(P2_TryStatement):
    @property
    def Block(self):
        return self.children[1]

    @property
    def Catch(self):
        return self.children[2]

    @property
    def Finally(self):
        return self.children[3]

    def ContainsDuplicateLabels(self, labelSet):
        return any(pn.ContainsDuplicateLabels(labelSet) for pn in (self.Block, self.Catch, self.Finally))

    def ContainsUndefinedBreakTarget(self, labelSet):
        return any(pn.ContainsUndefinedBreakTarget(labelSet) for pn in (self.Block, self.Catch, self.Finally))

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        return any(
            pn.ContainsUndefinedContinueTarget(iterationSet, []) for pn in (self.Block, self.Catch, self.Finally)
        )

    def VarDeclaredNames(self):
        res = []
        for pn in (self.Block, self.Catch, self.Finally):
            res.extend(pn.VarDeclaredNames())
        return res

    def VarScopedDeclarations(self):
        res = []
        for pn in (self.Block, self.Catch, self.Finally):
            res.extend(pn.VarScopedDeclarations())
        return res

    def evaluate(self):
        # 13.15.8 Runtime Semantics: Evaluation
        # TryStatement : try Block Catch Finally
        #   1. Let B be the result of evaluating Block.
        #   2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].
        #   3. Else, let C be B.
        #   4. Let F be the result of evaluating Finally.
        #   5. If F.[[Type]] is normal, set F to C.
        #   6. Return Completion(UpdateEmpty(F, undefined)).
        try:
            C = self.Block.evaluate()
        except ESError as err:
            C = self.Catch.CatchClauseEvaluation(err.ecma_object)
        finally:
            self.Finally.evaluate()
        return UpdateEmpty(C, None)


def parse_TryStatement(context, lexer, pos, strict, Yield, Await, Return):
    # 13.15 The try Statement
    # Syntax
    #   TryStatement[Yield, Await, Return] :
    #       try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
    #       try Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
    #       try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
    try_token = lexer.id_if(pos, "try")
    if try_token:
        block = parse_Block(context, lexer, try_token.span.after, strict, Yield, Await, Return)
        if block:
            catch = parse_Catch(context, lexer, block.after, strict, Yield, Await, Return)
            catch_after = catch.after if catch else block.after
            fin = parse_Finally(context, lexer, catch_after, strict, Yield, Await, Return)
            if catch and fin:
                return P2_TryStatement_TRY_Block_Catch_Finally(context, strict, [try_token, block, catch, fin])
            if catch:
                return P2_TryStatement_TRY_Block_Catch(context, strict, [try_token, block, catch])
            if fin:
                return P2_TryStatement_TRY_Block_Finally(context, strict, [try_token, block, fin])
    return None


# --------======= 𝓒𝓪𝓽𝓬𝓱 =======--------
# Syntax
#   Catch :
#       catch ( CatchParameter ) Block
#       catch Block


class P2_Catch(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Catch", strict, children)


class P2_Catch_CATCH_CatchParameter_Block(P2_Catch):
    @property
    def CatchParameter(self):
        return self.children[2]

    @property
    def Block(self):
        return self.children[4]

    def EarlyErrors(self):
        # 13.15.1 Static Semantics: Early Errors
        # Catch : catch ( CatchParameter ) Block
        #   * It is a Syntax Error if BoundNames of CatchParameter contains any duplicate elements.
        #   * It is a Syntax Error if any element of the BoundNames of CatchParameter also occurs in the
        #     LexicallyDeclaredNames of Block.
        #   * It is a Syntax Error if any element of the BoundNames of CatchParameter also occurs in the
        #     VarDeclaredNames of Block.
        errs = []
        bn = self.CatchParameter.BoundNames()
        duplicates = [name for name, count in Counter(bn).items() if count > 1]
        if duplicates:
            errs.append(CreateSyntaxError(f"Multiple definitions in parameter list: {', '.join(duplicates)}"))
        common = set(bn).intersection(set(self.Block.LexicallyDeclaredNames()))
        if common:
            errs.append(CreateSyntaxError(f"Parameters duplicated in lexical declarations: {', '.join(common)}"))
        common = set(bn).intersection(set(self.Block.VarDeclaredNames()))
        if common:
            errs.append(CreateSyntaxError(f"Parameters duplicated in var declarations: {', '.join(common)}"))
        return errs

    def ContainsDuplicateLabels(self, labelSet):
        return self.Block.ContainsDuplicateLabels(labelSet)

    def ContainsUndefinedBreakTarget(self, labelSet):
        return self.Block.ContainsUndefinedBreakTarget(labelSet)

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        return self.Block.ContainsUndefinedContinueTarget(iterationSet, [])

    def VarDeclaredNames(self):
        return self.Block.VarDeclaredNames()

    def VarScopedDeclarations(self):
        return self.Block.VarScopedDeclarations()

    def CatchClauseEvaluation(self, thrownValue):
        # 13.15.7 Runtime Semantics: CatchClauseEvaluation
        #   With parameter thrownValue.
        # Catch : catch ( CatchParameter ) Block
        #   1. Let oldEnv be the running execution context's LexicalEnvironment.
        #   2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).
        #   3. Let catchEnvRec be catchEnv's EnvironmentRecord.
        #   4. For each element argName of the BoundNames of CatchParameter, do
        #       a. Perform ! catchEnvRec.CreateMutableBinding(argName, false).
        #   5. Set the running execution context's LexicalEnvironment to catchEnv.
        #   6. Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.
        #   7. If status is an abrupt completion, then
        #       a. Set the running execution context's LexicalEnvironment to oldEnv.
        #       b. Return Completion(status).
        #   8. Let B be the result of evaluating Block.
        #   9. Set the running execution context's LexicalEnvironment to oldEnv.
        #   10. Return Completion(B).
        # NOTE
        # No matter how control leaves the Block the LexicalEnvironment is always restored to its former state.
        oldEnv = surrounding_agent.running_ec.lexical_environment
        catchEnv = NewDeclarativeEnvironment(oldEnv)
        catchEnvRec = catchEnv.environment_record
        for argName in self.CatchParameter.BoundNames():
            catchEnvRec.CreateMutableBinding(argName, False)
        surrounding_agent.running_ec.lexical_environment = catchEnv
        try:
            self.CatchParameter.BindingInitialization(thrownValue, catchEnv)
            return self.Block.evaluate()
        finally:
            surrounding_agent.running_ec.lexical_environment = oldEnv


class P2_Catch_CATCH_Block(P2_Catch):
    @property
    def Block(self):
        return self.children[1]

    CatchParameter = None


def parse_Catch(context, lexer, pos, strict, Yield, Await, Return):
    # 13.15 The try Statement
    # Syntax
    #   Catch[Yield, Await, Return] :
    #       catch ( CatchParameter[?Yield, ?Await] ) Block[?Yield, ?Await, ?Return]
    #       catch Block[?Yield, ?Await, ?Return]
    catch = lexer.id_if(pos, "catch")
    if catch:
        after_catch = catch.span.after
        lp = lexer.token_if(after_catch, "(")
        if lp:
            cp = parse_CatchParameter(context, lexer, lp.span.after, strict, Yield, Await)
            if cp:
                rp = lexer.token_if(cp.after, ")")
                if rp:
                    block = parse_Block(context, lexer, rp.span.after, strict, Yield, Await, Return)
                    if block:
                        return P2_Catch_CATCH_CatchParameter_Block(context, strict, [catch, lp, cp, rp, block])
        block2 = parse_Block(context, lexer, after_catch, strict, Yield, Await, Return)
        if block2:
            return P2_Catch_CATCH_Block(context, strict, [catch, block2])
    return None


# --------======= 𝓕𝓲𝓷𝓪𝓵𝓵𝔂 =======--------
# Syntax
#   Finally :
#       finally Block


class P2_Finally(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Finally", strict, children)


class P2_Finally_FINALLY_Block(P2_Finally):
    @property
    def Block(self):
        return self.children[1]


def parse_Finally(context, lexer, pos, strict, Yield, Await, Return):
    # 13.15 The try Statement
    #   Finally[Yield, Await, Return] :
    #       finally Block[?Yield, ?Await, ?Return]
    finally_tok = lexer.id_if(pos, "finally")
    if finally_tok:
        block = parse_Block(context, lexer, finally_tok.span.after, strict, Yield, Await, Return)
        if block:
            return P2_Finally_FINALLY_Block(context, strict, [finally_tok, block])
    return None


# --------======= 𝓒𝓪𝓽𝓬𝓱𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻 =======--------
# Syntax
#   CatchParameter :
#       BindingIdentifier
#       BindingPattern


class P2_CatchParameter(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CatchParameter", strict, children)


class P2_CatchParameter_BindingIdentifier(P2_CatchParameter):
    @property
    def BindingIdentifier(self):
        return self.children[0]


class P2_CatchParameter_BindingPattern(P2_CatchParameter):
    @property
    def BindingPattern(self):
        return self.children[0]


def parse_CatchParameter(context, lexer, pos, strict, Yield, Await):
    # 13.15 The try Statement
    # Syntax
    #   CatchParameter[Yield, Await] :
    #       BindingIdentifier[?Yield, ?Await]
    #       BindingPattern[?Yield, ?Await]
    bi = parse_BindingIdentifier(context, lexer, pos, strict, Yield, Await)
    if bi:
        return P2_CatchParameter_BindingIdentifier(context, strict, [bi])
    bp = parse_BindingPattern(context, lexer, pos, strict, Yield, Await)
    if bp:
        return P2_CatchParameter_BindingPattern(context, strict, [bp])
    return None


#######################################################################################################################
#
#  d888    .d8888b.       d888    .d8888b.      88888888888 888
# d8888   d88P  Y88b     d8888   d88P  Y88b         888     888
#   888        .d88P       888   888                888     888
#   888       8888"        888   888d888b.          888     88888b.   .d88b.
#   888        "Y8b.       888   888P "Y88b         888     888 "88b d8P  Y8b
#   888   888    888       888   888    888         888     888  888 88888888
#   888   Y88b  d88P d8b   888   Y88b  d88P         888     888  888 Y8b.
# 8888888  "Y8888P"  Y8P 8888888  "Y8888P"          888     888  888  "Y8888
#
#
#
#      888          888
#      888          888
#      888          888
#  .d88888  .d88b.  88888b.  888  888  .d88b.   .d88b.   .d88b.  888d888
# d88" 888 d8P  Y8b 888 "88b 888  888 d88P"88b d88P"88b d8P  Y8b 888P"
# 888  888 88888888 888  888 888  888 888  888 888  888 88888888 888
# Y88b 888 Y8b.     888 d88P Y88b 888 Y88b 888 Y88b 888 Y8b.     888
#  "Y88888  "Y8888  88888P"   "Y88888  "Y88888  "Y88888  "Y8888  888
#                                          888      888
#                                     Y8b d88P Y8b d88P
#                                      "Y88P"   "Y88P"
#  .d8888b.  888             888                                             888
# d88P  Y88b 888             888                                             888
# Y88b.      888             888                                             888
#  "Y888b.   888888  8888b.  888888  .d88b.  88888b.d88b.   .d88b.  88888b.  888888
#     "Y88b. 888        "88b 888    d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
#       "888 888    .d888888 888    88888888 888  888  888 88888888 888  888 888
# Y88b  d88P Y88b.  888  888 Y88b.  Y8b.     888  888  888 Y8b.     888  888 Y88b.
#  "Y8888P"   "Y888 "Y888888  "Y888  "Y8888  888  888  888  "Y8888  888  888  "Y888
#
#
#
#
#######################################################################################################################
# 13.16 The debugger Statement
# 13.16.1 RS: Evaluation
#######################################################################################################################

#################################################################################
# `·._.·●.._.·●.._.·●..... 13.16 The debugger Statement .....●·._..●·._..●·._.·´ #
#################################################################################
# 13.16 The debugger Statement

# --------======= 𝓓𝓮𝓫𝓾𝓰𝓰𝓮𝓻𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽 =======--------
# Syntax
#   DebuggerStatement :
#       debugger ;


class P2_DebuggerStatement(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "DebuggerStatement", strict, children)


class P2_DebuggerStatement_DEBUGGER(P2_DebuggerStatement):
    pass


def parse_DebuggerStatement(context, lexer, pos, strict):
    # 13.16 The debugger Statement
    # Syntax
    #   DebuggerStatement :
    #       debugger ;
    deb = lexer.id_if(pos, "debugger")
    if deb:
        semi = lexer.token_asi(deb.span.after)
        if semi:
            return P2_DebuggerStatement_DEBUGGER(context, strict, [deb, semi])
    return None


#######################################################################################################################
#
#  d888       d8888       d888       8888888888                            888    d8b
# d8888      d8P888      d8888       888                                   888    Y8P
#   888     d8P 888        888       888                                   888
#   888    d8P  888        888       8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.
#   888   d88   888        888       888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b
#   888   8888888888       888       888        888  888 888  888 888      888    888 888  888 888  888
#   888         888  d8b   888       888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888
# 8888888       888  Y8P 8888888     888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888
#
#
#
# 8888888b.            .d888 d8b          d8b 888    d8b
# 888  "Y88b          d88P"  Y8P          Y8P 888    Y8P
# 888    888          888                     888
# 888    888  .d88b.  888888 888 88888b.  888 888888 888  .d88b.  88888b.  .d8888b
# 888    888 d8P  Y8b 888    888 888 "88b 888 888    888 d88""88b 888 "88b 88K
# 888    888 88888888 888    888 888  888 888 888    888 888  888 888  888 "Y8888b.
# 888  .d88P Y8b.     888    888 888  888 888 Y88b.  888 Y88..88P 888  888      X88
# 8888888P"   "Y8888  888    888 888  888 888  "Y888 888  "Y88P"  888  888  88888P'
#
#
#
#
#######################################################################################################################
# 14.1 Function Definitions
# 14.1.1 Directive Prologues and the Use Strict Directive
# 14.1.2 SS: Early Errors
# 14.1.3 SS: BoundNames
# 14.1.4 SS: Contains
# 14.1.5 SS: ContainsExpression
# 14.1.6 SS: ContainsUseStrict
# 14.1.7 SS: ExpectedArgumentCount
# 14.1.8 SS: HasInitializer
# 14.1.9 SS: HasName
# 14.1.10 SS: IsAnonymousFunctionDefinition ( expr )
# 14.1.11 SS: IsConstantDeclaration
# 14.1.12 SS: IsFunctionDefinition
# 14.1.13 SS: IsSimpleParameterList
# 14.1.14 SS: LexicallyDeclaredNames
# 14.1.15 SS: LexicallyScopedDeclarations
# 14.1.16 SS: VarDeclaredNames
# 14.1.17 SS: VarScopedDeclarations
# 14.1.18 RS: EvaluateBody
# 14.1.19 RS: IteratorBindingInitialization
# 14.1.20 RS: InstantiateFunctionObject
# 14.1.21 RS: NamedEvaluation
# 14.1.22 RS: Evaluation
#######################################################################################################################

###############################################################################
# `·._.·●.._.·●.._.·●..... 14.1 Function Definitions .....●·._..●·._..●·._.·´ #
###############################################################################
# 14.1 Function Definitions

# --------======= 𝓕𝓾𝓷𝓬𝓽𝓲𝓸𝓷𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   FunctionDeclaration :
#       function BindingIdentifier ( FormalParameters ) { FunctionBody }
#       function ( FormalParameters ) { FunctionBody }


class P2_FunctionDeclaration(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FunctionDeclaration", strict, children)

    contains_unenclosed_continue = False
    contains_unenclosed_break = False


def FunctionDecl_EarlyErrors(pn):
    # 14.1.2 Static Semantics: Early Errors
    # FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
    # FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
    # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
    #   * If the source code matching this production is strict mode code, the Early Error rules for
    #     UniqueFormalParameters:FormalParameters are applied.
    #   * If the source code matching this production is strict mode code, it is a Syntax Error if BindingIdentifier is
    #     present and the StringValue of BindingIdentifier is "eval" or "arguments".
    #   * It is a Syntax Error if ContainsUseStrict of FunctionBody is true and IsSimpleParameterList of
    #     FormalParameters is false.
    #   * It is a Syntax Error if any element of the BoundNames of FormalParameters also occurs in the
    #     LexicallyDeclaredNames of FunctionBody.
    #   * It is a Syntax Error if FormalParameters Contains SuperProperty is true.
    #   * It is a Syntax Error if FunctionBody Contains SuperProperty is true.
    #   * It is a Syntax Error if FormalParameters Contains SuperCall is true.
    #   * It is a Syntax Error if FunctionBody Contains SuperCall is true.
    # NOTE 1
    # The LexicallyDeclaredNames of a FunctionBody does not include identifiers bound using var or function
    # declarations.
    errs = []
    if pn.strict:
        errs.extend(UniqueFormalParameters_EarlyErrors(pn.FormalParameters))
        if pn.BindingIdentifier and pn.BindingIdentifier.StringValue in ["eval", "arguments"]:
            errs.append(
                pn.CreateSyntaxError(
                    f"Redefining '{pn.BindingIdentifier.StringValue}' is not allowed in strict mode"
                )
            )
    if pn.FunctionBody.ContainsUseStrict() and not pn.FormalParameters.IsSimpleParameterList():
        errs.append(pn.CreateSyntaxError("Parameters must be simple for strict mode functions"))
    param_names = set(pn.FormalParameters.BoundNames())
    body_names = set(pn.FunctionBody.LexicallyDeclaredNames())
    duplicated_names = param_names.intersection(body_names)
    if duplicated_names:
        errs.append(
            pn.CreateSyntaxError(
                f'Lexical declarations in the function body must be different than parameter names ({", ".join(duplicated_names)})'
            )
        )
    if pn.FormalParameters.Contains("SuperProperty") or pn.FunctionBody.Contains("SuperProperty"):
        errs.append(pn.CreateSyntaxError("Super properties not allowed in functions"))
    if pn.FormalParameters.Contains("SuperCall") or pn.FunctionBody.Contains("SuperCall"):
        errs.append(pn.CreateSyntaxError("Super calls not allowed in functions"))
    return errs


class P2_FunctionDeclaration_FUNCTION_BindingIdentifier_FormalParameters_FunctionBody(P2_FunctionDeclaration):
    @property
    def BindingIdentifier(self):
        return self.children[1]

    @property
    def FormalParameters(self):
        return self.children[3]

    @property
    def FunctionBody(self):
        return self.children[6]

    @cached_property
    def contains_encapsulated_unenclosed_break(self):
        return self.FunctionBody.contains_unenclosed_break or super().contains_encapsulated_unenclosed_break

    @cached_property
    def contains_encapsulated_unenclosed_continue(self):
        return self.FunctionBody.contains_unenclosed_continue or super().contains_encapsulated_unenclosed_continue

    def EarlyErrors(self):
        return FunctionDecl_EarlyErrors(self)

    def BoundNames(self):
        # 14.1.3 Static Semantics: BoundNames
        # FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return the BoundNames of BindingIdentifier.
        return self.BindingIdentifier.BoundNames()

    def Contains(self, symbol):
        # 14.1.4 Static Semantics: Contains
        #   With parameter symbol.
        # FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        # NOTE
        # Static semantic rules that depend upon substructure generally do not look into function definitions.
        return False

    def HasName(self):
        # 14.1.9 Static Semantics: HasName
        # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return true.
        return True

    def IsConstantDeclaration(self):
        # 14.1.11 Static Semantics: IsConstantDeclaration
        # FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        return False

    def InstantiateFunctionObject(self, scope):
        # 14.1.20 Runtime Semantics: InstantiateFunctionObject
        #   With parameter scope.
        # FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. If the function code for FunctionDeclaration is strict mode code, let strict be true. Otherwise let strict be false.
        #   2. Let name be StringValue of BindingIdentifier.
        #   3. Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).
        #   4. Perform MakeConstructor(F).
        #   5. Perform SetFunctionName(F, name).
        #   6. Set F.[[SourceText]] to the source text matched by FunctionDeclaration.
        #   7. Return F.
        name = self.BindingIdentifier.StringValue
        F = FunctionCreate(NORMAL, self.FormalParameters, self.FunctionBody, scope, self.strict)
        MakeConstructor(F)
        SetFunctionName(F, name)
        F.SourceText = self.matched_source()
        return F

    def evaluate(self):
        # 14.1.22 Runtime Semantics: Evaluation
        # FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return NormalCompletion(empty).
        return EMPTY

    def AssignStrictitude(self):
        if self.FunctionBody.ContainsUseStrict():
            self.set_strict_in_subtree()


class P2_FunctionDeclaration_FUNCTION_FormalParameters_FunctionBody(P2_FunctionDeclaration):
    @property
    def FormalParameters(self):
        return self.children[2]

    @property
    def FunctionBody(self):
        return self.children[5]

    def EarlyErrors(self):
        return FunctionDecl_EarlyErrors(self)

    def BoundNames(self):
        # 14.1.3 Static Semantics: BoundNames
        # FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
        #   1. Return « "*default*" ».
        # NOTE  | "*default*" is used within this specification as a synthetic name for hoistable anonymous functions
        #       | that are defined using export declarations.
        return ["*default*"]

    def Contains(self, symbol):
        # 14.1.4 Static Semantics: Contains
        #   With parameter symbol.
        # FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        # NOTE
        # Static semantic rules that depend upon substructure generally do not look into function definitions.
        return False

    def HasName(self):
        # 14.1.9 Static Semantics: HasName
        # FunctionExpression : function ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        return False

    def IsConstantDeclaration(self):
        # 14.1.11 Static Semantics: IsConstantDeclaration
        # FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        return False

    @cached_property
    def contains_encapsulated_unenclosed_break(self):
        return self.FunctionBody.contains_unenclosed_break or super().contains_encapsulated_unenclosed_break

    @cached_property
    def contains_encapsulated_unenclosed_continue(self):
        return self.FunctionBody.contains_unenclosed_continue or super().contains_encapsulated_unenclosed_continue

    def InstantiateFunctionObject(self, scope):
        # 14.1.20 Runtime Semantics: InstantiateFunctionObject
        #   With parameter scope.
        # FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
        #   1. Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, true).
        #   2. Perform MakeConstructor(F).
        #   3. Perform SetFunctionName(F, "default").
        #   4. Set F.[[SourceText]] to the source text matched by FunctionDeclaration.
        #   5. Return F.
        # NOTE  | An anonymous FunctionDeclaration can only occur as part of an export default declaration, and its
        #       | function code is therefore always strict mode code.
        F = FunctionCreate(NORMAL, self.FormalParameters, self.FunctionBody, scope, True)
        MakeConstructor(F)
        SetFunctionName(F, "default")
        F.SourceText = self.matched_source()
        return F

    def evaluate(self):
        # 14.1.22 Runtime Semantics: Evaluation
        # FunctionDeclaration : function ( FormalParameters ) { FunctionBody }
        #   1. Return NormalCompletion(empty).
        return EMPTY


def parse_FunctionDeclaration(context, lexer, pos, strict, Yield, Await, Default):
    # 14.1 Function Definitions
    # Syntax
    #   FunctionDeclaration[Yield, Await, Default] :
    #       function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
    #       [+Default] function ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
    function = lexer.id_if(pos, "function")
    if function:
        bi = parse_BindingIdentifier(context, lexer, function.span.after, strict, Yield, Await)
        if bi or Default:
            lp = lexer.token_if(bi.after if bi else function.span.after, "(")
            if lp:
                fp = parse_FormalParameters(context, lexer, lp.span.after, strict, False, False)
                if fp:
                    rp = lexer.token_if(fp.after, ")")
                    if rp:
                        lc = lexer.token_if(rp.span.after, "{")
                        if lc:
                            body = parse_FunctionBody(context, lexer, lc.span.after, strict, False, False)
                            if body:
                                rc = lexer.token_if(body.after, "}")
                                if rc:
                                    if bi:
                                        return P2_FunctionDeclaration_FUNCTION_BindingIdentifier_FormalParameters_FunctionBody(
                                            context, body.strict, [function, bi, lp, fp, rp, lc, body, rc]
                                        )
                                    return P2_FunctionDeclaration_FUNCTION_FormalParameters_FunctionBody(
                                        context, body.strict, [function, lp, fp, rp, lc, body, rc]
                                    )
    return None


# --------======= 𝓕𝓾𝓷𝓬𝓽𝓲𝓸𝓷𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   FunctionExpression :
#       function BindingIdentifier ( FormalParameters ) { FunctionBody }
#       function ( FormalParameters ) { FunctionBody }


class P2_FunctionExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FunctionExpression", strict, children)

    @property
    def FunctionBody(self):
        raise NotImplementedError("Abstract classes should not be instantiated.")

    def AssignStrictitude(self):
        if self.FunctionBody.ContainsUseStrict():
            self.set_strict_in_subtree()

    contains_unenclosed_break = False
    contains_unenclosed_continue = False


class P2_FunctionExpression_FUNCTION_BindingIdentifier_FormalParameters_FunctionBody(P2_FunctionExpression):
    @property
    def BindingIdentifier(self):
        return self.children[1]

    @property
    def FormalParameters(self):
        return self.children[3]

    @property
    def FunctionBody(self):
        return self.children[6]

    def EarlyErrors(self):
        return FunctionDecl_EarlyErrors(self)

    def Contains(self, symbol):
        # 14.1.4 Static Semantics: Contains
        #   With parameter symbol.
        # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        # NOTE
        # Static semantic rules that depend upon substructure generally do not look into function definitions.
        return False

    def HasName(self):
        # 14.1.9 Static Semantics: HasName
        # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return true.
        return True

    def IsFunctionDefinition(self):
        # 14.1.12 Static Semantics: IsFunctionDefinition
        # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return true.
        return True

    @cached_property
    def contains_encapsulated_unenclosed_break(self):
        return self.FunctionBody.contains_unenclosed_break or super().contains_encapsulated_unenclosed_break

    @cached_property
    def contains_encapsulated_unenclosed_continue(self):
        return self.FunctionBody.contains_unenclosed_continue or super().contains_encapsulated_unenclosed_continue

    def evaluate(self):
        # 14.1.22 Runtime Semantics: Evaluation
        # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let
        #      strict be false.
        #   2. Let scope be the running execution context's LexicalEnvironment.
        #   3. Let funcEnv be NewDeclarativeEnvironment(scope).
        #   4. Let envRec be funcEnv's EnvironmentRecord.
        #   5. Let name be StringValue of BindingIdentifier.
        #   6. Perform envRec.CreateImmutableBinding(name, false).
        #   7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).
        #   8. Perform MakeConstructor(closure).
        #   9. Perform SetFunctionName(closure, name).
        #   10. Set closure.[[SourceText]] to the source text matched by FunctionExpression.
        #   11. Perform envRec.InitializeBinding(name, closure).
        #   12. Return closure.
        #
        # NOTE 2
        # The BindingIdentifier in a FunctionExpression can be referenced from inside the FunctionExpression's
        # FunctionBody to allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the
        # BindingIdentifier in a FunctionExpression cannot be referenced from and does not affect the scope enclosing
        # the FunctionExpression.
        #
        # NOTE 3
        # A prototype property is automatically created for every function defined using a FunctionDeclaration or
        # FunctionExpression, to allow for the possibility that the function will be used as a constructor.
        strict = self.strict
        scope = surrounding_agent.running_ec.lexical_environment
        funcEnv = NewDeclarativeEnvironment(scope)
        envRec = funcEnv.environment_record
        name = self.BindingIdentifier.StringValue
        envRec.CreateImmutableBinding(name, False)
        closure = FunctionCreate(NORMAL, self.FormalParameters, self.FunctionBody, funcEnv, strict)
        MakeConstructor(closure)
        SetFunctionName(closure, name)
        closure.SourceText = self.matched_source()
        envRec.InitializeBinding(name, closure)
        return closure


class P2_FunctionExpression_FUNCTION_FormalParameters_FunctionBody(P2_FunctionExpression):
    @property
    def FormalParameters(self):
        return self.children[2]

    @property
    def FunctionBody(self):
        return self.children[5]

    BindingIdentifier = None

    def EarlyErrors(self):
        return FunctionDecl_EarlyErrors(self)

    def Contains(self, symbol):
        # 14.1.4 Static Semantics: Contains
        #   With parameter symbol.
        # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        # NOTE
        # Static semantic rules that depend upon substructure generally do not look into function definitions.
        return False

    def HasName(self):
        # 14.1.9 Static Semantics: HasName
        # FunctionExpression : function ( FormalParameters ) { FunctionBody }
        #   1. Return false.
        return False

    def IsFunctionDefinition(self):
        # 14.1.12 Static Semantics: IsFunctionDefinition
        # FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody }
        #   1. Return true.
        return True

    @cached_property
    def contains_encapsulated_unenclosed_break(self):
        return self.FunctionBody.contains_unenclosed_break or super().contains_encapsulated_unenclosed_break

    @cached_property
    def contains_encapsulated_unenclosed_continue(self):
        return self.FunctionBody.contains_unenclosed_continue or super().contains_encapsulated_unenclosed_continue

    def NamedEvaluation(self, name):
        # 14.1.21 Runtime Semantics: NamedEvaluation
        #   With parameter name.
        # FunctionExpression : function ( FormalParameters ) { FunctionBody }
        #   1. Let closure be the result of evaluating this FunctionExpression.
        #   2. Perform SetFunctionName(closure, name).
        #   3. Return closure.
        closure = self.evaluate()
        SetFunctionName(closure, name)
        return closure

    def evaluate(self):
        # 14.1.22 Runtime Semantics: Evaluation
        # FunctionExpression : function ( FormalParameters ) { FunctionBody }
        #   1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
        #   2. Let scope be the LexicalEnvironment of the running execution context.
        #   3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).
        #   4. Perform MakeConstructor(closure).
        #   5. Set closure.[[SourceText]] to the source text matched by FunctionExpression.
        #   6. Return closure.
        strict = self.strict
        scope = surrounding_agent.running_ec.lexical_environment
        closure = FunctionCreate(NORMAL, self.FormalParameters, self.FunctionBody, scope, strict)
        MakeConstructor(closure)
        closure.SourceText = self.matched_source()
        return closure


def parse_FunctionExpression(context, lexer, pos, strict):
    # 14.1 Function Definitions
    # Syntax
    #   FunctionExpression :
    #       function BindingIdentifier[~Yield, ~Await] ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
    #       function ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
    function = lexer.id_if(pos, "function")
    if function:
        bi = parse_BindingIdentifier(context, lexer, function.span.after, strict, False, False)
        lp = lexer.token_if(bi.after if bi else function.span.after, "(")
        if lp:
            fp = parse_FormalParameters(context, lexer, lp.span.after, strict, False, False)
            if fp:
                rp = lexer.token_if(fp.after, ")")
                if rp:
                    lc = lexer.token_if(rp.span.after, "{")
                    if lc:
                        body = parse_FunctionBody(context, lexer, lc.span.after, strict, False, False)
                        if body:
                            rc = lexer.token_if(body.after, "}")
                            if rc:
                                if bi:
                                    return P2_FunctionExpression_FUNCTION_BindingIdentifier_FormalParameters_FunctionBody(
                                        context, body.strict, [function, bi, lp, fp, rp, lc, body, rc]
                                    )
                                return P2_FunctionExpression_FUNCTION_FormalParameters_FunctionBody(
                                    context, body.strict, [function, lp, fp, rp, lc, body, rc]
                                )
    return None


# --------======= 𝓤𝓷𝓲𝓺𝓾𝓮𝓕𝓸𝓻𝓶𝓪𝓵𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼 =======--------
# Syntax
#   UniqueFormalParameters :
#       FormalParameters


class P2_UniqueFormalParameters(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "UniqueFormalParameters", strict, children)


class P2_UniqueFormalParameters_FormalParameters(P2_UniqueFormalParameters):
    @property
    def FormalParameters(self):
        return self.children[0]

    def EarlyErrors(self):
        return UniqueFormalParameters_EarlyErrors(self.FormalParameters)


def UniqueFormalParameters_EarlyErrors(pn):
    # 14.1.2 Static Semantics: Early Errors
    # UniqueFormalParameters : FormalParameters
    #   * It is a Syntax Error if BoundNames of FormalParameters contains any duplicate elements.
    bn = pn.BoundNames()
    duplicates = [name for name, count in Counter(bn).items() if count > 1]
    if duplicates:
        return [CreateSyntaxError(f"Multiple definitions in parameter list: {', '.join(duplicates)}")]
    return []


def parse_UniqueFormalParameters(context, lexer, pos, strict, Yield, Await):
    # 14.1 Function Definitions
    # Syntax
    #   UniqueFormalParameters[Yield, Await] :
    #       FormalParameters[?Yield, ?Await]
    fp = parse_FormalParameters(context, lexer, pos, strict, Yield, Await)
    if fp:
        return P2_UniqueFormalParameters_FormalParameters(context, strict, [fp])
    return None


# --------======= 𝓕𝓸𝓻𝓶𝓪𝓵𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼 =======--------
# Syntax
#   FormalParameters :
#       [empty]
#       FunctionRestParameter
#       FormalParameterList
#       FormalParameterList ,
#       FormalParameterList , FunctionRestParameter


class P2_FormalParameters(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FormalParameters", strict, children)


class P2_FormalParameters_EMPTY(P2_FormalParameters):
    def __init__(self, ctx, pos, strict):
        super().__init__(ctx, strict, [])
        self.after = pos

    FormalParameterList = None
    FunctionRestParameter = None

    def BoundNames(self):
        # 14.1.3 Static Semantics: BoundNames
        # FormalParameters : [empty]
        #   1. Return a new empty List.
        return []

    def ContainsExpression(self):
        # 14.1.5 Static Semantics: ContainsExpression
        # FormalParameters : [empty]
        #   1. Return false.
        return False

    def ExpectedArgumentCount(self):
        # 14.1.7 Static Semantics: ExpectedArgumentCount
        # FormalParameters : [empty]
        #   1. Return 0.
        return 0

    def IsSimpleParameterList(self):
        # 14.1.13 Static Semantics: IsSimpleParameterList
        # FormalParameters : [empty]
        #   1. Return true.
        return True

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 14.1.19 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # FormalParameters : [empty]
        #   1. Return NormalCompletion(empty).
        return EMPTY


class P2_FormalParameters_FunctionRestParameter(P2_FormalParameters):
    @property
    def FunctionRestParameter(self):
        return self.children[0]

    FormalParameterList = None

    def ExpectedArgumentCount(self):
        return 0

    def IsSimpleParameterList(self):
        return False


class P2_FormalParameters_FormalParameterList(P2_FormalParameters):
    @property
    def FormalParameterList(self):
        return self.children[0]

    FunctionRestParameter = None

    def EarlyErrors(self):
        # 14.1.2 Static Semantics: Early Errors
        # FormalParameters : FormalParameterList
        #   * It is a Syntax Error if IsSimpleParameterList of FormalParameterList is false and BoundNames of
        #     FormalParameterList contains any duplicate elements.
        # NOTE 2
        # Multiple occurrences of the same BindingIdentifier in a FormalParameterList is only allowed for functions
        # which have simple parameter lists and which are not defined in strict mode code.
        if not self.FormalParameterList.IsSimpleParameterList():
            duplicates = [
                name for name, count in Counter(self.FormalParameterList.BoundNames()).items() if count > 1
            ]
            if duplicates:
                return [CreateSyntaxError(f"Multiple definitions in parameter list: {', '.join(duplicates)}")]
        return []
        # One wonders if this is sufficient. What about the COMMA production? The "rest" productions?


class P2_FormalParameters_FormalParameterList_FunctionRestParameter(P2_FormalParameters):
    @property
    def FormalParameterList(self):
        return self.children[0]

    @property
    def FunctionRestParameter(self):
        return self.children[2]

    def BoundNames(self):
        # FormalParameters : FormalParameterList , FunctionRestParameter
        #   1. Let names be BoundNames of FormalParameterList.
        #   2. Append to names the BoundNames of FunctionRestParameter.
        #   3. Return names.
        names = self.FormalParameterList.BoundNames()
        names.extend(self.FunctionRestParameter.BoundNames())
        return names

    def ContainsExpression(self):
        # 14.1.5 Static Semantics: ContainsExpression
        # FormalParameters : FormalParameterList , FunctionRestParameter
        #   1. If ContainsExpression of FormalParameterList is true, return true.
        #   2. Return ContainsExpression of FunctionRestParameter.
        return self.FormalParameterList.ContainsExpression() or self.FunctionRestParameter.ContainsExpression()

    def ExpectedArgumentCount(self):
        # 14.1.7 Static Semantics: ExpectedArgumentCount
        # FormalParameters:FormalParameterList,FunctionRestParameter
        #   1. Return ExpectedArgumentCount of FormalParameterList.
        # NOTE
        # The ExpectedArgumentCount of a FormalParameterList is the number of FormalParameters to the left of either
        # the rest parameter or the first FormalParameter with an Initializer. A FormalParameter without an initializer
        # is allowed after the first parameter with an initializer but such parameters are considered to be optional
        # with undefined as their default value.
        return self.FormalParameterList.ExpectedArgumentCount()

    def IsSimpleParameterList(self):
        # 14.1.13 Static Semantics: IsSimpleParameterList
        # FormalParameters : FormalParameterList , FunctionRestParameter
        #   1. Return false.
        return False

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 14.1.19Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # FormalParameters : FormalParameterList , FunctionRestParameter
        #   1. Perform ? IteratorBindingInitialization for FormalParameterList using iteratorRecord and environment as
        #      the arguments.
        #   2. Return the result of performing IteratorBindingInitialization for FunctionRestParameter using
        #      iteratorRecord and environment as the arguments.
        self.FormalParameterList.IteratorBindingInitialization(iteratorRecord, environment)
        return self.FunctionRestParameter.IteratorBindingInitialization(iteratorRecord, environment)


def parse_FormalParameters(context, lexer, pos, strict, Yield, Await):
    # 14.1 Function Definitions
    # Syntax
    #   FormalParameters[Yield, Await] :
    #       [empty]
    #       FunctionRestParameter[?Yield, ?Await]
    #       FormalParameterList[?Yield, ?Await]
    #       FormalParameterList[?Yield, ?Await] ,
    #       FormalParameterList[?Yield, ?Await] , FunctionRestParameter[?Yield, ?Await]
    fpl = parse_FormalParameterList(context, lexer, pos, strict, Yield, Await)
    if fpl:
        comma = lexer.token_if(fpl.after, ",")
        if comma:
            frp = parse_FunctionRestParameter(context, lexer, comma.span.after, strict, Yield, Await)
            if frp:
                return P2_FormalParameters_FormalParameterList_FunctionRestParameter(
                    context, strict, [fpl, comma, frp]
                )
            return P2_FormalParameters_FormalParameterList(context, strict, [fpl, comma])
        return P2_FormalParameters_FormalParameterList(context, strict, [fpl])
    frp2 = parse_FunctionRestParameter(context, lexer, pos, strict, Yield, Await)
    if frp2:
        return P2_FormalParameters_FunctionRestParameter(context, strict, [frp2])
    return P2_FormalParameters_EMPTY(context, pos, strict)


# --------======= 𝓕𝓸𝓻𝓶𝓪𝓵𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   FormalParameterList :
#       FormalParameter
#       FormalParameterList , FormalParameter


class P2_FormalParameterList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FormalParameterList", strict, children)


class P2_FormalParameterList_FormalParameter(P2_FormalParameterList):
    @property
    def FormalParameter(self):
        return self.children[0]

    def ExpectedArgumentCount(self):
        return 1 if not self.FormalParameter.HasInitializer() else 0


class P2_FormalParameterList_FormalParameterList_FormalParameter(P2_FormalParameterList):
    @property
    def FormalParameterList(self):
        return self.children[0]

    @property
    def FormalParameter(self):
        return self.children[2]

    def BoundNames(self):
        # 14.1.3 Static Semantics: BoundNames
        # FormalParameterList : FormalParameterList , FormalParameter
        #   1. Let names be BoundNames of FormalParameterList.
        #   2. Append to names the BoundNames of FormalParameter.
        #   3. Return names.
        names = self.FormalParameterList.BoundNames()
        names.extend(self.FormalParameter.BoundNames())
        return names

    def ContainsExpression(self):
        # 14.1.5 Static Semantics: ContainsExpression
        # FormalParameterList : FormalParameterList , FormalParameter
        #   1. If ContainsExpression of FormalParameterList is true, return true.
        #   2. Return ContainsExpression of FormalParameter.
        return self.FormalParameterList.ContainsExpression() or self.FormalParameter.ContainsExpression()

    def ExpectedArgumentCount(self):
        # 14.1.7 Static Semantics: ExpectedArgumentCount
        # FormalParameterList : FormalParameterList , FormalParameter
        #   1. Let count be ExpectedArgumentCount of FormalParameterList.
        #   2. If HasInitializer of FormalParameterList is true or HasInitializer of FormalParameter is true, return count.
        #   3. Return count + 1.
        count = self.FormalParameterList.ExpectedArgumentCount()
        if self.FormalParameterList.HasInitializer() or self.FormalParameter.HasInitializer():
            return count
        return count + 1

    def HasInitializer(self):
        # 14.1.8 Static Semantics: HasInitializer
        # FormalParameterList : FormalParameterList , FormalParameter
        #   1. If HasInitializer of FormalParameterList is true, return true.
        #   2. Return HasInitializer of FormalParameter.
        return self.FormalParameterList.HasInitializer() or self.FormalParameter.HasInitializer()

    def IsSimpleParameterList(self):
        # 14.1.13 Static Semantics: IsSimpleParameterList
        # FormalParameterList : FormalParameterList , FormalParameter
        #   1. If IsSimpleParameterList of FormalParameterList is false, return false.
        #   2. Return IsSimpleParameterList of FormalParameter.
        return self.FormalParameterList.IsSimpleParameterList() and self.FormalParameter.IsSimpleParameterList()

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 14.1.19 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # FormalParameterList : FormalParameterList , FormalParameter
        #   1. Perform ? IteratorBindingInitialization for FormalParameterList using iteratorRecord and environment as
        #      the arguments.
        #   2. Return the result of performing IteratorBindingInitialization for FormalParameter using iteratorRecord
        #      and environment as the arguments.
        self.FormalParameterList.IteratorBindingInitialization(iteratorRecord, environment)
        return self.FormalParameter.IteratorBindingInitialization(iteratorRecord, environment)


def parse_FormalParameterList(context, lexer, pos, strict, Yield, Await):
    # 14.1 Function Definitions
    # Syntax
    #   FormalParameterList[Yield, Await] :
    #       FormalParameter[?Yield, ?Await]
    #       FormalParameterList[?Yield, ?Await] , FormalParameter[?Yield, ?Await]
    def parse(pos, previous=None):
        if previous is None:
            fp = parse_FormalParameter(context, lexer, pos, strict, Yield, Await)
            if fp:
                return lambda: parse(fp.after, P2_FormalParameterList_FormalParameter(context, strict, [fp]))
        else:
            comma = lexer.token_if(pos, ",")
            if comma:
                fp2 = parse_FormalParameter(context, lexer, comma.span.after, strict, Yield, Await)
                if fp2:
                    return lambda: parse(
                        fp2.after,
                        P2_FormalParameterList_FormalParameterList_FormalParameter(
                            context, strict, [previous, comma, fp2]
                        ),
                    )
        return previous

    return trampoline(lambda: parse(pos))


# --------======= 𝓕𝓾𝓷𝓬𝓽𝓲𝓸𝓷𝓡𝓮𝓼𝓽𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻 =======--------
# Syntax
#   FunctionRestParameter :
#       BindingRestElement


class P2_FunctionRestParameter(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FunctionRestParameter", strict, children)


class P2_FunctionRestParameter_BindingRestElement(P2_FunctionRestParameter):
    @property
    def BindingRestElement(self):
        return self.children[0]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 14.1.19 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # FunctionRestParameter : BindingRestElement
        #   1. If ContainsExpression of BindingRestElement is false, return the result of performing
        #      IteratorBindingInitialization for BindingRestElement using iteratorRecord and environment as the
        #      arguments.
        #   2. Let currentContext be the running execution context.
        #   3. Let originalEnv be the VariableEnvironment of currentContext.
        #   4. Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.
        #   5. Assert: environment and originalEnv are the same.
        #   6. Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).
        #   7. Set the VariableEnvironment of currentContext to paramVarEnv.
        #   8. Set the LexicalEnvironment of currentContext to paramVarEnv.
        #   9. Let result be the result of performing IteratorBindingInitialization for BindingRestElement using
        #      iteratorRecord and environment as the arguments.
        #   10. Set the VariableEnvironment of currentContext to originalEnv.
        #   11. Set the LexicalEnvironment of currentContext to originalEnv.
        #   12. Return result.
        # NOTE 3
        # The new Environment Record created in step 6 is only used if the BindingRestElement contains a direct eval.
        if not self.BindingRestElement.ContainsExpression():
            return self.BindingRestElement.IteratorBindingInitialization(iteratorRecord, environment)
        currentContext = surrounding_agent.running_ec
        originalEnv = currentContext.variable_environment
        assert originalEnv == currentContext.lexical_environment
        assert environment == originalEnv
        paramVarEnv = NewDeclarativeEnvironment(originalEnv)
        currentContext.variable_environment = paramVarEnv
        currentContext.lexical_environment = paramVarEnv
        try:
            return self.BindingRestElement.IteratorBindingInitialization(iteratorRecord, environment)
        finally:
            currentContext.variable_environment = originalEnv
            currentContext.lexical_environment = originalEnv


def parse_FunctionRestParameter(context, lexer, pos, strict, Yield, Await):
    # 14.1 Function Definitions
    # Syntax
    #   FunctionRestParameter[Yield, Await] :
    #       BindingRestElement[?Yield, ?Await]
    bre = parse_BindingRestElement(context, lexer, pos, strict, Yield, Await)
    if bre:
        return P2_FunctionRestParameter_BindingRestElement(context, strict, [bre])
    return None


# --------======= 𝓕𝓸𝓻𝓶𝓪𝓵𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻 =======--------
# Syntax
#   FormalParameter :
#       BindingElement


class P2_FormalParameter(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FormalParameter", strict, children)


class P2_FormalParameter_BindingElement(P2_FormalParameter):
    @property
    def BindingElement(self):
        return self.children[0]

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 14.1.19 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        # FormalParameter : BindingElement
        #   1. If ContainsExpression of BindingElement is false, return the result of performing
        #      IteratorBindingInitialization for BindingElement using iteratorRecord and environment as the arguments.
        #   2. Let currentContext be the running execution context.
        #   3. Let originalEnv be the VariableEnvironment of currentContext.
        #   4. Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.
        #   5. Assert: environment and originalEnv are the same.
        #   6. Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).
        #   7. Set the VariableEnvironment of currentContext to paramVarEnv.
        #   8. Set the LexicalEnvironment of currentContext to paramVarEnv.
        #   9. Let result be the result of performing IteratorBindingInitialization for BindingElement using
        #      iteratorRecord and environment as the arguments.
        #   10. Set the VariableEnvironment of currentContext to originalEnv.
        #   11. Set the LexicalEnvironment of currentContext to originalEnv.
        #   12. Return result.
        # NOTE 2
        # The new Environment Record created in step 6 is only used if the BindingElement contains a direct eval.
        if not self.BindingElement.ContainsExpression():
            return self.BindingElement.IteratorBindingInitialization(iteratorRecord, environment)
        currentContext = surrounding_agent.running_ec
        originalEnv = currentContext.variable_environment
        assert originalEnv == currentContext.lexical_environment
        assert originalEnv == environment
        paramVarEnv = NewDeclarativeEnvironment(originalEnv)
        currentContext.variable_environment = paramVarEnv
        currentContext.lexical_environment = paramVarEnv
        try:
            return self.BindingElement.IteratorBindingInitialization(iteratorRecord, environment)
        finally:
            currentContext.variable_environment = originalEnv
            currentContext.lexical_environment = originalEnv


def parse_FormalParameter(context, lexer, pos, strict, Yield, Await):
    # 14.1 Function Definitions
    # Syntax
    #   FormalParameter[Yield, Await] :
    #       BindingElement[?Yield, ?Await]
    be = parse_BindingElement(context, lexer, pos, strict, Yield, Await)
    if be:
        return P2_FormalParameter_BindingElement(context, strict, [be])
    return None


# --------======= 𝓕𝓾𝓷𝓬𝓽𝓲𝓸𝓷𝓑𝓸𝓭𝔂 =======--------
# Syntax
#   FunctionBody :
#       FunctionStatementList


class P2_FunctionBody(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FunctionBody", strict, children)


class P2_FunctionBody_FunctionStatementList(P2_FunctionBody):
    @property
    def FunctionStatementList(self):
        return self.children[0]

    def EarlyErrors(self):
        # 14.1.2 Static Semantics: Early Errors
        # FunctionBody : FunctionStatementList
        #   * It is a Syntax Error if the LexicallyDeclaredNames of FunctionStatementList contains any duplicate
        #     entries.
        #   * It is a Syntax Error if any element of the LexicallyDeclaredNames of FunctionStatementList also occurs in
        #     the VarDeclaredNames of FunctionStatementList.
        #   * It is a Syntax Error if ContainsDuplicateLabels of FunctionStatementList with argument « » is true.
        #   * It is a Syntax Error if ContainsUndefinedBreakTarget of FunctionStatementList with argument « » is true.
        #   * It is a Syntax Error if ContainsUndefinedContinueTarget of FunctionStatementList with arguments « » and
        #     « » is true.
        errs = []
        fsl = self.FunctionStatementList
        ldn = fsl.LexicallyDeclaredNames()
        ldn_duplicates = [name for name, count in Counter(ldn).items() if count > 1]
        if ldn_duplicates:
            errs.append(
                self.CreateSyntaxError(
                    f'Identifiers with multiple lexical declarations: {", ".join(ldn_duplicates)}'
                )
            )
        vdn = fsl.VarDeclaredNames()
        in_common_names = set(vdn).intersection(set(ldn))
        if in_common_names:
            errs.append(
                self.CreateSyntaxError(
                    f'Identifiers with lexical declarations and var declarations: {", ".join(in_common_names)}'
                )
            )
        if fsl.ContainsDuplicateLabels([]):
            errs.append(self.CreateSyntaxError("Duplicated labels detected in function body"))
        if fsl.ContainsUndefinedBreakTarget([]):
            errs.append(self.CreateSyntaxError("Undefined break target detected in function body"))
        if fsl.ContainsUndefinedContinueTarget([], []):
            errs.append(self.CreateSyntaxError("Undefined continue target detected in function body"))
        return errs

    def ContainsUseStrict(self):
        # 14.1.6 Static Semantics: ContainsUseStrict
        # FunctionBody : FunctionStatementList
        #   1. If the Directive Prologue of FunctionStatementList contains a Use Strict Directive, return true;
        #      otherwise, return false.
        _, dp = self.FunctionStatementList.LeadingStrings()
        return "'use strict'" in dp or '"use strict"' in dp

    def EvaluateBody(self, functionObject, argumentsList):
        # 14.1.18 Runtime Semantics: EvaluateBody
        #   With parameters functionObject and List argumentsList.
        # FunctionBody : FunctionStatementList
        #   1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
        #   2. Return the result of evaluating FunctionStatementList.
        FunctionDeclarationInstantiation(functionObject, argumentsList)
        return self.FunctionStatementList.evaluate()


def parse_FunctionBody(context, lexer, pos, strict, Yield, Await):
    # 14.1 Function Definitions
    # Syntax
    #   FunctionBody[Yield, Await] :
    #       FunctionStatementList[?Yield, ?Await]
    fsl = parse_FunctionStatementList(context, lexer, pos, strict, Yield, Await)
    if fsl:
        return P2_FunctionBody_FunctionStatementList(context, fsl.strict, [fsl])
    return None


# --------======= 𝓕𝓾𝓷𝓬𝓽𝓲𝓸𝓷𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   FunctionStatementList :
#       [empty]
#       StatementList


class P2_FunctionStatementList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "FunctionStatementList", strict, children)


class P2_FunctionStatementList_StatementList(P2_FunctionStatementList):
    @property
    def StatementList(self):
        return self.children[0]

    def LexicallyDeclaredNames(self):
        # 14.1.14 Static Semantics: LexicallyDeclaredNames
        # FunctionStatementList : StatementList
        #   1. Return TopLevelLexicallyDeclaredNames of StatementList.
        return self.StatementList.TopLevelLexicallyDeclaredNames()

    def LexicallyScopedDeclarations(self):
        # 14.1.15 Static Semantics: LexicallyScopedDeclarations
        # FunctionStatementList : StatementList
        #   1. Return the TopLevelLexicallyScopedDeclarations of StatementList.
        return self.StatementList.TopLevelLexicallyScopedDeclarations()

    def VarDeclaredNames(self):
        # 14.1.16 Static Semantics: VarDeclaredNames
        # FunctionStatementList : StatementList
        #   1. Return TopLevelVarDeclaredNames of StatementList.
        return self.StatementList.TopLevelVarDeclaredNames()

    def VarScopedDeclarations(self):
        # 14.1.17 Static Semantics: VarScopedDeclarations
        # FunctionStatementList : StatementList
        #   1. Return the TopLevelVarScopedDeclarations of StatementList.
        return self.StatementList.TopLevelVarScopedDeclarations()


class P2_FunctionStatementList_EMPTY(P2_FunctionStatementList):
    def __init__(self, ctx, pos, strict):
        super().__init__(ctx, strict, [])
        self.after = pos

    StatementList = None

    def LexicallyDeclaredNames(self):
        # 14.1.14 Static Semantics: LexicallyDeclaredNames
        # FunctionStatementList : [empty]
        #   1. Return a new empty List.
        return []

    def LexicallyScopedDeclarations(self):
        # 14.1.15 Static Semantics: LexicallyScopedDeclarations
        # FunctionStatementList : [empty]
        #   1. Return a new empty List.
        return []

    def VarDeclaredNames(self):
        # 14.1.16 Static Semantics: VarDeclaredNames
        # FunctionStatementList : [empty]
        #   1. Return a new empty List.
        return []

    def VarScopedDeclarations(self):
        # 14.1.17 Static Semantics: VarScopedDeclarations
        # FunctionStatementList : [empty]
        #   1. Return a new empty List.
        return []

    def evaluate(self):
        # 14.1.21 Runtime Semantics: Evaluation
        #   1. Return NormalCompletion(undefined).
        return None

    def ContainsDuplicateLabels(self, labelSet):
        return False

    def ContainsUndefinedBreakTarget(self, labelSet):
        return False

    def ContainsUndefinedContinueTarget(self, iterationSet, labelSet):
        return False

    def LeadingStrings(self):
        return (False, [])


def parse_FunctionStatementList(context, lexer, pos, strict, Yield, Await):
    # 14.1 Function Definitions
    # Syntax
    #   FunctionStatementList[Yield, Await] :
    #       StatementList[?Yield, ?Await, +Return]opt
    sl = parse_StatementList(context, lexer, pos, strict, True, Yield, Await, True)
    if sl:
        return P2_FunctionStatementList_StatementList(context, strict or sl.strict, [sl])
    return P2_FunctionStatementList_EMPTY(context, pos, strict)


# 14.1.10 Static Semantics: IsAnonymousFunctionDefinition ( expr )
def IsAnonymousFunctionDefinition(expr):
    # The abstract operation IsAnonymousFunctionDefinition determines if its argument is a function definition that
    # does not bind a name. The argument expr is the result of parsing an AssignmentExpression or Initializer. The
    # following steps are taken:
    #   1. If IsFunctionDefinition of expr is false, return false.
    #   2. Let hasName be the result of HasName of expr.
    #   3. If hasName is true, return false.
    #   4. Return true.
    return expr.IsFunctionDefinition() and not expr.HasName()


#######################################################################################################################
#
#  d888       d8888       .d8888b.             d8888
# d8888      d8P888      d88P  Y88b           d88888
#   888     d8P 888             888          d88P888
#   888    d8P  888           .d88P         d88P 888 888d888 888d888  .d88b.  888  888  888
#   888   d88   888       .od888P"         d88P  888 888P"   888P"   d88""88b 888  888  888
#   888   8888888888     d88P"            d88P   888 888     888     888  888 888  888  888
#   888         888  d8b 888"            d8888888888 888     888     Y88..88P Y88b 888 d88P
# 8888888       888  Y8P 888888888      d88P     888 888     888      "Y88P"   "Y8888888P"
#
#
#
# 8888888888                            888    d8b
# 888                                   888    Y8P
# 888                                   888
# 8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.
# 888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b
# 888        888  888 888  888 888      888    888 888  888 888  888
# 888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888
# 888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888
#
#
#
# 8888888b.            .d888 d8b          d8b 888    d8b
# 888  "Y88b          d88P"  Y8P          Y8P 888    Y8P
# 888    888          888                     888
# 888    888  .d88b.  888888 888 88888b.  888 888888 888  .d88b.  88888b.  .d8888b
# 888    888 d8P  Y8b 888    888 888 "88b 888 888    888 d88""88b 888 "88b 88K
# 888    888 88888888 888    888 888  888 888 888    888 888  888 888  888 "Y8888b.
# 888  .d88P Y8b.     888    888 888  888 888 Y88b.  888 Y88..88P 888  888      X88
# 8888888P"   "Y8888  888    888 888  888 888  "Y888 888  "Y88P"  888  888  88888P'
#
#
#
#
#######################################################################################################################
# 14.2 Arrow Function Definitions
# 14.2.1 SS: Early Errors
# 14.2.2 SS: BoundNames
# 14.2.3 SS: Contains
# 14.2.4 SS: ContainsExpression
# 14.2.5 SS: ContainsUseStrict
# 14.2.6 SS: ExpectedArgumentCount
# 14.2.7 SS: HasName
# 14.2.8 SS: IsSimpleParameterList
# 14.2.9 SS: CoveredFormalsList
# 14.2.10 SS: LexicallyDeclaredNames
# 14.2.11 SS: LexicallyScopedDeclarations
# 14.2.12 SS: VarDeclaredNames
# 14.2.13 SS: VarScopedDeclarations
# 14.2.14 RS: IteratorBindingInitialization
# 14.2.15 RS: EvaluateBody
# 14.2.16 RS: NamedEvaluation
# 14.2.17 RS: Evaluation
#######################################################################################################################

#####################################################################################
# `·._.·●.._.·●.._.·●..... 14.2 Arrow Function Definitions .....●·._..●·._..●·._.·´ #
#####################################################################################
# 14.2 Arrow Function Definitions

# --------======= 𝓐𝓻𝓻𝓸𝔀𝓕𝓾𝓷𝓬𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   ArrowFunction :
#       ArrowParameters => ConciseBody


class P2_ArrowFunction(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ArrowFunction", strict, children)

    contains_unenclosed_break = False
    contains_unenclosed_continue = False


class P2_ArrowFunction_ArrowParameters_ConciseBody(P2_ArrowFunction):
    @property
    def ArrowParameters(self):
        return self.children[0]

    @property
    def ConciseBody(self):
        return self.children[2]

    @cached_property
    def contains_encapsulated_unenclosed_break(self):
        return self.ConciseBody.contains_unenclosed_break or super().contains_encapsulated_unenclosed_break

    @cached_property
    def contains_encapsulated_unenclosed_continue(self):
        return self.ConciseBody.contains_unenclosed_continue or super().contains_encapsulated_unenclosed_continue

    def EarlyErrors(self):
        # 14.2.1 Static Semantics: Early Errors
        # ArrowFunction : ArrowParameters => ConciseBody
        #   * It is a Syntax Error if ArrowParameters Contains YieldExpression is true.
        #   * It is a Syntax Error if ArrowParameters Contains AwaitExpression is true.
        #   * It is a Syntax Error if ContainsUseStrict of ConciseBody is true and IsSimpleParameterList of
        #     ArrowParameters is false.
        #   * It is a Syntax Error if any element of the BoundNames of ArrowParameters also occurs in the
        #     LexicallyDeclaredNames of ConciseBody.
        clashes = set(self.ArrowParameters.BoundNames()).intersection(set(self.ConciseBody.LexicallyDeclaredNames()))
        return list(
            filter(
                None,
                [
                    self.ArrowParameters.Contains("YieldExpression")
                    and self.CreateSyntaxError("'yield' not allowed in parameters"),
                    self.ArrowParameters.Contains("AwaitExpression")
                    and self.CreateSyntaxError("'await' not allowed in parameters"),
                    self.ConciseBody.ContainsUseStrict()
                    and not self.ArrowParameters.IsSimpleParameterList()
                    and self.CreateSyntaxError("parameters must be simple in strict mode"),
                    len(clashes)
                    and self.CreateSyntaxError(f"parameters clash with body declarations: {', '.join(clashes)}"),
                ],
            )
        )

    def Contains(self, symbol):
        # 14.2.3 Static Semantics: Contains
        #   With parameter symbol.
        # ArrowFunction : ArrowParameters => ConciseBody
        #   1. If symbol is not one of NewTarget, SuperProperty, SuperCall, super or this, return false.
        #   2. If ArrowParameters Contains symbol is true, return true.
        #   3. Return ConciseBody Contains symbol.
        return symbol in ("NewTarget", "SuperProperty", "SuperCall", "super", "this") and (
            self.ArrowParameters.Contains(symbol) or self.ConciseBody.Contains(symbol)
        )

    def HasName(self):
        # 14.2.7 Static Semantics: HasName
        # ArrowFunction : ArrowParameters => ConciseBody
        #   1. Return false.
        return False

    def NamedEvaluation(self, name):
        # 14.2.16 Runtime Semantics: NamedEvaluation
        #   With parameter name.
        # ArrowFunction : ArrowParameters => ConciseBody
        #   1. Let closure be the result of evaluating this ArrowFunction.
        #   2. Perform SetFunctionName(closure, name).
        #   3. Return closure.
        closure = self.evaluate()
        SetFunctionName(closure, name)
        return closure

    def evaluate(self):
        # 14.2.17 Runtime Semantics: Evaluation
        # ArrowFunction : ArrowParameters => ConciseBody
        #   1. If the function code for this ArrowFunction is strict mode code, let strict be true. Otherwise let
        #      strict be false.
        #   2. Let scope be the LexicalEnvironment of the running execution context.
        #   3. Let parameters be CoveredFormalsList of ArrowParameters.
        #   4. Let closure be FunctionCreate(Arrow, parameters, ConciseBody, scope, strict).
        #   5. Set closure.[[SourceText]] to the source text matched by ArrowFunction.
        #   6. Return closure.
        # NOTE  | An ArrowFunction does not define local bindings for arguments, super, this, or new.target. Any
        #       | reference to arguments, super, this, or new.target within an ArrowFunction must resolve to a binding
        #       | in a lexically enclosing environment. Typically this will be the Function Environment of an
        #       | immediately enclosing function. Even though an ArrowFunction may contain references to super, the
        #       | function object created in step 4 is not made into a method by performing MakeMethod. An
        #       | ArrowFunction that references super is always contained within a non-ArrowFunction and the necessary
        #       | state to implement super is accessible via the scope that is captured by the function object of the
        #       | ArrowFunction.
        scope = surrounding_agent.running_ec.lexical_environment
        parameters = self.ArrowParameters.CoveredFormalsList
        closure = FunctionCreate(ARROW, parameters, self.ConciseBody, scope, self.strict)
        closure.SourceText = self.matched_source()
        return closure


def parse_ArrowFunction(context, lexer, pos, strict, In, Yield, Await):
    # 14.2 Arrow Function Definitions
    # Syntax
    #   ArrowFunction[In, Yield, Await] :
    #       ArrowParameters[?Yield, ?Await] [no LineTerminator here] => ConciseBody[?In]
    ap = parse_ArrowParameters(context, lexer, pos, strict, Yield, Await)
    if ap:
        tok = lexer.token(ap.after)
        if tok and not tok.newlines:
            arrow = lexer.token_if(ap.after, "=>")
            if arrow:
                cb = parse_ConciseBody(context, lexer, arrow.span.after, strict, In)
                if cb:
                    return P2_ArrowFunction_ArrowParameters_ConciseBody(context, strict, [ap, arrow, cb])
    return None


# --------======= 𝓐𝓻𝓻𝓸𝔀𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼 =======--------
# Syntax
#   ArrowParameters :
#       BindingIdentifier
#       CoverParenthesizedExpressionAndArrowParameterList


class P2_ArrowParameters(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ArrowParameters", strict, children)


class P2_ArrowParameters_BindingIdentifier(P2_ArrowParameters):
    @property
    def BindingIdentifier(self):
        return self.children[0]

    def ContainsExpression(self):
        # 14.2.4 Static Semantics: ContainsExpression
        # ArrowParameters : BindingIdentifier
        #   1. Return false.
        return False

    def ExpectedArgumentCount(self):
        # 14.2.6 Static Semantics: ExpectedArgumentCount
        # ArrowParameters : BindingIdentifier
        #   1. Return 1.
        return 1

    def IsSimpleParameterList(self):
        # 14.2.8 Static Semantics: IsSimpleParameterList
        # ArrowParameters : BindingIdentifier
        #   1. Return true.
        return True

    @cached_property
    def CoveredFormalsList(self):
        # 14.2.9 Static Semantics: CoveredFormalsList
        # ArrowParameters : BindingIdentifier
        #   1. Return this ArrowParameters.
        return self

    def IteratorBindingInitialization(self, iteratorRecord, environment):
        # 14.2.14 Runtime Semantics: IteratorBindingInitialization
        #   With parameters iteratorRecord and environment.
        #
        # NOTE  | When undefined is passed for environment it indicates that a PutValue operation should be used to
        #       | assign the initialization value. This is the case for formal parameter lists of non-strict functions.
        #       | In that case the formal parameter bindings are preinitialized in order to deal with the possibility
        #       | of multiple parameters with the same name.
        #
        # ArrowParameters : BindingIdentifier
        #   1. Assert: iteratorRecord.[[Done]] is false.
        #   2. Let next be IteratorStep(iteratorRecord).
        #   3. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #   4. ReturnIfAbrupt(next).
        #   5. If next is false, set iteratorRecord.[[Done]] to true.
        #   6. Else,
        #       a. Let v be IteratorValue(next).
        #       b. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
        #       c. ReturnIfAbrupt(v).
        #   7. If iteratorRecord.[[Done]] is true, let v be undefined.
        #   8. Return the result of performing BindingInitialization for BindingIdentifier using v and environment as
        #      the arguments.
        assert not iteratorRecord.Done
        try:
            nxt = IteratorStep(iteratorRecord)
        except ESAbrupt:
            iteratorRecord.Done = True
            raise
        if nxt == False:
            iteratorRecord.Done = True
        else:
            try:
                v = IteratorValue(nxt)
            except ESAbrupt:
                iteratorRecord.Done = True
                raise
        if iteratorRecord.Done:
            v = None
        return self.BindingIdentifier.BindingInitialization(v, environment)


class P2_ArrowParameters_CoverParenthesizedExpressionAndArrowParameterList(P2_ArrowParameters):
    @property
    def CoverParenthesizedExpressionAndArrowParameterList(self):
        return self.children[0]

    def EarlyErrors(self):
        # 14.2.1 Static Semantics: Early Errors
        # ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
        #   * It is a Syntax Error if CoverParenthesizedExpressionAndArrowParameterList is not covering an
        #     ArrowFormalParameters.
        #   * All early error rules for ArrowFormalParameters and its derived productions also apply to
        #     CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList.
        cfl = self.CoverParenthesizedExpressionAndArrowParameterList.CoveredFormalsList
        return cfl.EarlyErrors() if cfl else [self.CreateSyntaxError("Invalid parameter syntax")]

    def BoundNames(self):
        # 14.2.2 Static Semantics: BoundNames
        # ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let formals be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. Return the BoundNames of formals.
        return self.CoverParenthesizedExpressionAndArrowParameterList.CoveredFormalsList.BoundNames()

    def Contains(self, symbol):
        # 14.2.3Static Semantics: Contains
        #   With parameter symbol.
        # ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let formals be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. Return formals Contains symbol.
        return self.CoverParenthesizedExpressionAndArrowParameterList.CoveredFormalsList.Contains(symbol)

    def IsSimpleParameterList(self):
        # 14.2.8 Static Semantics: IsSimpleParameterList
        # ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
        #   1. Let formals be CoveredFormalsList of CoverParenthesizedExpressionAndArrowParameterList.
        #   2. Return IsSimpleParameterList of formals.
        return self.CoverParenthesizedExpressionAndArrowParameterList.CoveredFormalsList.IsSimpleParameterList()

    @cached_property
    def CoveredFormalsList(self):
        return self.CoverParenthesizedExpressionAndArrowParameterList.CoveredFormalsList


def parse_ArrowParameters(context, lexer, pos, strict, Yield, Await):
    # 14.2 Arrow Function Definitions
    # Syntax
    #   ArrowParameters[Yield, Await] :
    #       BindingIdentifier[?Yield, ?Await]
    #       CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
    bi = parse_BindingIdentifier(context, lexer, pos, strict, Yield, Await)
    if bi:
        return P2_ArrowParameters_BindingIdentifier(context, strict, [bi])
    cpeapl = parse_CoverParenthesizedExpressionAndArrowParameterList(context, lexer, pos, strict, Yield, Await)
    if cpeapl:
        return P2_ArrowParameters_CoverParenthesizedExpressionAndArrowParameterList(context, strict, [cpeapl])
    return None


# --------======= 𝓒𝓸𝓷𝓬𝓲𝓼𝓮𝓑𝓸𝓭𝔂 =======--------
# Syntax
#   ConciseBody :
#       AssignmentExpression
#       { FunctionBody }


class P2_ConciseBody(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ConciseBody", strict, children)


class P2_ConciseBody_AssignmentExpression(P2_ConciseBody):
    @property
    def AssignmentExpression(self):
        return self.children[0]

    def ContainsUseStrict(self):
        # 14.2.5 Static Semantics: ContainsUseStrict
        # ConciseBody : AssignmentExpression
        #   1. Return false.
        return False

    def LexicallyDeclaredNames(self):
        # 14.2.10 Static Semantics: LexicallyDeclaredNames
        # ConciseBody : AssignmentExpression
        #   1. Return a new empty List.
        return []

    def LexicallyScopedDeclarations(self):
        # 14.2.11 Static Semantics: LexicallyScopedDeclarations
        # ConciseBody : AssignmentExpression
        #   1. Return a new empty List.
        return []

    def VarDeclaredNames(self):
        # 14.2.12 Static Semantics: VarDeclaredNames
        # ConciseBody : AssignmentExpression
        #   1. Return a new empty List.
        return []

    def VarScopedDeclarations(self):
        # 14.2.13 Static Semantics: VarScopedDeclarations
        # ConciseBody : AssignmentExpression
        #   1. Return a new empty List.
        return []

    def EvaluateBody(self, functionObject, argumentsList):
        # 14.2.15 Runtime Semantics: EvaluateBody
        #   With parameters functionObject and List argumentsList.
        # ConciseBody : AssignmentExpression
        #   1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
        #   2. Let exprRef be the result of evaluating AssignmentExpression.
        #   3. Let exprValue be ? GetValue(exprRef).
        #   4. Return Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }.
        FunctionDeclarationInstantiation(functionObject, argumentsList)
        raise ESReturn(value=GetValue(self.AssignmentExpression.evaluate()))


class P2_ConciseBody_FunctionBody(P2_ConciseBody):
    @property
    def FunctionBody(self):
        return self.children[1]


def parse_ConciseBody(context, lexer, pos, strict, In):
    # 14.2 Arrow Function Definitions
    # Syntax
    #   ConciseBody[In] :
    #       [lookahead ≠ {] AssignmentExpression[?In, ~Yield, ~Await]
    #       { FunctionBody[~Yield, ~Await] }
    lc = lexer.token_if(pos, "{")
    if lc:
        fb = parse_FunctionBody(context, lexer, lc.span.after, strict, False, False)
        if fb:
            rc = lexer.token_if(fb.after, "}")
            if rc:
                return P2_ConciseBody_FunctionBody(context, fb.strict, [lc, fb, rc])
    else:
        ae = parse_AssignmentExpression(context, lexer, pos, strict, In, False, False)
        if ae:
            return P2_ConciseBody_AssignmentExpression(context, strict, [ae])
    return None


# --------======= 𝓐𝓻𝓻𝓸𝔀𝓕𝓸𝓻𝓶𝓪𝓵𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼 =======--------
# Syntax
#   ArrowFormalParameters :
#       ( UniqueFormalParameters )


class P2_ArrowFormalParameters(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ArrowFormalParameters", strict, children)


class P2_ArrowFormalParameters_UniqueFormalParameters(P2_ArrowFormalParameters):
    @property
    def UniqueFormalParameters(self):
        return self.children[1]


def parse_ArrowFormalParameters(context, lexer, pos, strict, Yield, Await):
    # 14.2 Arrow Function Definitions
    # Syntax
    #   ArrowFormalParameters[Yield, Await] :
    #       ( UniqueFormalParameters[?Yield, ?Await] )
    lp = lexer.token_if(pos, "(")
    if lp:
        ufp = parse_UniqueFormalParameters(context, lexer, pos, strict, Yield, Await)
        if ufp:
            rp = lexer.token_if(ufp.after, ")")
            if rp:
                return P2_ArrowFormalParameters_UniqueFormalParameters(context, strict, [lp, ufp, rp])
    return None


#######################################################################################################################
#
#  d888       d8888       .d8888b.      888b     d888          888    888                    888
# d8888      d8P888      d88P  Y88b     8888b   d8888          888    888                    888
#   888     d8P 888           .d88P     88888b.d88888          888    888                    888
#   888    d8P  888          8888"      888Y88888P888  .d88b.  888888 88888b.   .d88b.   .d88888
#   888   d88   888           "Y8b.     888 Y888P 888 d8P  Y8b 888    888 "88b d88""88b d88" 888
#   888   8888888888     888    888     888  Y8P  888 88888888 888    888  888 888  888 888  888
#   888         888  d8b Y88b  d88P     888   "   888 Y8b.     Y88b.  888  888 Y88..88P Y88b 888
# 8888888       888  Y8P  "Y8888P"      888       888  "Y8888   "Y888 888  888  "Y88P"   "Y88888
#
#
#
# 8888888b.            .d888 d8b          d8b 888    d8b
# 888  "Y88b          d88P"  Y8P          Y8P 888    Y8P
# 888    888          888                     888
# 888    888  .d88b.  888888 888 88888b.  888 888888 888  .d88b.  88888b.  .d8888b
# 888    888 d8P  Y8b 888    888 888 "88b 888 888    888 d88""88b 888 "88b 88K
# 888    888 88888888 888    888 888  888 888 888    888 888  888 888  888 "Y8888b.
# 888  .d88P Y8b.     888    888 888  888 888 Y88b.  888 Y88..88P 888  888      X88
# 8888888P"   "Y8888  888    888 888  888 888  "Y888 888  "Y88P"  888  888  88888P'
#
#
#
#
#######################################################################################################################
# 14.3 Method Definitions
# 14.3.1 SS: Early Errors
# 14.3.2 SS: ComputedPropertyContains
# 14.3.3 SS: ExpectedArgumentCount
# 14.3.4 SS: HasDirectSuper
# 14.3.5 SS: PropName
# 14.3.6 SS: SpecialMethod
# 14.3.7 RS: DefineMethod
# 14.3.8 RS: PropertyDefinitionEvaluation
#######################################################################################################################

###########################################################################################
# `·._.·●.._.·●.._.·●..... 14.3 Method Definitions .....●·._..●·._..●·._.·´ #
###########################################################################################
# 14.3 Method Definitions

# --------======= 𝓜𝓮𝓽𝓱𝓸𝓭𝓓𝓮𝓯𝓲𝓷𝓲𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   MethodDefinition :
#       PropertyName ( UniqueFormalParameters ) { FunctionBody }
#       GeneratorMethod
#       AsyncMethod
#       AsyncGeneratorMethod
#       get PropertyName ( ) { FunctionBody }
#       set PropertyName ( PropertySetParameterList ) { FunctionBody }


class P2_MethodDefinition(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "MethodDefinition", strict, children)


class P2_MethodDefinition_PropertyName(P2_MethodDefinition):
    # For the productions that have a PropertyName:
    #   MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
    #   MethodDefinition : get PropertyName ( ) { FunctionBody }
    #   MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody }
    @property
    def PropertyName(self):
        raise NotImplementedError("Abstract class should not be instantiated")

    def ComputedPropertyContains(self, symbol):
        # 14.3.2 Static Semantics: ComputedPropertyContains
        #   With parameter symbol.
        #   1. Return the result of ComputedPropertyContains for PropertyName with argument symbol.
        return self.PropertyName.ComputedPropertyContains(symbol)

    def PropName(self):
        # 14.3.5 Static Semantics: PropName
        #   1. Return PropName of PropertyName.
        return self.PropertyName.PropName()


MethodDefinitionRecord = namedtuple("MethodDefinitionRecord", ["Closure", "Key"])


class P2_MethodDefinition_PropertyName_UniqueFormalParameters_FunctionBody(P2_MethodDefinition_PropertyName):
    @property
    def PropertyName(self):
        return self.children[0]

    @property
    def UniqueFormalParameters(self):
        return self.children[2]

    @property
    def FunctionBody(self):
        return self.children[5]

    def EarlyErrors(self):
        # 14.3.1 Static Semantics: Early Errors
        #   * It is a Syntax Error if ContainsUseStrict of FunctionBody is true and IsSimpleParameterList of UniqueFormalParameters is false.
        #   * It is a Syntax Error if any element of the BoundNames of UniqueFormalParameters also occurs in the LexicallyDeclaredNames of FunctionBody.
        errs = []
        if self.FunctionBody.ContainsUseStrict() and not self.UniqueFormalParameters.IsSimpleParameterList():
            errs.append(CreateSyntaxError("Complex parameter lists not allowed in strict mode"))
        bn = self.UniqueFormalParameters.BoundNames()
        ldn = self.FunctionBody.LexicallyDeclaredNames()
        duplicates = set(bn).intersection(set(ldn))
        if duplicates:
            errs.append(
                CreateSyntaxError(
                    f'Parameter names and lexical declarations must not clash. (Clashing identifiers: {", ".join(duplicates)})'
                )
            )
        return errs

    def HasDirectSuper(self):
        # 14.3.4 Static Semantics: HasDirectSuper
        #   1. If UniqueFormalParameters Contains SuperCall is true, return true.
        #   2. Return FunctionBody Contains SuperCall.
        return any(pn.Contains("SuperCall") for pn in (self.UniqueFormalParameters, self.FunctionBody))

    def SpecialMethod(self):
        # 14.3.6 Static Semantics: SpecialMethod
        #   1. Return false.
        return False

    def DefineMethod(self, object, functionPrototype=EMPTY):
        # 14.3.7 Runtime Semantics: DefineMethod
        #   With parameters object and optional parameter functionPrototype.
        #   1. Let propKey be the result of evaluating PropertyName.
        #   2. ReturnIfAbrupt(propKey).
        #   3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.
        #   4. Let scope be the running execution context's LexicalEnvironment.
        #   5. If functionPrototype is present as a parameter, then
        #       a. Let kind be Normal.
        #       b. Let prototype be functionPrototype.
        #   6. Else,
        #       a. Let kind be Method.
        #       b. Let prototype be the intrinsic object %FunctionPrototype%.
        #   7. Let closure be FunctionCreate(kind, UniqueFormalParameters, FunctionBody, scope, strict, prototype).
        #   8. Perform MakeMethod(closure, object).
        #   9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.
        #   10. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.
        propKey = self.PropertyName.evaluate()
        scope = surrounding_agent.running_ec.lexical_environment
        if functionPrototype != EMPTY:
            kind = NORMAL
            prototype = functionPrototype
        else:
            kind = METHOD
            prototype = surrounding_agent.running_ec.realm.intrinsics["%FunctionPrototype%"]
        closure = FunctionCreate(kind, self.UniqueFormalParameters, self.FunctionBody, scope, self.strict, prototype)
        MakeMethod(closure, object)
        closure.SourceText = self.matched_source()
        return MethodDefinitionRecord(Key=propKey, Closure=closure)

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation
        #   With parameters object and enumerable.
        #   1. Let methodDef be DefineMethod of MethodDefinition with argument object.
        #   2. ReturnIfAbrupt(methodDef).
        #   3. Perform SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).
        #   4. Let desc be the PropertyDescriptor { [[Value]]: methodDef.[[Closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }.
        #   5. Return ? DefinePropertyOrThrow(object, methodDef.[[Key]], desc).
        methodDef = self.DefineMethod(object)
        SetFunctionName(methodDef.Closure, methodDef.Key)
        desc = PropertyDescriptor(value=methodDef.Closure, writable=True, enumerable=enumerable, configurable=True)
        return DefinePropertyOrThrow(object, methodDef.Key, desc)


class P2_MethodDefinition_GeneratorMethod(P2_MethodDefinition):
    @property
    def GeneratorMethod(self):
        return self.children[0]

    def SpecialMethod(self):
        # 14.3.6 Static Semantics: SpecialMethod
        #   1. Return true.
        return True


class P2_MethodDefinition_AsyncMethod(P2_MethodDefinition):
    @property
    def AsyncMethod(self):
        return self.children[0]

    def SpecialMethod(self):
        # 14.3.6 Static Semantics: SpecialMethod
        #   1. Return true.
        return True


class P2_MethodDefinition_AsyncGeneratorMethod(P2_MethodDefinition):
    @property
    def AsyncGeneratorMethod(self):
        return self.children[0]

    def SpecialMethod(self):
        # 14.3.6 Static Semantics: SpecialMethod
        #   1. Return true.
        return True


class P2_MethodDefinition_GET_PropertyName_FunctionBody(P2_MethodDefinition_PropertyName):
    @property
    def PropertyName(self):
        return self.children[1]

    @property
    def FunctionBody(self):
        return self.children[5]

    def HasDirectSuper(self):
        # 14.3.4 Static Semantics: HasDirectSuper
        #   1. Return FunctionBody Contains SuperCall.
        return self.FunctionBody.Contains("SuperCall")

    def SpecialMethod(self):
        # 14.3.6 Static Semantics: SpecialMethod
        #   1. Return true.
        return True

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation
        #   With parameters object and enumerable.
        #   1. Let propKey be the result of evaluating PropertyName.
        #   2. ReturnIfAbrupt(propKey).
        #   3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.
        #   4. Let scope be the running execution context's LexicalEnvironment.
        #   5. Let formalParameterList be an instance of the production FormalParameters:[empty] .
        #   6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).
        #   7. Perform MakeMethod(closure, object).
        #   8. Perform SetFunctionName(closure, propKey, "get").
        #   9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.
        #   10. Let desc be the PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
        #   11. Return ? DefinePropertyOrThrow(object, propKey, desc).
        propKey = self.PropertyName.evaluate()
        scope = surrounding_agent.running_ec.lexical_environment
        formalParameterList = P2_FormalParameters_EMPTY(self.context, 0, self.strict)
        closure = FunctionCreate(METHOD, formalParameterList, self.FunctionBody, scope, self.strict)
        MakeMethod(closure, object)
        SetFunctionName(closure, propKey, "get")
        closure.SourceText = self.matched_source()
        desc = PropertyDescriptor(Get=closure, enumerable=enumerable, configurable=True)
        return DefinePropertyOrThrow(object, propKey, desc)


class P2_MethodDefinition_SET_PropertyName_PropertySetParameterList_FunctionBody(P2_MethodDefinition_PropertyName):
    @property
    def PropertyName(self):
        return self.children[1]

    @property
    def PropertySetParameterList(self):
        return self.children[3]

    @property
    def FunctionBody(self):
        return self.children[6]

    def EarlyErrors(self):
        # 14.3.1 Static Semantics: Early Errors
        #   * It is a Syntax Error if BoundNames of PropertySetParameterList contains any duplicate elements.
        #   * It is a Syntax Error if ContainsUseStrict of FunctionBody is true and IsSimpleParameterList of PropertySetParameterList is false.
        #   * It is a Syntax Error if any element of the BoundNames of PropertySetParameterList also occurs in the LexicallyDeclaredNames of FunctionBody.
        errs = []
        bn = self.PropertySetParameterList.BoundNames()
        duplicates = [name for name, count in Counter(bn).items() if count > 1]
        if duplicates:
            errs.append(CreateSyntaxError(f'Multiple definitions in parameter list: {", ".join(duplicates)}'))
        if self.FunctionBody.ContainsUseStrict() and not self.PropertySetParameterList.IsSimpleParameterList():
            errs.append(CreateSyntaxError("Complex parameter lists not allowed for strict functions"))
        ldn = self.FunctionBody.LexicallyDeclaredNames()
        clashes = set(bn).intersection(set(ldn))
        if clashes:
            errs.append(
                CreateSyntaxError(
                    f'Parameter names and lexical declarations must not clash. (Clashing identifiers: {", ".join(clashes)})'
                )
            )
        return errs

    def HasDirectSuper(self):
        # 14.3.4 Static Semantics: HasDirectSuper
        #   1. If PropertySetParameterList Contains SuperCall is true, return true.
        #   2. Return FunctionBody Contains SuperCall.
        return any(pn.Contains("SuperCall") for pn in (self.PropertySetParameterList, self.FunctionBody))

    def SpecialMethod(self):
        # 14.3.6 Static Semantics: SpecialMethod
        #   1. Return true.
        return True

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation
        #   With parameters object and enumerable.
        #   1. Let propKey be the result of evaluating PropertyName.
        #   2. ReturnIfAbrupt(propKey).
        #   3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.
        #   4. Let scope be the running execution context's LexicalEnvironment.
        #   5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).
        #   6. Perform MakeMethod(closure, object).
        #   7. Perform SetFunctionName(closure, propKey, "set").
        #   8. Set closure.[[SourceText]] to the source text matched by MethodDefinition.
        #   9. Let desc be the PropertyDescriptor { [[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
        #   10. Return ? DefinePropertyOrThrow(object, propKey, desc).
        propKey = self.PropertyName.evaluate()
        scope = surrounding_agent.running_ec.lexical_environment
        closure = FunctionCreate(METHOD, self.PropertySetParameterList, self.FunctionBody, scope, self.strict)
        MakeMethod(closure, object)
        SetFunctionName(closure, propKey, "set")
        closure.SourceText = self.matched_source()
        desc = PropertyDescriptor(Set=closure, enumerable=enumerable, configurable=True)
        return DefinePropertyOrThrow(object, propKey, desc)


def parse_MethodDefinition(context, lexer, pos, strict, Yield, Await):
    # 14.3 Method Definitions
    # Syntax
    #   MethodDefinition[Yield, Await] :
    #       PropertyName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] }
    #       GeneratorMethod[?Yield, ?Await]
    #       AsyncMethod[?Yield, ?Await]
    #       AsyncGeneratorMethod[?Yield, ?Await]
    #       get PropertyName[?Yield, ?Await] ( ) { FunctionBody[~Yield, ~Await] }
    #       set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }
    pn1 = parse_PropertyName(context, lexer, pos, strict, Yield, Await)
    if pn1:
        lp1 = lexer.token_if(pn1.after, "(")
        if lp1:
            ufp = parse_UniqueFormalParameters(context, lexer, lp1.span.after, strict, False, False)
            if ufp:
                rp1 = lexer.token_if(ufp.after, ")")
                if rp1:
                    lc1 = lexer.token_if(rp1.span.after, "{")
                    if lc1:
                        fb1 = parse_FunctionBody(context, lexer, lc1.span.after, strict, False, False)
                        if fb1:
                            rc1 = lexer.token_if(fb1.after, "}")
                            if rc1:
                                return P2_MethodDefinition_PropertyName_UniqueFormalParameters_FunctionBody(
                                    context, fb1.strict, [pn1, lp1, ufp, rp1, lc1, fb1, rc1]
                                )
    gm = parse_GeneratorMethod(context, lexer, pos, strict, Yield, Await)
    if gm:
        return P2_MethodDefinition_GeneratorMethod(context, strict, [gm])
    am = parse_AsyncMethod(context, lexer, pos, strict, Yield, Await)
    if am:
        return P2_MethodDefinition_AsyncMethod(context, strict, [am])
    agm = parse_AsyncGeneratorMethod(context, lexer, pos, strict, Yield, Await)
    if agm:
        return P2_MethodDefinition_AsyncGeneratorMethod(context, strict, [agm])
    get = lexer.id_if(pos, "get")
    if get:
        pn_get = parse_PropertyName(context, lexer, get.span.after, strict, Yield, Await)
        if pn_get:
            lp_get = lexer.token_if(pn_get.after, "(")
            if lp_get:
                rp_get = lexer.token_if(lp_get.span.after, ")")
                if rp_get:
                    lc_get = lexer.token_if(rp_get.span.after, "{")
                    if lc_get:
                        fb_get = parse_FunctionBody(context, lexer, lc_get.span.after, strict, False, False)
                        if fb_get:
                            rc_get = lexer.token_if(fb_get.after, "}")
                            if rc_get:
                                return P2_MethodDefinition_GET_PropertyName_FunctionBody(
                                    context, fb_get.strict, [get, pn_get, lp_get, rp_get, lc_get, fb_get, rc_get]
                                )
    set_tok = lexer.id_if(pos, "set")
    if set_tok:
        pn_set = parse_PropertyName(context, lexer, set_tok.span.after, strict, Yield, Await)
        if pn_set:
            lp_set = lexer.token_if(pn_set.after, "(")
            if lp_set:
                pspl = parse_PropertySetParameterList(context, lexer, lp_set.span.after, strict)
                if pspl:
                    rp_set = lexer.token_if(pspl.after, ")")
                    if rp_set:
                        lc_set = lexer.token_if(rp_set.span.after, "{")
                        if lc_set:
                            fb_set = parse_FunctionBody(context, lexer, lc_set.span.after, strict, False, False)
                            if fb_set:
                                rc_set = lexer.token_if(fb_set.after, "}")
                                if rc_set:
                                    return P2_MethodDefinition_SET_PropertyName_PropertySetParameterList_FunctionBody(
                                        context,
                                        fb_set.strict,
                                        [set_tok, pn_set, lp_set, pspl, rp_set, lc_set, fb_set, rc_set],
                                    )
    return None


# --------======= 𝓟𝓻𝓸𝓹𝓮𝓻𝓽𝔂𝓢𝓮𝓽𝓟𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓛𝓲𝓼𝓽 =======--------
# Syntax
#   PropertySetParameterList :
#       FormalParameter


class P2_PropertySetParameterList(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "PropertySetParameterList", strict, children)


class P2_PropertySetParameterList_FormalParameter(P2_PropertySetParameterList):
    @property
    def FormalParameter(self):
        return self.children[0]

    def ExpectedArgumentCount(self):
        # 14.3.3 Static Semantics: ExpectedArgumentCount
        #   1. If HasInitializer of FormalParameter is true, return 0.
        #   2. Return 1.
        return 0 if self.FormalParameter.HasInitializer() else 1


def parse_PropertySetParameterList(context, lexer, pos, strict):
    # 14.3 Method Definitions
    # Syntax
    #   PropertySetParameterList :
    #       FormalParameter[~Yield, ~Await]
    fp = parse_FormalParameter(context, lexer, pos, strict, False, False)
    if fp:
        return P2_PropertySetParameterList_FormalParameter(context, strict, [fp])
    return None


#######################################################################################################################
#
#  d888       d8888          d8888       .d8888b.                                              888
# d8888      d8P888         d8P888      d88P  Y88b                                             888
#   888     d8P 888        d8P 888      888    888                                             888
#   888    d8P  888       d8P  888      888         .d88b.  88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888
#   888   d88   888      d88   888      888  88888 d8P  Y8b 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"
#   888   8888888888     8888888888     888    888 88888888 888  888 88888888 888     .d888888 888    888  888 888
#   888         888  d8b       888      Y88b  d88P Y8b.     888  888 Y8b.     888     888  888 Y88b.  Y88..88P 888
# 8888888       888  Y8P       888       "Y8888P88  "Y8888  888  888  "Y8888  888     "Y888888  "Y888  "Y88P"  888
#
#
#
# 8888888888                            888    d8b
# 888                                   888    Y8P
# 888                                   888
# 8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.
# 888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b
# 888        888  888 888  888 888      888    888 888  888 888  888
# 888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888
# 888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888
#
#
#
# 8888888b.            .d888 d8b          d8b 888    d8b
# 888  "Y88b          d88P"  Y8P          Y8P 888    Y8P
# 888    888          888                     888
# 888    888  .d88b.  888888 888 88888b.  888 888888 888  .d88b.  88888b.  .d8888b
# 888    888 d8P  Y8b 888    888 888 "88b 888 888    888 d88""88b 888 "88b 88K
# 888    888 88888888 888    888 888  888 888 888    888 888  888 888  888 "Y8888b.
# 888  .d88P Y8b.     888    888 888  888 888 Y88b.  888 Y88..88P 888  888      X88
# 8888888P"   "Y8888  888    888 888  888 888  "Y888 888  "Y88P"  888  888  88888P'
#
#
#
#
#######################################################################################################################
# 14.4 Generator Function Definitions
# 14.4.1 SS: Early Errors
# 14.4.2 SS: BoundNames
# 14.4.3 SS: ComputedPropertyContains
# 14.4.4 SS: Contains
# 14.4.5 SS: HasDirectSuper
# 14.4.6 SS: HasName
# 14.4.7 SS: IsConstantDeclaration
# 14.4.8 SS: IsFunctionDefinition
# 14.4.9 SS: PropName
# 14.4.10 RS: EvaluateBody
# 14.4.11 RS: InstantiateFunctionObject
# 14.4.12 RS: PropertyDefinitionEvaluation
# 14.4.13 RS: NamedEvaluation
# 14.4.14 RS: Evaluation
#######################################################################################################################

###########################################################################################
# `·._.·●.._.·●.._.·●..... 14.4 Generator Function Definitions .....●·._..●·._..●·._.·´ #
###########################################################################################
# 14.4 Generator Function Definitions

# --------======= 𝓖𝓮𝓷𝓮𝓻𝓪𝓽𝓸𝓻𝓜𝓮𝓽𝓱𝓸𝓭 =======--------
# Syntax
#   GeneratorMethod :
#       * PropertyName ( UniqueFormalParameters ) { GeneratorBody }


class P2_GeneratorMethod(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "GeneratorMethod", strict, children)


class P2_GeneratorMethod_PropertyName_UniqueFormalParameters_GeneratorBody(P2_GeneratorMethod):
    @property
    def PropertyName(self):
        return self.children[1]

    @property
    def UniqueFormalParameters(self):
        return self.children[3]

    @property
    def GeneratorBody(self):
        return self.children[6]

    def EarlyErrors(self):
        # 14.4.1 Static Semantics: Early Errors
        # * It is a Syntax Error if HasDirectSuper of GeneratorMethod is true.
        # * It is a Syntax Error if UniqueFormalParameters Contains YieldExpression is true.
        # * It is a Syntax Error if ContainsUseStrict of GeneratorBody is true and IsSimpleParameterList of
        #   UniqueFormalParameters is false.
        # * It is a Syntax Error if any element of the BoundNames of UniqueFormalParameters also occurs in the
        #   LexicallyDeclaredNames of GeneratorBody.
        def ds():
            return self.HasDirectSuper()

        def hasyield():
            return self.UniqueFormalParameters.Contains("YieldExpression")

        def simple():
            return self.GeneratorBody.ContainsUseStrict() and not self.UniqueFormalParameters.IsSimpleParameterList()

        def hasduplicates():
            bn = self.UniqueFormalParameters.BoundNames()
            ldn = self.GeneratorBody.LexicallyDeclaredNames()
            duplicates = set(bn).intersection(set(ldn))
            return bool(duplicates)

        checks = (
            (ds, "Generator Methods may not have direct supers"),
            (hasyield, "Cannot have yield expressions in generator parameters"),
            (simple, "Parameters must be simple in strict mode"),
            (
                hasduplicates,
                "Cannot have the same identifiers in a parameter list and the generator's lexically declared names",
            ),
        )

        def run_check(inp):
            check, err = inp
            return (None, err)[check()]

        return list(map(ESSyntaxError, filter(None, map(run_check, checks))))

    def ComputedPropertyContains(self, symbol):
        # 14.4.3 Static Semantics: ComputedPropertyContains
        #       With parameter symbol.
        #   1. Return the result of ComputedPropertyContains for PropertyName with argument symbol.
        return self.PropertyName.ComputedPropertyContains(symbol)

    def HasDirectSuper(self):
        # 14.4.5 Static Semantics: HasDirectSuper
        #   1. If UniqueFormalParameters Contains SuperCall is true, return true.
        #   2. Return GeneratorBody Contains SuperCall.
        return any(pn.Contains("SuperCall") for pn in (self.UniqueFormalParameters, self.GeneratorBody))

    def PropName(self):
        # 14.4.9 Static Semantics: PropName
        #   1. Return PropName of PropertyName.
        return self.PropertyName.PropName()

    def PropertyDefinitionEvaluation(self, object, enumerable):
        # 14.4.12 Runtime Semantics: PropertyDefinitionEvaluation
        #       With parameters object and enumerable.
        #   1. Let propKey be the result of evaluating PropertyName.
        #   2. ReturnIfAbrupt(propKey).
        #   3. If the function code for this GeneratorMethod is strict mode code, let strict be true. Otherwise let
        #      strict be false.
        #   4. Let scope be the running execution context's LexicalEnvironment.
        #   5. Let closure be GeneratorFunctionCreate(Method, UniqueFormalParameters, GeneratorBody, scope, strict).
        #   6. Perform MakeMethod(closure, object).
        #   7. Let prototype be ObjectCreate(%GeneratorPrototype%).
        #   8. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype,
        #      [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        #   9. Perform SetFunctionName(closure, propKey).
        #   10. Let desc be the PropertyDescriptor { [[Value]]: closure, [[Writable]]: true,
        #       [[Enumerable]]: enumerable, [[Configurable]]: true }.
        #   11. Return ? DefinePropertyOrThrow(object, propKey, desc).
        propKey = self.PropertyName.evaluate()
        scope = surrounding_agent.running_ec.lexical_environment
        closure = GeneratorFunctionCreate(
            METHOD, self.UniqueFormalParameters, self.GeneratorBody, scope, self.strict
        )
        MakeMethod(closure, object)
        prototype = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%GeneratorPrototype%"])
        DefinePropertyOrThrow(
            closure,
            "prototype",
            PropertyDescriptor(value=prototype, writable=True, enumerable=False, configurable=False),
        )
        SetFunctionName(closure, propKey)
        desc = PropertyDescriptor(value=closure, writable=True, enumerable=enumerable, configurable=True)
        return DefinePropertyOrThrow(object, propKey, desc)


def parse_GeneratorMethod(context, lexer, pos, strict, Yield, Await):
    # 14.4 Generator Function Definitions
    # Syntax
    #   GeneratorMethod[Yield, Await] :
    #       * PropertyName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, ~Await] ) { GeneratorBody }
    star = lexer.token_if(pos, "*")
    if star:
        pn = parse_PropertyName(context, lexer, star.span.after, strict, Yield, Await)
        if pn:
            lp = lexer.token_if(pn.after, "(")
            if lp:
                ufp = parse_UniqueFormalParameters(context, lexer, lp.span.after, strict, True, False)
                if ufp:
                    rp = lexer.token_if(ufp.after, ")")
                    if rp:
                        lc = lexer.token_if(rp.span.after, "{")
                        if lc:
                            gb = parse_GeneratorBody(context, lexer, lc.span.after, strict)
                            if gb:
                                rc = lexer.token_if(gb.after, "}")
                                if rc:
                                    return P2_GeneratorMethod_PropertyName_UniqueFormalParameters_GeneratorBody(
                                        context, strict, [star, pn, lp, ufp, rp, lc, gb, rc]
                                    )
    return None


# --------======= 𝓖𝓮𝓷𝓮𝓻𝓪𝓽𝓸𝓻𝓓𝓮𝓬𝓵𝓪𝓻𝓪𝓽𝓲𝓸𝓷 =======--------
# Syntax
#   GeneratorDeclaration :
#       function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
#       function * ( FormalParameters ) { GeneratorBody }


class P2_GeneratorDeclaration(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "GeneratorDeclaration", strict, children)


class GeneratorCommon(ParseNode2):
    # The common routines for GeneratorDeclarations and GeneratorExpressions
    @property
    def GeneratorBody(self):
        raise NotImplementedError("Abstract classes should not be instantiated")

    @property
    def FormalParameters(self):
        raise NotImplementedError("Abstract classes should not be instantiated")

    @property
    def BindingIdentifier(self):
        raise NotImplementedError("Abstract classes should not be instantiated")

    def EarlyErrors(self):
        # 14.4.1 Static Semantics: Early Errors
        # * If the source code matching this production is strict mode code, the Early Error rules for
        #   UniqueFormalParameters:FormalParameters are applied.
        # * If the source code matching this production is strict mode code, it is a Syntax Error if BindingIdentifier
        #   is present and the StringValue of BindingIdentifier is "eval" or  "arguments".
        # * It is a Syntax Error if ContainsUseStrict of GeneratorBody is true and IsSimpleParameterList of
        #   FormalParameters is false.
        # * It is a Syntax Error if any element of the BoundNames of FormalParameters also occurs in the
        #   LexicallyDeclaredNames of GeneratorBody.
        # * It is a Syntax Error if FormalParameters Contains YieldExpression is true.
        # * It is a Syntax Error if FormalParameters Contains SuperProperty is true.
        # * It is a Syntax Error if GeneratorBody Contains SuperProperty is true.
        # * It is a Syntax Error if FormalParameters Contains SuperCall is true.
        # * It is a Syntax Error if GeneratorBody Contains SuperCall is true.
        errs = []
        if self.strict:
            errs.extend(UniqueFormalParameters_EarlyErrors(self.FormalParameters))
            if self.BindingIdentifier and self.BindingIdentifier.StringValue in ["eval", "arguments"]:
                errs.append(
                    ESSyntaxError('Strict mode disallows "eval" and "arguments" as identifier names in this context')
                )
        if self.GeneratorBody.ContainsUseStrict() and not self.FormalParameters.IsSimpleParameterList():
            errs.append(ESSyntaxError("Parameters must be simple in strict mode"))
        bn = self.FormalParameters.BoundNames()
        ldn = self.GeneratorBody.LexicallyDeclaredNames()
        duplicates = set(bn).intersection(set(ldn))
        if duplicates:
            errs.append(
                ESSyntaxError(
                    "Cannot have the same identifiers in a parameter list and the generator's lexically declared names"
                )
            )
        if self.FormalParameters.Contains("YieldExpression"):
            errs.append(ESSyntaxError("yield expressions not allowed in generator parameter lists"))
        if self.FormalParameters.Contains("SuperProperty"):
            errs.append(ESSyntaxError("super properties not allowed in generator parameter lists"))
        if self.GeneratorBody.Contains("SuperProperty"):
            errs.append(ESSyntaxError("super properties not allowed in generator bodies"))
        if self.FormalParameters.Contains("SuperCall"):
            errs.append(ESSyntaxError("super calls not allowed in generator parameter lists"))
        if self.GeneratorBody.Contains("SuperCall"):
            errs.append(ESSyntaxError("super calls not allowed in generator bodies"))
        return errs

    def Contains(self, symbol):
        # 14.4.4 Static Semantics: Contains
        #       With parameter symbol.
        #   1. Return false.
        return False
        # NOTE
        # Static semantic rules that depend upon substructure generally do not look into function definitions.


class P2_GeneratorDeclaration_FUNCTION_BindingIdentifier_FormalParameters_GeneratorBody(
    P2_GeneratorDeclaration, GeneratorCommon
):
    @property
    def BindingIdentifier(self):
        return self.children[2]

    @property
    def FormalParameters(self):
        return self.children[4]

    @property
    def GeneratorBody(self):
        return self.children[7]

    def BoundNames(self):
        # 14.4.2 Static Semantics: BoundNames
        #   1. Return the BoundNames of BindingIdentifier.
        return self.BindingIdentifier.BoundNames()

    def IsConstantDeclaration(self):
        # 14.4.7 Static Semantics: IsConstantDeclaration
        return False

    def InstantiateFunctionObject(self, scope):
        # 14.4.11 Runtime Semantics: InstantiateFunctionObject
        #       With parameter scope.
        #   1. If the function code for GeneratorDeclaration is strict mode code, let strict be true. Otherwise let
        #      strict be false.
        #   2. Let name be StringValue of BindingIdentifier.
        #   3. Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).
        #   4. Let prototype be ObjectCreate(%GeneratorPrototype%).
        #   5. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype,
        #      [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        #   6. Perform SetFunctionName(F, name).
        #   7. Return F.
        name = self.BindingIdentifier.StringValue
        F = GeneratorFunctionCreate(NORMAL, self.FormalParameters, self.GeneratorBody, scope, self.strict)
        prototype = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%GeneratorPrototype%"])
        DefinePropertyOrThrow(
            F, "prototype", PropertyDescriptor(value=prototype, writable=True, enumerable=False, configurable=False)
        )
        SetFunctionName(F, name)
        return F


class P2_GeneratorDeclaration_FUNCTION_FormalParameters_GeneratorBody(P2_GeneratorDeclaration, GeneratorCommon):
    BindingIdentifier = None

    @property
    def FormalParameters(self):
        return self.children[3]

    @property
    def GeneratorBody(self):
        return self.children[6]

    def BoundNames(self):
        # 14.4.2 Static Semantics: BoundNames
        # GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody }
        #   1. Return « "*default*" ».
        return ["*default*"]

    def IsConstantDeclaration(self):
        # 14.4.7 Static Semantics: IsConstantDeclaration
        return False

    def InstantiateFunctionObject(self, scope):
        # 14.4.11 Runtime Semantics: InstantiateFunctionObject
        #   With parameter scope.
        # GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody }
        #   1. Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, true).
        #   2. Let prototype be ObjectCreate(%GeneratorPrototype%).
        #   3. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype,
        #      [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        #   4. Perform SetFunctionName(F, "default").
        #   5. Set F.[[SourceText]] to the source text matched by GeneratorDeclaration.
        #   6. Return F.
        F = GeneratorFunctionCreate(NORMAL, self.FormalParameters, self.GeneratorBody, scope, True)
        prototype = ObjectCreate(surrounding_agent.running_ec.realm["%GeneratorPrototype%"])
        DefinePropertyOrThrow(
            F, "prototype", PropertyDescriptor(value=prototype, writable=True, enumerable=False, configurable=False)
        )
        SetFunctionName(F, "default")
        F.SourceText = self.matched_source()
        return F


def parse_GeneratorDeclaration(context, lexer, pos, strict, Yield, Await, Default):
    # 14.4 Generator Function Definitions
    # Syntax
    # GeneratorDeclaration[Yield, Await, Default] :
    #   function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
    #   [+Default] function * ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
    fun = lexer.id_if(pos, "function")
    if fun:
        star = lexer.token_if(fun.span.after, "*")
        if star:
            bi = parse_BindingIdentifier(context, lexer, star.span.after, strict, Yield, Await)
            if bi or Default:
                lp = lexer.token_if(bi.after if bi else star.span.after, "(")
                if lp:
                    fp = parse_FormalParameters(context, lexer, lp.span.after, strict, True, False)
                    if fp:
                        rp = lexer.token_if(fp.after, ")")
                        if rp:
                            lc = lexer.token_if(rp.span.after, "{")
                            if lc:
                                gb = parse_GeneratorBody(context, lexer, lc.span.after, strict)
                                if gb:
                                    rc = lexer.token_if(gb.after, "}")
                                    if rc:
                                        ctor = (
                                            P2_GeneratorDeclaration_FUNCTION_BindingIdentifier_FormalParameters_GeneratorBody
                                            if bi
                                            else P2_GeneratorDeclaration_FUNCTION_FormalParameters_GeneratorBody
                                        )
                                        children = list(filter(None, [fun, star, bi, lp, fp, rp, lc, gb, rc]))
                                        return ctor(context, strict, children)
    return None


# --------======= 𝓖𝓮𝓷𝓮𝓻𝓪𝓽𝓸𝓻𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   GeneratorExpression :
#       function * BindingIdentifier[opt] ( FormalParameters ) { GeneratorBody }


class P2_GeneratorExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "GeneratorExpression", strict, children)

    def IsFunctionDefinition(self):
        # 14.4.8 Static Semantics: IsFunctionDefinition
        return True


class P2_GeneratorExpression_FUNCTION_BindingIdentifier_FormalParameters_GeneratorBody(
    P2_GeneratorExpression, GeneratorCommon
):
    @property
    def BindingIdentifier(self):
        return self.children[2]

    @property
    def FormalParameters(self):
        return self.children[4]

    @property
    def GeneratorBody(self):
        return self.children[7]

    def HasName(self):
        # 14.4.6 Static Semantics: HasName
        #   1. Return true.
        return True

    def evaluate(self):
        # 14.4.13 Runtime Semantics: Evaluation
        #   1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise
        #      let strict be false.
        #   2. Let scope be the running execution context's LexicalEnvironment.
        #   3. Let funcEnv be NewDeclarativeEnvironment(scope).
        #   4. Let envRec be funcEnv's EnvironmentRecord.
        #   5. Let name be StringValue of BindingIdentifier.
        #   6. Perform envRec.CreateImmutableBinding(name, false).
        #   7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).
        #   8. Let prototype be ObjectCreate(%GeneratorPrototype%).
        #   9. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype,
        #      [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        #   10. Perform SetFunctionName(closure, name).
        #   11. Perform envRec.InitializeBinding(name, closure).
        #   12. Return closure.
        scope = surrounding_agent.running_ec.lexical_environment
        funcEnv = NewDeclarativeEnvironment(scope)
        envRec = funcEnv.environment_record
        name = self.BindingIdentifier.StringValue
        envRec.CreateImmutableBinding(name, False)
        closure = GeneratorFunctionCreate(NORMAL, self.FormalParameters, self.GeneratorBody, funcEnv, self.strict)
        prototype = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%GeneratorPrototype%"])
        DefinePropertyOrThrow(
            closure,
            "prototype",
            PropertyDescriptor(value=prototype, writable=True, enumerable=False, configurable=False),
        )
        SetFunctionName(closure, name)
        envRec.InitializeBinding(name, closure)
        return closure
        # NOTE
        # The BindingIdentifier in a GeneratorExpression can be referenced from inside the GeneratorExpression's
        # FunctionBody to allow the generator code to call itself recursively. However, unlike in a
        # GeneratorDeclaration, the BindingIdentifier in a GeneratorExpression cannot be referenced from and does not
        # affect the scope enclosing the GeneratorExpression.


class P2_GeneratorExpression_FUNCTION_FormalParameters_GeneratorBody(P2_GeneratorExpression, GeneratorCommon):
    BindingIdentifier = None

    @property
    def FormalParameters(self):
        return self.children[3]

    @property
    def GeneratorBody(self):
        return self.children[6]

    def HasName(self):
        # 14.4.6 Static Semantics: HasName
        #   1. Return false.
        return False

    def evaluate(self):
        # 14.4.13 Runtime Semantics: Evaluation
        #   1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise
        #      let strict be false.
        #   2. Let scope be the LexicalEnvironment of the running execution context.
        #   3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).
        #   4. Let prototype be ObjectCreate(%GeneratorPrototype%).
        #   5. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype,
        #      [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        #   6. Return closure.
        scope = surrounding_agent.running_ec.lexical_environment
        closure = GeneratorFunctionCreate(NORMAL, self.FormalParameters, self.GeneratorBody, scope, self.strict)
        prototype = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%GeneratorPrototype%"])
        DefinePropertyOrThrow(
            closure,
            "prototype",
            PropertyDescriptor(value=prototype, writable=True, enumerable=False, configurable=False),
        )
        return closure


def parse_GeneratorExpression(context, lexer, pos, strict):
    # 14.4 Generator Function Definitions
    # Syntax
    #   GeneratorExpression :
    #       function * BindingIdentifier[+Yield, ~Await]opt ( FormalParameters[+Yield, ~Await] ) { GeneratorBody }
    fun = lexer.id_if(pos, "function")
    if fun:
        star = lexer.token_if(fun.span.after, "*")
        if star:
            bi = parse_BindingIdentifier(context, lexer, star.span.after, strict, True, False)
            lp = lexer.token_if(bi.after if bi else star.span.after, "(")
            if lp:
                fp = parse_FormalParameters(context, lexer, lp.span.after, strict, True, False)
                if fp:
                    rp = lexer.token_if(fp.after, ")")
                    if rp:
                        lc = lexer.token_if(rp.span.after, "{")
                        if lc:
                            gb = parse_GeneratorBody(context, lexer, lc.span.after, strict)
                            if gb:
                                rc = lexer.token_if(gb.after, "}")
                                if rc:
                                    ctor = (
                                        P2_GeneratorExpression_FUNCTION_BindingIdentifier_FormalParameters_GeneratorBody
                                        if bi
                                        else P2_GeneratorExpression_FUNCTION_FormalParameters_GeneratorBody
                                    )
                                    children = list(filter(None, [fun, star, bi, lp, fp, rp, lc, gb, rc]))
                                    return ctor(context, strict, children)
    return None


# --------======= 𝓖𝓮𝓷𝓮𝓻𝓪𝓽𝓸𝓻𝓑𝓸𝓭𝔂 =======--------
# Syntax
#   GeneratorBody :
#       FunctionBody


class P2_GeneratorBody(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "GeneratorBody", strict, children)


class P2_GeneratorBody_FunctionBody(P2_GeneratorBody):
    @property
    def FunctionBody(self):
        return self.children[0]

    def EvaluateBody(self, functionObject, argumentsList):
        # 14.4.10 Runtime Semantics: EvaluateBody
        #       With parameters functionObject and List argumentsList.
        #   1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
        #   2. Let G be ? OrdinaryCreateFromConstructor(functionObject, "%GeneratorPrototype%", « [[GeneratorState]],
        #      [[GeneratorContext]] »).
        #   3. Perform GeneratorStart(G, FunctionBody).
        #   4. Return Completion { [[Type]]: return, [[Value]]: G, [[Target]]: empty }.
        FunctionDeclarationInstantiation(functionObject, argumentsList)
        G = OrdinaryCreateFromConstructor(
            functionObject, "%GeneratorPrototype%", ["GeneratorState", "GeneratorContext"]
        )
        GeneratorStart(G, self.FunctionBody)
        raise ESReturn(value=G)


def parse_GeneratorBody(context, lexer, pos, strict):
    # 14.4 Generator Function Definitions
    # Syntax
    #   GeneratorBody :
    #       FunctionBody[+Yield, ~Await]
    fb = parse_FunctionBody(context, lexer, pos, strict, True, False)
    if fb:
        return P2_GeneratorBody_FunctionBody(context, fb.strict, [fb])
    return None


# --------======= 𝓨𝓲𝓮𝓵𝓭𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷 =======--------
# Syntax
#   YieldExpression :
#       yield
#       yield AssignmentExpression
#       yield * AssignmentExpression


class P2_YieldExpression(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "YieldExpression", strict, children)


class P2_YieldExpression_YIELD(P2_YieldExpression):
    def evaluate(self):
        # 14.4.13 Runtime Semantics: Evaluation
        #   1. Let generatorKind be ! GetGeneratorKind().
        #   2. If generatorKind is async, then return ? AsyncGeneratorYield(undefined).
        #   3. Otherwise, return ? GeneratorYield(CreateIterResultObject(undefined, false)).
        if GetGeneratorKind() == ASYNC:
            return AsyncGeneratorYield(None)
        iro = CreateIterResultObject(None, False)
        result = GeneratorYield(iro)
        return result


class P2_YieldExpression_YIELD_AssignmentExpression(P2_YieldExpression):
    @property
    def AssignmentExpression(self):
        return self.children[1]

    def evaluate(self):
        # 14.4.13 Runtime Semantics: Evaluation
        #   1. Let generatorKind be ! GetGeneratorKind().
        #   2. Let exprRef be the result of evaluating AssignmentExpression.
        #   3. Let value be ? GetValue(exprRef).
        #   4. If generatorKind is async, then return ? AsyncGeneratorYield(value).
        #   5. Otherwise, return ? GeneratorYield(CreateIterResultObject(value, false)).
        generatorKind = GetGeneratorKind()
        value = GetValue(self.AssignmentExpression.evaluate())
        if generatorKind == ASYNC:
            return AsyncGeneratorYield(value)
        iro = CreateIterResultObject(value, False)
        result = GeneratorYield(iro)
        return result


class P2_YieldExpression_YIELD_STAR_AssignmentExpression(P2_YieldExpression):
    @property
    def AssignmentExpression(self):
        return self.children[2]

    def evaluate(self):
        # 14.4.13 Runtime Semantics: Evaluation
        #   1. Let generatorKind be ! GetGeneratorKind().
        #   2. Let exprRef be the result of evaluating AssignmentExpression.
        #   3. Let value be ? GetValue(exprRef).
        #   4. Let iteratorRecord be ? GetIterator(value, generatorKind).
        #   5. Let iterator be iteratorRecord.[[Iterator]].
        #   6. Let received be NormalCompletion(undefined).
        #   7. Repeat,
        #       a. If received.[[Type]] is normal, then
        #           i. Let innerResult be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « received.[[Value]] »).
        #           ii. If generatorKind is async, then set innerResult to ? Await(innerResult).
        #           iii. If Type(innerResult) is not Object, throw a TypeError exception.
        #           iv. Let done be ? IteratorComplete(innerResult).
        #           v. If done is true, then
        #               1. Return ? IteratorValue(innerResult).
        #           vi. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).
        #           vii. Else, set received to GeneratorYield(innerResult).
        #       b. Else if received.[[Type]] is throw, then
        #           i. Let throw be ? GetMethod(iterator, "throw").
        #           ii. If throw is not undefined, then
        #               1. Let innerResult be ? Call(throw, iterator, « received.[[Value]] »).
        #               2. If generatorKind is async, then set innerResult to ? Await(innerResult).
        #               3. NOTE: Exceptions from the inner iterator throw method are propagated. Normal completions from an inner throw method are processed similarly to an inner next.
        #               4. If Type(innerResult) is not Object, throw a TypeError exception.
        #               5. Let done be ? IteratorComplete(innerResult).
        #               6. If done is true, then
        #                   a. Return ? IteratorValue(innerResult).
        #               7. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).
        #               8. Else, set received to GeneratorYield(innerResult).
        #           iii. Else,
        #               1. NOTE: If iterator does not have a throw method, this throw is going to terminate the yield* loop. But first we need to give iterator a chance to clean up.
        #               2. Let closeCompletion be Completion { [[Type]]: normal, [[Value]]: empty, [[Target]]: empty }.
        #               3. If generatorKind is async, perform ? AsyncIteratorClose(iteratorRecord, closeCompletion).
        #               4. Else, perform ? IteratorClose(iteratorRecord, closeCompletion).
        #               5. NOTE: The next step throws a TypeError to indicate that there was a yield* protocol violation: iterator does not have a throw method.
        #               6. Throw a TypeError exception.
        #       c. Else,
        #           i. Assert: received.[[Type]] is return.
        #           ii. Let return be ? GetMethod(iterator, "return").
        #           iii. If return is undefined, then
        #               1. If generatorKind is async, then set received.[[Value]] to ? Await(received.[[Value]]).
        #               2. Return Completion(received).
        #           iv. Let innerReturnResult be ? Call(return, iterator, « received.[[Value]] »).
        #           v. If generatorKind is async, then set innerReturnResult to ? Await(innerReturnResult).
        #           vi. If Type(innerReturnResult) is not Object, throw a TypeError exception.
        #           vii. Let done be ? IteratorComplete(innerReturnResult).
        #           viii. If done is true, then
        #               1. Let value be ? IteratorValue(innerReturnResult).
        #               2. Return Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
        #           ix. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerReturnResult)).
        #           x. Else, set received to GeneratorYield(innerReturnResult).
        generatorKind = GetGeneratorKind()
        value = GetValue(self.AssignmentExpression.evaluate())
        iteratorRecord = GetIterator(value, generatorKind)
        iterator = iteratorRecord.Iterator
        received = Completion(CompletionType.NORMAL, None, EMPTY)
        while 1:
            if received.ctype == CompletionType.NORMAL:
                innerResult = Call(iteratorRecord.NextMethod, iteratorRecord.Iterator, [received.value])
                if generatorKind == ASYNC:
                    innerResult = Await(innerResult)
                if not isObject(innerResult):
                    raise ESTypeError("Iterator Corrupted")
                done = IteratorComplete(innerResult)
                if done:
                    return IteratorValue(innerResult)
                try:
                    if generatorKind == ASYNC:
                        rval = AsyncGeneratorYield(IteratorValue(innerResult))
                    else:
                        rval = GeneratorYield(innerResult)
                    received = Completion(CompletionType.NORMAL, value=rval, target=EMPTY)
                except ESError as err:
                    received = Completion(CompletionType.THROW, value=err.ecma_object, target=EMPTY)
                except ESAbrupt as abrupt:
                    received = abrupt.completion
            elif received.ctype == CompletionType.THROW:
                throw = GetMethod(iterator, "throw")
                if throw is not None:
                    innerResult = Call(throw, iterator, [received.value])
                    if generatorKind == ASYNC:
                        innerResult = Await(innerResult)
                    if not isObject(innerResult):
                        raise ESTypeError("Iterator corruption in generator")
                    done = IteratorComplete(innerResult)
                    if done:
                        return IteratorValue(innerResult)
                    try:
                        if generatorKind == ASYNC:
                            rval = AsyncGeneratorYield(IteratorValue(innerResult))
                        else:
                            rval = GeneratorYield(innerResult)
                        received = Completion(CompletionType.NORMAL, rval, EMPTY)
                    except ESError as err:
                        received = Completion(CompletionType.THROW, err.ecma_object, EMPTY)
                    except ESAbrupt as abrupt:
                        received = abrupt.completion
                else:
                    if generatorKind == ASYNC:
                        AsyncIteratorClose(iteratorRecord)
                    else:
                        IteratorClose(iteratorRecord)
                    raise ESTypeError("Generator has no throw method")
            else:
                assert received.ctype == CompletionType.RETURN
                return_method = GetMethod(iterator, "return")
                if return_method is None:
                    if generatorKind == ASYNC:
                        received.value = Await(received.value)
                    raise ESReturn(received.value, received.target)
                innerReturnResult = Call(return_method, iterator, [received.value])
                if generatorKind == ASYNC:
                    innerReturnResult = Await(innerReturnResult)
                if not isObject(innerReturnResult):
                    raise ESTypeError("Non-object result from return method of iterator")
                done = IteratorComplete(innerReturnResult)
                if done:
                    raise ESReturn(IteratorValue(innerReturnResult))
                try:
                    if generatorKind == ASYNC:
                        rval = AsyncGeneratorYield(IteratorValue(innerReturnResult))
                    else:
                        rval = GeneratorYield(innerReturnResult)
                    received = Completion(CompletionType.NORMAL, rval, EMPTY)
                except ESError as err:
                    received = Completion(CompletionType.THROW, err.ecma_object, EMPTY)
                except ESAbrupt as abrupt:
                    received = abrupt.completion


def parse_YieldExpression(context, lexer, pos, strict, In, Await):
    # 14.4 Generator Function Definitions
    # Syntax
    #   YieldExpression[In, Await]:
    #       yield
    #       yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
    #       yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await]
    y = lexer.id_if(pos, "yield")
    if y:
        ltcheck = lexer.token(y.span.after, goal=lexer.InputElementRegExpOrTemplateTail)
        if not ltcheck or ltcheck.newlines:
            return P2_YieldExpression_YIELD(context, strict, [y])
        star = lexer.token_if(y.span.after, "*")
        ae = parse_AssignmentExpression(
            context, lexer, star.span.after if star else y.span.after, strict, In, True, Await
        )
        if ae:
            ctor = (
                P2_YieldExpression_YIELD_AssignmentExpression
                if not star
                else P2_YieldExpression_YIELD_STAR_AssignmentExpression
            )
            children = list(filter(None, [y, star, ae]))
            return ctor(context, children)
    return None


############################################################################
# `·._.·●.._.·●.._.·●..... 14.6 Class Definitions .....●·._..●·._..●·._.·´ #
############################################################################
# 14.6 Class Definitions
# 14.6.1 SS: Early Errors
# 14.6.2 SS: BoundNames
# 14.6.3 SS: ConstructorMethod
# 14.6.4 SS: Contains
# 14.6.5 SS: ComputedPropertyContains
# 14.6.6 SS: HasName
# 14.6.7 SS: IsConstantDeclaration
# 14.6.8 SS: IsFunctionDefinition
# 14.6.9 SS: IsStatic
# 14.6.10 SS: NonConstructorMethodDefinitions
# 14.6.11 SS: PrototypePropertyNameList
# 14.6.12 SS: PropName
# 14.6.13 RS: ClassDefinitionEvaluation
# 14.6.14 RS: BindingClassDeclarationEvaluation
# 14.6.15 RS: NamedEvaluation
# 14.6.16 RS: Evaluation
############################################################################

# --------======= ClassDeclaration =======--------
# Syntax
#   ClassDeclaration :
#       class BindingIdentifier ClassTail
#       [+Default]class ClassTail


class P2_ClassDeclaration(ParseNode2):
    def __init__(self, ctx, children):
        super().__init__(ctx, "ClassDeclaration", True, children)

    def IsConstantDeclaration(self):
        # 14.6.7 Static Semantics: IsConstantDeclaration
        # ClassDeclaration : class BindingIdentifier ClassTail
        # ClassDeclaration : class ClassTail
        #   1. Return false.
        return False


class P2_ClassDeclaration_CLASS_BindingIdentifier_ClassTail(P2_ClassDeclaration):
    @cached_property
    def BindingIdentifier(self):
        return self.children[1]

    @cached_property
    def ClassTail(self):
        return self.children[2]

    def BoundNames(self):
        # 14.6.2 Static Semantics: BoundNames
        # ClassDeclaration : class BindingIdentifier ClassTail
        #   1. Return the BoundNames of BindingIdentifier.
        return self.BindingIdentifier.BoundNames()

    def BindingClassDeclarationEvaluation(self):
        # 14.6.14 Runtime Semantics: BindingClassDeclarationEvaluation
        # ClassDeclaration : class BindingIdentifier ClassTail
        #   1. Let className be StringValue of BindingIdentifier.
        #   2. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments className and className.
        #   3. ReturnIfAbrupt(value).
        #   4. Set value.[[SourceText]] to the source text matched by ClassDeclaration.
        #   5. Let env be the running execution context's LexicalEnvironment.
        #   6. Perform ? InitializeBoundName(className, value, env).
        #   7. Return value.
        className = self.BindingIdentifier.StringValue
        value = self.ClassTail.ClassDefinitionEvaluation(className, className)
        value.SourceText = self.matched_source()
        env = surrounding_agent.running_ec.lexical_environment
        InitializeBoundName(className, value, env, self.strict)
        return value

    def evaluate(self):
        # 14.6.16 Runtime Semantics: Evaluation
        # ClassDeclaration : class BindingIdentifier ClassTail
        #   1. Perform ? BindingClassDeclarationEvaluation of this ClassDeclaration.
        #   2. Return NormalCompletion(empty).
        self.BindingClassDeclarationEvaluation()
        return EMPTY


class P2_ClassDeclaration_CLASS_ClassTail(P2_ClassDeclaration):
    @cached_property
    def ClassTail(self):
        return self.children[1]

    def BoundNames(self):
        # 14.6.2 Static Semantics: BoundNames
        # ClassDeclaration : class ClassTail
        #   1. Return « "*default*" ».
        return ["*default*"]

    def BindingClassDeclarationEvaluation(self):
        # 14.6.14 Runtime Semantics: BindingClassDeclarationEvaluation
        # ClassDeclaration : class ClassTail
        #   1. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and
        #      "default".
        #   2. ReturnIfAbrupt(value).
        #   3. Set value.[[SourceText]] to the source text matched by ClassDeclaration.
        #   4. Return value.
        # NOTE  | ClassDeclaration:classClassTail only occurs as part of an ExportDeclaration and establishing its
        #       | binding is handled as part of the evaluation action for that production. See 15.2.3.11.
        value = self.ClassTail.ClassDefinitionEvaluation(None, "default")
        value.SourceText = self.matched_source()
        return value


def parse_ClassDeclaration(context, lexer, pos, _, Yield, Await, Default):
    # 14.6 Class Definitions
    #   ClassDeclaration[Yield, Await, Default] :
    #       class BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
    #       [+Default]class ClassTail[?Yield, ?Await]
    c = lexer.id_if(pos, "class")
    if c:
        bi = parse_BindingIdentifier(context, lexer, c.span.after, True, Yield, Await)
        if bi or Default:
            ct = parse_ClassTail(context, lexer, bi.after if bi else c.span.after, True, Yield, Await)
            if ct:
                if bi:
                    return P2_ClassDeclaration_CLASS_BindingIdentifier_ClassTail(context, [c, bi, ct])
                return P2_ClassDeclaration_CLASS_ClassTail(context, [c, ct])
    return None


# --------======= ClassExpression =======--------
# Syntax
#   ClassExpression[Yield, Await]:
#       class BindingIdentifier ClassTail
#       class ClassTail
class P2_ClassExpression(ParseNode2):
    def __init__(self, ctx, children):
        super().__init__(ctx, "ClassExpression", True, children)

    class_name = None

    @cached_property
    def ClassTail(self):
        raise ValueError("ClassTail access from base class P2_ClassExpression")

    def evaluate(self):
        # 14.6.16 Runtime Semantics: Evaluation
        # ClassExpression : class BindingIdentifier ClassTail
        #   1. If BindingIdentifieropt is not present, let className be undefined.
        #   2. Else, let className be StringValue of BindingIdentifier.
        #   3. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments className and className.
        #   4. ReturnIfAbrupt(value).
        #   5. Set value.[[SourceText]] to the source text matched by ClassExpression.
        #   6. Return value.
        className = self.class_name
        value = self.ClassTail.ClassDefinitionEvaluation(className, className)
        value.SourceText = self.matched_source()
        return value

    def IsFunctionDefinition(self):
        # 14.6.8 Static Semantics: IsFunctionDefinition
        # ClassExpression : class BindingIdentifier ClassTail
        #   1. Return true.
        return True


class P2_ClassExpression_CLASS_BindingIdentifier_ClassTail(P2_ClassExpression):
    @cached_property
    def BindingIdentifier(self):
        return self.children[1]

    @cached_property
    def ClassTail(self):
        return self.children[2]

    @cached_property
    def class_name(self):
        return self.BindingIdentifier.StringValue

    def HasName(self):
        # 14.6.6 Static Semantics: HasName
        # ClassExpression : class BindingIdentifier ClassTail
        #   1. Return true.
        return True


class P2_ClassExpression_CLASS_ClassTail(P2_ClassExpression):
    @cached_property
    def ClassTail(self):
        return self.children[1]

    class_name = None

    def HasName(self):
        # 14.6.6 Static Semantics: HasName
        # ClassExpression : class ClassTail
        #   1. Return false.
        return False

    def NamedEvaluation(self, name):
        # 14.6.15 Runtime Semantics: NamedEvaluation
        #   With parameter name.
        # ClassExpression : class ClassTail
        #   1. Return the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and name.
        return self.ClassTail.ClassDefinitionEvaluation(None, name)


def parse_ClassExpression(context, lexer, pos, _, Yield, Await):
    # 14.6 Class Definitions
    #   ClassExpression[Yield, Await]:
    #       class BindingIdentifier[?Yield, ?Await]opt ClassTail[?Yield, ?Await]
    c = lexer.id_if(pos, "class")
    if c:
        bi = parse_BindingIdentifier(context, lexer, c.span.after, True, Yield, Await)
        ct = parse_ClassTail(context, lexer, bi.after if bi else c.span.after, True, Yield, Await)
        if ct:
            if bi:
                return P2_ClassExpression_CLASS_BindingIdentifier_ClassTail(context, [c, bi, ct])
            return P2_ClassExpression_CLASS_ClassTail(context, [c, ct])
    return None


# --------======= ClassTail =======--------
# Syntax
#   ClassTail:
#       { }
#       { ClassBody }
#       ClassHeritage { }
#       ClassHeritage { ClassBody }


class P2_ClassTail(ParseNode2):
    def __init__(self, ctx, children):
        super().__init__(ctx, "ClassTail", True, children)

    ClassBody = None
    ClassHeritage = None

    def ClassDefinitionEvaluation(self, classBinding, className):
        # 14.6.13 Runtime Semantics: ClassDefinitionEvaluation
        #   With parameters classBinding and className.
        # ClassTail : ClassHeritage { ClassBody }
        #   1. Let lex be the LexicalEnvironment of the running execution context.
        #   2. Let classScope be NewDeclarativeEnvironment(lex).
        #   3. Let classScopeEnvRec be classScope's EnvironmentRecord.
        #   4. If classBinding is not undefined, then
        #       a. Perform classScopeEnvRec.CreateImmutableBinding(classBinding, true).
        #   5. If ClassHeritage[opt] is not present, then
        #       a. Let protoParent be the intrinsic object %ObjectPrototype%.
        #       b. Let constructorParent be the intrinsic object %FunctionPrototype%.
        #   6. Else,
        #       a. Set the running execution context's LexicalEnvironment to classScope.
        #       b. Let superclassRef be the result of evaluating ClassHeritage.
        #       c. Set the running execution context's LexicalEnvironment to lex.
        #       d. Let superclass be ? GetValue(superclassRef).
        #       e. If superclass is null, then
        #           i. Let protoParent be null.
        #           ii. Let constructorParent be the intrinsic object %FunctionPrototype%.
        #       f. Else if IsConstructor(superclass) is false, throw a TypeError exception.
        #       g. Else,
        #           i. Let protoParent be ? Get(superclass, "prototype").
        #           ii. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.
        #           iii. Let constructorParent be superclass.
        #   7. Let proto be ObjectCreate(protoParent).
        #   8. If ClassBody[opt] is not present, let constructor be empty.
        #   9. Else, let constructor be ConstructorMethod of ClassBody.
        #   10. If constructor is empty, then
        #       a. If ClassHeritageopt is present, then
        #           i. Set constructor to the result of parsing the source text
        #               constructor(... args){ super (...args);}
        #              using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].
        #       b. Else,
        #           i. Set constructor to the result of parsing the source text
        #               constructor(){ }
        #              using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].
        #   11. Set the running execution context's LexicalEnvironment to classScope.
        #   12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto
        #       and constructorParent as the optional functionPrototype argument.
        #   13. Assert: constructorInfo is not an abrupt completion.
        #   14. Let F be constructorInfo.[[Closure]].
        #   15. If ClassHeritageopt is present, set F.[[ConstructorKind]] to "derived".
        #   16. Perform MakeConstructor(F, false, proto).
        #   17. Perform MakeClassConstructor(F).
        #   18. If className is not undefined, then
        #       a. Perform SetFunctionName(F, className).
        #   19. Perform CreateMethodProperty(proto, "constructor", F).
        #   20. If ClassBodyopt is not present, let methods be a new empty List.
        #   21. Else, let methods be NonConstructorMethodDefinitions of ClassBody.
        #   22. For each ClassElement m in order from methods, do
        #       a. If IsStatic of m is false, then
        #           i. Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.
        #       b. Else,
        #           i. Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.
        #       c. If status is an abrupt completion, then
        #           i. Set the running execution context's LexicalEnvironment to lex.
        #           ii. Return Completion(status).
        #   23. Set the running execution context's LexicalEnvironment to lex.
        #   24. If classBinding is not undefined, then
        #       a. Perform classScopeEnvRec.InitializeBinding(classBinding, F).
        #   25. Return F.
        running_ec = surrounding_agent.running_ec
        realm = running_ec.realm
        lex = running_ec.lexical_environment
        classScope = NewDeclarativeEnvironment(lex)
        classScopeEnvRec = classScope.environment_record
        if classBinding is not None:
            classScopeEnvRec.CreateImmutableBinding(classBinding, True)
        if self.ClassHeritage is None:
            protoParent = realm.intrinsics["%ObjectPrototype%"]
            constructorParent = realm.intrinsics["%FunctionPrototype%"]
        else:
            running_ec.lexical_environment = classScope
            superclassRef = self.ClassHeritage.evaluate()
            running_ec.lexical_environment = lex
            superclass = GetValue(superclassRef)
            if isNull(superclass):
                protoParent = JSNull.NULL
                constructorParent = realm.intrinsics["%FunctionPrototype%"]
            elif not IsConstructor(superclass):
                raise ESTypeError("Class super must be a constructor")
            else:
                protoParent = Get(superclass, "prototype")
                if not isNull(protoParent) and not isObject(protoParent):
                    raise ESTypeError("Class prototype must be null or an object")
                constructorParent = superclass
        proto = ObjectCreate(protoParent)
        if self.ClassBody is None:
            constructor = None
        else:
            constructor = self.ClassBody.ConstructorMethod
        if not constructor:
            method_context = Parse2Context(False, self.CreateSyntaxError, "MethodDefinition")
            lexer = LexerCore(
                "constructor(... args){super(...args);}" if self.ClassHeritage else "constructor(){}",
                self.CreateSyntaxError,
            )
            constructor = parse_MethodDefinition(method_context, lexer, 0, True, False, False)
        running_ec.lexical_environment = classScope
        constructorInfo = constructor.DefineMethod(proto, constructorParent)
        F = constructorInfo.Closure
        if self.ClassHeritage:
            F.ConstructorKind = "derived"
        MakeConstructor(F, False, proto)
        MakeClassConstructor(F)
        if className is not None:
            SetFunctionName(F, className)
        CreateMethodProperty(proto, "constructor", F)
        methods = self.ClassBody.NonConstructorMethodDefinitions if self.ClassBody else []
        try:
            for m in methods:
                obj = F if m.IsStatic else proto
                m.PropertyDefinitionEvaluation(obj, False)
        finally:
            running_ec.lexical_environment = lex
        if classBinding is not None:
            classScopeEnvRec.InitializeBinding(classBinding, F)
        return F


class P2_ClassTail_EMPTY(P2_ClassTail):
    pass


class P2_ClassTail_ClassBody(P2_ClassTail):
    @cached_property
    def ClassBody(self):
        return self.children[1]

    ClassHeritage = None

    def EarlyErrors(self):
        # 14.6.1 Static Semantics: Early Errors
        # ClassTail : ClassHeritage { ClassBody }
        # It is a Syntax Error if ClassHeritage is not present and the following algorithm evaluates to true:
        #   1. Let constructor be ConstructorMethod of ClassBody.
        #   2. If constructor is empty, return false.
        #   3. Return HasDirectSuper of constructor.
        constructor = self.ClassBody.ConstructorMethod
        if constructor and constructor.HasDirectSuper():
            return [self.CreateSyntaxError("Direct Super not allowed in class constructors")]
        return []

    def Contains(self, symbol):
        # 14.6.4 Static Semantics: Contains
        #   With parameter symbol.
        # ClassTail : ClassHeritage { ClassBody }
        #   1. If symbol is ClassBody, return true.
        #   2. If symbol is ClassHeritage, then
        #       a. If ClassHeritage is present, return true; otherwise return false.
        #   3. Let inHeritage be ClassHeritage Contains symbol.
        #   4. If inHeritage is true, return true.
        #   5. Return the result of ComputedPropertyContains for ClassBody with argument symbol.
        # NOTE  | Static semantic rules that depend upon substructure generally do not look into class bodies except
        #       | for PropertyNames.
        if symbol == "ClassBody":
            return True
        if symbol == "ClassHeritage":
            return False
        return self.ClassBody.ComputedPropertyContains(symbol)


class P2_ClassTail_ClassHeritage(P2_ClassTail):
    @cached_property
    def ClassHeritage(self):
        return self.children[0]

    ClassBody = None


class P2_ClassTail_ClassHeritage_ClassBody(P2_ClassTail):
    @cached_property
    def ClassHeritage(self):
        return self.children[0]

    @cached_property
    def ClassBody(self):
        return self.children[2]

    def Contains(self, symbol):
        # 14.6.4 Static Semantics: Contains
        #   With parameter symbol.
        # ClassTail : ClassHeritage { ClassBody }
        #   1. If symbol is ClassBody, return true.
        #   2. If symbol is ClassHeritage, then
        #       a. If ClassHeritage is present, return true; otherwise return false.
        #   3. Let inHeritage be ClassHeritage Contains symbol.
        #   4. If inHeritage is true, return true.
        #   5. Return the result of ComputedPropertyContains for ClassBody with argument symbol.
        # NOTE  | Static semantic rules that depend upon substructure generally do not look into class bodies except
        #       | for PropertyNames.
        return (
            symbol in ("ClassBody", "ClassHeritage")
            or self.ClassHeritage.Contains(symbol)
            or self.ClassBody.ComputedPropertyContains(symbol)
        )


def parse_ClassTail(context, lexer, pos, _, Yield, Await):
    # 14.6 Class Definitions
    #   ClassTail[Yield, Await]:
    #       ClassHeritage[?Yield, ?Await]opt { ClassBody[?Yield, ?Await]opt }
    ch = parse_ClassHeritage(context, lexer, pos, True, Yield, Await)
    lc = lexer.token_if(ch.after if ch else pos, "{")
    if lc:
        cb = parse_ClassBody(context, lexer, lc.span.after, True, Yield, Await)
        rc = lexer.token_if(cb.after if cb else lc.span.after, "}")
        if rc:
            if ch and cb:
                return P2_ClassTail_ClassHeritage_ClassBody(context, [ch, lc, cb, rc])
            if ch:
                return P2_ClassTail_ClassHeritage(context, [ch, lc, rc])
            if cb:
                return P2_ClassTail_ClassBody(context, [lc, cb, rc])
            return P2_ClassTail_EMPTY(context, [lc, rc])
    return None


# --------======= ClassHeritage =======--------
# Syntax
#   ClassHeritage:
#       extends LeftHandSideExpression
class P2_ClassHeritage(ParseNode2):
    def __init__(self, ctx, children):
        super().__init__(ctx, "ClassHeritage", True, children)


class P2_ClassHeritage_EXTENDS_LeftHandSideExpression(P2_ClassHeritage):
    @cached_property
    def LeftHandSideExpression(self):
        return self.children[1]


def parse_ClassHeritage(context, lexer, pos, _, Yield, Await):
    # 14.6 Class Definitions
    #   ClassHeritage[Yield, Await]:
    #       extends LeftHandSideExpression[?Yield, ?Await]
    e = lexer.id_if(pos, "extends")
    if e:
        lhs = parse_LeftHandSideExpression(context, lexer, e.span.after, True, Yield, Await)
        if lhs:
            return P2_ClassHeritage_EXTENDS_LeftHandSideExpression(context, [e, lhs])
    return None


# --------======= ClassBody =======--------
# Syntax
# ClassBody:
#   ClassElementList
class P2_ClassBody(ParseNode2):
    def __init__(self, ctx, children):
        super().__init__(ctx, "ClassBody", True, children)


class P2_ClassBody_ClassElementList(P2_ClassBody):
    @cached_property
    def ClassElementList(self):
        return self.children[0]

    def EarlyErrors(self):
        # 14.6.1 Static Semantics: Early Errors
        # ClassBody : ClassElementList
        #   * It is a Syntax Error if PrototypePropertyNameList of ClassElementList contains more than one
        #     occurrence of "constructor".
        return list(
            filter(
                None,
                (
                    self.ClassElementList.PrototypePropertyNameList.count("constructor") > 1
                    and self.CreateSyntaxError("Classes may only have one constructor"),
                ),
            )
        )


def parse_ClassBody(context, lexer, pos, _, Yield, Await):
    # 14.6 Class Definitions
    #   ClassBody[Yield, Await]:
    #     ClassElementList[?Yield, ?Await]
    cel = parse_ClassElementList(context, lexer, pos, True, Yield, Await)
    if cel:
        return P2_ClassBody_ClassElementList(context, [cel])
    return None


# --------======= ClassElementList =======--------
# Syntax
#   ClassElementList:
#     ClassElement
#     ClassElementList ClassElement
class P2_ClassElementList(ParseNode2):
    def __init__(self, ctx, children):
        super().__init__(ctx, "ClassElementList", True, children)


class P2_ClassElementList_ClassElement(P2_ClassElementList):
    @cached_property
    def ClassElement(self):
        return self.children[0]

    @cached_property
    def ConstructorMethod(self):
        # 14.6.3 Static Semantics: ConstructorMethod
        # ClassElementList : ClassElement
        #   1. If ClassElement is ClassElement : ; , return empty.
        #   2. If IsStatic of ClassElement is true, return empty.
        #   3. If PropName of ClassElement is not "constructor", return empty.
        #   4. Return ClassElement.
        return self.ClassElement.ConstructorMethod

    @cached_property
    def NonConstructorMethodDefinitions(self):
        # 14.6.10 Static Semantics: NonConstructorMethodDefinitions
        # ClassElementList : ClassElement
        #   1. If ClassElement is ClassElement:; , return a new empty List.
        #   2. If IsStatic of ClassElement is false and PropName of ClassElement is "constructor", return a new
        #      empty List.
        #   3. Return a List containing ClassElement.
        return self.ClassElement.NonConstructorMethodDefinitions

    @cached_property
    def PrototypePropertyNameList(self):
        # 14.6.11 Static Semantics: PrototypePropertyNameList
        # ClassElementList : ClassElement
        #   1. If PropName of ClassElement is empty, return a new empty List.
        #   2. If IsStatic of ClassElement is true, return a new empty List.
        #   3. Return a List containing PropName of ClassElement.
        return self.ClassElement.PrototypePropertyNameList


class P2_ClassElementList_ClassElementList_ClassElement(P2_ClassElementList):
    @cached_property
    def ClassElementList(self):
        return self.children[0]

    @cached_property
    def ClassElement(self):
        return self.children[1]

    @cached_property
    def ConstructorMethod(self):
        # 14.6.3 Static Semantics: ConstructorMethod
        # ClassElementList : ClassElementList ClassElement
        #   1. Let head be ConstructorMethod of ClassElementList.
        #   2. If head is not empty, return head.
        #   3. If ClassElement is ClassElement:; , return empty.
        #   4. If IsStatic of ClassElement is true, return empty.
        #   5. If PropName of ClassElement is not "constructor", return empty.
        #   6. Return ClassElement.
        return self.ClassElementList.ConstructorMethod or self.ClassElement.ConstructorMethod

    @cached_property
    def NonConstructorMethodDefinitions(self):
        # 14.6.10 Static Semantics: NonConstructorMethodDefinitions
        # ClassElementList : ClassElementList ClassElement
        #   1. Let list be NonConstructorMethodDefinitions of ClassElementList.
        #   2. If ClassElement is ClassElement:; , return list.
        #   3. If IsStatic of ClassElement is false and PropName of ClassElement is "constructor", return list.
        #   4. Append ClassElement to the end of list.
        #   5. Return list.
        return (
            self.ClassElementList.NonConstructorMethodDefinitions + self.ClassElement.NonConstructorMethodDefinitions
        )

    @lru_cache
    def ComputedPropertyContains(self, symbol):
        # 14.6.5 Static Semantics: ComputedPropertyContains
        #   With parameter symbol.
        # ClassElementList : ClassElementList ClassElement
        #   1. Let inList be the result of ComputedPropertyContains for ClassElementList with argument symbol.
        #   2. If inList is true, return true.
        #   3. Return the result of ComputedPropertyContains for ClassElement with argument symbol.
        return self.ClassElementList.ComputedPropertyContains(symbol) or self.ClassElement.ComputedPropertyContains(
            symbol
        )

    @cached_property
    def PrototypePropertyNameList(self):
        # 14.6.11 Static Semantics: PrototypePropertyNameList
        # ClassElementList : ClassElementList ClassElement
        #   1. Let list be PrototypePropertyNameList of ClassElementList.
        #   2. If PropName of ClassElement is empty, return list.
        #   3. If IsStatic of ClassElement is true, return list.
        #   4. Append PropName of ClassElement to the end of list.
        #   5. Return list.
        return self.ClassElementList.PrototypePropertyNameList + self.ClassElement.PrototypePropertyNameList


def parse_ClassElementList(context, lexer, pos, _, Yield, Await):
    # 14.6 Class Definitions
    #   ClassElementList[Yield, Await]:
    #     ClassElement[?Yield, ?Await]
    #     ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]
    def parse(pos, previous=None):
        ce = parse_ClassElement(context, lexer, pos, True, Yield, Await)
        if ce:
            if previous:
                return lambda: parse(
                    ce.after, P2_ClassElementList_ClassElementList_ClassElement(context, [previous, ce])
                )
            return lambda: parse(ce.after, P2_ClassElementList_ClassElement(context, [ce]))
        return previous

    return trampoline(lambda: parse(pos))


# --------======= ClassElement =======--------
# Syntax
#   ClassElement:
#       MethodDefinition
#       static MethodDefinition
#       ;
class P2_ClassElement(ParseNode2):
    def __init__(self, ctx, children):
        super().__init__(ctx, "ClassElement", True, children)

    # 14.6.9 Static Semantics: IsStatic
    # ClassElement : MethodDefinition
    # ClassElement : ;
    #   1. Return false.
    IsStatic = False


class P2_ClassElement_hasmethod(P2_ClassElement):
    @cached_property
    def MethodDefinition(self):
        raise ValueError("base class")

    @cached_property
    def ConstructorMethod(self):
        # 14.6.3 Static Semantics: ConstructorMethod
        # ClassElementList : ClassElement
        #   1. If ClassElement is ClassElement : ; , return empty.
        #   2. If IsStatic of ClassElement is true, return empty.
        #   3. If PropName of ClassElement is not "constructor", return empty.
        #   4. Return ClassElement.
        return self if not self.IsStatic and self.PropName() == "constructor" else None

    def ComputedPropertyContains(self, symbol):
        # 14.6.5 Static Semantics: ComputedPropertyContains
        #   With parameter symbol.
        # ClassElement : MethodDefinition
        # ClassElement : static MethodDefinition
        #   1. Return the result of ComputedPropertyContains for MethodDefinition with argument symbol.
        return self.MethodDefinition.ComputedPropertyContains(symbol)


class P2_ClassElement_MethodDefinition(P2_ClassElement_hasmethod):
    @cached_property
    def MethodDefinition(self):
        return self.children[0]

    def EarlyErrors(self):
        # 14.6.1 Static Semantics: Early Errors
        # ClassElement : MethodDefinition
        #   * It is a Syntax Error if PropName of MethodDefinition is not "constructor" and HasDirectSuper of
        #     MethodDefinition is true.
        #   * It is a Syntax Error if PropName of MethodDefinition is "constructor" and SpecialMethod of
        #     MethodDefinition is true.
        return list(
            filter(
                None,
                (
                    self.MethodDefinition.PropName() != "constructor"
                    and self.MethodDefinition.HasDirectSuper()
                    and self.CreateSyntaxError("Direct Supers only allowed in constructors"),
                    self.MethodDefinition.PropName() == "constructor"
                    and self.MethodDefinition.SpecialMethod()
                    and self.CreateSyntaxError("Constructors must be ordinary methods"),
                ),
            )
        )

    @cached_property
    def NonConstructorMethodDefinitions(self):
        # 14.6.10 Static Semantics: NonConstructorMethodDefinitions
        # ClassElementList : ClassElement
        #   1. If ClassElement is ClassElement:; , return a new empty List.
        #   2. If IsStatic of ClassElement is false and PropName of ClassElement is "constructor", return a new
        #      empty List.
        #   3. Return a List containing ClassElement.
        return [self] if self.PropName() != "constructor" else []

    @cached_property
    def PrototypePropertyNameList(self):
        # 14.6.11 Static Semantics: PrototypePropertyNameList
        # ClassElementList : ClassElement
        #   1. If PropName of ClassElement is empty, return a new empty List.
        #   2. If IsStatic of ClassElement is true, return a new empty List.
        #   3. Return a List containing PropName of ClassElement.
        return [self.PropName()]


class P2_ClassElement_STATIC_MethodDefinition(P2_ClassElement_hasmethod):
    @cached_property
    def MethodDefinition(self):
        return self.children[1]

    # 14.6.9 Static Semantics: IsStatic
    # ClassElement : static MethodDefinition
    #   1. Return true.
    IsStatic = True

    def EarlyErrors(self):
        # 14.6.1 Static Semantics: Early Errors
        # ClassElement : static MethodDefinition
        #   * It is a Syntax Error if HasDirectSuper of MethodDefinition is true.
        #   * It is a Syntax Error if PropName of MethodDefinition is "prototype".
        return list(
            filter(
                None,
                (
                    self.MethodDefinition.HasDirectSuper()
                    and self.CreateSyntaxError("Static methods in classes may not have a direct super"),
                    self.MethodDefinition.PropName() == "prototype"
                    and self.CreateSyntaxError("static methods may not be named 'prototype'"),
                ),
            )
        )

    @cached_property
    def NonConstructorMethodDefinitions(self):
        # 14.6.10 Static Semantics: NonConstructorMethodDefinitions
        # ClassElementList : ClassElement
        #   1. If ClassElement is ClassElement:; , return a new empty List.
        #   2. If IsStatic of ClassElement is false and PropName of ClassElement is "constructor", return a new
        #      empty List.
        #   3. Return a List containing ClassElement.
        return [self]

    # 14.6.11 Static Semantics: PrototypePropertyNameList
    # ClassElementList : ClassElement
    #   1. If PropName of ClassElement is empty, return a new empty List.
    #   2. If IsStatic of ClassElement is true, return a new empty List.
    #   3. Return a List containing PropName of ClassElement.
    PrototypePropertyNameList = []


class P2_ClassElement_EMPTY(P2_ClassElement):
    # 14.6.3 Static Semantics: ConstructorMethod
    # ClassElementList : ClassElement
    #   1. If ClassElement is ClassElement : ; , return empty.
    #   2. If IsStatic of ClassElement is true, return empty.
    #   3. If PropName of ClassElement is not "constructor", return empty.
    #   4. Return ClassElement.
    ConstructorMethod = None

    def ComputedPropertyContains(self, symbol):
        # 14.6.5 Static Semantics: ComputedPropertyContains
        #   With parameter symbol.
        # ClassElement : ;
        #   1. Return false.
        return False

    # 14.6.10 Static Semantics: NonConstructorMethodDefinitions
    # ClassElementList : ClassElement
    #   1. If ClassElement is ClassElement:; , return a new empty List.
    #   2. If IsStatic of ClassElement is false and PropName of ClassElement is "constructor", return a new empty
    #      List.
    #   3. Return a List containing ClassElement.
    NonConstructorMethodDefinitions = []

    # 14.6.11 Static Semantics: PrototypePropertyNameList
    # ClassElementList : ClassElement
    #   1. If PropName of ClassElement is empty, return a new empty List.
    #   2. If IsStatic of ClassElement is true, return a new empty List.
    #   3. Return a List containing PropName of ClassElement.
    PrototypePropertyNameList = []

    def PropName(self):
        # 14.6.12 Static Semantics: PropName
        # ClassElement : ;
        #   1. Return empty.
        return EMPTY


def parse_ClassElement(context, lexer, pos, _, Yield, Await):
    #   ClassElement[Yield, Await]:
    #       MethodDefinition[?Yield, ?Await]
    #       static MethodDefinition[?Yield, ?Await]
    #       ;
    s = lexer.id_if(pos, "static")
    md = parse_MethodDefinition(context, lexer, s.span.after if s else pos, True, Yield, Await)
    if md:
        if s:
            return P2_ClassElement_STATIC_MethodDefinition(context, [s, md])
        return P2_ClassElement_MethodDefinition(context, [md])
    semi = lexer.token_if(pos, ";")
    if semi:
        return P2_ClassElement_EMPTY(context, [semi])
    return None


###########################################################################################
# `·._.·●.._.·●.._.·●..... 14.8 Async Arrow Function Definitions .....●·._..●·._..●·._.·´ #
###########################################################################################
# 14.8 Async Arrow Function Definitions

#   AsyncArrowFunction[In, Yield, Await] :
#       async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]
#       CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In]
#   AsyncConciseBody[In] :
#       [lookahead ≠ {] AssignmentExpression[?In, ~Yield, +Await]
#       { AsyncFunctionBody }
#   AsyncArrowBindingIdentifier[Yield] :
#       BindingIdentifier[?Yield, +Await]


# --------======= 𝓒𝓸𝓿𝓮𝓻𝓒𝓪𝓵𝓵𝓔𝔁𝓹𝓻𝓮𝓼𝓼𝓲𝓸𝓷𝓐𝓷𝓭𝓐𝓼𝔂𝓷𝓬𝓐𝓻𝓻𝓸𝔀𝓗𝓮𝓪𝓭 =======--------
# Syntax
#   CoverCallExpressionAndAsyncArrowHead :
#       MemberExpression Arguments


class P2_CoverCallExpressionAndAsyncArrowHead(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "CoverCallExpressionAndAsyncArrowHead", strict, children)


class P2_CoverCallExpressionAndAsyncArrowHead_MemberExpression_Arguments(P2_CoverCallExpressionAndAsyncArrowHead):
    @property
    def MemberExpression(self):
        return self.children[0]

    @property
    def Arguments(self):
        return self.children[1]


def parse_CoverCallExpressionAndAsyncArrowHead(context, lexer, pos, strict, Yield, Await):
    # 14.8 Async Arrow Function Definitions
    # Syntax
    #   CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
    #       MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    me = parse_MemberExpression(context, lexer, pos, strict, Yield, Await)
    if me:
        args = parse_Arguments(context, lexer, me.after, strict, Yield, Await)
        if args:
            return P2_CoverCallExpressionAndAsyncArrowHead_MemberExpression_Arguments(context, strict, [me, args])
    return None

    #   AsyncArrowHead :
    #       async [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]


def parse_AwaitExpression(*args):
    return None


def parse_AsyncArrowFunction(*args):
    return None


def parse_AsyncFunctionDeclaration(*args):
    return None


def parse_AsyncGeneratorDeclaration(*args):
    return None


def parse_AsyncMethod(*args):
    return None


def parse_AsyncGeneratorMethod(*args):
    return None


def parse_AsyncFunctionExpression(*args):
    return None


def parse_AsyncGeneratorExpression(*args):
    return None


def parse_AsyncFunctionBody(*args):
    return None


def parse_AsyncGeneratorBody(*args):
    return None


################################################################################################################################################################################
#
#  d888       d8888       .d8888b.      88888888888          d8b 888     8888888b.                    d8b 888    d8b                        .d8888b.           888 888
# d8888      d8P888      d88P  Y88b         888              Y8P 888     888   Y88b                   Y8P 888    Y8P                       d88P  Y88b          888 888
#   888     d8P 888      888    888         888                  888     888    888                       888                              888    888          888 888
#   888    d8P  888      Y88b. d888         888      8888b.  888 888     888   d88P  .d88b.  .d8888b  888 888888 888  .d88b.  88888b.      888         8888b.  888 888 .d8888b
#   888   d88   888       "Y888P888         888         "88b 888 888     8888888P"  d88""88b 88K      888 888    888 d88""88b 888 "88b     888            "88b 888 888 88K
#   888   8888888888            888         888     .d888888 888 888     888        888  888 "Y8888b. 888 888    888 888  888 888  888     888    888 .d888888 888 888 "Y8888b.
#   888         888  d8b Y88b  d88P         888     888  888 888 888     888        Y88..88P      X88 888 Y88b.  888 Y88..88P 888  888     Y88b  d88P 888  888 888 888      X88
# 8888888       888  Y8P  "Y8888P"          888     "Y888888 888 888     888         "Y88P"   88888P' 888  "Y888 888  "Y88P"  888  888      "Y8888P"  "Y888888 888 888  88888P'
#
#
#
################################################################################################################################################################################
# 14.9 Tail Position Calls
# 14.9.1 Static Semantics: IsInTailPosition ( call )
def IsInTailPosition(call):
    # Needs Implementation @@@
    return False


# 14.9.3 Runtime Semantics: PrepareForTailCall ( )
def PrepareForTailCall():
    # Needs Implementation @@@
    return EMPTY


"""
 d888   888888888       d888        .d8888b.                   d8b          888
d8888   888            d8888       d88P  Y88b                  Y8P          888
  888   888              888       Y88b.                                    888
  888   8888888b.        888        "Y888b.    .d8888b 888d888 888 88888b.  888888 .d8888b
  888        "Y88b       888           "Y88b. d88P"    888P"   888 888 "88b 888    88K
  888          888       888             "888 888      888     888 888  888 888    "Y8888b.
  888   Y88b  d88P d8b   888       Y88b  d88P Y88b.    888     888 888 d88P Y88b.       X88
8888888  "Y8888P"  Y8P 8888888      "Y8888P"   "Y8888P 888     888 88888P"   "Y888  88888P'
                                                                   888
                                                                   888
                                                                   888

15.1 Scripts
15.1.1 SS: Early Errors
15.1.2 SS: IsStrict
15.1.3 SS: LexicallyDeclaredNames
15.1.4 SS: LexicallyScopedDeclarations
15.1.5 SS: VarDeclaredNames
15.1.6 SS: VarScopedDeclarations
15.1.7 RS: Evaluation
15.1.8 Script Records
15.1.9 ParseScript ( sourceText, realm, hostDefined )
15.1.10 ScriptEvaluation ( scriptRecord )
15.1.11 RS: GlobalDeclarationInstantiation ( script, env )
15.1.12 RS: ScriptEvaluationJob ( sourceText, hostDefined )
"""

###################################################################
# `·._.·●.._.·●.._.·●..... 𝟏𝟓.𝟏 𝓢𝓬𝓻𝓲𝓹𝓽𝓼 .....●·._..●·._..●·._.·´ #
###################################################################
# 15.1 Scripts

# --------======= 𝓢𝓬𝓻𝓲𝓹𝓽 =======--------
# Syntax
#   Script :
#       [empty]
#       ScriptBody
#
class P2_Script(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "Script", strict, children)

    def AssignStrictitude(self):
        # Check the directive prologue for a 'strict' directive:
        if self.IsStrict():
            # Got one. So, set the strict flag on all this node's progeny.
            self.set_strict_in_subtree()
            return


class P2_Script_Empty(P2_Script):
    # 𝓢𝓬𝓻𝓲𝓹𝓽 : [𝓮𝓶𝓹𝓽𝔂]
    @property
    def ScriptBody(self):
        return None

    def LexicallyDeclaredNames(self):
        return []

    def VarDeclaredNames(self):
        return []

    def VarScopedDeclarations(self):
        return []

    def LexicallyScopedDeclarations(self):
        return []

    def evaluate(self):
        # 15.1.7 Runtime Semantics: Evaluation
        # Script : [empty]
        #      1. Return NormalCompletion(undefined).
        return None

    def IsStrict(self):
        return False


class P2_Script_ScriptBody(P2_Script):
    # 𝓢𝓬𝓻𝓲𝓹𝓽 : 𝓢𝓬𝓻𝓲𝓹𝓽𝓑𝓸𝓭𝔂
    @property
    def ScriptBody(self):
        return self.children[0]

    def EarlyErrors(self):
        # 15.1.1 Static Semantics: Early Errors
        # Script : ScriptBody
        #   * It is a Syntax Error if the LexicallyDeclaredNames of ScriptBody contains any duplicate entries.
        #   * It is a Syntax Error if any element of the LexicallyDeclaredNames of ScriptBody also occurs in the VarDeclaredNames of ScriptBody.
        errs = []
        lexnames = self.ScriptBody.LexicallyDeclaredNames()
        lexnameset = set(lexnames)
        if len(lexnames) != len(lexnameset):
            errs.append("Duplicate Lexical Declarations")
        if not lexnameset.isdisjoint(set(self.ScriptBody.VarDeclaredNames())):
            errs.append("Var declaration mirrors lexical declaration")
        if self.contains_unenclosed_continue or self.contains_encapsulated_unenclosed_continue:
            errs.append("Continue statement not enclosed within an iteration statement")
        if self.contains_unenclosed_break or self.contains_encapsulated_unenclosed_break:
            errs.append("Break statement not enclosed within an iteration statement nor a switch statement")
        return [self.CreateSyntaxError(msg) for msg in errs]


def parse_Script(ctx, lexer, pos, strict):
    # 15.1 Scripts
    # Syntax:
    #   Script :
    #       [empty]
    #       ScriptBody
    if lexer.token(pos) is None:
        return P2_Script_Empty(ctx, strict, [empty_node(ctx)])
    sb = parse_ScriptBody(ctx, lexer, pos, strict)
    if sb:
        return P2_Script_ScriptBody(ctx, strict, [sb])
    return None


# --------======= 𝓢𝓬𝓻𝓲𝓹𝓽𝓑𝓸𝓭𝔂 =======--------
# Syntax
#   ScriptBody :
#       StatementList
#
class P2_ScriptBody(ParseNode2):
    def __init__(self, ctx, strict, children):
        super().__init__(ctx, "ScriptBody", strict, children)


class P2_ScriptBody_StatementList(P2_ScriptBody):
    # 𝓢𝓬𝓻𝓲𝓹𝓽𝓑𝓸𝓭𝔂 : 𝓢𝓽𝓪𝓽𝓮𝓶𝓮𝓷𝓽𝓛𝓲𝓼𝓽
    @property
    def StatementList(self):
        return self.children[0]

    def EarlyErrors(self):
        # 15.1.1 Static Semantics: Early Errors
        # ScriptBody : StatementList
        # * It is a Syntax Error if StatementList Contains super unless the source code containing super is eval code that is
        #   being processed by a direct eval. Additional early error rules for super within direct eval are defined in
        #   18.2.1.1.
        # * It is a Syntax Error if StatementList Contains NewTarget unless the source code containing NewTarget is eval code
        #   that is being processed by a direct eval. Additional early error rules for NewTarget in direct eval are defined in
        #   18.2.1.1.
        # * It is a Syntax Error if ContainsDuplicateLabels of StatementList with argument « » is true.
        # * It is a Syntax Error if ContainsUndefinedBreakTarget of StatementList with argument « » is true.
        # * It is a Syntax Error if ContainsUndefinedContinueTarget of StatementList with arguments « » and « » is true.
        errs = []
        if not self.direct_eval and self.StatementList.Contains("super"):
            errs.append("'super' not allowed in this context")
        if not self.direct_eval and self.StatementList.Contains("NewTarget"):
            errs.append("'new.target' not allowed in this context")
        if self.StatementList.ContainsDuplicateLabels([]):
            errs.append("Duplicate Labels Detected")
        if self.StatementList.ContainsUndefinedBreakTarget([]):
            errs.append("Undefined Break Target")
        if self.StatementList.ContainsUndefinedContinueTarget([], []):
            errs.append("Undefined Continue Target")
        return [self.CreateSyntaxError(msg) for msg in errs]

    @cached_property
    def early_errors_eval_outside_functions(self):
        # 18.2.1.1.1 Additional Early Error Rules for Eval Outside Functions
        # These static semantics are applied by PerformEval when a direct eval call occurs outside of any function.
        #   ScriptBody : StatementList
        #   * It is a Syntax Error if StatementList Contains NewTarget.
        return tuple(
            chain(
                filter(
                    None,
                    (
                        self.StatementList.Contains("NewTarget")
                        and self.CreateSyntaxError("'new.target' not allowed in this context"),
                    ),
                ),
                super().early_errors_eval_outside_functions,
            )
        )

    @cached_property
    def early_errors_eval_outside_methods(self):
        # 18.2.1.1.2 Additional Early Error Rules for Eval Outside Methods
        # These static semantics are applied by PerformEval when a direct eval call occurs outside of a
        # MethodDefinition.
        #   ScriptBody : StatementList
        #   * It is a Syntax Error if StatementList Contains SuperProperty.
        return tuple(
            chain(
                filter(
                    None,
                    (
                        self.StatementList.Contains("SuperProperty")
                        and self.CreateSyntaxError("'super' properties not allowed in this context"),
                    ),
                ),
                super().early_errors_eval_outside_methods,
            )
        )

    @cached_property
    def early_errors_eval_outside_constructor_methods(self):
        # 18.2.1.1.3 Additional Early Error Rules for Eval Outside Constructor Methods
        # These static semantics are applied by PerformEval when a direct eval call occurs outside of the constructor
        # method of a ClassDeclaration or ClassExpression.
        #   ScriptBody : StatementList
        #   * It is a Syntax Error if StatementList Contains SuperCall.
        return tuple(
            chain(
                filter(
                    None,
                    (
                        self.StatementList.Contains("SuperCall")
                        and self.CreateSyntaxError("'super' calls not allowed in this context"),
                    ),
                ),
                super().early_errors_eval_outside_constructor_methods,
            )
        )

    def IsStrict(self):
        # 15.1.2 Static Semantics: IsStrict
        # ScriptBody : StatementList
        #    1. If the Directive Prologue of StatementList contains a Use Strict Directive, return true; otherwise, return false.
        (_, dp) = self.StatementList.LeadingStrings()  # This is a list of strings, subsets of the source text
        return "'use strict'" in dp or '"use strict"' in dp

    def LexicallyDeclaredNames(self):
        return self.StatementList.TopLevelLexicallyDeclaredNames()

    def VarDeclaredNames(self):
        return self.StatementList.TopLevelVarDeclaredNames()

    def VarScopedDeclarations(self):
        return self.StatementList.TopLevelVarScopedDeclarations()

    def LexicallyScopedDeclarations(self):
        return self.StatementList.TopLevelLexicallyScopedDeclarations()


def parse_ScriptBody(ctx, lexer, pos, strict):
    # 15.1 Scripts
    # Syntax:
    #   ScriptBody :
    #       StatementList [~Yield, ~Await, ~Return]
    sl = parse_StatementList(ctx, lexer, pos, strict, True, False, False, False)
    if sl:
        return P2_ScriptBody_StatementList(ctx, strict, [sl])
    return None


# 15.1.8 Script Records
#
# A Script Record encapsulates information about a script being evaluated. Each script record contains the fields
# listed in Table 36.
#
# Table 36: Script Record Fields
# +--------------------+-----------------------+----------------------------------------------------------------------+
# | Field Name         | Value Type            | Meaning                                                              |
# +--------------------+-----------------------+----------------------------------------------------------------------+
# | [[Realm]]          | Realm Record |        | The realm within which this script was created. undefined if not yet |
# |                    | undefined             | assigned.                                                            |
# +--------------------+-----------------------+----------------------------------------------------------------------+
# | [[Environment]]    | Lexical Environment | | The Lexical Environment containing the top level bindings for this   |
# |                    | undefined             | script. This field is set when the script is instantiated.           |
# +--------------------+-----------------------+----------------------------------------------------------------------+
# | [[ECMAScriptCode]] | a Parse Node          | The result of parsing the source text of this module using Script as |
# |                    |                       | the goal symbol.                                                     |
# +--------------------+-----------------------+----------------------------------------------------------------------+
# | [[HostDefined]]    | Any, default value is | Field reserved for use by host environments that need to associate   |
# |                    | undefined.            | additional information with a script.                                |
# +--------------------+-----------------------+----------------------------------------------------------------------+
class ScriptRecord(Record):
    __slots__ = ["Realm", "Environment", "ECMAScriptCode", "HostDefined"]


# 15.1.9 ParseScript ( sourceText, realm, hostDefined )
def ParseScript(sourceText, realm, hostDefined):
    # The abstract operation ParseScript with arguments sourceText, realm, and hostDefined creates a Script Record based upon
    # the result of parsing sourceText as a Script. ParseScript performs the following steps:
    #
    # 1. Assert: sourceText is an ECMAScript source text (see clause 10).
    # 2. Parse sourceText using Script as the goal symbol and analyse the parse result for any Early Error conditions. If the
    #    parse was successful and no early errors were found, let body be the resulting parse tree. Otherwise, let body be a
    #    List of one or more SyntaxError or ReferenceError objects representing the parsing errors and/or early errors. Parsing
    #    and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or
    #    early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least
    #    one must be present.
    lex = LexerCore(sourceText, ESSyntaxError)
    context = Parse2Context(direct_eval=True, syntax_error_ctor=CreateSyntaxError)
    tree = parse_Script(context, lex, 0, False)
    after = max((t.span.after for t in tree.terminals()), default=0) if tree else 0
    errs = list(
        chain(
            filter(
                None,
                [
                    not tree and ESSyntaxError("Bad parse of script"),
                    tree
                    and not lex.is_done(after)
                    and ESSyntaxError(
                        f"Syntax error at position {after}; {sourceText[after-100:after]}-$-$-$->{sourceText[after:]}"
                    ),
                ],
            ),
            (tree.EarlyErrorsScan() if tree else ()),
        )
    )
    body = errs or tree
    # 3. If body is a List of errors, return body.
    if isinstance(body, list):
        return body
    # 4. Return Script Record { [[Realm]]: realm, [[Environment]]: undefined, [[ECMAScriptCode]]: body,
    #                           [[HostDefined]]: hostDefined }.
    print(f"{body.pn_count} parse nodes in script")
    return ScriptRecord(Realm=realm, Environment=None, ECMAScriptCode=body, HostDefined=hostDefined)
    # NOTE
    # An implementation may parse script source text and analyse it for Early Error conditions prior to evaluation of
    # ParseScript for that script source text. However, the reporting of any errors must be deferred until the point where this
    # specification actually performs ParseScript upon that source text.


# 15.1.10 ScriptEvaluation ( scriptRecord )
def ScriptEvaluation(scriptRecord):
    # 1. Let globalEnv be scriptRecord.[[Realm]].[[GlobalEnv]].
    globalEnv = scriptRecord.Realm.global_env
    # 2. Let scriptCxt be a new ECMAScript code execution context.
    scriptCtx = ExecutionContext()
    # 3. Set the Function of scriptCxt to null.
    scriptCtx.function = JSNull.NULL
    # 4. Set the Realm of scriptCxt to scriptRecord.[[Realm]].
    scriptCtx.realm = scriptRecord.Realm
    # 5. Set the ScriptOrModule of scriptCxt to scriptRecord.
    scriptCtx.script_or_module = scriptRecord
    # 6. Set the VariableEnvironment of scriptCxt to globalEnv.
    scriptCtx.variable_environment = globalEnv
    # 7. Set the LexicalEnvironment of scriptCxt to globalEnv.
    scriptCtx.lexical_environment = globalEnv
    # 8. Suspend the currently running execution context.
    surrounding_agent.running_ec.suspend()
    # 9. Push scriptCxt on to the execution context stack; scriptCxt is now the running execution context.
    surrounding_agent.ec_stack.append(scriptCtx)
    surrounding_agent.running_ec = scriptCtx
    # 10. Let scriptBody be scriptRecord.[[ECMAScriptCode]].
    scriptBody = scriptRecord.ECMAScriptCode
    # 11. Let result be GlobalDeclarationInstantiation(scriptBody, globalEnv).
    try:
        GlobalDeclarationInstantiation(scriptBody, globalEnv)
        # 12. If result.[[Type]] is normal, then
        # a. Set result to the result of evaluating scriptBody.
        result = scriptBody.evaluate()
        if type(result) == types.GeneratorType:
            try:
                result = next(result)
            except StopIteration as si:
                result = si.value

        # 13. If result.[[Type]] is normal and result.[[Value]] is empty, then
        # a. Set result to NormalCompletion(undefined).
        if result == EMPTY:
            result = None
    except ESAbrupt as err:
        raise RuntimeError(f"Had an abrupt completion ({err.completion!r}) at the top level.")
    finally:
        # 14. Suspend scriptCxt and remove it from the execution context stack.
        scriptCtx.suspend()
        surrounding_agent.ec_stack.pop()
        # 15. Assert: The execution context stack is not empty.
        assert len(surrounding_agent.ec_stack) > 0
        # 16. Resume the context that is now on the top of the execution context stack as the running execution context.
        surrounding_agent.running_ec = surrounding_agent.ec_stack[-1]
        surrounding_agent.running_ec.resume()
    # 17. Return Completion(result).
    return result


# 15.1.11 Runtime Semantics: GlobalDeclarationInstantiation ( script, env )
def GlobalDeclarationInstantiation(script, env):
    # NOTE 1
    # When an execution context is established for evaluating scripts, declarations are instantiated in the current global
    # environment. Each global binding declared in the code is instantiated.
    #
    # GlobalDeclarationInstantiation is performed as follows using arguments script and env. script is the ScriptBody for
    # which the execution context is being established. env is the global lexical environment in which bindings are to be
    # created.
    #
    # 1. Let envRec be env's EnvironmentRecord.
    envRec = env.environment_record
    # 2. Assert: envRec is a global Environment Record.
    assert hasattr(envRec, "global_this_value")
    # 3. Let lexNames be the LexicallyDeclaredNames of script.
    lexNames = script.LexicallyDeclaredNames()
    # 4. Let varNames be the VarDeclaredNames of script.
    varNames = script.VarDeclaredNames()
    # 5. For each name in lexNames, do
    for name in lexNames:
        # a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.
        if envRec.HasVarDeclaration(name):
            raise ESSyntaxError()
        # b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
        if envRec.HasLexicalDeclaration(name):
            raise ESSyntaxError()
        # c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).
        hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name)
        # d. If hasRestrictedGlobal is true, throw a SyntaxError exception.
        if hasRestrictedGlobal:
            raise ESSyntaxError()
    # 6. For each name in varNames, do
    for name in varNames:
        # a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
        if envRec.HasLexicalDeclaration(name):
            raise ESSyntaxError()
    # 7. Let varDeclarations be the VarScopedDeclarations of script.
    varDeclarations = script.VarScopedDeclarations()
    # 8. Let functionsToInitialize be a new empty List.
    functionsToInitialize = deque()
    # 9. Let declaredFunctionNames be a new empty List.
    declaredFunctionNames = []
    # 10. For each d in varDeclarations, in reverse list order, do
    for d in (varDeclarations[-x - 1] for x in range(len(varDeclarations))):
        # --- each of these 'd' is a ParseNode.
        # a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
        if d.name not in ["VariableDeclaration", "ForBinding", "BindingIdentifier"]:
            # i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an
            #    AsyncGeneratorDeclaration.
            assert d.name in [
                "FunctionDeclaration",
                "GeneratorDeclaration",
                "AsyncFunctionDeclaration",
                "AsyncGeneratorDeclaration",
            ]
            # ii. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
            # iii. Let fn be the sole element of the BoundNames of d.
            fn = d.BoundNames()[0]
            # iv. If fn is not an element of declaredFunctionNames, then
            if fn not in declaredFunctionNames:
                # 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).
                fnDefinable = envRec.CanDeclareGlobalFunction(fn)
                # 2. If fnDefinable is false, throw a TypeError exception.
                if not fnDefinable:
                    raise ESTypeError()
                # 3. Append fn to declaredFunctionNames.
                declaredFunctionNames.append(fn)
                # 4. Insert d as the first element of functionsToInitialize.
                functionsToInitialize.appendleft(d)
    # 11. Let declaredVarNames be a new empty List.
    declaredVarNames = []
    # 12. For each d in varDeclarations, do
    for d in varDeclarations:
        # a. If d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, then
        if d.name in ["VariableDeclaration", "ForBinding", "BindingIdentifier"]:
            # i. For each String vn in the BoundNames of d, do
            for vn in d.BoundNames():
                # 1. If vn is not an element of declaredFunctionNames, then
                if vn not in declaredFunctionNames:
                    # a. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).
                    vnDefinable = envRec.CanDeclareGlobalVar(vn)
                    # b. If vnDefinable is false, throw a TypeError exception.
                    if not vnDefinable:
                        raise ESTypeError()
                    # c. If vn is not an element of declaredVarNames, then
                    if vn not in declaredVarNames:
                        # i. Append vn to declaredVarNames.
                        declaredVarNames.append(vn)
    # 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However,
    #     if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of
    #     the following steps.
    # 14. NOTE: Annex B.3.3.2 adds additional steps at this point.
    # 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.
    lexDeclarations = script.LexicallyScopedDeclarations()
    # 16. For each element d in lexDeclarations, do
    for d in lexDeclarations:
        # a. NOTE: Lexically declared names are only instantiated here but not initialized.
        # b. For each element dn of the BoundNames of d, do
        for dn in d.BoundNames():
            # i. If IsConstantDeclaration of d is true, then
            if d.IsConstantDeclaration():
                # 1. Perform ? envRec.CreateImmutableBinding(dn, true).
                envRec.CreateImmutableBinding(dn, True)
            # ii. Else,
            else:
                # 1. Perform ? envRec.CreateMutableBinding(dn, false).
                envRec.CreateMutableBinding(dn, False)
    # 17. For each Parse Node f in functionsToInitialize, do
    for f in functionsToInitialize:
        # a. Let fn be the sole element of the BoundNames of f.
        fn = f.BoundNames()[0]
        # b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.
        fo = f.InstantiateFunctionObject(env)
        # c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).
        envRec.CreateGlobalFunctionBinding(fn, fo, False)
    # 18.For each String vn in declaredVarNames, in list order, do
    for vn in declaredVarNames:
        # a. Perform ? envRec.CreateGlobalVarBinding(vn, false).
        envRec.CreateGlobalVarBinding(vn, False)
    # 19. Return NormalCompletion(empty).
    return EMPTY
    # NOTE 2
    # Early errors specified in 15.1.1 prevent name conflicts between function/var declarations and let/const/class
    # declarations as well as redeclaration of let/const/class bindings for declaration contained within a single Script.
    # However, such conflicts and redeclarations that span more than one Script are detected as runtime errors during
    # GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if
    # the global object is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be
    # unreliable resulting in an abrupt completion and some global declarations not being instantiated. If this occurs, the
    # code for the Script is not evaluated.
    #
    # Unlike explicit var or function declarations, properties that are directly created on the global object result in global
    # bindings that may be shadowed by let/const/class declarations.


# 15.1.12 Runtime Semantics: ScriptEvaluationJob ( sourceText, hostDefined )
def ScriptEvaluationJob(source_text, host_defined):
    # The job ScriptEvaluationJob with parameters sourceText and hostDefined parses, validates, and evaluates
    # sourceText as a Script.
    #
    # 1. Assert: sourceText is an ECMAScript source text (see clause 10).
    assert isString(source_text)
    # 2. Let realm be the current Realm Record.
    realm = surrounding_agent.running_ec.realm
    # 3. Let s be ParseScript(sourceText, realm, hostDefined).
    script_nodes = ParseScript(source_text, realm, host_defined)
    # 4. If s is a List of errors, then
    if isinstance(script_nodes, list):
        # a. Perform HostReportErrors(s).
        HostReportErrors(script_nodes)
        # b. Return NormalCompletion(undefined).
        return None
    # 5. Return ? ScriptEvaluation(s).
    return ScriptEvaluation(script_nodes)


# 15.2.1.20 Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText, hostDefined )
def TopLevelModuleEvaluationJob(sourceText, hostDefined):
    raise NotImplementedError("Modules not yet implemented")


# 16.1 HostReportErrors ( errorList )
HostErrorReporter = None


def SetHostErrorCallback(fcn):
    global HostErrorReporter
    HostErrorReporter = fcn


def HostReportErrors(errorList):
    # HostReportErrors is an implementation-defined abstract operation that allows host environments to report parsing
    # errors, early errors, and runtime errors.
    #
    # An implementation of HostReportErrors must complete normally in all cases. The default implementation of
    # HostReportErrors is to unconditionally return an empty normal completion.
    #
    # NOTE
    # errorList will be a List of ECMAScript language values. If the errors are parsing errors or early errors, these
    # will always be SyntaxError or ReferenceError objects. Runtime errors, however, can be any ECMAScript value.

    errs = [getattr(err, "ecma_object", err) for err in errorList]
    if HostErrorReporter:
        HostErrorReporter(errs)
    else:
        for err in errs:
            print(ToString(err))

    return EMPTY


# 18.2 Function Properties of the Global Object
# 18.2.1 eval ( x )
def global_eval(this_value, new_target, x=None, *_):
    # The eval function is the %eval% intrinsic object. When the eval function is called with one argument x, the
    # following steps are taken:
    #   1. Assert: The execution context stack has at least two elements.
    #   2. Let callerContext be the second to top element of the execution context stack.
    #   3. Let callerRealm be callerContext's Realm.
    #   4. Let calleeRealm be the current Realm Record.
    #   5. Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).
    #   6. Return ? PerformEval(x, calleeRealm, false, false).
    assert len(surrounding_agent.ec_stack) >= 2
    callerContext = surrounding_agent.ec_stack[-2]
    callerRealm = callerContext.realm
    calleeRealm = surrounding_agent.running_ec.realm
    HostEnsureCanCompileStrings(callerRealm, calleeRealm)
    return PerformEval(x, calleeRealm, False, False)


global_eval.length = 1
global_eval.name = "eval"


def CreateAnnotatedFunctionObject(realm, fn, slots=[]):
    func = CreateBuiltinFunction(fn, slots, realm)
    DefinePropertyOrThrow(
        func, "length", PropertyDescriptor(value=fn.length, writable=False, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        func, "name", PropertyDescriptor(value=fn.name, writable=False, enumerable=False, configurable=True)
    )
    return func


# 18.2.1.1 Runtime Semantics: PerformEval ( x, evalRealm, strictCaller, direct )
def PerformEval(x, evalRealm, strictCaller, direct):
    # The abstract operation PerformEval with arguments x, evalRealm, strictCaller, and direct performs the following
    # steps:
    #   1. Assert: If direct is false, then strictCaller is also false.
    #   2. If Type(x) is not String, return x.
    #   3. Let thisEnvRec be ! GetThisEnvironment().
    #   4. If thisEnvRec is a function Environment Record, then
    #       a. Let F be thisEnvRec.[[FunctionObject]].
    #       b. Let inFunction be true.
    #       c. Let inMethod be thisEnvRec.HasSuperBinding().
    #       d. If F.[[ConstructorKind]] is "derived", let inDerivedConstructor be true; otherwise, let
    #          inDerivedConstructor be false.
    #   5. Else,
    #       a. Let inFunction be false.
    #       b. Let inMethod be false.
    #       c. Let inDerivedConstructor be false.
    #   6. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode
    #      text as described in 6.1.4, for the goal symbol Script. If inFunction is false, additional early error rules
    #      from 18.2.1.1.1 are applied. If inMethod is false, additional early error rules from 18.2.1.1.2 are applied.
    #      If inDerivedConstructor is false, additional early error rules from 18.2.1.1.3 are applied. If the parse
    #      fails, throw a SyntaxError exception. If any early errors are detected, throw a SyntaxError or a
    #      ReferenceError exception, depending on the type of the error (but see also clause 16). Parsing and early
    #      error detection may be interweaved in an implementation-dependent manner.
    #   7. If script Contains ScriptBody is false, return undefined.
    #   8. Let body be the ScriptBody of script.
    #   9. If strictCaller is true, let strictEval be true.
    #   10. Else, let strictEval be IsStrict of script.
    #   11. Let ctx be the running execution context.
    #   12. NOTE: If direct is true, ctx will be the execution context that performed the direct eval. If direct is
    #       false, ctx will be the execution context for the invocation of the eval function.
    #   13. If direct is true, then
    #       a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).
    #       b. Let varEnv be ctx's VariableEnvironment.
    #   14. Else,
    #       a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).
    #       b. Let varEnv be evalRealm.[[GlobalEnv]].
    #   15. If strictEval is true, set varEnv to lexEnv.
    #   16. If ctx is not already suspended, suspend ctx.
    #   17. Let evalCxt be a new ECMAScript code execution context.
    #   18. Set the evalCxt's Function to null.
    #   19. Set the evalCxt's Realm to evalRealm.
    #   20. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.
    #   21. Set the evalCxt's VariableEnvironment to varEnv.
    #   22. Set the evalCxt's LexicalEnvironment to lexEnv.
    #   23. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.
    #   24. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).
    #   25. If result.[[Type]] is normal, then
    #       a. Set result to the result of evaluating body.
    #   26. If result.[[Type]] is normal and result.[[Value]] is empty, then
    #       a. Set result to NormalCompletion(undefined).
    #   27. Suspend evalCxt and remove it from the execution context stack.
    #   28. Resume the context that is now on the top of the execution context stack as the running execution context.
    #   29. Return Completion(result).
    # NOTE  | The eval code cannot instantiate variable or function bindings in the variable environment of the
    #       | calling context that invoked the eval if the calling context is evaluating formal parameter initializers
    #       | or if either the code of the calling context or the eval code is strict mode code. Instead such bindings
    #       | are instantiated in a new VariableEnvironment that is only accessible to the eval code. Bindings
    #       | introduced by let, const, or class declarations are always instantiated in a new LexicalEnvironment.
    assert direct or not strictCaller
    if not isString(x):
        return x
    thisEnvRec = GetThisEnvironment() if surrounding_agent.running_ec.lexical_environment else None
    if isinstance(thisEnvRec, FunctionEnvironmentRecord):
        F = thisEnvRec.function_object
        inFunction = True
        inMethod = thisEnvRec.HasSuperBinding()
        inDerivedConstructor = F.ConstructorKind == "derived"
    else:
        inFunction = False
        inMethod = False
        inDerivedConstructor = False
    lex = LexerCore(x, ESSyntaxError)
    context = Parse2Context(direct_eval=direct, syntax_error_ctor=CreateSyntaxError)
    tree = parse_Script(context, lex, 0, strictCaller)
    after = max((t.span.after for t in tree.terminals()), default=0) if tree else 0
    errs = list(
        chain(
            filter(
                None,
                (
                    not tree and CreateSyntaxError("Not valid ECMAScript"),
                    tree
                    and not lex.is_done(after)
                    and CreateSyntaxError(
                        f"Syntax error at position {after}; {x[after-min(after, 100):after]}-$-$-$->{x[after:]}"
                    ),
                ),
            ),
            (tree.EarlyErrorsScan() if tree else ()),
            (tree.early_errors_eval_outside_functions if tree and not inFunction else ()),
            (tree.early_errors_eval_outside_methods if tree and not inMethod else ()),
            (tree.early_errors_eval_outside_constructor_methods if tree and not inDerivedConstructor else ()),
        )
    )
    if errs:
        raise ESSyntaxError("\n".join(msg for msg in (Get(obj, "message") for obj in errs) if isString(msg)))

    if not tree.Contains("ScriptBody"):
        return None

    body = tree.ScriptBody
    strictEval = strictCaller or tree.IsStrict()
    ctx = surrounding_agent.running_ec
    if direct:
        lexEnv = NewDeclarativeEnvironment(ctx.lexical_environment)
        varEnv = ctx.variable_environment
    else:
        lexEnv = NewDeclarativeEnvironment(evalRealm.global_env)
        varEnv = evalRealm.global_env
    if strictEval:
        varEnv = lexEnv
    ctx.suspend()
    evalCtx = ExecutionContext()
    evalCtx.function = JSNull.NULL
    evalCtx.realm = evalRealm
    evalCtx.script_or_module = ctx.script_or_module
    evalCtx.variable_environment = varEnv
    evalCtx.lexical_environment = lexEnv
    surrounding_agent.ec_stack.append(evalCtx)
    surrounding_agent.running_ec = evalCtx
    try:
        EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval)
        result = body.evaluate()
        if result == EMPTY:
            result = None
    finally:
        evalCtx.suspend()
        surrounding_agent.ec_stack.pop()
        surrounding_agent.running_ec = surrounding_agent.ec_stack[-1]
    return result


# 18.2.1.2 HostEnsureCanCompileStrings ( callerRealm, calleeRealm )
def HostEnsureCanCompileStrings(callerRealm, calleeRealm):
    # HostEnsureCanCompileStrings is an implementation-defined abstract operation that allows host environments to
    # block certain ECMAScript functions which allow developers to compile strings into ECMAScript code.
    #
    # An implementation of HostEnsureCanCompileStrings may complete normally or abruptly. Any abrupt completions will
    # be propagated to its callers. The default implementation of HostEnsureCanCompileStrings is to unconditionally
    # return an empty normal completion.
    return EMPTY


# 18.2.1.3 Runtime Semantics: EvalDeclarationInstantiation ( body, varEnv, lexEnv, strict )
def EvalDeclarationInstantiation(body, varEnv, lexEnv, strict):
    # When the abstract operation EvalDeclarationInstantiation is called with arguments body, varEnv, lexEnv, and
    # strict, the following steps are taken:
    #   1. Let varNames be the VarDeclaredNames of body.
    #   2. Let varDeclarations be the VarScopedDeclarations of body.
    #   3. Let lexEnvRec be lexEnv's EnvironmentRecord.
    #   4. Let varEnvRec be varEnv's EnvironmentRecord.
    #   5. If strict is false, then
    #       a. If varEnvRec is a global Environment Record, then
    #           i. For each name in varNames, do
    #               1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
    #               2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical
    #                  declaration.
    #       b. Let thisLex be lexEnv.
    #       c. Assert: The following loop will terminate.
    #       d. Repeat, while thisLex is not the same as varEnv,
    #           i. Let thisEnvRec be thisLex's EnvironmentRecord.
    #           ii. If thisEnvRec is not an object Environment Record, then
    #               1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't
    #                  need to be checked for var/let hoisting conflicts.
    #               2. For each name in varNames, do
    #                   a. If thisEnvRec.HasBinding(name) is true, then
    #                       i. Throw a SyntaxError exception.
    #                       ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.
    #                   b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.
    #           iii. Set thisLex to thisLex's outer environment reference.
    #   6. Let functionsToInitialize be a new empty List.
    #   7. Let declaredFunctionNames be a new empty List.
    #   8. For each d in varDeclarations, in reverse list order, do
    #       a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
    #           i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or
    #              an AsyncGeneratorDeclaration.
    #           ii. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
    #           iii. Let fn be the sole element of the BoundNames of d.
    #           iv. If fn is not an element of declaredFunctionNames, then
    #               1. If varEnvRec is a global Environment Record, then
    #                   a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).
    #                   b. If fnDefinable is false, throw a TypeError exception.
    #               2. Append fn to declaredFunctionNames.
    #               3. Insert d as the first element of functionsToInitialize.
    #   9. NOTE: Annex B.3.3.3 adds additional steps at this point.
    #   10. Let declaredVarNames be a new empty List.
    #   11. For each d in varDeclarations, do
    #       a. If d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, then
    #           i. For each String vn in the BoundNames of d, do
    #               1. If vn is not an element of declaredFunctionNames, then
    #                   a. If varEnvRec is a global Environment Record, then
    #                       i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).
    #                       ii. If vnDefinable is false, throw a TypeError exception.
    #                   b. If vn is not an element of declaredVarNames, then
    #                       i. Append vn to declaredVarNames.
    #   12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment
    #       Record and the global object is a Proxy exotic object.
    #   13. Let lexDeclarations be the LexicallyScopedDeclarations of body.
    #   14. For each element d in lexDeclarations, do
    #       a. NOTE: Lexically declared names are only instantiated here but not initialized.
    #       b. For each element dn of the BoundNames of d, do
    #           i. If IsConstantDeclaration of d is true, then
    #               1. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).
    #           ii. Else,
    #               1. Perform ? lexEnvRec.CreateMutableBinding(dn, false).
    #   15. For each Parse Node f in functionsToInitialize, do
    #       a. Let fn be the sole element of the BoundNames of f.
    #       b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.
    #       c. If varEnvRec is a global Environment Record, then
    #           i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).
    #       d. Else,
    #           i. Let bindingExists be varEnvRec.HasBinding(fn).
    #           ii. If bindingExists is false, then
    #               1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).
    #               2. Assert: status is not an abrupt completion because of validation preceding step 12.
    #               3. Perform ! varEnvRec.InitializeBinding(fn, fo).
    #           iii. Else,
    #               1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).
    #   16. For each String vn in declaredVarNames, in list order, do
    #       a. If varEnvRec is a global Environment Record, then
    #           i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).
    #       b. Else,
    #           i. Let bindingExists be varEnvRec.HasBinding(vn).
    #           ii. If bindingExists is false, then
    #               1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).
    #               2. Assert: status is not an abrupt completion because of validation preceding step 12.
    #               3. Perform ! varEnvRec.InitializeBinding(vn, undefined).
    #   17. Return NormalCompletion(empty).
    varNames = body.VarDeclaredNames()
    varDeclarations = body.VarScopedDeclarations()
    lexEnvRec = lexEnv.environment_record
    varEnvRec = varEnv.environment_record
    if not strict:
        if isinstance(varEnvRec, GlobalEnvironmentRecord):
            for name in varNames:
                if varEnvRec.HasLexicalDeclaration(name):
                    raise ESSyntaxError(f"Cannot delcare variable {name} when already lexically declared")
        thisLex = lexEnv
        while thisLex != varEnv:
            thisEnvRec = thisLex.environment_record
            if not isinstance(thisEnvRec, ObjectEnvironmentRecord):
                for name in varNames:
                    if thisEnvRec.HasBinding(name):
                        raise ESSyntaxError(f"var/let hoisting conflict: {name}")
            thisLex = thisLex.outer
    functionsToInitialize = deque([])
    declaredFunctionNames = []
    for d in reversed(varDeclarations):
        if not isinstance(d, (P2_VariableDeclaration, P2_ForBinding, P2_BindingIdentifier)):
            assert isinstance(
                d,
                (
                    P2_FunctionDeclaration,
                    P2_GeneratorDeclaration,
                    # P2_AsyncFunctionDeclaration,
                    # P2_AsyncGeneratorDeclaration,
                ),
            )
            fn = d.BoundNames()[0]
            if fn not in declaredFunctionNames:
                if isinstance(varEnvRec, GlobalEnvironmentRecord):
                    fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn)
                    if not fnDefinable:
                        raise ESTypeError(f"Cannot define function {fn}.")
                declaredFunctionNames.append(fn)
                functionsToInitialize.appendleft(d)
    declaredVarNames = []
    for d in varDeclarations:
        if isinstance(d, (P2_VariableDeclaration, P2_ForBinding, P2_BindingIdentifier)):
            for vn in d.BoundNames():
                if vn not in declaredFunctionNames:
                    if isinstance(varEnvRec, GlobalEnvironmentRecord):
                        vnDefinable = varEnvRec.CanDeclareGlobalVar(vn)
                        if not vnDefinable:
                            raise ESTypeError(f"Cannot declare global {vn}")
                    if vn not in declaredVarNames:
                        declaredVarNames.append(vn)
    lexDeclarations = body.LexicallyScopedDeclarations()
    for d in lexDeclarations:
        for dn in d.BoundNames():
            if d.IsConstantDeclaration():
                lexEnvRec.CreateImmutableBinding(dn, True)
            else:
                lexEnvRec.CreateMutableBinding(dn, False)
    for f in functionsToInitialize:
        fn = f.BoundNames()[0]
        fo = f.InstantiateFunctionObject(lexEnv)
        if isinstance(varEnvRec, GlobalEnvironmentRecord):
            varEnvRec.CreateGlobalFunctionBinding(fn, fo, True)
        else:
            bindingExists = varEnvRec.HasBinding(fn)
            if not bindingExists:
                varEnvRec.CreateMutableBinding(fn, True)
                varEnvRec.InitializeBinding(fn, fo)
            else:
                varEnvRec.SetMutableBinding(fn, fo, False)
    for vn in declaredVarNames:
        if isinstance(varEnvRec, GlobalEnvironmentRecord):
            varEnvRec.CreateGlobalVarBinding(vn, True)
        else:
            if not varEnvRec.HasBinding(vn):
                varEnvRec.CreateMutableBinding(vn, True)
                varEnvRec.InitializeBinding(vn, None)
    return EMPTY


# 18.2.2 isFinite ( number )
def global_isFinite(this_value, new_target, number=None, *_):
    # The isFinite function is the %isFinite% intrinsic object. When the isFinite function is called with one argument
    # number, the following steps are taken:
    #   1. Let num be ? ToNumber(number).
    #   2. If num is NaN, +∞, or -∞, return false.
    #   3. Otherwise, return true.
    num = ToNumber(number)
    return math.isfinite(num)


global_isFinite.length = 1
global_isFinite.name = "isFinite"

# 18.2.3 isNaN ( number )
def global_isNaN(this_value, new_target, number=None, *_):
    # The isNaN function is the %isNaN% intrinsic object. When the isNaN function is called with one argument number,
    # the following steps are taken:
    #   1. Let num be ? ToNumber(number).
    #   2. If num is NaN, return true.
    #   3. Otherwise, return false.
    num = ToNumber(number)
    return math.isnan(num)


global_isNaN.length = 1
global_isNaN.name = "isNaN"

_parseNum_RemoveLeadingWhitespace_pattern = regex.compile(
    rf"(?:({LexerCore.WhiteSpace}|{LexerCore.LineTerminator})*)(?P<content>.*)"
)

_ExponentPart = r"([eE][-+]?[0-9]+)"
_StrUnsignedDecimalLiteral = (
    rf"(Infinity|([0-9]+\.[0-9]*{_ExponentPart}?)|(\.[0-9]+{_ExponentPart}?)|([0-9]+{_ExponentPart}?))"
)
_StrDecimalLiteral = rf"([-+]?{_StrUnsignedDecimalLiteral})"

_parseFloat_pattern = regex.compile(_StrDecimalLiteral)
# 18.2.4 parseFloat ( string )
def global_parseFloat(this_value, new_target, string=None, *_):
    # The parseFloat function produces a Number value dictated by interpretation of the contents of the string
    # argument as a decimal literal.
    #
    # The parseFloat function is the %parseFloat% intrinsic object. When the parseFloat function is called with one
    # argument string, the following steps are taken:
    #   1. Let inputString be ? ToString(string).
    #   2. Let trimmedString be a substring of inputString consisting of the leftmost code unit that is not a
    #      StrWhiteSpaceChar and all code units to the right of that code unit. (In other words, remove leading
    #      white space.) If inputString does not contain any such code units, let trimmedString be the empty string.
    #   3. If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral
    #      (see 7.1.3.1), return NaN.
    #   4. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that
    #      satisfies the syntax of a StrDecimalLiteral.
    #   5. Let mathFloat be MV of numberString.
    #   6. If mathFloat = 0, then
    #       a. If the first code unit of trimmedString is the code unit 0x002D (HYPHEN-MINUS), return -0.
    #       b. Return +0.
    #   7. Return the Number value for mathFloat.
    # NOTE  | parseFloat may interpret only a leading portion of string as a Number value; it ignores any code units
    #       | that cannot be interpreted as part of the notation of a decimal literal, and no indication is given
    #       | that any such code units were ignored.
    inputString = ToString(string)
    m = _parseNum_RemoveLeadingWhitespace_pattern.match(inputString)
    assert m is not None  # That regex can't fail
    num = _parseFloat_pattern.match(m.group("content"))
    if not num:
        return math.nan
    return float(num.group(0))


global_parseFloat.length = 1
global_parseFloat.name = "parseFloat"

# 18.2.5 parseInt ( string, radix )
def global_parseInt(this_value, new_target, string=None, radix=None, *_):
    # The parseInt function produces an integer value dictated by interpretation of the contents of the string
    # argument according to the specified radix. Leading white space in string is ignored. If radix is undefined or 0,
    # it is assumed to be 10 except when the number begins with the code unit pairs 0x or 0X, in which case a radix of
    # 16 is assumed. If radix is 16, the number may also optionally begin with the code unit pairs 0x or 0X.
    #
    # The parseInt function is the %parseInt% intrinsic object. When the parseInt function is called, the following
    # steps are taken:
    #   1. Let inputString be ? ToString(string).
    #   2. Let S be a newly created substring of inputString consisting of the first code unit that is not a
    #      StrWhiteSpaceChar and all code units following that code unit. (In other words, remove leading white space.)
    #      If inputString does not contain any such code unit, let S be the empty string.
    #   3. Let sign be 1.
    #   4. If S is not empty and the first code unit of S is the code unit 0x002D (HYPHEN-MINUS), set sign to -1.
    #   5. If S is not empty and the first code unit of S is the code unit 0x002B (PLUS SIGN) or the code unit 0x002D
    #      (HYPHEN-MINUS), remove the first code unit from S.
    #   6. Let R be ? ToInt32(radix).
    #   7. Let stripPrefix be true.
    #   8. If R ≠ 0, then
    #       a. If R < 2 or R > 36, return NaN.
    #       b. If R ≠ 16, set stripPrefix to false.
    #   9. Else R = 0,
    #       a. Set R to 10.
    #   10. If stripPrefix is true, then
    #       a. If the length of S is at least 2 and the first two code units of S are either "0x" or "0X", then
    #           i. Remove the first two code units from S.
    #           ii. Set R to 16.
    #   11. If S contains a code unit that is not a radix-R digit, let Z be the substring of S consisting of all code
    #       units before the first such code unit; otherwise, let Z be S.
    #   12. If Z is empty, return NaN.
    #   13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the
    #       letters A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20
    #       significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of
    #       the implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent
    #       approximation to the mathematical integer value that is represented by Z in radix-R notation.)
    #   14. If mathInt = 0, then
    #       a. If sign = -1, return -0.
    #       b. Return +0.
    #   15. Let number be the Number value for mathInt.
    #   16. Return sign × number.
    # NOTE  | parseInt may interpret only a leading portion of string as an integer value; it ignores any code units
    #       | that cannot be interpreted as part of the notation of an integer, and no indication is given that any
    #       | such code units were ignored.
    inputString = ToString(string)
    m = _parseNum_RemoveLeadingWhitespace_pattern.match(inputString)
    assert m is not None  # That regex can't fail
    S = m.group("content")
    sign = 1
    if S and S[0] == "-":
        sign = -1
    if S and S[0] in "+-":
        S = S[1:]
    R = ToInt32(radix)
    stripPrefix = True
    if R != 0:
        if R < 2 or R > 36:
            return math.nan
        if R != 16:
            stripPrefix = False
    else:
        R = 10
    if stripPrefix:
        if len(S) >= 2 and S[0:2] in ("0x", "0X"):
            S = S[2:]
            R = 16
    valid_digits = "0123456789"[0 : min(R, 10)]
    valid_digits += "abcdefghijklmnopqrstuvwxyz"[0 : max(0, min(36, R - 10))]
    valid_digits += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[0 : max(0, min(36, R - 10))]
    valid_pattern = regex.compile(rf"(?P<valid>[{valid_digits}]+).*")
    m = valid_pattern.match(S)
    if not m:
        return math.nan
    Z = m.group("valid")
    mathInt = int(Z, R)
    if mathInt == 0 and sign < 0:
        return -0.0
    return sign * mathInt


global_parseInt.length = 2
global_parseInt.name = "parseInt"


"""
 d888    .d8888b.       d888        .d88888b.  888         d8b                   888
d8888   d88P  Y88b     d8888       d88P" "Y88b 888         Y8P                   888
  888   888    888       888       888     888 888                               888
  888   Y88b. d888       888       888     888 88888b.    8888  .d88b.   .d8888b 888888
  888    "Y888P888       888       888     888 888 "88b   "888 d8P  Y8b d88P"    888
  888          888       888       888     888 888  888    888 88888888 888      888
  888   Y88b  d88P d8b   888       Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.
8888888  "Y8888P"  Y8P 8888888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888
                                                           888
                                                          d88P
                                                        888P"
 .d88888b.  888         d8b                   888
d88P" "Y88b 888         Y8P                   888
888     888 888                               888
888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
888     888 888  888    888 88888888 888      888    "Y8888b.
Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
 "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
                        888
                       d88P
                     888P"

19.1 Object Objects
19.1.1 The Object Constructor
19.1.2 Properties of the Object Constructor
19.1.3 Properties of the Object Prototype Object
19.1.4 Properties of Object Instances
"""


# 19.1.1 The Object Constructor
#
# The Object constructor:
#
#     * is the intrinsic object %Object%.
#     * is the initial value of the Object property of the global object.
#     * creates a new ordinary object when called as a constructor.
#     * performs a type conversion when called as a function rather than as a constructor.
#     * is designed to be subclassable. It may be used as the value of an extends clause of a class definition.
def BindBuiltinFunctions(realm, obj, details):
    for key, fcn, length in details:
        func_obj = CreateBuiltinFunction(fcn, [], realm)
        # Check a bunch of things. We need to make our bindable functions in a particular way...
        argspec = inspect.getfullargspec(fcn)
        # function arity must be at least 2: (an empty arg list still has a this pointer and a new target).
        assert len(argspec.args) >= 2
        # All but the first two positional args must have default values:
        # From section 17:
        #   Unless otherwise specified in the description of a particular function, if a built-in function or
        #   constructor is given fewer arguments than the function is specified to require, the function or constructor
        #   shall behave exactly as if it had been given sufficient additional arguments, each such argument being the
        #   undefined value. Such missing arguments are considered to be “not present” and may be identified in that
        #   manner by specification algorithms.
        assert len(argspec.defaults or ()) >= len(argspec.args) - 2
        # Functions must allow any number of arguments:
        # From section 17:
        #   Unless otherwise specified in the description of a particular function, if a built-in function or
        #   constructor described is given more arguments than the function is specified to allow, the extra arguments
        #   are evaluated by the call and then ignored by the function.
        assert argspec.varargs is not None

        # The 'length' property:
        # From section 17:
        #   Every built-in function object, including constructors, has a "length" property whose value is an integer.
        #       Unless otherwise specified, this value is equal to the largest number of named arguments shown in the
        #       subclause headings for the function description. Optional parameters (which are indicated with
        #       brackets: [ ]) or rest parameters (which are shown using the form «...name») are not included in the
        #       default argument count.
        #   Unless otherwise specified, the "length" property of a built-in function object has the attributes
        #       { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.

        # (Old implementation had us passing in length. We assert for consistency here, I'll eventually remove the old
        # implementation.)
        if length is None:
            length = getattr(fcn, "length", len(argspec.args) - 2)
        assert getattr(fcn, "length", len(argspec.args) - 2) == length
        DefinePropertyOrThrow(
            func_obj, "length", PropertyDescriptor(value=length, writable=False, enumerable=False, configurable=True)
        )

        # The 'name' property:
        # From section 17:
        #   Every built-in function object, including constructors, that is not identified as an anonymous function has
        #       a name property whose value is a String. Unless otherwise specified, this value is the name that is
        #       given to the function in this specification. For functions that are specified as properties of objects,
        #       the name value is the property name string used to access the function. Functions that are specified as
        #       get or set accessor functions of built-in properties have "get " or "set " prepended to the property
        #       name string. The value of the name property is explicitly specified for each built-in functions whose
        #       property key is a Symbol value.
        #   Unless otherwise specified, the name property of a built-in function object, if it exists, has the
        #       attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.

        # Again: old implementation uses the key as the name; I want to break that and record the name along with the
        # function definition. A get-with-default is here to ease the pain.
        name = getattr(fcn, "name", key)
        DefinePropertyOrThrow(
            func_obj, "name", PropertyDescriptor(value=name, writable=False, enumerable=False, configurable=True)
        )
        CreateMethodPropertyOrThrow(obj, key, func_obj)

        overrides = getattr(fcn, "attributes", None)
        if overrides:
            desc = obj.GetOwnProperty(key)
            for attr in ("Get", "Set", "value", "writable", "enumerable", "configurable"):
                if hasattr(overrides, attr):
                    setattr(desc, attr, getattr(overrides, attr))
            DefinePropertyOrThrow(obj, key, desc)

    return None


def CreateAndAnnotateBuiltinFunction(fcn, realm):
    argspec = inspect.getfullargspec(fcn)
    assert len(argspec.args) >= 2
    assert len(argspec.defaults or ()) >= len(argspec.args) - 2
    assert argspec.varargs is not None

    f = CreateBuiltinFunction(fcn, [], realm)
    for key in ("length", "name"):
        DefinePropertyOrThrow(
            f, key, PropertyDescriptor(value=getattr(fcn, key), writable=False, enumerable=False, configurable=True)
        )
    return f


def BindBuiltinAccessors(realm, obj, details):
    for key, get_fcn, set_fcn in details:
        g = CreateAndAnnotateBuiltinFunction(get_fcn, realm) if get_fcn else None
        s = CreateAndAnnotateBuiltinFunction(set_fcn, realm) if set_fcn else None
        DefinePropertyOrThrow(obj, key, PropertyDescriptor(Get=g, Set=s, enumerable=False, configurable=True))


def Object_establish_intrinsics(realm):
    # The prototype is already handled for object intrinsics, due to the way bootstrapping happens.
    realm.intrinsics["%Object%"] = CreateObjectConstructor(realm)
    AddObjectPrototypeProps(realm)


def CreateObjectConstructor(realm):
    intrinsics = realm.intrinsics
    obj = CreateBuiltinFunction(ObjectFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "Object")]:
        DefinePropertyOrThrow(
            obj, key, PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        )
    DefinePropertyOrThrow(
        obj,
        "prototype",
        PropertyDescriptor(
            value=intrinsics["%ObjectPrototype%"], writable=False, enumerable=False, configurable=False
        ),
    )
    BindBuiltinFunctions(
        realm,
        obj,
        [
            ("assign", ObjectMethod_assign, 2),
            ("create", ObjectMethod_create, 2),
            ("defineProperties", ObjectMethod_defineProperties, 2),
            ("defineProperty", ObjectMethod_defineProperty, 3),
            ("entries", ObjectMethod_entries, 1),
            ("freeze", ObjectMethod_freeze, 1),
            ("getOwnPropertyDescriptor", ObjectMethod_getOwnPropertyDescriptor, 2),
            ("getOwnPropertyDescriptors", ObjectMethod_getOwnPropertyDescriptors, 1),
            ("getOwnPropertyNames", ObjectMethod_getOwnPropertyNames, 1),
            ("getOwnPropertySymbols", ObjectMethod_getOwnPropertySymbols, 1),
            ("getPrototypeOf", ObjectMethod_getPrototypeOf, 1),
            ("is", ObjectMethod_is, 2),
            ("isExtensible", ObjectMethod_isExtensible, 1),
            ("isFrozen", ObjectMethod_isFrozen, 1),
            ("isSealed", ObjectMethod_isSealed, 1),
            ("keys", ObjectMethod_keys, 1),
            ("preventExtensions", ObjectMethod_preventExtensions, 1),
            ("seal", ObjectMethod_seal, 1),
            ("setPrototypeOf", ObjectMethod_setPrototypeOf, 2),
            ("values", ObjectMethod_values, 1),
        ],
    )
    return obj


# 19.1.1.1 Object ( [ value ] )
def ObjectFunction(this_value, new_target, value=None, *_):
    # When the Object function is called with optional argument value, the following steps are taken:
    #
    # 1. If NewTarget is neither undefined nor the active function, then
    active_function = GetActiveFunction()
    if new_target is not None and new_target != active_function:
        # a. Return ? OrdinaryCreateFromConstructor(NewTarget, "%ObjectPrototype%").
        return OrdinaryCreateFromConstructor(new_target, "%ObjectPrototype%")
    # 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).
    if value is None or isNull(value):
        return ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
    # 3. Return ! ToObject(value).
    return ToObject(value)


# 19.1.2.1 Object.assign ( target, ...sources )
def ObjectMethod_assign(_a, _b, target=None, *sources):
    # The assign function is used to copy the values of all of the enumerable own properties from one or more source
    # objects to a target object. When the assign function is called, the following steps are taken:
    #
    # 1. Let to be ? ToObject(target).
    to_obj = ToObject(target)
    # 2. If only one argument was passed, return to.
    if len(sources) == 0:
        return to_obj
    # 3. Let sources be the List of argument values starting with the second argument.
    # 4. For each element nextSource of sources, in ascending index order, do
    for next_source in sources:
        # a. If nextSource is undefined or null, let keys be a new empty List.
        if isNull(next_source) or next_source is None:
            keys = []
        # b. Else,
        else:
            # i. Let from be ! ToObject(nextSource).
            from_obj = ToObject(next_source)
            # ii. Let keys be ? from.[[OwnPropertyKeys]]().
            keys = from_obj.OwnPropertyKeys()
        # c. For each element nextKey of keys in List order, do
        for next_key in keys:
            # i. Let desc be ? from.[[GetOwnProperty]](nextKey).
            desc = from_obj.GetOwnProperty(next_key)
            # ii. If desc is not undefined and desc.[[Enumerable]] is true, then
            if desc is not None and desc.enumerable:
                # 1. Let propValue be ? Get(from, nextKey).
                prop_value = Get(from_obj, next_key)
                # 2. Perform ? Set(to, nextKey, propValue, true).
                Set(to_obj, next_key, prop_value, True)
    # 5. Return to.
    return to_obj


ObjectMethod_assign.length = 2
ObjectMethod_assign.name = "assign"

# 19.1.2.2 Object.create ( O, Properties )
def ObjectMethod_create(_a, _b, o_value=None, properties=None, *_):
    # The create function creates a new object with a specified prototype. When the create function is called, the
    # following steps are taken:
    #
    # 1. If Type(O) is neither Object nor Null, throw a TypeError exception.
    if not isObject(o_value) and not isNull(o_value):
        raise ESTypeError()
    # 2. Let obj be ObjectCreate(O).
    obj = ObjectCreate(o_value)
    # 3. If Properties is not undefined, then
    if properties is not None:
        # a. Return ? ObjectDefineProperties(obj, Properties).
        return ObjectDefineProperties(obj, properties)
    # 4. Return obj.
    return obj


# 19.1.2.3 Object.defineProperties ( O, Properties )
def ObjectMethod_defineProperties(_a, _b, o_value=None, properties=None, *_):
    # The defineProperties function is used to add own properties and/or update the attributes of existing own
    # properties of an object. When the defineProperties function is called, the following steps are taken:
    #
    # 1. Return ? ObjectDefineProperties(O, Properties).
    return ObjectDefineProperties(o_value, properties)


# 19.1.2.3.1 Runtime Semantics: ObjectDefineProperties ( O, Properties )
def ObjectDefineProperties(o_value, properties):
    # The abstract operation ObjectDefineProperties with arguments O and Properties performs the following steps:
    #
    # 1. If Type(O) is not Object, throw a TypeError exception.
    if not isObject(o_value):
        raise ESTypeError()
    # 2. Let props be ? ToObject(Properties).
    props = ToObject(properties)
    # 3. Let keys be ? props.[[OwnPropertyKeys]]().
    keys = props.OwnPropertyKeys()
    # 4. Let descriptors be a new empty List.
    descriptors = []
    # 5. For each element nextKey of keys in List order, do
    for next_key in keys:
        # a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).
        prop_desc = props.GetOwnProperty(next_key)
        # b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then
        if prop_desc is not None and prop_desc.enumerable:
            # i. Let descObj be ? Get(props, nextKey).
            desc_obj = Get(props, next_key)
            # ii. Let desc be ? ToPropertyDescriptor(descObj).
            desc = ToPropertyDescriptor(desc_obj)
            # iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.
            descriptors.append((next_key, desc))
    # 6. For each pair from descriptors in list order, do
    for prop_key, desc in descriptors:
        # a. Let P be the first element of pair.
        # b. Let desc be the second element of pair.
        # c. Perform ? DefinePropertyOrThrow(O, P, desc).
        DefinePropertyOrThrow(o_value, prop_key, desc)
    # 7. Return O.
    return o_value


# 19.1.2.4 Object.defineProperty ( O, P, Attributes )
def ObjectMethod_defineProperty(_a, _b, o_value=None, prop=None, attributes=None, *_):
    # The defineProperty function is used to add an own property and/or update the attributes of an existing own
    # property of an object. When the defineProperty function is called, the following steps are taken:
    #
    # 1. If Type(O) is not Object, throw a TypeError exception.
    if not isObject(o_value):
        raise ESTypeError()
    # 2. Let key be ? ToPropertyKey(P).
    key = ToPropertyKey(prop)
    # 3. Let desc be ? ToPropertyDescriptor(Attributes).
    desc = ToPropertyDescriptor(attributes)
    # 4. Perform ? DefinePropertyOrThrow(O, key, desc).
    DefinePropertyOrThrow(o_value, key, desc)
    # 5. Return O.
    return o_value


# 19.1.2.5 Object.entries ( O )
def ObjectMethod_entries(_a, _b, o_value=None, *_):
    # When the entries function is called with argument O, the following steps are taken:
    #
    # 1. Let obj be ? ToObject(O).
    obj = ToObject(o_value)
    # 2. Let nameList be ? EnumerableOwnPropertyNames(obj, "key+value").
    name_list = EnumerableOwnPropertyNames(obj, "key+value")
    # 3. Return CreateArrayFromList(nameList).
    return CreateArrayFromList(name_list)


# 19.1.2.6 Object.freeze ( O )
def ObjectMethod_freeze(_a, _b, o_value=None, *_):
    # When the freeze function is called, the following steps are taken:
    #
    # 1. If Type(O) is not Object, return O.
    if not isObject(o_value):
        return o_value
    # 2. Let status be ? SetIntegrityLevel(O, "frozen").
    status = SetIntegrityLevel(o_value, "frozen")
    # 3. If status is false, throw a TypeError exception.
    if not status:
        raise ESTypeError()
    # 4. Return O.
    return o_value


# 19.1.2.7 Object.getOwnPropertyDescriptor ( O, P )
def ObjectMethod_getOwnPropertyDescriptor(_a, _b, o_value=None, propkey=None, *_):
    # When the getOwnPropertyDescriptor function is called, the following steps are taken:
    #
    # 1. Let obj be ? ToObject(O).
    obj = ToObject(o_value)
    # 2. Let key be ? ToPropertyKey(P).
    key = ToPropertyKey(propkey)
    # 3. Let desc be ? obj.[[GetOwnProperty]](key).
    desc = obj.GetOwnProperty(key)
    # 4. Return FromPropertyDescriptor(desc).
    return FromPropertyDescriptor(desc)


# 19.1.2.8 Object.getOwnPropertyDescriptors ( O )
def ObjectMethod_getOwnPropertyDescriptors(_a, _b, o_value=None, *_):
    # When the getOwnPropertyDescriptors function is called, the following steps are taken:
    #
    # 1. Let obj be ? ToObject(O).
    obj = ToObject(o_value)
    # 2. Let ownKeys be ? obj.[[OwnPropertyKeys]]().
    own_keys = obj.OwnPropertyKeys()
    # 3. Let descriptors be ! ObjectCreate(%ObjectPrototype%).
    descriptors = ObjectCreate(surrounding_agent.running_ec.realm.intrinsics["%ObjectPrototype%"])
    # 4. For each element key of ownKeys in List order, do
    for key in own_keys:
        # a. Let desc be ? obj.[[GetOwnProperty]](key).
        desc = obj.GetOwnProperty(key)
        # b. Let descriptor be ! FromPropertyDescriptor(desc).
        descriptor = FromPropertyDescriptor(desc)
        # c. If descriptor is not undefined, perform ! CreateDataProperty(descriptors, key, descriptor).
        if descriptor is not None:
            CreateDataProperty(descriptors, key, descriptor)
    # 5. Return descriptors.
    return descriptors


# 19.1.2.9 Object.getOwnPropertyNames ( O )
def ObjectMethod_getOwnPropertyNames(_a, _b, o_value=None, *_):
    # When the getOwnPropertyNames function is called, the following steps are taken:
    #
    # 1. Return ? GetOwnPropertyKeys(O, String).
    return GetOwnPropertyKeys(o_value, isString)


# 19.1.2.10 Object.getOwnPropertySymbols ( O )
def ObjectMethod_getOwnPropertySymbols(_a, _b, o_value=None, *_):
    # When the getOwnPropertySymbols function is called with argument O, the following steps are taken:
    #
    # 1. Return ? GetOwnPropertyKeys(O, Symbol).
    return GetOwnPropertyKeys(o_value, isSymbol)


# 19.1.2.10.1 Runtime Semantics: GetOwnPropertyKeys ( O, Type )
def GetOwnPropertyKeys(o_value, type_checker):
    # The abstract operation GetOwnPropertyKeys is called with arguments O and Type where O is an Object and Type is
    # one of the ECMAScript specification types String or Symbol. The following steps are taken:
    #
    # 1. Let obj be ? ToObject(O).
    obj = ToObject(o_value)
    # 2. Let keys be ? obj.[[OwnPropertyKeys]]().
    keys = obj.OwnPropertyKeys()
    # 3. Let nameList be a new empty List.
    # 4. For each element nextKey of keys in List order, do
    # a. If Type(nextKey) is Type, then
    # i. Append nextKey as the last element of nameList.
    name_list = [key for key in keys if type_checker(key)]
    # 5. Return CreateArrayFromList(nameList).
    return CreateArrayFromList(name_list)


# 19.1.2.11 Object.getPrototypeOf ( O )
def ObjectMethod_getPrototypeOf(_a, _b, o_value=None, *_):
    # When the getPrototypeOf function is called with argument O, the following steps are taken:
    #
    # 1. Let obj be ? ToObject(O).
    obj = ToObject(o_value)
    # 2. Return ? obj.[[GetPrototypeOf]]().
    return obj.GetPrototypeOf()


# 19.1.2.12 Object.is ( value1, value2 )
def ObjectMethod_is(_a, _b, value1=None, value2=None, *_):
    # When the is function is called with arguments value1 and value2, the following steps are taken:
    #
    # 1. Return SameValue(value1, value2).
    return SameValue(value1, value2)


# 19.1.2.13 Object.isExtensible ( O )
def ObjectMethod_isExtensible(_a, _b, o_value=None, *_):
    # When the isExtensible function is called with argument O, the following steps are taken:
    #
    # 1. If Type(O) is not Object, return false.
    if not isObject(o_value):
        return False
    # 2. Return ? IsExtensible(O).
    return IsExtensible(o_value)


# 19.1.2.14 Object.isFrozen ( O )
def ObjectMethod_isFrozen(_a, _b, o_value=None, *_):
    # When the isFrozen function is called with argument O, the following steps are taken:
    #
    # 1. If Type(O) is not Object, return true.
    if not isObject(o_value):
        return True
    # 2. Return ? TestIntegrityLevel(O, "frozen").
    return TestIntegrityLevel(o_value, "frozen")


# 19.1.2.15 Object.isSealed ( O )
def ObjectMethod_isSealed(_a, _b, o_value=None, *_):
    # When the isSealed function is called with argument O, the following steps are taken:
    #
    # 1. If Type(O) is not Object, return true.
    if not isObject(o_value):
        return True
    # 2. Return ? TestIntegrityLevel(O, "sealed").
    return TestIntegrityLevel(o_value, "sealed")


# 19.1.2.16 Object.keys ( O )
def ObjectMethod_keys(_a, _b, o_value=None, *_):
    # When the keys function is called with argument O, the following steps are taken:
    #
    # 1. Let obj be ? ToObject(O).
    obj = ToObject(o_value)
    # 2. Let nameList be ? EnumerableOwnPropertyNames(obj, "key").
    name_list = EnumerableOwnPropertyNames(obj, "key")
    # 3. Return CreateArrayFromList(nameList).
    return CreateArrayFromList(name_list)


# 19.1.2.17 Object.preventExtensions ( O )
def ObjectMethod_preventExtensions(_a, _b, o_value=None, *_):
    # When the preventExtensions function is called, the following steps are taken:
    #
    # 1. If Type(O) is not Object, return O.
    if not isObject(o_value):
        return o_value
    # 2. Let status be ? O.[[PreventExtensions]]().
    status = o_value.PreventExtensions()
    # 3. If status is false, throw a TypeError exception.
    if not status:
        raise ESTypeError()
    # 4. Return O.
    return o_value


# 19.1.2.19 Object.seal ( O )
def ObjectMethod_seal(_a, _b, o_value=None, *_):
    # When the seal function is called, the following steps are taken:
    #
    # 1. If Type(O) is not Object, return O.
    if not isObject(o_value):
        return o_value
    # 2. Let status be ? SetIntegrityLevel(O, "sealed").
    status = SetIntegrityLevel(o_value, "sealed")
    # 3. If status is false, throw a TypeError exception.
    if not status:
        raise ESTypeError()
    # 4. Return O.
    return o_value


# 19.1.2.20 Object.setPrototypeOf ( O, proto )
def ObjectMethod_setPrototypeOf(_a, _b, o_value=None, proto=None, *_):
    # When the setPrototypeOf function is called with arguments O and proto, the following steps are taken:
    #
    # 1. Let O be ? RequireObjectCoercible(O).
    o_value = RequireObjectCoercible(o_value)
    # 2. If Type(proto) is neither Object nor Null, throw a TypeError exception.
    if not isObject(proto) and not isNull(proto):
        raise ESTypeError()
    # 3. If Type(O) is not Object, return O.
    if not isObject(o_value):
        return o_value
    # 4. Let status be ? O.[[SetPrototypeOf]](proto).
    status = o_value.SetPrototypeOf(proto)
    # 5. If status is false, throw a TypeError exception.
    if not status:
        raise ESTypeError()
    # 6. Return O.
    return o_value


# 19.1.2.21 Object.values ( O )
def ObjectMethod_values(_a, _b, o_value=None, *_):
    # When the values function is called with argument O, the following steps are taken:
    #
    # 1. Let obj be ? ToObject(O).
    obj = ToObject(o_value)
    # 2. Let nameList be ? EnumerableOwnPropertyNames(obj, "value").
    name_list = EnumerableOwnPropertyNames(obj, "value")
    # 3. Return CreateArrayFromList(nameList).
    return CreateArrayFromList(name_list)


# 19.1.3 Properties of the Object Prototype Object
#
# The Object prototype object:
#    * is the intrinsic object %ObjectPrototype%.
#    * is an immutable prototype exotic object.
#    * has a [[Prototype]] internal slot whose value is null.
#
def AddObjectPrototypeProps(realm_rec):
    intrinsics = realm_rec.intrinsics
    obj = intrinsics["%ObjectPrototype%"]
    # 19.1.3.1 Object.prototype.constructor
    # The initial value of Object.prototype.constructor is the intrinsic object %Object%.
    DefinePropertyOrThrow(
        obj,
        "constructor",
        PropertyDescriptor(value=intrinsics["%Object%"], writable=False, enumerable=False, configurable=False),
    )
    BindBuiltinFunctions(
        realm_rec,
        obj,
        [
            ("hasOwnProperty", ObjectPrototype_hasOwnProperty, 1),
            ("isPrototypeOf", ObjectPrototype_isPrototypeOf, 1),
            ("propertyIsEnumerable", ObjectPrototype_propertyIsEnumerable, 1),
            ("toLocaleString", ObjectPrototype_toLocaleString, 0),
            ("toString", ObjectPrototype_toString, 0),
            ("valueOf", ObjectPrototype_valueOf, 0),
        ],
    )
    return None


# 19.1.3.2 Object.prototype.hasOwnProperty ( V )
def ObjectPrototype_hasOwnProperty(this_value, _nt, key=None, *_):
    # When the hasOwnProperty method is called with argument V, the following steps are taken:
    #
    # 1. Let P be ? ToPropertyKey(V).
    p = ToPropertyKey(key)
    # 2. Let O be ? ToObject(this value).
    o = ToObject(this_value)
    # 3. Return ? HasOwnProperty(O, P).
    return HasOwnProperty(o, p)
    # NOTE
    # The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in
    # previous editions of this specification will continue to be thrown even if the this value is undefined or null.


# 19.1.3.3 Object.prototype.isPrototypeOf ( V )
def ObjectPrototype_isPrototypeOf(this_value, _nt, obj=None, *_):
    # When the isPrototypeOf method is called with argument V, the following steps are taken:
    #
    # 1. If Type(V) is not Object, return false.
    if not isObject(obj):
        return False
    # 2. Let O be ? ToObject(this value).
    o = ToObject(this_value)
    # 3. Repeat,
    while 1:
        # a. Let V be ? V.[[GetPrototypeOf]]().
        obj = obj.GetPrototypeOf()
        # b. If V is null, return false.
        if isNull(obj):
            return False
        # c. If SameValue(O, V) is true, return true.
        if SameValue(o, obj):
            return True
    # NOTE
    # The ordering of steps 1 and 2 preserves the behaviour specified by previous editions of this specification for
    # the case where V is not an object and the this value is undefined or null.


# 19.1.3.4 Object.prototype.propertyIsEnumerable ( V )
def ObjectPrototype_propertyIsEnumerable(this_value, _nt, v=None, *_):
    # When the propertyIsEnumerable method is called with argument V, the following steps are taken:
    #
    # 1. Let P be ? ToPropertyKey(V).
    p = ToPropertyKey(v)
    # 2. Let O be ? ToObject(this value).
    o = ToObject(this_value)
    # 3. Let desc be ? O.[[GetOwnProperty]](P).
    desc = o.GetOwnProperty(p)
    # 4. If desc is undefined, return false.
    if desc is None:
        return False
    # 5. Return desc.[[Enumerable]].
    return desc.enumerable
    # NOTE 1
    # This method does not consider objects in the prototype chain.
    # NOTE 2
    # The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 in
    # previous editions of this specification will continue to be thrown even if the this value is undefined or null.


# 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
def ObjectPrototype_toLocaleString(this_value, _nt, reserved1=EMPTY, reserved2=EMPTY, *_):
    # When the toLocaleString method is called, the following steps are taken:
    #
    # 1. Let O be the this value.
    o = this_value
    # 2. Return ? Invoke(O, "toString").
    return Invoke(o, "toString")
    # The optional parameters to this function are not used but are intended to correspond to the parameter pattern
    # used by ECMA-402  toLocaleString functions. Implementations that do not include ECMA-402 support must not use
    # those parameter positions for other purposes.
    #
    # NOTE 1
    # This function provides a generic toLocaleString implementation for objects that have no locale-specific toString
    # behaviour. Array, Number, Date, and Typed Arrays provide their own locale-sensitive toLocaleString methods.
    # NOTE 2
    # ECMA-402 intentionally does not provide an alternative to this default implementation.


ObjectPrototype_toLocaleString.length = 0
ObjectPrototype_toLocaleString.name = "toLocaleString"

# 19.1.3.6 Object.prototype.toString ( )
def ObjectPrototype_toString(this_value, new_target, *_):
    # When the toString method is called, the following steps are taken:
    #
    # 1. If the this value is undefined, return "[object Undefined]".
    if this_value is None:
        return "[object Undefined]"
    # 2. If the this value is null, return "[object Null]".
    if isNull(this_value):
        return "[object Null]"
    # 3. Let O be ! ToObject(this value).
    o = ToObject(this_value)
    # 4. Let isArray be ? IsArray(O).
    is_array = IsArray(o)
    # 5. If isArray is true, let builtinTag be "Array".
    if is_array:
        builtin_tag = "Array"
    # 6. Else if O is a String exotic object, let builtinTag be "String".
    elif isinstance(o, StringObject):
        builtin_tag = "String"
    # 7. Else if O has a [[ParameterMap]] internal slot, let builtinTag be "Arguments".
    elif hasattr(o, "ParameterMap"):
        builtin_tag = "Arguments"
    # 8. Else if O has a [[Call]] internal method, let builtinTag be "Function".
    elif hasattr(o, "Call"):
        builtin_tag = "Function"
    # 9. Else if O has an [[ErrorData]] internal slot, let builtinTag be "Error".
    elif hasattr(o, "ErrorData"):
        builtin_tag = "Error"
    # 10. Else if O has a [[BooleanData]] internal slot, let builtinTag be "Boolean".
    elif hasattr(o, "BooleanData"):
        builtin_tag = "Boolean"
    # 11. Else if O has a [[NumberData]] internal slot, let builtinTag be "Number".
    elif hasattr(o, "NumberData"):
        builtin_tag = "Number"
    # 12. Else if O has a [[DateValue]] internal slot, let builtinTag be "Date".
    elif hasattr(o, "DateValue"):
        builtin_tag = "Date"
    # 13. Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be "RegExp".
    elif hasattr(o, "RegExpMatcher"):
        builtin_tag = "RegExp"
    # 14. Else, let builtinTag be "Object".
    else:
        builtin_tag = "Object"
    # 15. Let tag be ? Get(O, @@toStringTag).
    tag = Get(o, wks_to_string_tag)
    # 16. If Type(tag) is not String, let tag be builtinTag.
    if not isString(tag):
        tag = builtin_tag
    # 17. Return the string-concatenation of "[object ", tag, and "]".
    return f"[object {tag}]"
    # This function is the %ObjProto_toString% intrinsic object.
    # NOTE
    # Historically, this function was occasionally used to access the String value of the [[Class]] internal slot that
    # was used in previous editions of this specification as a nominal type tag for various built-in objects. The above
    # definition of toString preserves compatibility for legacy code that uses toString as a test for those specific
    # kinds of built-in objects. It does not provide a reliable type testing mechanism for other kinds of built-in or
    # program defined objects. In addition, programs can use @@toStringTag in ways that will invalidate the reliability
    # of such legacy type tests.


# 19.1.3.7 Object.prototype.valueOf ( )
def ObjectPrototype_valueOf(this_value, new_target, *_):
    # When the valueOf method is called, the following steps are taken:
    #
    # 1. Return ? ToObject(this value).
    return ToObject(this_value)
    # This function is the %ObjProto_valueOf% intrinsic object.


#####################################################################################################################################################################
#
#  d888    .d8888b.       .d8888b.      8888888888                            888    d8b                        .d88888b.  888         d8b                   888
# d8888   d88P  Y88b     d88P  Y88b     888                                   888    Y8P                       d88P" "Y88b 888         Y8P                   888
#   888   888    888            888     888                                   888                              888     888 888                               888
#   888   Y88b. d888          .d88P     8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#   888    "Y888P888      .od888P"      888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
#   888          888     d88P"          888        888  888 888  888 888      888    888 888  888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
#   888   Y88b  d88P d8b 888"           888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 8888888  "Y8888P"  Y8P 888888888      888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                                                      888
#                                                                                                                                     d88P
#                                                                                                                                   888P"
#
#####################################################################################################################################################################
# 19.2 Function Objects
# 19.2.1 The Function Constructor

# The Function constructor:
#
# * is the intrinsic object %Function%.
# * is the initial value of the Function property of the global object.
# * creates and initializes a new function object when called as a function rather than as a constructor. Thus the
#   function call Function(…) is equivalent to the object creation expression new Function(…) with the same arguments.
# * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#   constructors that intend to inherit the specified Function behaviour must include a super call to the Function
#   constructor to create and initialize a subclass instance with the internal slots necessary for built-in function
#   behaviour. All ECMAScript syntactic forms for defining function objects create instances of Function. There is no
#   syntactic means to create instances of Function subclasses except for the built-in GeneratorFunction,
#   AsyncFunction, and AsyncGeneratorFunction subclasses.

# ------------------------------------ 𝟏𝟗.𝟐.𝟏.𝟏 𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏 ( 𝒑𝟏, 𝒑𝟐, … , 𝒑𝒏, 𝒃𝒐𝒅𝒚 ) ------------------------------------
# 19.2.1.1 Function ( p1, p2, … , pn, body )
def FunctionFunction(this_value, new_target, *args):
    # The last argument specifies the body (executable code) of a function; any preceding arguments specify formal
    # parameters.
    #
    # When the Function function is called with some arguments p1, p2, … , pn, body (where n might be 0, that is, there
    # are no “ p ” arguments, and where body might also not be provided), the following steps are taken:
    #
    #   1. Let C be the active function object.
    #   2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
    #   3. Return ? CreateDynamicFunction(C, NewTarget, "normal", args).
    return CreateDynamicFunction(surrounding_agent.running_ec.function, new_target, "normal", args)
    #
    # NOTE
    # It is permissible but not necessary to have one argument for each formal parameter to be specified. For example,
    # all three of the following expressions produce the same result:
    #
    # new Function("a", "b", "c", "return a+b+c")
    # new Function("a, b, c", "return a+b+c")
    # new Function("a,b", "c", "return a+b+c")


# ------------------------------------ 𝟏𝟗.𝟐.𝟏.𝟏.𝟏 𝑹𝒖𝒏𝒕𝒊𝒎𝒆 𝑺𝒆𝒎𝒂𝒏𝒕𝒊𝒄𝒔: 𝑪𝒓𝒆𝒂𝒕𝒆𝑫𝒚𝒏𝒂𝒎𝒊𝒄𝑭𝒖𝒏𝒄𝒕𝒊𝒐𝒏 ( 𝒄𝒐𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒐𝒓, 𝒏𝒆𝒘𝑻𝒂𝒓𝒈𝒆𝒕, 𝒌𝒊𝒏𝒅, 𝒂𝒓𝒈𝒔 ) ------------------------------------
# 19.2.1.1.1 Runtime Semantics: CreateDynamicFunction ( constructor, newTarget, kind, args )
def CreateDynamicFunction(constructor, newTarget, kind, args):
    # The abstract operation CreateDynamicFunction is called with arguments constructor, newTarget, kind, and args.
    # constructor is the constructor function that is performing this action, newTarget is the constructor that new was
    # initially applied to, kind is either "normal", "generator",  "async", or "async generator", and args is a List
    # containing the actual argument values that were passed to constructor. The following steps are taken:
    #
    #   1. Assert: The execution context stack has at least two elements.
    #   2. Let callerContext be the second to top element of the execution context stack.
    #   3. Let callerRealm be callerContext's Realm.
    #   4. Let calleeRealm be the current Realm Record.
    #   5. Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).
    #   6. If newTarget is undefined, set newTarget to constructor.
    #   7. If kind is "normal", then
    #       a. Let goal be the grammar symbol FunctionBody[~Yield, ~Await].
    #       b. Let parameterGoal be the grammar symbol FormalParameters[~Yield, ~Await].
    #       c. Let fallbackProto be "%FunctionPrototype%".
    #   8. Else if kind is "generator", then
    #       a. Let goal be the grammar symbol GeneratorBody.
    #       b. Let parameterGoal be the grammar symbol FormalParameters[+Yield, ~Await].
    #       c. Let fallbackProto be "%Generator%".
    #   9. Else if kind is "async", then
    #       a. Assert: kind is "async".
    #       b. Let goal be the grammar symbol AsyncFunctionBody.
    #       c. Let parameterGoal be the grammar symbol FormalParameters[~Yield, +Await].
    #       d. Let fallbackProto be "%AsyncFunctionPrototype%".
    #   10. Else,
    #       a. Assert: kind is "async generator".
    #       b. Let goal be the grammar symbol AsyncGeneratorBody.
    #       c. Let parameterGoal be the grammar symbol FormalParameters[+Yield, +Await].
    #       d. Let fallbackProto be "%AsyncGenerator%".
    #   11. Let argCount be the number of elements in args.
    #   12. Let P be the empty String.
    #   13. If argCount = 0, let bodyText be the empty String.
    #   14. Else if argCount = 1, let bodyText be args[0].
    #   15. Else argCount > 1,
    #       a. Let firstArg be args[0].
    #       b. Set P to ? ToString(firstArg).
    #       c. Let k be 1.
    #       d. Repeat, while k < argCount-1
    #           i. Let nextArg be args[k].
    #           ii. Let nextArgString be ? ToString(nextArg).
    #           iii. Set P to the string-concatenation of the previous value of P, "," (a comma), and nextArgString.
    #           iv. Increase k by 1.
    #       e. Let bodyText be args[k].
    #   16. Set bodyText to ? ToString(bodyText).
    #   17. Let parameters be the result of parsing P, interpreted as UTF-16 encoded Unicode text as described in
    #       6.1.4, using parameterGoal as the goal symbol. Throw a SyntaxError exception if the parse fails.
    #   18. Let body be the result of parsing bodyText, interpreted as UTF-16 encoded Unicode text as described in
    #       6.1.4, using goal as the goal symbol. Throw a SyntaxError exception if the parse fails.
    #   19. Let strict be ContainsUseStrict of body.
    #   20. If any static semantics errors are detected for parameters or body, throw a SyntaxError or a ReferenceError
    #       exception, depending on the type of the error. If strict is true, the Early Error rules for
    #       UniqueFormalParameters:FormalParameters are applied. Parsing and early error detection may be interweaved
    #       in an implementation-dependent manner.
    #   21. If strict is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.
    #   22. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a
    #       SyntaxError exception.
    #   23. If body Contains SuperCall is true, throw a SyntaxError exception.
    #   24. If parameters Contains SuperCall is true, throw a SyntaxError exception.
    #   25. If body Contains SuperProperty is true, throw a SyntaxError exception.
    #   26. If parameters Contains SuperProperty is true, throw a SyntaxError exception.
    #   27. If kind is "generator" or "async generator", then
    #       a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.
    #   28. If kind is "async" or "async generator", then
    #       a. If parameters Contains AwaitExpression is true, throw a SyntaxError exception.
    #   29. If strict is true, then
    #       a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.
    #   30. Let proto be ? GetPrototypeFromConstructor(newTarget, fallbackProto).
    #   31. Let F be FunctionAllocate(proto, strict, kind).
    #   32. Let realmF be F.[[Realm]].
    #   33. Let scope be realmF.[[GlobalEnv]].
    #   34. Perform FunctionInitialize(F, Normal, parameters, body, scope).
    #   35. If kind is "generator", then
    #       a. Let prototype be ObjectCreate(%GeneratorPrototype%).
    #       b. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype,
    #          [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
    #   36. Else if kind is "async generator", then
    #       a. Let prototype be ObjectCreate(%AsyncGeneratorPrototype%).
    #       b. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype,
    #          [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
    #   37. Else if kind is "normal", perform MakeConstructor(F).
    #   38. NOTE: Async functions are not constructable and do not have a [[Construct]] internal method or a
    #       "prototype" property.
    #   39. Perform SetFunctionName(F, "anonymous").
    #   40. Return F.
    assert len(surrounding_agent.ec_stack) >= 2
    callerContext = surrounding_agent.ec_stack[-2]
    callerRealm = callerContext.realm
    calleeRealm = surrounding_agent.running_ec.realm
    HostEnsureCanCompileStrings(callerRealm, calleeRealm)
    if newTarget is None:
        newTarget = constructor
    if kind == "normal":
        goal = "FunctionBody"
        goal_parse = lambda context, lexer: parse_FunctionBody(context, lexer, 0, False, False, False)
        parameterGoal = "FormalParameters"
        param_parse = lambda context, lexer: parse_FormalParameters(context, lexer, 0, False, False, False)
        fallbackProto = "%FunctionPrototype%"
    elif kind == "generator":
        goal = "GeneratorBody"
        goal_parse = parse_GeneratorBody
        parameterGoal = "FormalParameters"
        param_parse = lambda context, lexer: parse_FormalParameters(context, lexer, 0, False, True, False)
        fallbackProto = "%Generator%"
    elif kind == "async":
        goal = "AsyncFunctionBody"
        goal_parse = parse_AsyncFunctionBody
        parameterGoal = "FormalParameters"
        param_parse = lambda context, lexer: parse_FormalParameters(context, lexer, 0, False, False, True)
        fallbackProto = "%AsyncFunctionPrototype%"
    else:
        assert kind == "async generator"
        goal = "AsyncGeneratorBody"
        goal_parse = parse_AsyncGeneratorBody
        parameterGoal = "FormalParameters"
        param_parse = lambda context, lexer: parse_FormalParameters(context, lexer, 0, False, True, True)
        fallbackProto = "%AsyncGenerator%"
    argCount = len(args)
    P = ""
    if argCount == 0:
        bodyText = ""
    elif argCount == 1:
        bodyText = args[0]
    else:
        P = ",".join(ToString(nextArg) for nextArg in args[:-1])
        bodyText = args[-1]
    bodyText = ToString(bodyText)

    parameter_context = Parse2Context(direct_eval=False, syntax_error_ctor=ESSyntaxError, goal=parameterGoal)
    plexer = LexerCore(P, ESSyntaxError)
    try:
        parameters = param_parse(parameter_context, plexer)
    except ESError as err:
        raise ESSyntaxError(ToString(err.ecma_object))

    body_context = Parse2Context(direct_eval=False, syntax_error_ctor=ESSyntaxError, goal=goal)
    blexer = LexerCore(bodyText, ESSyntaxError)
    try:
        body = goal_parse(body_context, blexer)
    except ESError as err:
        raise ESSyntaxError(ToString(err.ecma_object))

    strict = body.ContainsUseStrict()
    body_early = body.EarlyErrorsScan()
    if body_early:
        raise ESError(body_early[0])
    param_early = parameters.EarlyErrorsScan()
    if strict:
        param_early.extend(UniqueFormalParameters_EarlyErrors(parameters))
    if param_early:
        raise ESError(param_early[0])
    if strict and not parameters.IsSimpleParameterList():
        raise ESSyntaxError("Complex parameter lists not allowed in strict mode")
    bn = set(parameters.BoundNames())
    ldn = set(body.LexicallyDeclaredNames())
    dups = bn.intersection(ldn)
    if dups:
        raise ESSyntaxError(f'Parameter identifiers duplicated in body: {", ".join(dups)}')
    if body.Contains("SuperCall") or parameters.Contains("SuperCall"):
        raise ESSyntaxError("Eval function may not contain super calls")
    if any(pn.Contains("SuperProperty") for pn in (body, parameters)):
        raise ESSyntaxError("Eval function may not contain super properties")
    if kind in ("generator", "async generator") and parameters.Contains("YieldExpression"):
        raise ESSyntaxError("Yield statements not allowed in generators")
    if kind in ("async", "async generator") and parameters.Contains("AwaitExpression"):
        raise ESSyntaxError("Await statements not allowed in async functions")
    if strict:
        duplicates = [name for name, count in Counter(parameters.BoundNames()).items() if count > 1]
        if duplicates:
            raise ESSyntaxError(f'Duplicate parameter declarations: {", ".join(duplicates)}')

    proto = GetPrototypeFromConstructor(newTarget, fallbackProto)
    F = FunctionAllocate(proto, strict, kind)
    realmF = F.Realm
    scope = realmF.global_env
    FunctionInitialize(F, NORMAL, parameters, body, scope)
    if kind == "generator":
        prototype = ObjectCreate(surrounding_agent.running_ec.realm["%GeneratorPrototype%"])
        DefinePropertyOrThrow(
            F, "prototype", PropertyDescriptor(value=prototype, writable=True, enumerable=False, configurable=False)
        )
    elif kind == "async generator":
        prototype = ObjectCreate(surrounding_agent.running_ec.realm["%AsyncGeneratorPrototype%"])
        DefinePropertyOrThrow(
            F, "prototype", PropertyDescriptor(value=prototype, writable=True, enumerable=False, configurable=False)
        )
    elif kind == "normal":
        MakeConstructor(F)
    SetFunctionName(F, "anonymous")
    return F
    # NOTE
    # A prototype property is created for every non-async function created using CreateDynamicFunction to provide for
    # the possibility that the function will be used as a constructor.


# 19.2.2 Properties of the Function Constructor
# The Function constructor:
#
# * is itself a built-in function object.
# * has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.


def CreateFunctionConstructor(realm):
    obj = CreateBuiltinFunction(FunctionFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "Function")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    return obj


def FunctionFixups(realm):
    constructor = realm.intrinsics["%Function%"]
    prototype = realm.intrinsics["%FunctionPrototype%"]
    DefinePropertyOrThrow(
        constructor,
        "prototype",
        PropertyDescriptor(value=prototype, writable=False, enumerable=False, configurable=False),
    )
    DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor(value=constructor))
    return None


def AttachFunctionPrototypeProperties(proto, realm):
    DefinePropertyOrThrow(
        proto, "length", PropertyDescriptor(value=0, writable=False, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        proto, "name", PropertyDescriptor(value="", writable=False, enumerable=False, configurable=True)
    )
    BindBuiltinFunctions(
        realm,
        proto,
        [
            ("apply", FunctionPrototype_apply, 2),
            ("bind", FunctionPrototype_bind, 1),
            ("call", FunctionPrototype_call, 1),
            ("toString", FunctionPrototype_toString, 0),
        ],
    )
    func = CreateBuiltinFunction(FunctionPrototype_hasInstance, [], realm)
    DefinePropertyOrThrow(
        func, "length", PropertyDescriptor(value=1, writable=False, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        func,
        "name",
        PropertyDescriptor(value="[Symbol.hasInstance]", writable=False, enumerable=False, configurable=False),
    )
    CreateMethodPropertyOrThrow(proto, wks_has_instance, func)


# 19.2.3.1 Function.prototype.apply ( thisArg, argArray )
def FunctionPrototype_apply(this_value, new_target, thisArg=None, argArray=None, *_):
    # When the apply method is called on an object func with arguments thisArg and argArray, the following steps are
    # taken:
    #
    #   1. If IsCallable(func) is false, throw a TypeError exception.
    #   2. If argArray is undefined or null, then
    #       a. Perform PrepareForTailCall().
    #       b. Return ? Call(func, thisArg).
    #   3. Let argList be ? CreateListFromArrayLike(argArray).
    #   4. Perform PrepareForTailCall().
    #   5. Return ? Call(func, thisArg, argList).
    if not IsCallable(this_value):
        raise ESTypeError("'apply' called as a method of a non-function")
    if argArray is None or isNull(argArray):
        PrepareForTailCall()
        return Call(this_value, thisArg)
    argList = CreateListFromArrayLike(argArray)
    PrepareForTailCall()
    return Call(this_value, thisArg, argList)
    # NOTE 1
    # The thisArg value is passed without modification as the this value. This is a change from Edition 3, where an
    # undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that
    # result is passed as the this value. Even though the thisArg is passed without modification, non-strict functions
    # still perform these transformations upon entry to the function.
    #
    # NOTE 2
    # If func is an arrow function or a bound function then the thisArg will be ignored by the function [[Call]] in
    # step 5.


# 19.2.3.2 Function.prototype.bind ( thisArg, ...args )
def FunctionPrototype_bind(this_value, new_target, thisArg=None, *args):
    # When the bind method is called with argument thisArg and zero or more args, it performs the following steps:
    #
    #   1. Let Target be the this value.
    #   2. If IsCallable(Target) is false, throw a TypeError exception.
    #   3. Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in
    #      order.
    #   4. Let F be ? BoundFunctionCreate(Target, thisArg, args).
    #   5. Let targetHasLength be ? HasOwnProperty(Target, "length").
    #   6. If targetHasLength is true, then
    #       a. Let targetLen be ? Get(Target, "length").
    #       b. If Type(targetLen) is not Number, let L be 0.
    #       c. Else,
    #           i. Let targetLen be ToInteger(targetLen).
    #           ii. Let L be the larger of 0 and the result of targetLen minus the number of elements of args.
    #   7. Else, let L be 0.
    #   8. Perform ! SetFunctionLength(F, L).
    #   9. Let targetName be ? Get(Target, "name").
    #   10. If Type(targetName) is not String, let targetName be the empty string.
    #   11. Perform SetFunctionName(F, targetName, "bound").
    #   12. Return F.
    Target = this_value
    if not IsCallable(Target):
        raise ESTypeError("'bind' called from non-function")
    F = BoundFunctionCreate(Target, thisArg, args)
    if HasOwnProperty(Target, "length"):
        targetLen = Get(Target, "length")
        if not isNumber(targetLen):
            L = 0
        else:
            targetLen = ToInteger(targetLen)
            L = max(0, targetLen - len(args))
    else:
        L = 0
    SetFunctionLength(F, L)
    targetName = Get(Target, "name")
    if not isString(targetName):
        targetName = ""
    SetFunctionName(F, targetName, "bound")
    return F
    # NOTE 1
    # Function objects created using Function.prototype.bind are exotic objects. They also do not have a prototype
    # property.
    #
    # NOTE 2
    # If Target is an arrow function or a bound function then the thisArg passed to this method will not be used by
    # subsequent calls to F.


# 19.2.3.3 Function.prototype.call ( thisArg, ...args )
def FunctionPrototype_call(this_value, new_target, thisArg=None, *args):
    # When the call method is called on an object func with argument, thisArg and zero or more args, the following
    # steps are taken:
    #
    #   1. If IsCallable(func) is false, throw a TypeError exception.
    #   2. Let argList be a new empty List.
    #   3. If this method was called with more than one argument, then in left to right order, starting with the second
    #      argument, append each argument as the last element of argList.
    #   4. Perform PrepareForTailCall().
    #   5. Return ? Call(func, thisArg, argList).
    if not IsCallable(this_value):
        raise TypeError("'call' called from a non-function")
    PrepareForTailCall()
    return Call(this_value, thisArg, args)
    # NOTE 1
    # The thisArg value is passed without modification as the this value. This is a change from Edition 3, where an
    # undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that
    # result is passed as the this value. Even though the thisArg is passed without modification, non-strict functions
    # still perform these transformations upon entry to the function.
    #
    # NOTE 2
    # If func is an arrow function or a bound function then the thisArg will be ignored by the function [[Call]] in
    # step 5.


# 19.2.3.5 Function.prototype.toString ( )
def FunctionPrototype_toString(this_value, new_target, *_):
    # When the toString method is called on an object func, the following steps are taken:
    #
    #   1. If func is a Bound Function exotic object, then
    #       a. Return an implementation-dependent String source code representation of func. The representation must
    #          conform to the rules below. It is implementation-dependent whether the representation includes bound
    #          function information or information about the target function.
    #   2. If Type(func) is Object and is either a built-in function object or has an [[ECMAScriptCode]] internal slot,
    #      then
    #       a. Return an implementation-dependent String source code representation of func. The representation must
    #          conform to the rules below.
    #   3. Throw a TypeError exception.
    #
    # toString Representation Requirements:
    #
    # The string representation must have the syntax of a FunctionDeclaration, FunctionExpression,
    # GeneratorDeclaration, GeneratorExpression, AsyncFunctionDeclaration, AsyncFunctionExpression,
    # AsyncGeneratorDeclaration, AsyncGeneratorExpression, ClassDeclaration, ClassExpression, ArrowFunction,
    # AsyncArrowFunction, or MethodDefinition depending upon the actual characteristics of the object.
    #
    # The use and placement of white space, line terminators, and semicolons within the representation String is
    # implementation-dependent.
    #
    # If the object was defined using ECMAScript code and the returned string representation is not in the form of a
    # MethodDefinition or GeneratorMethod then the representation must be such that if the string is evaluated, using
    # eval in a lexical context that is equivalent to the lexical context used to create the original object, it will
    # result in a new functionally equivalent object. In that case the returned source code must not mention freely any
    # variables that were not mentioned freely by the original function's source code, even if these “extra” names were
    # originally in scope.
    #
    # If the implementation cannot produce a source code string that meets these criteria then it must return a string
    # for which eval will throw a SyntaxError exception.

    # Note: this gets changed around a lot in the next version of ecmascript, so pouring lots into the implementation
    # here now seems like a poor use of time.
    return "function () { [ native code ] }"


# 19.2.3.6 Function.prototype [ @@hasInstance ] ( V )
def FunctionPrototype_hasInstance(this_value, new_target, V, *_):
    # When the @@hasInstance method of an object F is called with value V, the following steps are taken:
    #
    #   1. Let F be the this value.
    #   2. Return ? OrdinaryHasInstance(F, V).
    return OrdinaryHasInstance(this_value, V)
    # The value of the name property of this function is "[Symbol.hasInstance]".
    #
    # This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.
    #
    # NOTE
    # This is the default implementation of @@hasInstance that most functions inherit. @@hasInstance is called by the
    # instanceof operator to determine whether a value is an instance of a specific constructor. An expression such as
    #
    # v instanceof F
    #
    # evaluates as
    #
    # F[@@hasInstance](v)
    #
    # A constructor function can control which objects are recognized as its instances by instanceof by exposing a
    # different @@hasInstance method on the function.
    #
    # This property is non-writable and non-configurable to prevent tampering that could be used to globally expose the
    # target function of a bound function.


#####################################################################################################################################################################
#
#  d888    .d8888b.       .d8888b.      888888b.                     888                                 .d88888b.  888         d8b                   888
# d8888   d88P  Y88b     d88P  Y88b     888  "88b                    888                                d88P" "Y88b 888         Y8P                   888
#   888   888    888          .d88P     888  .88P                    888                                888     888 888                               888
#   888   Y88b. d888         8888"      8888888K.   .d88b.   .d88b.  888  .d88b.   8888b.  88888b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#   888    "Y888P888          "Y8b.     888  "Y88b d88""88b d88""88b 888 d8P  Y8b     "88b 888 "88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
#   888          888     888    888     888    888 888  888 888  888 888 88888888 .d888888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
#   888   Y88b  d88P d8b Y88b  d88P     888   d88P Y88..88P Y88..88P 888 Y8b.     888  888 888  888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 8888888  "Y8888P"  Y8P  "Y8888P"      8888888P"   "Y88P"   "Y88P"  888  "Y8888  "Y888888 888  888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                                               888
#                                                                                                                              d88P
#                                                                                                                            888P"
#
#####################################################################################################################################################################
# 19.3 Boolean Objects
#
# 19.3.1 The Boolean Constructor
#
# The Boolean constructor:
#
#   * is the intrinsic object %Boolean%.
#   * is the initial value of the Boolean property of the global object.
#   * creates and initializes a new Boolean object when called as a constructor.
#   * performs a type conversion when called as a function rather than as a constructor.
#   * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#     constructors that intend to inherit the specified Boolean behaviour must include a super call to the Boolean constructor
#     to create and initialize the subclass instance with a [[BooleanData]] internal slot.
def CreateBooleanConstructor(realm):
    obj = CreateBuiltinFunction(BooleanFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "Boolean")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    return obj


# 19.3.1.1 Boolean ( value )
def BooleanFunction(_tv, new_target, value=None, *_):
    # When Boolean is called with argument value, the following steps are taken:
    #
    # 1. Let b be ToBoolean(value).
    b = ToBoolean(value)
    # 2. If NewTarget is undefined, return b.
    if new_target is None:
        return b
    # 3. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%BooleanPrototype%", « [[BooleanData]] »).
    o = OrdinaryCreateFromConstructor(new_target, "%BooleanPrototype%", ["BooleanData"])
    # 4. Set O.[[BooleanData]] to b.
    o.BooleanData = b
    # 5. Return O.
    return o


def BooleanFixups(realm):
    boolean_constructor = realm.intrinsics["%Boolean%"]
    boolean_prototype = realm.intrinsics["%BooleanPrototype%"]
    DefinePropertyOrThrow(
        boolean_constructor,
        "prototype",
        PropertyDescriptor(value=boolean_prototype, writable=False, enumerable=False, configurable=False),
    )
    DefinePropertyOrThrow(boolean_prototype, "constructor", PropertyDescriptor(value=boolean_constructor))
    return None


# 19.3.3 Properties of the Boolean Prototype Object
#
# The Boolean prototype object:
#
#   * is the intrinsic object %BooleanPrototype%.
#   * is an ordinary object.
#   * is itself a Boolean object; it has a [[BooleanData]] internal slot with the value false.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
def CreateBooleanPrototype(realm):
    boolean_prototype = ObjectCreate(realm.intrinsics["%ObjectPrototype%"], ["BooleanData"])
    boolean_prototype.BooleanData = False
    BindBuiltinFunctions(
        realm,
        boolean_prototype,
        [("toString", BooleanPrototype_toString, 0), ("valueOf", BooleanPrototype_valueOf, 0)],
    )
    return boolean_prototype


def thisBooleanValue(value):
    # The abstract operation thisBooleanValue(value) performs the following steps:
    #
    # 1. If Type(value) is Boolean, return value.
    if isBoolean(value):
        return value
    # 2. If Type(value) is Object and value has a [[BooleanData]] internal slot, then
    if isObject(value) and hasattr(value, "BooleanData"):
        # a. Let b be value.[[BooleanData]].
        b = value.BooleanData
        # b. Assert: Type(b) is Boolean.
        assert isBoolean(b)
        # c. Return b.
        return b
    # 3. Throw a TypeError exception.
    raise ESTypeError()


# 19.3.3.2 Boolean.prototype.toString ( )
def BooleanPrototype_toString(this_value, nt, *_):
    # The following steps are taken:
    #
    # 1. Let b be ? thisBooleanValue(this value).
    b = thisBooleanValue(this_value)
    # 2. If b is true, return "true"; else return "false".
    return "true" if b else "false"


# 19.3.3.3 Boolean.prototype.valueOf ( )
def BooleanPrototype_valueOf(this_value, nt, *_):
    # The following steps are taken:
    #
    # 1. Return ? thisBooleanValue(this value).
    return thisBooleanValue(this_value)


# 19.4 Symbol Objects

# 19.4.1The Symbol Constructor
# The Symbol constructor:
#
#   * is the intrinsic object %Symbol%.
#   * is the initial value of the Symbol property of the global object.
#   * returns a new Symbol value when called as a function.
#   * is not intended to be used with the new operator.
#   * is not intended to be subclassed.
#   * may be used as the value of an extends clause of a class definition but a super call to it will cause an
#     exception.


def CreateSymbolConstructor(realm: Realm) -> JSObject:
    obj = CreateBuiltinFunction(SymbolFunction, ["Construct"], realm=realm)
    # Symbol has configurable (but not enumerable nor writable) properties as well as
    # unconfigurable, unenumerable, unwritable properties.
    for key, value, configurable in (
        ("length", 0, True),
        ("name", "Symbol", True),
        ("asyncIterator", wks_async_iterator, False),
        ("hasInstance", wks_has_instance, False),
        ("isConcatSpreadable", wks_is_concat_spreadable, False),
        ("iterator", wks_iterator, False),
        ("match", wks_match, False),
        ("replace", wks_replace, False),
        ("search", wks_search, False),
        ("species", wks_species, False),
        ("split", wks_split, False),
        ("toPrimitive", wks_to_primitive, False),
        ("toStringTag", wks_to_string_tag, False),
        ("unscopables", wks_unscopables, False),
    ):
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=configurable)
        DefinePropertyOrThrow(obj, key, desc)
    BindBuiltinFunctions(realm, obj, (("for", SymbolFor, None), ("keyFor", SymbolKeyFor, None)))
    return obj


# 19.4.1.1 Symbol ( [ description ] )
def SymbolFunction(this_value, new_target, description=None, *_):
    # When Symbol is called with optional argument description, the following steps are taken:
    #   1. If NewTarget is not undefined, throw a TypeError exception.
    #   2. If description is undefined, let descString be undefined.
    #   3. Else, let descString be ? ToString(description).
    #   4. Return a new unique Symbol value whose [[Description]] value is descString.
    if new_target is not None:
        raise ESTypeError("Symbol is not a constructor")
    descString = ToString(description) if description is not None else None
    return JSSymbol(descString)


# 19.4.2 Properties of the Symbol Constructor

# 19.4.2.2 Symbol.for ( key )
GlobalSymbolRegistry = {}


def SymbolFor(this_value, new_target, key=None, *_):
    # When Symbol.for is called with argument key it performs the following steps:
    #   1. Let stringKey be ? ToString(key).
    #   2. For each element e of the GlobalSymbolRegistry List, do
    #       a. If SameValue(e.[[Key]], stringKey) is true, return e.[[Symbol]].
    #   3. Assert: GlobalSymbolRegistry does not currently contain an entry for stringKey.
    #   4. Let newSymbol be a new unique Symbol value whose [[Description]] value is stringKey.
    #   5. Append the Record { [[Key]]: stringKey, [[Symbol]]: newSymbol } to the GlobalSymbolRegistry List.
    #   6. Return newSymbol.
    #
    # The GlobalSymbolRegistry is a List that is globally available. It is shared by all realms. Prior to the
    # evaluation of any ECMAScript code it is initialized as a new empty List. Elements of the GlobalSymbolRegistry
    # are Records with the structure defined in Table 48.
    #
    # Table 48: GlobalSymbolRegistry Record Fields
    # +------------+----------+----------------------------------------------------------------------------------------
    # | Field Name | Value    | Usage
    # +------------+----------+----------------------------------------------------------------------------------------
    # | [[Key]]    | A String | A string key used to globally identify a Symbol.
    # +------------+----------+----------------------------------------------------------------------------------------
    # | [[Symbol]] | A Symbol | A symbol that can be retrieved from any realm.
    # +------------+----------+----------------------------------------------------------------------------------------
    stringKey = ToString(key)
    if stringKey in GlobalSymbolRegistry:
        return GlobalSymbolRegistry[stringKey]
    newSymbol = JSSymbol(stringKey)
    GlobalSymbolRegistry[stringKey] = newSymbol
    return newSymbol


SymbolFor.name = "for"
SymbolFor.length = 1

# 19.4.2.6 Symbol.keyFor ( sym )
def SymbolKeyFor(this_value, new_target, sym=None, *_):
    # When Symbol.keyFor is called with argument sym it performs the following steps:
    #   1. If Type(sym) is not Symbol, throw a TypeError exception.
    #   2. For each element e of the GlobalSymbolRegistry List (see 19.4.2.2), do
    #       a. If SameValue(e.[[Symbol]], sym) is true, return e.[[Key]].
    #   3. Assert: GlobalSymbolRegistry does not currently contain an entry for sym.
    #   4. Return undefined.
    if not isSymbol(sym):
        raise ESTypeError(f"{ToString(sym)} is not a symbol")
    return next((key for key, value in GlobalSymbolRegistry.items() if SameValue(value, sym)), None)


SymbolKeyFor.name = "keyFor"
SymbolKeyFor.length = 1

# 19.4.3 Properties of the Symbol Prototype Object

# The Symbol prototype object:
#
#   * is the intrinsic object %SymbolPrototype%.
#   * is an ordinary object.
#   * is not a Symbol instance and does not have a [[SymbolData]] internal slot.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.


def CreateSymbolPrototype(realm: Realm) -> JSObject:
    prototype = ObjectCreate(realm.intrinsics["%ObjectPrototype%"], [])
    BindBuiltinFunctions(
        realm,
        prototype,
        (
            ("toString", SymbolPrototype_toString, None),
            ("valueOf", SymbolPrototype_valueOf, None),
            (wks_to_primitive, SymbolPrototype_toPrimitive, None),
        ),
    )
    BindBuiltinAccessors(realm, prototype, (("description", SymbolPrototype_getDescription, None),))
    DefinePropertyOrThrow(
        prototype,
        wks_to_string_tag,
        PropertyDescriptor(value="Symbol", writable=False, enumerable=False, configurable=True),
    )
    return prototype


def thisSymbolValue(value):
    # The abstract operation thisSymbolValue(value) performs the following steps:
    #
    #   1. If Type(value) is Symbol, return value.
    #   2. If Type(value) is Object and value has a [[SymbolData]] internal slot, then
    #       a. Let s be value.[[SymbolData]].
    #       b. Assert: Type(s) is Symbol.
    #       c. Return s.
    #   3. Throw a TypeError exception.
    if isSymbol(value):
        return value
    if isObject(value) and hasattr(value, "SymbolData"):
        s = value.SymbolData
        assert isSymbol(s)
        return s
    raise ESTypeError(f"{ToString(value)} is not a symbol")


# 19.4.3.2 get Symbol.prototype.description
def SymbolPrototype_getDescription(this_value, new_target, *_):
    # Symbol.prototype.description is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Let s be the this value.
    #   2. Let sym be ? thisSymbolValue(s).
    #   3. Return sym.[[Description]].
    sym = thisSymbolValue(this_value)
    return sym.description


SymbolPrototype_getDescription.length = 0
SymbolPrototype_getDescription.name = "get description"

# 19.4.3.3 Symbol.prototype.toString ( )
def SymbolPrototype_toString(this_value, new_target, *_):
    # The following steps are taken:
    #   1. Let sym be ? thisSymbolValue(this value).
    #   2. Return SymbolDescriptiveString(sym).
    return SymbolDescriptiveString(thisSymbolValue(this_value))


SymbolPrototype_toString.length = 0
SymbolPrototype_toString.name = "toString"


def SymbolFixups(realm: Realm) -> None:
    constructor = realm.intrinsics["%Symbol%"]
    prototype = realm.intrinsics["%SymbolPrototype%"]
    DefinePropertyOrThrow(
        constructor,
        "prototype",
        PropertyDescriptor(value=prototype, writable=False, enumerable=False, configurable=False),
    )
    DefinePropertyOrThrow(
        prototype,
        "constructor",
        PropertyDescriptor(value=constructor, writable=True, enumerable=False, configurable=True),
    )


##################################################################################################################################################################################
# ------------------------------------ 𝟏𝟗.𝟒.𝟑.𝟐.𝟏 𝑺𝒚𝒎𝒃𝒐𝒍𝑫𝒆𝒔𝒄𝒓𝒊𝒑𝒕𝒊𝒗𝒆𝑺𝒕𝒓𝒊𝒏𝒈 ( 𝒔𝒚𝒎 ) ------------------------------------
# 19.4.3.2.1 Runtime Semantics: SymbolDescriptiveString ( sym )
def SymbolDescriptiveString(sym):
    # When the abstract operation SymbolDescriptiveString is called with argument sym, the following steps are taken:
    #
    # 1. Assert: Type(sym) is Symbol.
    # 2. Let desc be sym's [[Description]] value.
    # 3. If desc is undefined, let desc be the empty string.
    # 4. Assert: Type(desc) is String.
    # 5. Return the string-concatenation of "Symbol(", desc, and ")".
    assert isSymbol(sym)
    desc = sym.description or ""
    assert isString(desc)
    return f"Symbol({desc})"


# 19.4.3.4 Symbol.prototype.valueOf ( )
def SymbolPrototype_valueOf(this_value, new_target, *_):
    # The following steps are taken:
    #
    #   1. Return ? thisSymbolValue(this value).
    return thisSymbolValue(this_value)


SymbolPrototype_valueOf.length = 0
SymbolPrototype_valueOf.name = "valueOf"

# 19.4.3.5 Symbol.prototype [ @@toPrimitive ] ( hint )
def SymbolPrototype_toPrimitive(this_value, new_target, hint=None, *_):
    # This function is called by ECMAScript language operators to convert a Symbol object to a primitive value. The
    # allowed values for hint are "default", "number", and "string".
    #
    # When the @@toPrimitive method is called with argument hint, the following steps are taken:
    #   1. Return ? thisSymbolValue(this value).
    return thisSymbolValue(this_value)
    # The value of the name property of this function is "[Symbol.toPrimitive]".
    # This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.


SymbolPrototype_toPrimitive.length = 1
SymbolPrototype_toPrimitive.name = "[Symbol.toPrimitive]"
SymbolPrototype_toPrimitive.attributes = Record(writable=False, enumerable=False, configurable=True)

##################################################################################################################################################################################
#
#  d888    .d8888b.      888888888      8888888888                                       .d88888b.  888         d8b                   888
# d8888   d88P  Y88b     888            888                                             d88P" "Y88b 888         Y8P                   888
#   888   888    888     888            888                                             888     888 888                               888
#   888   Y88b. d888     8888888b.      8888888    888d888 888d888  .d88b.  888d888     888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#   888    "Y888P888          "Y88b     888        888P"   888P"   d88""88b 888P"       888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
#   888          888            888     888        888     888     888  888 888         888     888 888  888    888 88888888 888      888    "Y8888b.
#   888   Y88b  d88P d8b Y88b  d88P     888        888     888     Y88..88P 888         Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 8888888  "Y8888P"  Y8P  "Y8888P"      8888888888 888     888      "Y88P"  888          "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                               888
#                                                                                                              d88P
#                                                                                                            888P"
#
##################################################################################################################################################################################
# 19.5 Error Objects
# Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as
# base objects for user-defined exception classes.
#
# 19.5.1 The Error Constructor
# The Error constructor:
#
#  * is the intrinsic object %Error%.
#  * is the initial value of the Error property of the global object.
#  * creates and initializes a new Error object when called as a function rather than as a constructor. Thus the
#    function call Error(…) is equivalent to the object creation expression new Error(…) with the same arguments.
#  * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#    constructors that intend to inherit the specified Error behaviour must include a super call to the Error
#    constructor to create and initialize subclass instances with an [[ErrorData]] internal slot.
def CreateErrorConstructor(realm):
    obj = CreateBuiltinFunction(ErrorFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "Error")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    return obj


# 19.5.1.1 Error ( message )
def ErrorFunction(this_value, new_target, message=None, *_):
    # When the Error function is called with argument message, the following steps are taken:
    #
    # 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
    # 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%ErrorPrototype%", « [[ErrorData]] »).
    # 3. If message is not undefined, then
    #    a. Let msg be ? ToString(message).
    #    b. Let msgDesc be the PropertyDescriptor
    #       { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
    #    c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
    # 4. Return O.
    newTarget = new_target or surrounding_agent.running_ec.function
    O = OrdinaryCreateFromConstructor(newTarget, "%ErrorPrototype%", ["ErrorData"])
    if message is not None:
        msg = ToString(message)
        msgDesc = PropertyDescriptor(value=msg, writable=True, enumerable=False, configurable=True)
        DefinePropertyOrThrow(O, "message", msgDesc)
    return O


# 19.5.2 Properties of the Error Constructor
# The Error constructor:
#
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.
#   * has the following properties:

# 19.5.2.1 Error.prototype
# The initial value of Error.prototype is the intrinsic object %ErrorPrototype%.
# This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.


def ErrorFixups(realm):
    error_constructor = realm.intrinsics["%Error%"]
    error_prototype = realm.intrinsics["%ErrorPrototype%"]
    DefinePropertyOrThrow(
        error_constructor,
        "prototype",
        PropertyDescriptor(value=error_prototype, writable=False, enumerable=False, configurable=False),
    )
    # 19.5.3.1 Error.prototype.constructor
    # The initial value of Error.prototype.constructor is the intrinsic object %Error%.
    DefinePropertyOrThrow(error_prototype, "constructor", PropertyDescriptor(value=error_constructor))
    return None


# 19.5.3 Properties of the Error Prototype Object
# The Error prototype object:
#
#   * is the intrinsic object %ErrorPrototype%.
#   * is an ordinary object.
#   * is not an Error instance and does not have an [[ErrorData]] internal slot.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
def CreateErrorPrototype(realm):
    error_prototype = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    # 19.5.3.2 Error.prototype.message
    # The initial value of Error.prototype.message is the empty String.
    # 19.5.3.3 Error.prototype.name
    # The initial value of Error.prototype.name is "Error".
    for key, value in [("message", ""), ("name", "Error")]:
        DefinePropertyOrThrow(
            error_prototype, key, PropertyDescriptor(value=value, writable=True, enumerable=False, configurable=True)
        )
    BindBuiltinFunctions(realm, error_prototype, [("toString", ErrorPrototype_toString, 0)])
    return error_prototype


# 19.5.3.4 Error.prototype.toString ( )
def ErrorPrototype_toString(this_value, new_target, *_):
    # The following steps are taken:
    #
    # 1. Let O be the this value.
    # 2. If Type(O) is not Object, throw a TypeError exception.
    # 3. Let name be ? Get(O, "name").
    # 4. If name is undefined, let name be "Error"; otherwise let name be ? ToString(name).
    # 5. Let msg be ? Get(O, "message").
    # 6. If msg is undefined, let msg be the empty String; otherwise let msg be ? ToString(msg).
    # 7. If name is the empty String, return msg.
    # 8. If msg is the empty String, return name.
    # 9. Return the string-concatenation of name, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and msg.
    if not isObject(this_value):
        raise ESTypeError("Method used on non-object")
    name = Get(this_value, "name")
    if name is None:
        name = "Error"
    else:
        name = ToString(name)
    msg = Get(this_value, "message")
    if msg is None:
        msg = ""
    else:
        msg = ToString(msg)
    if name == "":
        return msg
    if msg == "":
        return name
    return f"{name}: {msg}"


def CreateNativeErrorConstructor(realm, errorname):
    errfunc = CreateErrorConstructorFunction(errorname)
    obj = CreateBuiltinFunction(errfunc, ["Construct"], realm=realm, prototype=realm.intrinsics["%Error%"])
    for key, value in [("length", 1), ("name", f"{errorname}Error")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    return obj


def CreateErrorConstructorFunction(name):
    def native_error_function(this_value, new_target, message=None, *_):
        newTarget = new_target or surrounding_agent.running_ec.function
        O = OrdinaryCreateFromConstructor(newTarget, f"%{name}ErrorPrototype%", ["ErrorData"])
        if message is not None:
            msg = ToString(message)
            msgDesc = PropertyDescriptor(value=msg, writable=True, enumerable=False, configurable=True)
            DefinePropertyOrThrow(O, "message", msgDesc)
        return O

    return native_error_function


def NativeErrorFixups(realm):
    for name in ["Eval", "Range", "Reference", "Syntax", "Type", "URI"]:
        constructor = realm.intrinsics[f"%{name}Error%"]
        prototype = realm.intrinsics[f"%{name}ErrorPrototype%"]
        DefinePropertyOrThrow(
            constructor,
            "prototype",
            PropertyDescriptor(value=prototype, writable=False, enumerable=False, configurable=False),
        )
        DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor(value=constructor))
    return None


def CreateNativeErrorPrototype(realm, name):
    prototype = ObjectCreate(realm.intrinsics["%ErrorPrototype%"])
    for key, value in [("message", ""), ("name", f"{name}Error")]:
        Set(prototype, key, value, True)
    return prototype


##################################################################################################################################################################################
##################################################################################################################################################################################
##
##  .d8888b.   .d8888b.      888b    888                        888                                                           888     8888888b.           888
## d88P  Y88b d88P  Y88b     8888b   888                        888                                                           888     888  "Y88b          888
##        888 888    888     88888b  888                        888                                                           888     888    888          888
##      .d88P 888    888     888Y88b 888 888  888 88888b.d88b.  88888b.   .d88b.  888d888 .d8888b       8888b.  88888b.   .d88888     888    888  8888b.  888888  .d88b.  .d8888b
##  .od888P"  888    888     888 Y88b888 888  888 888 "888 "88b 888 "88b d8P  Y8b 888P"   88K              "88b 888 "88b d88" 888     888    888     "88b 888    d8P  Y8b 88K
## d88P"      888    888     888  Y88888 888  888 888  888  888 888  888 88888888 888     "Y8888b.     .d888888 888  888 888  888     888    888 .d888888 888    88888888 "Y8888b.
## 888"       Y88b  d88P     888   Y8888 Y88b 888 888  888  888 888 d88P Y8b.     888          X88     888  888 888  888 Y88b 888     888  .d88P 888  888 Y88b.  Y8b.          X88
## 888888888   "Y8888P"      888    Y888  "Y88888 888  888  888 88888P"   "Y8888  888      88888P'     "Y888888 888  888  "Y88888     8888888P"  "Y888888  "Y888  "Y8888   88888P'
##
##################################################################################################################################################################################
##################################################################################################################################################################################

#######################################################################################################################################################################
#
#  .d8888b.   .d8888b.       d888       888b    888                        888                            .d88888b.  888         d8b                   888
# d88P  Y88b d88P  Y88b     d8888       8888b   888                        888                           d88P" "Y88b 888         Y8P                   888
#        888 888    888       888       88888b  888                        888                           888     888 888                               888
#      .d88P 888    888       888       888Y88b 888 888  888 88888b.d88b.  88888b.   .d88b.  888d888     888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  .od888P"  888    888       888       888 Y88b888 888  888 888 "888 "88b 888 "88b d8P  Y8b 888P"       888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# d88P"      888    888       888       888  Y88888 888  888 888  888  888 888  888 88888888 888         888     888 888  888    888 88888888 888      888    "Y8888b.
# 888"       Y88b  d88P d8b   888       888   Y8888 Y88b 888 888  888  888 888 d88P Y8b.     888         Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888888888   "Y8888P"  Y8P 8888888     888    Y888  "Y88888 888  888  888 88888P"   "Y8888  888          "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                                                888
#                                                                                                                               d88P
#                                                                                                                             888P"
#
#######################################################################################################################################################################
# 20.1.1 The Number Constructor
# The Number constructor:
#
#   * is the intrinsic object %Number%.
#   * is the initial value of the Number property of the global object.
#   * creates and initializes a new Number object when called as a constructor.
#   * performs a type conversion when called as a function rather than as a constructor.
#   * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#     constructors that intend to inherit the specified Number behaviour must include a super call to the Number constructor
#     to create and initialize the subclass instance with a [[NumberData]] internal slot.
#
def CreateNumberConstructor(realm):
    obj = CreateBuiltinFunction(NumberFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "Number")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)

    # The "false-false-false" properties
    for key, value in [
        # 20.1.2.1 Number.EPSILON
        # The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1 that is
        # representable as a Number value, which is approximately 2.2204460492503130808472633361816 x 10^-16.
        ("EPSILON", sys.float_info.epsilon),
        # 20.1.2.6 Number.MAX_SAFE_INTEGER
        # NOTE: The value of Number.MAX_SAFE_INTEGER is the largest integer n such that n and n + 1 are both exactly
        # representable as a Number value.
        # The value of Number.MAX_SAFE_INTEGER is 9007199254740991 (2^53-1).
        ("MAX_SAFE_INTEGER", 2 ** 53 - 1),
        # 20.1.2.7 Number.MAX_VALUE
        # The value of Number.MAX_VALUE is the largest positive finite value of the Number type, which is approximately
        # 1.7976931348623157 × 10^308.
        ("MAX_VALUE", sys.float_info.max),
        # 20.1.2.8 Number.MIN_SAFE_INTEGER
        # NOTE The value of Number.MIN_SAFE_INTEGER is the smallest integer n such that n and n - 1 are both exactly
        # representable as a Number value.
        # The value of Number.MIN_SAFE_INTEGER is -9007199254740991 (-(2^53-1)).
        ("MIN_SAFE_INTEGER", -(2 ** 53 - 1)),
        # 20.1.2.9 Number.MIN_VALUE
        # The value of Number.MIN_VALUE is the smallest positive value of the Number type, which is approximately
        # 5 × 10^-324.
        # In the IEEE 754-2008 double precision binary representation, the smallest possible value is a denormalized
        # number. If an implementation does not support denormalized values, the value of Number.MIN_VALUE must be the
        # smallest non-zero positive value that can actually be represented by the implementation.
        ("MIN_VALUE", 5e-324),  # sys.float_info.min is the smalled normalized float, in python.
        # 20.1.2.10 Number.NaN
        # The value of Number.NaN is NaN.
        ("NaN", math.nan),
        # 20.1.2.11 Number.NEGATIVE_INFINITY
        # The value of Number.NEGATIVE_INFINITY is -∞.
        ("NEGATIVE_INFINITY", -math.inf),
        # 20.1.2.14 Number.POSITIVE_INFINITY
        # The value of Number.POSITIVE_INFINITY is +∞.
        ("POSITIVE_INFINITY", math.inf),
    ]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=False)
        DefinePropertyOrThrow(obj, key, desc)

    BindBuiltinFunctions(
        realm,
        obj,
        [
            ("isFinite", Number_isFinite, 1),
            ("isInteger", Number_isInteger, 1),
            ("isNaN", Number_isNaN, 1),
            ("isSafeInteger", Number_isSafeInteger, 1),
        ],
    )
    return obj


# 20.1.1.1 Number ( value )
def NumberFunction(this_value, new_target, value=EMPTY, *_):
    # When Number is called with argument value, the following steps are taken:
    #
    # 1. If no arguments were passed to this function invocation, let n be +0.
    if value == EMPTY:
        n = 0
    # 2. Else, let n be ? ToNumber(value).
    else:
        n = ToNumber(value)
    # 3. If NewTarget is undefined, return n.
    if new_target is None:
        return n
    # 4. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%NumberPrototype%", « [[NumberData]] »).
    o = OrdinaryCreateFromConstructor(new_target, "%NumberPrototype%", ["NumberData"])
    # 5. Set O.[[NumberData]] to n.
    o.NumberData = n
    # 6. Return O.
    return o


# 20.1.2 Properties of the Number Constructor

# 20.1.2.2 Number.isFinite ( number )
def Number_isFinite(this_value, new_target, number=None, *_):
    # When Number.isFinite is called with one argument number, the following steps are taken:
    #
    #   1. If Type(number) is not Number, return false.
    #   2. If number is NaN, +∞, or -∞, return false.
    #   3. Otherwise, return true.
    return isNumber(number) and math.isfinite(number)


# 20.1.2.3 Number.isInteger ( number )
def Number_isInteger(this_value, new_target, number=None, *_):
    # When Number.isInteger is called with one argument number, the following steps are taken:
    #
    #   1. If Type(number) is not Number, return false.
    #   2. If number is NaN, +∞, or -∞, return false.
    #   3. Let integer be ToInteger(number).
    #   4. If integer is not equal to number, return false.
    #   5. Otherwise, return true.
    return isNumber(number) and math.isfinite(number) and ToInteger(number) == number


# 20.1.2.4 Number.isNaN ( number )
def Number_isNaN(this_value, new_target, number=None, *_):
    # When Number.isNaN is called with one argument number, the following steps are taken:
    #
    #   1. If Type(number) is not Number, return false.
    #   2. If number is NaN, return true.
    #   3. Otherwise, return false.
    return isNumber(number) and math.isnan(number)
    # NOTE
    # This function differs from the global isNaN function (18.2.3) in that it does not convert its argument to a
    # Number before determining whether it is NaN.


# 20.1.2.5 Number.isSafeInteger ( number )
def Number_isSafeInteger(this_value, new_target, number=None, *_):
    # When Number.isSafeInteger is called with one argument number, the following steps are taken:
    #
    #   1. If Type(number) is not Number, return false.
    #   2. If number is NaN, +∞, or -∞, return false.
    #   3. Let integer be ToInteger(number).
    #   4. If integer is not equal to number, return false.
    #   5. If abs(integer) ≤ 2^53-1, return true.
    #   6. Otherwise, return false.
    if not isNumber(number) or not math.isfinite(number):
        return False
    integer = ToInteger(number)
    return integer == number and abs(integer) <= 2 ** 53 - 1


# 20.1.3 Properties of the Number Prototype Object
# The Number prototype object:
#
#   * is the intrinsic object %NumberPrototype%.
#   * is an ordinary object.
#   * is itself a Number object; it has a [[NumberData]] internal slot with the value +0.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
#   * Unless explicitly stated otherwise, the methods of the Number prototype object defined below are not generic and the this
#     value passed to them must be either a Number value or an object that has a [[NumberData]] internal slot that has been
#     initialized to a Number value.
def CreateNumberPrototype(realm):
    number_prototype = ObjectCreate(realm.intrinsics["%ObjectPrototype%"], ["NumberData"])
    number_prototype.NumberData = 0
    BindBuiltinFunctions(
        realm, number_prototype, [("toString", NumberPrototype_toString, 1), ("valueOf", NumberPrototype_valueOf, 0)]
    )
    return number_prototype


def thisNumberValue(value):
    # The abstract operation thisNumberValue(value) performs the following steps:
    #
    # 1. If Type(value) is Number, return value.
    if isNumber(value):
        return value
    # 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then
    if isObject(value) and hasattr(value, "NumberData"):
        # a. Let n be value.[[NumberData]].
        n = value.NumberData
        # b. Assert: Type(n) is Number.
        assert isNumber(n)
        # c. Return n.
        return n
    # 3. Throw a TypeError exception.
    raise ESTypeError()
    # The phrase “this Number value” within the specification of a method refers to the result returned by calling the abstract
    # operation thisNumberValue with the this value of the method invocation passed as the argument.


# 20.1.3.6 Number.prototype.toString ( [ radix ] )
def NumberPrototype_toString(this_value, _, radix=None, *args):
    # NOTE
    # The optional radix should be an integer value in the inclusive range 2 to 36. If radix is not present or is undefined the
    # Number 10 is used as the value of radix.
    #
    # The following steps are performed:
    #
    # 1. Let x be ? thisNumberValue(this value).
    x = thisNumberValue(this_value)
    # 2. If radix is not present, let radixNumber be 10.
    # 3. Else if radix is undefined, let radixNumber be 10.
    if radix is None:
        radixNumber = 10
    # 4. Else, let radixNumber be ? ToInteger(radix).
    else:
        radixNumber = ToInteger(radix)
    # 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.
    if radixNumber < 2 or radixNumber > 36:
        raise ESRangeError()
    # 6. If radixNumber = 10, return ! ToString(x).
    if radixNumber == 10:
        return ToString(x)
    # 7. Return the String representation of this Number value using the radix specified by radixNumber. Letters a-z are used
    #    for digits with values 10 through 35. The precise algorithm is implementation-dependent, however the algorithm should
    #    be a generalization of that specified in 7.1.12.1.
    raise NotImplementedError()
    # The toString function is not generic; it throws a TypeError exception if its this value is not a Number or a Number
    # object. Therefore, it cannot be transferred to other kinds of objects for use as a method.


# 20.1.3.7 Number.prototype.valueOf ( )
def NumberPrototype_valueOf(this_value, nt, *_):
    # 1. Return ? thisNumberValue(this value).
    return thisNumberValue(this_value)


def NumberFixups(realm):
    number_constructor = realm.intrinsics["%Number%"]
    number_prototype = realm.intrinsics["%NumberPrototype%"]
    proto_desc = PropertyDescriptor(value=number_prototype, writable=False, enumerable=False, configurable=False)
    DefinePropertyOrThrow(number_constructor, "prototype", proto_desc)
    DefinePropertyOrThrow(number_prototype, "constructor", PropertyDescriptor(value=number_constructor))
    return None


# 20.2 The Math Object
# The Math object:
#
#   * is the intrinsic object %Math%.
#   * is the initial value of the Math property of the global object.
#   * is an ordinary object.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
#   * is not a function object.
#   * does not have a [[Construct]] internal method; it cannot be used as a constructor with the new operator.
#   * does not have a [[Call]] internal method; it cannot be invoked as a function.
# NOTE  | In this specification, the phrase “the Number value for x” has a technical meaning defined in 6.1.6.
def CreateMathObject(realm):
    obj = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    for name, value in (
        ("E", math.e),
        ("LN10", math.log(10)),
        ("LN2", math.log(2)),
        ("LOG10E", math.log10(math.e)),
        ("LOG2E", math.log(math.e, 2)),
        ("PI", math.pi),
        ("SQRT1_2", math.sqrt(0.5)),
        ("SQRT2", math.sqrt(2)),
    ):
        DefinePropertyOrThrow(
            obj, name, PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=False)
        )
    DefinePropertyOrThrow(
        obj, wks_to_string_tag, PropertyDescriptor(vlaue="Math", writable=False, enumerable=False, configurable=True)
    )
    BindBuiltinFunctions(
        realm,
        obj,
        (
            ("abs", Math_abs, 1),
            ("acos", Math_acos, 1),
            ("acosh", Math_acosh, 1),
            ("asin", Math_asin, 1),
            ("asinh", Math_asinh, 1),
            ("atan", Math_atan, 1),
            ("atanh", Math_atanh, 1),
            ("atan2", Math_atan2, 2),
            ("cbrt", Math_cbrt, 1),
            ("ceil", Math_ceil, 1),
            ("clz32", Math_clz32, 1),
            ("cos", Math_cos, 1),
            ("cosh", Math_cosh, 1),
            ("exp", Math_exp, 1),
            ("expm1", Math_expm1, 1),
            ("floor", Math_floor, 1),
            ("fround", Math_fround, 1),
            ("hypot", Math_hypot, 2),
            ("imul", Math_imul, 2),
            ("log", Math_log, 1),
            ("log1p", Math_log1p, 1),
            ("log10", Math_log10, 1),
            ("log2", Math_log2, 1),
            ("max", Math_max, 2),
            ("min", Math_min, 2),
            ("pow", Math_pow, 2),
            ("random", Math_random, 0),
            ("round", Math_round, 1),
            ("sign", Math_sign, 1),
            ("sin", Math_sin, 1),
            ("sinh", Math_sinh, 1),
            ("sqrt", Math_sqrt, 1),
            ("tan", Math_tan, 1),
            ("tanh", Math_tanh, 1),
            ("trunc", Math_trunc, 1),
        ),
    )
    return obj


def Math_abs(this_value, new_target, x=None, *_):
    return abs(ToNumber(x))


def Math_acos(this_value, new_target, x=None, *_):
    try:
        return math.acos(ToNumber(x))
    except ValueError:
        return math.nan


def Math_acosh(this_value, new_target, x=None, *_):
    try:
        return math.acosh(ToNumber(x))
    except ValueError:
        return math.nan


def Math_asin(this_value, new_target, x=None, *_):
    try:
        return math.asin(ToNumber(x))
    except ValueError:
        return math.nan


def Math_asinh(this_value, new_target, x=None, *_):
    return math.asinh(ToNumber(x))


def Math_atan(this_value, new_target, x=None, *_):
    return math.atan(ToNumber(x))


def Math_atanh(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    try:
        return math.atanh(arg)
    except ValueError:
        return -math.inf if arg == -1.0 else (math.inf if arg == 1.0 else math.nan)


def Math_atan2(this_value, new_target, y=None, x=None, *_):
    return math.atan2(ToNumber(y), ToNumber(x))


def Math_cbrt(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    return -math.inf if arg == -math.inf else arg ** (1 / 3)


def Math_ceil(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    return (
        math.nan
        if math.isnan(arg)
        else (
            -0.0
            if arg == 0 and math.copysign(1.0, arg) == -1.0
            else (
                math.inf
                if arg == math.inf
                else (-math.inf if arg == -math.inf else (-0.0 if arg > -1.0 and arg < 0.0 else math.ceil(arg)))
            )
        )
    )


def Math_clz32(this_value, new_target, x=None, *_):
    arg = ToUint32(x)
    # this is one instruction in assembly language. :(
    for i in range(31, -1, -1):
        if arg & (1 << i):
            return 31 - i
    return 32


def Math_cos(this_value, new_target, x=None, *_):
    try:
        return math.cos(ToNumber(x))
    except ValueError:
        return math.nan


def Math_cosh(this_value, new_target, x=None, *_):
    return math.cosh(ToNumber(x))


def Math_exp(this_value, new_target, x=None, *_):
    return math.exp(ToNumber(x))


def Math_expm1(this_value, new_target, x=None, *_):
    return math.expm1(ToNumber(x))


def Math_floor(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    return (
        math.nan
        if math.isnan(arg)
        else (
            -0.0
            if arg == 0 and math.copysign(1.0, arg) == -1.0
            else (math.inf if arg == math.inf else (-math.inf if arg == -math.inf else (math.floor(arg))))
        )
    )


def Math_fround(this_value, new_target, x=None, *_):
    # No clue how python handles IEEE rounding.
    arg = ToNumber(x)
    if arg == 0:
        return arg  # To preserve -0
    return float(arg)


def Math_hypot(this_value, new_target, *args):
    values = (ToNumber(x) for x in args)
    return math.hypot(*values)


Math_hypot.length = 2
Math_hypot.name = "hypot"


def Math_imul(this_value, new_target, x=None, y=None, *_):
    a = ToUint32(x)
    b = ToUint32(y)
    product = (a * b) % (2 ** 32)
    if product >= (2 ** 31):
        return product - (2 ** 32)
    return product


def Math_log(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    try:
        return math.log(arg)
    except ValueError:
        if arg == 0:
            return -math.inf
        return math.nan


def Math_log1p(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    try:
        return math.log1p(arg)
    except ValueError:
        if arg == -1.0:
            return -math.inf
        return math.nan


def Math_log10(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    try:
        return math.log10(arg)
    except ValueError:
        if arg == 0:
            return -math.inf
        return math.nan


def Math_log2(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    try:
        return math.log2(arg)
    except ValueError:
        if arg == 0:
            return -math.inf
        return math.nan


def Math_max(this_value, new_target, *args):
    return max((ToNumber(x) for x in args), default=-math.inf)


Math_max.length = 2
Math_max.name = "max"


def Math_min(this_value, new_target, *args):
    return min((ToNumber(x) for x in args), default=math.inf)


Math_min.length = 2
Math_min.name = "min"


def Math_pow(this_value, new_target, base=None, exponent=None, *_):
    return ExponentiationOperation(base, exponent)


def Math_random(this_value, new_target, *_):
    return random.random()


def Math_round(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    if arg >= -0.5 and (arg < 0 or arg == 0 and math.copysign(1.0, arg) == -1.0):
        return -0.0
    try:
        return math.floor(arg + 0.5)
    except ValueError:
        return math.nan
    except OverflowError:
        return math.copysign(math.inf, arg)


def Math_sign(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    if math.isnan(arg) or arg == 0:
        return arg
    return math.copysign(1.0, arg)


def Math_sin(this_value, new_target, x=None, *_):
    try:
        return math.sin(ToNumber(x))
    except ValueError:
        return math.nan


def Math_sinh(this_value, new_taret, x=None, *_):
    return math.sinh(ToNumber(x))


def Math_sqrt(this_value, new_target, x=None, *_):
    try:
        return math.sqrt(ToNumber(x))
    except ValueError:
        return math.nan


def Math_tan(this_value, new_target, x=None, *_):
    try:
        return math.tan(ToNumber(x))
    except ValueError:
        return math.nan


def Math_tanh(this_value, new_target, x=None, *_):
    return math.tanh(ToNumber(x))


def Math_trunc(this_value, new_target, x=None, *_):
    arg = ToNumber(x)
    if not math.isfinite(arg) or arg == 0:
        return arg
    if -1 < arg < 0:
        return -0.0
    return int(arg)


# 20.3 Date Objects
# 20.3.1.2 Day Number and Time within Day
# A given time value t belongs to day number
#   Day(t) = floor(t / msPerDay)
# where the number of milliseconds per day is
#   msPerDay = 86400000
# The remainder is called the time within the day:
#   TimeWithinDay(t) = t modulo msPerDay
msPerDay = 86400000


def Day(t):
    return math.floor(t / msPerDay)


def TimeWithinDay(t):
    return t % msPerDay


# 20.3.1.3 Year Number
# ECMAScript uses a proleptic Gregorian calendar to map a day number to a year number and to determine the month and
# date within that year. In this calendar, leap years are precisely those which are (divisible by 4) and ((not
# divisible by 100) or (divisible by 400)). The number of days in year number y is therefore defined by
#
#   DaysInYear(y)
#     = 365 if (y modulo 4) ≠ 0
#     = 366 if (y modulo 4) = 0 and (y modulo 100) ≠ 0
#     = 365 if (y modulo 100) = 0 and (y modulo 400) ≠ 0
#     = 366 if (y modulo 400) = 0
#
# All non-leap years have 365 days with the usual number of days per month and leap years have an extra day in
# February. The day number of the first day of year y is given by:
#
#   DayFromYear(y) = 365 × (y-1970) + floor((y-1969)/4) - floor((y-1901)/100) + floor((y-1601)/400)
#
# The time value of the start of a year is:
#
#   TimeFromYear(y) = msPerDay × DayFromYear(y)
#
# A time value determines a year by:
#
#   YearFromTime(t) = the largest integer y (closest to positive infinity) such that TimeFromYear(y) ≤ t
#
# The leap-year function is 1 for a time within a leap year and otherwise is zero:
#
#   InLeapYear(t)
#       = 0 if DaysInYear(YearFromTime(t)) = 365
#       = 1 if DaysInYear(YearFromTime(t)) = 366
def DaysInYear(y):
    return 365 if y % 4 != 0 else 366 if y % 100 != 0 else 365 if y % 400 != 0 else 366


def DayFromYear(y):
    return (
        365 * (y - 1970) + math.floor((y - 1969) / 4) - math.floor((y - 1901) / 100) + math.floor((y - 1601) / 400)
    )


def TimeFromYear(y):
    return msPerDay * DayFromYear(y)


def YearFromTime(t):
    year = math.floor(1970 + t / 365 / msPerDay)  # First guess. Should only be wrong on the high side
    assert TimeFromYear(year) > t or TimeFromYear(year + 1) > t
    while TimeFromYear(year) > t:
        year -= 1
    return year


def InLeapYear(t):
    return 0 if DaysInYear(YearFromTime(t)) == 365 else 1


# 20.3.1.4 Month Number
# Months are identified by an integer in the range 0 to 11, inclusive. The mapping MonthFromTime(t) from a time value t
# to a month number is defined by:
#
#   MonthFromTime(t)
#       = 0 if 0 ≤ DayWithinYear(t) < 31
#       = 1 if 31 ≤ DayWithinYear(t) < 59+InLeapYear(t)
#       = 2 if 59+InLeapYear(t) ≤ DayWithinYear(t) < 90+InLeapYear(t)
#       = 3 if 90+InLeapYear(t) ≤ DayWithinYear(t) < 120+InLeapYear(t)
#       = 4 if 120+InLeapYear(t) ≤ DayWithinYear(t) < 151+InLeapYear(t)
#       = 5 if 151+InLeapYear(t) ≤ DayWithinYear(t) < 181+InLeapYear(t)
#       = 6 if 181+InLeapYear(t) ≤ DayWithinYear(t) < 212+InLeapYear(t)
#       = 7 if 212+InLeapYear(t) ≤ DayWithinYear(t) < 243+InLeapYear(t)
#       = 8 if 243+InLeapYear(t) ≤ DayWithinYear(t) < 273+InLeapYear(t)
#       = 9 if 273+InLeapYear(t) ≤ DayWithinYear(t) < 304+InLeapYear(t)
#       = 10 if 304+InLeapYear(t) ≤ DayWithinYear(t) < 334+InLeapYear(t)
#       = 11 if 334+InLeapYear(t) ≤ DayWithinYear(t) < 365+InLeapYear(t)
#
# where
#
#   DayWithinYear(t) = Day(t)-DayFromYear(YearFromTime(t))
#
# A month value of 0 specifies January; 1 specifies February; 2 specifies March; 3 specifies April; 4 specifies May; 5
# specifies June; 6 specifies July; 7 specifies August; 8 specifies September; 9 specifies October; 10 specifies
# November; and 11 specifies December. Note that MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.
def DayWithinYear(t):
    return Day(t) - DayFromYear(YearFromTime(t))


def MonthFromTime(t):
    day = DayWithinYear(t)
    monthend = [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]
    leapend = [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
    checker = monthend if not InLeapYear(t) else leapend
    for idx, endday in enumerate(checker):
        if day < endday:
            return idx


# 20.3.1.5 Date Number
# A date number is identified by an integer in the range 1 through 31, inclusive. The mapping DateFromTime(t) from a
# time value t to a date number is defined by:
#
#   DateFromTime(t)
#       = DayWithinYear(t)+1 if MonthFromTime(t)=0
#       = DayWithinYear(t)-30 if MonthFromTime(t)=1
#       = DayWithinYear(t)-58-InLeapYear(t) if MonthFromTime(t)=2
#       = DayWithinYear(t)-89-InLeapYear(t) if MonthFromTime(t)=3
#       = DayWithinYear(t)-119-InLeapYear(t) if MonthFromTime(t)=4
#       = DayWithinYear(t)-150-InLeapYear(t) if MonthFromTime(t)=5
#       = DayWithinYear(t)-180-InLeapYear(t) if MonthFromTime(t)=6
#       = DayWithinYear(t)-211-InLeapYear(t) if MonthFromTime(t)=7
#       = DayWithinYear(t)-242-InLeapYear(t) if MonthFromTime(t)=8
#       = DayWithinYear(t)-272-InLeapYear(t) if MonthFromTime(t)=9
#       = DayWithinYear(t)-303-InLeapYear(t) if MonthFromTime(t)=10
#       = DayWithinYear(t)-333-InLeapYear(t) if MonthFromTime(t)=11
def DateFromTime(t):
    non_leap = [1, -30, -58, -89, -119, -150, -180, -211, -242, -272, -303, -333]
    leap = [1, -30, -59, -90, -120, -151, -181, -212, -243, -273, -304, -334]
    deltas = leap if InLeapYear(t) else non_leap
    return DayWithinYear(t) + deltas[MonthFromTime(t)]


# 20.3.1.6 Week Day
# The weekday for a particular time value t is defined as
#
#   WeekDay(t) = (Day(t) + 4) modulo 7
#
# A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies Tuesday; 3 specifies Wednesday; 4 specifies
# Thursday; 5 specifies Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4, corresponding to Thursday, 01
# January, 1970.
def WeekDay(t):
    return (Day(t) + 4) % 7


# 20.3.1.7 LocalTZA ( t, isUTC )
# LocalTZA( t, isUTC ) is an implementation-defined algorithm that must return a number representing milliseconds
# suitable for adding to a Time Value. The local political rules for standard time and daylight saving time in effect
# at t should be used to determine the result in the way specified in the following three paragraphs.
#
# When isUTC is true, LocalTZA( t, true ) should return the offset of the local time zone from UTC measured in
# milliseconds at time represented by time value t (UTC). When the result is added to t (UTC), it should yield the
# local time.
#
# When isUTC is false, LocalTZA( t, false ) should return the offset of the local time zone from UTC measured in
# milliseconds at local time represented by time value tlocal = t. When the result is subtracted from the local time
# tlocal, it should yield the corresponding UTC.
#
# When tlocal represents local time repeating multiple times at a negative time zone transition (e.g. when the
# daylight saving time ends or the time zone adjustment is decreased due to a time zone rule change) or skipped local
# time at a positive time zone transitions (e.g. when the daylight saving time starts or the time zone adjustment is
# increased due to a time zone rule change), tlocal must be interpreted with the time zone adjustment before the
# transition.
#
# If an implementation does not support a conversion described above or if political rules for time t are not available
# within the implementation, the result must be 0.
#
# NOTE
# It is recommended that implementations use the time zone information of the IANA Time Zone Database
# https://www.iana.org/time-zones/.
#
# 1:30 AM on November 5, 2017 in America/New_York is repeated twice (fall backward), but it must be interpreted as
# 1:30 AM UTC-04 instead of 1:30 AM UTC-05. LocalTZA(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0))),
# false) is -4 × msPerHour.
#
# 2:30 AM on March 12, 2017 in America/New_York does not exist, but it must be interpreted as 2:30 AM UTC-05
# (equivalent to 3:30 AM UTC-04). LocalTZA(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0))), false) is
# -5 × msPerHour.
def LocalTZA(t, isUTC):
    # Except for getting the current time, this is the only place we use the datetime module.
    # Sadly, it fails for years with >4 digits. So this doesn't work correctly (i.e.: it raises
    # an exception) for ecmascript's extended years.
    #
    # The only reason LocalTZA even _cares_ about the timestamp is to determine whether DST is on
    # or off at the time we're calculating an adjustment. It might be possible to simply use
    # the information in the tzinfo data to do that work ourselves.
    if isUTC:
        dt = datetime.datetime.fromtimestamp(t / 1000, datetime.timezone.utc).astimezone()
        return dt.tzinfo.utcoffset(dt).total_seconds() * 1000
    local = dateutil.tz.gettz()
    dt = datetime.datetime.fromtimestamp(t / 1000, local)
    return dt.tzinfo.utcoffset(dt).total_seconds() * 1000


def LocalTime(t):
    if not math.isfinite(t):
        return t
    return t + LocalTZA(t, True)


def UTC(t):
    if not math.isfinite(t):
        return t
    return t - LocalTZA(t, False)


HoursPerDay = 24
MinutesPerHour = 60
SecondsPerMinute = 60
msPerSecond = 1000
msPerMinute = msPerSecond * SecondsPerMinute
msPerHour = msPerMinute * MinutesPerHour


def HourFromTime(t):
    return math.floor(t / msPerHour) % HoursPerDay


def MinFromTime(t):
    return math.floor(t / msPerMinute) % MinutesPerHour


def SecFromTime(t):
    return math.floor(t / msPerSecond) % SecondsPerMinute


def msFromTime(t):
    return t % msPerSecond


# 20.3.1.11 MakeTime ( hour, min, sec, ms )
# The abstract operation MakeTime calculates a number of milliseconds from its four arguments, which must be ECMAScript
# Number values. This operator functions as follows:
#
#   1. If hour is not finite or min is not finite or sec is not finite or ms is not finite, return NaN.
#   2. Let h be ! ToInteger(hour).
#   3. Let m be ! ToInteger(min).
#   4. Let s be ! ToInteger(sec).
#   5. Let milli be ! ToInteger(ms).
#   6. Let t be h * msPerHour + m * msPerMinute + s * msPerSecond + milli, performing the arithmetic according to
#      IEEE 754-2008 rules (that is, as if using the ECMAScript operators * and +).
#   7. Return t.
def MakeTime(hour, min, sec, ms):
    if any(not math.isfinite(x) for x in (hour, min, sec, ms)):
        return math.nan
    h = ToInteger(hour)
    m = ToInteger(min)
    s = ToInteger(sec)
    milli = ToInteger(ms)
    return h * msPerHour + m * msPerMinute + s * msPerSecond + milli


# 20.3.1.12 MakeDay ( year, month, date )
# The abstract operation MakeDay calculates a number of days from its three arguments, which must be ECMAScript Number
# values. This operator functions as follows:
#
#   1. If year is not finite or month is not finite or date is not finite, return NaN.
#   2. Let y be ! ToInteger(year).
#   3. Let m be ! ToInteger(month).
#   4. Let dt be ! ToInteger(date).
#   5. Let ym be y + floor(m / 12).
#   6. Let mn be m modulo 12.
#   7. Find a value t such that YearFromTime(t) is ym and MonthFromTime(t) is mn and DateFromTime(t) is 1; but if this
#      is not possible (because some argument is out of range), return NaN.
#   8. Return Day(t) + dt - 1.
def MakeDay(year, month, date):
    if any(not math.isfinite(x) for x in (year, month, date)):
        return math.nan
    y = ToInteger(year)
    m = ToInteger(month)
    dt = ToInteger(date)
    ym = y + math.floor(m / 12)
    mn = round(m % 12)
    t = TimeFromYear(y)
    days_to_start_of_month = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
    days_to_start_of_month_leap = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]
    t += msPerDay * (days_to_start_of_month_leap if InLeapYear(t) else days_to_start_of_month)[mn]
    assert YearFromTime(t) == ym and MonthFromTime(t) == mn and DateFromTime(t) == 1
    return Day(t) + dt - 1


# 20.3.1.13 MakeDate ( day, time )
# The abstract operation MakeDate calculates a number of milliseconds from its two arguments, which must be ECMAScript
# Number values. This operator functions as follows:
#
#   1. If day is not finite or time is not finite, return NaN.
#   2. Return day × msPerDay + time.
def MakeDate(day, time):
    if any(not math.isfinite(x) for x in (day, time)):
        return math.nan
    return day * msPerDay + time


# 20.3.1.14 TimeClip ( time )
# The abstract operation TimeClip calculates a number of milliseconds from its argument, which must be an ECMAScript
# Number value. This operator functions as follows:
#
#   1. If time is not finite, return NaN.
#   2. If abs(time) > 8.64 × 10^15, return NaN.
#   3. Let clippedTime be ! ToInteger(time).
#   4. If clippedTime is -0, set clippedTime to +0.
#   5. Return clippedTime.
def TimeClip(time):
    if not math.isfinite(time) or abs(time) > 8.64e15:
        return math.nan
    clippedTime = ToInteger(time)
    if clippedTime == 0.0:
        clippedTime = 0
    return clippedTime


# 20.3.2 The Date Constructor
# The Date constructor:
#
#   * is the intrinsic object %Date%.
#   * is the initial value of the Date property of the global object.
#   * creates and initializes a new Date object when called as a constructor.
#   * returns a String representing the current time (UTC) when called as a function rather than as a constructor.
#   * is a single function whose behaviour is overloaded based upon the number and types of its arguments.
#   * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#     constructors that intend to inherit the specified Date behaviour must include a super call to the Date
#     constructor to create and initialize the subclass instance with a [[DateValue]] internal slot.
#   * has a length property whose value is 7.
def CreateDateConstructor(realm):
    obj = CreateBuiltinFunction(DateFunction, ["Construct"], realm=realm)
    for key, value in (("length", 7), ("name", "Date")):
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    return obj


# 20.3.2.1 Date ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )
# This description applies only if the Date constructor is called with at least two arguments.
#
# When the Date function is called, the following steps are taken:
#
#   1. Let numberOfArgs be the number of arguments passed to this function call.
#   2. Assert: numberOfArgs ≥ 2.
#   3. If NewTarget is undefined, then
#       a. Let now be the Number that is the time value (UTC) identifying the current time.
#       b. Return ToDateString(now).
#   4. Else,
#       a. Let y be ? ToNumber(year).
#       b. Let m be ? ToNumber(month).
#       c. If date is present, let dt be ? ToNumber(date); else let dt be 1.
#       d. If hours is present, let h be ? ToNumber(hours); else let h be 0.
#       e. If minutes is present, let min be ? ToNumber(minutes); else let min be 0.
#       f. If seconds is present, let s be ? ToNumber(seconds); else let s be 0.
#       g. If ms is present, let milli be ? ToNumber(ms); else let milli be 0.
#       h. If y is not NaN and 0 ≤ ToInteger(y) ≤ 99, let yr be 1900+ToInteger(y); otherwise, let yr be y.
#       i. Let finalDate be MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)).
#       j. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DatePrototype%", « [[DateValue]] »).
#       k. Set O.[[DateValue]] to TimeClip(UTC(finalDate)).
#       l. Return O.
def Date_Function_2plus(
    this_value, new_target, year, month, date=EMPTY, hours=EMPTY, minutes=EMPTY, seconds=EMPTY, ms=EMPTY, *_
):
    assert new_target is not None
    y = ToNumber(year)
    m = ToNumber(month)
    dt = ToNumber(date) if date != EMPTY else 1
    h = ToNumber(hours) if hours != EMPTY else 0
    min = ToNumber(minutes) if minutes != EMPTY else 0
    s = ToNumber(seconds) if seconds != EMPTY else 0
    milli = ToNumber(ms) if ms != EMPTY else 0
    if not math.isnan(y) and 0 <= ToInteger(y) <= 99:
        yr = 1900 + ToInteger(y)
    else:
        yr = y
    finalDate = MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))
    O = OrdinaryCreateFromConstructor(new_target, "%DatePrototype%", ["DateValue"])
    O.DateValue = TimeClip(UTC(finalDate))
    return O


def date_parse(sval):
    e262_interchange_fmt = re.compile(
        r"(?P<year>([-+][0-9]{6}|[0-9]{4}))(-(?P<month>[0-9]{2})(-(?P<day>[0-9]{2}))?)?(T(?P<hour>[0-9]{2}):(?P<minute>[0-9]{2})(:(?P<second>[0-9]{2})(\.(?P<milli>[0-9]{3}))?(?P<tz>(Z|[-+][0-9]{2}:[0-9]{2}))?)?)?"
    )
    m = e262_interchange_fmt.match(sval)
    if not m:
        return math.nan
    year = int(m["year"])
    month = int(m["month"] or 1)
    day = int(m["day"] or 1)
    hour = int(m["hour"] or 0)
    minute = int(m["minute"] or 0)
    second = int(m["second"] or 0)
    milli = int(m["milli"] or 0)
    # gonna ignore tz for the time being @@@
    finalDate = MakeDate(MakeDay(year, month, day), MakeTime(hour, minute, second, milli))
    return TimeClip(finalDate)


# 20.3.2.2 Date ( value )
# This description applies only if the Date constructor is called with exactly one argument.
#
# When the Date function is called, the following steps are taken:
#
#   1. Let numberOfArgs be the number of arguments passed to this function call.
#   2. Assert: numberOfArgs = 1.
#   3. If NewTarget is undefined, then
#       a. Let now be the Number that is the time value (UTC) identifying the current time.
#       b. Return ToDateString(now).
#   4. Else,
#       a. If Type(value) is Object and value has a [[DateValue]] internal slot, then
#           i. Let tv be thisTimeValue(value).
#       b. Else,
#           i. Let v be ? ToPrimitive(value).
#           ii. If Type(v) is String, then
#               1. Assert: The next step never returns an abrupt completion because v is a String value.
#               2. Let tv be the result of parsing v as a date, in exactly the same manner as for the parse method (20.3.3.2).
#           iii. Else,
#               1. Let tv be ? ToNumber(v).
#       c. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DatePrototype%", « [[DateValue]] »).
#       d. Set O.[[DateValue]] to TimeClip(tv).
#       e. Return O.
def Date_Function_1arg(this_value, new_target, value):
    assert new_target is not None
    if isObject(value) and hasattr(value, "DateValue"):
        tv = value.DateValue
    else:
        v = ToPrimitive(value)
        if isString(v):
            tv = date_parse(v)
        else:
            tv = ToNumber(v)
    O = OrdinaryCreateFromConstructor(new_target, "%DatePrototype%", ["DateValue"])
    O.DateValue = TimeClip(tv)
    return O


# 20.3.2.3 Date ( )
def Date_Function_noargs(this_value, new_target):
    # This description applies only if the Date constructor is called with no arguments.
    #
    # When the Date function is called, the following steps are taken:
    #
    #   1. Let numberOfArgs be the number of arguments passed to this function call.
    #   2. Assert: numberOfArgs = 0.
    #   3. If NewTarget is undefined, then
    #       a. Let now be the Number that is the time value (UTC) identifying the current time.
    #       b. Return ToDateString(now).
    #   4. Else,
    #       a. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DatePrototype%", « [[DateValue]] »).
    #       b. Set O.[[DateValue]] to the time value (UTC) identifying the current time.
    #       c. Return O.
    O = OrdinaryCreateFromConstructor(new_target, "%DatePrototype%", ["DateValue"])
    O.DateValue = datetime.datetime.now(datetime.timezone.utc).timestamp() * 1000
    return O


def DateFunction(this_value, new_target, *args):
    if new_target is None:
        now = datetime.datetime.now(datetime.timezone.utc).timestamp() * 1000
        return ToDateString(now)
    if len(args) == 0:
        return Date_Function_noargs(this_value, new_target)
    if len(args) == 1:
        return Date_Function_1arg(this_value, new_target, *args)
    return Date_Function_2plus(this_value, new_target, *args)


# 20.3.4.41.4 Runtime Semantics: ToDateString ( tv )
def ToDateString(tv):
    # The following steps are performed:
    #
    #   1. Assert: Type(tv) is Number.
    #   2. If tv is NaN, return "Invalid Date".
    #   3. Let t be LocalTime(tv).
    #   4. Return the string-concatenation of DateString(t), the code unit 0x0020 (SPACE), TimeString(t), and TimeZoneString(tv).
    assert isNumber(tv)
    if math.isnan(tv):
        return "Invalid Date"
    t = LocalTime(tv)
    return f"{DateString(t)} {TimeString(t)}{TimeZoneString(tv)}"


weekday_names = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
month_names = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

# 20.3.4.41.2 Runtime Semantics: DateString ( tv )
def DateString(tv):
    # The following steps are performed:
    #
    #   1. Assert: Type(tv) is Number.
    #   2. Assert: tv is not NaN.
    #   3. Let weekday be the Name of the entry in Table 46 with the Number WeekDay(tv).
    #   4. Let month be the Name of the entry in Table 47 with the Number MonthFromTime(tv).
    #   5. Let day be the String representation of DateFromTime(tv), formatted as a two-digit decimal number, padded to
    #      the left with a zero if necessary.
    #   6. Let year be the String representation of YearFromTime(tv), formatted as a decimal number of at least four
    #      digits, padded to the left with zeroes if necessary.
    #   7. Return the string-concatenation of weekday, the code unit 0x0020 (SPACE), month, the code unit 0x0020
    #      (SPACE), day, the code unit 0x0020 (SPACE), and year.
    #
    # Table 46: Names of days of the week
    # +--------+-------+
    # | Number | Name  |
    # +--------+-------+
    # | 0      | "Sun" |
    # | 1      | "Mon" |
    # | 2      | "Tue" |
    # | 3      | "Wed" |
    # | 4      | "Thu" |
    # | 5      | "Fri" |
    # | 6      | "Sat" |
    # +--------+-------+
    # Table 47: Names of months of the year
    # +--------+-------+
    # | Number | Name  |
    # +--------+-------+
    # | 0      | "Jan" |
    # | 1      | "Feb" |
    # | 2      | "Mar" |
    # | 3      | "Apr" |
    # | 4      | "May" |
    # | 5      | "Jun" |
    # | 6      | "Jul" |
    # | 7      | "Aug" |
    # | 8      | "Sep" |
    # | 9      | "Oct" |
    # | 10     | "Nov" |
    # | 11     | "Dec" |
    # +--------+-------+
    assert isNumber(tv) and not math.isnan(tv)
    return f"{weekday_names[WeekDay(tv)]} {month_names[MonthFromTime(tv)]} {DateFromTime(tv):02d} {YearFromTime(tv):04d}"


# 20.3.4.41.1 Runtime Semantics: TimeString ( tv )
def TimeString(tv):
    # The following steps are performed:
    #
    #   1. Assert: Type(tv) is Number.
    #   2. Assert: tv is not NaN.
    #   3. Let hour be the String representation of HourFromTime(tv), formatted as a two-digit decimal number, padded
    #      to the left with a zero if necessary.
    #   4. Let minute be the String representation of MinFromTime(tv), formatted as a two-digit decimal number, padded
    #      to the left with a zero if necessary.
    #   5. Let second be the String representation of SecFromTime(tv), formatted as a two-digit decimal number, padded
    #      to the left with a zero if necessary.
    #   6. Return the string-concatenation of hour, ":", minute, ":", second, the code unit 0x0020 (SPACE), and "GMT".
    assert isNumber(tv) and not math.isnan(tv)
    return f"{HourFromTime(tv):02d}:{MinFromTime(tv):02d}:{SecFromTime(tv):02d} GMT"


# 20.3.4.41.3 Runtime Semantics: TimeZoneString ( tv )
def TimeZoneString(tv):
    # The following steps are performed:
    #
    #   1. Assert: Type(tv) is Number.
    #   2. Assert: tv is not NaN.
    #   3. Let offset be LocalTZA(tv, true).
    #   4. If offset ≥ 0, let offsetSign be "+"; otherwise, let offsetSign be "-".
    #   5. Let offsetMin be the String representation of MinFromTime(abs(offset)), formatted as a two-digit decimal
    #      number, padded to the left with a zero if necessary.
    #   6. Let offsetHour be the String representation of HourFromTime(abs(offset)), formatted as a two-digit decimal
    #      number, padded to the left with a zero if necessary.
    #   7. Let tzName be an implementation-defined string that is either the empty string or the string-concatenation
    #      of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-dependent
    #      timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
    #   8. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.
    assert isNumber(tv) and not math.isnan(tv)
    offset = LocalTZA(tv, True)
    offsetSign = ("-", "+")[offset >= 0]
    offsetMin = f"{MinFromTime(abs(offset)):02d}"
    offsetHour = f"{HourFromTime(abs(offset)):02d}"
    local = dateutil.tz.gettz()
    dt = datetime.datetime.fromtimestamp(tv / 1000, local)
    tzName = f" ({local.tzname(dt)})"
    return f"{offsetSign}{offsetHour}{offsetMin}{tzName}"


def thisTimeValue(obj):
    if isObject(obj) and hasattr(obj, "DateValue"):
        return obj.DateValue
    raise ESTypeError(f"{ToString(obj)}: not a date object")


def CreateDatePrototype(realm):
    date_prototype = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    BindBuiltinFunctions(
        realm,
        date_prototype,
        [
            ("getDate", DatePrototype_getDate, 0),
            ("getDay", DatePrototype_getDay, 0),
            ("getFullYear", DatePrototype_getFullYear, 0),
            ("getHours", DatePrototype_getHours, 0),
            ("getMilliseconds", DatePrototype_getMilliseconds, 0),
            ("getMinutes", DatePrototype_getMinutes, 0),
            ("getMonth", DatePrototype_getMonth, 0),
            ("getSeconds", DatePrototype_getSeconds, 0),
            ("getTime", DatePrototype_getTime, 0),
            ("getTimezoneOffset", DatePrototype_getTimezoneOffset, 0),
            ("getUTCDate", DatePrototype_getUTCDate, 0),
            ("getUTCDay", DatePrototype_getUTCDay, 0),
            ("getUTCFullYear", DatePrototype_getUTCFullYear, 0),
            ("getUTCHours", DatePrototype_getUTCHours, 0),
            ("getUTCMilliseconds", DatePrototype_getUTCMilliseconds, 0),
            ("getUTCMinutes", DatePrototype_getUTCMinutes, 0),
            ("getUTCMonth", DatePrototype_getUTCMonth, 0),
            ("getUTCSeconds", DatePrototype_getUTCSeconds, 0),
            ("setDate", DatePrototype_setDate, 1),
            ("setFullYear", DatePrototype_setFullYear, 3),
            ("setHours", DatePrototype_setHours, 4),
            ("setMilliseconds", DatePrototype_setMilliseconds, 1),
            ("setMinutes", DatePrototype_setMinutes, 3),
            ("setMonth", DatePrototype_setMonth, 2),
            ("setSeconds", DatePrototype_setSeconds, 2),
            ("setTime", DatePrototype_setTime, 1),
            ("setUTCDate", DatePrototype_setUTCDate, 1),
            ("setUTCFullYear", DatePrototype_setUTCFullYear, 3),
            ("setUTCHours", DatePrototype_setUTCHours, 4),
            ("setUTCMilliseconds", DatePrototype_setUTCMilliseconds, 1),
            ("setUTCMinutes", DatePrototype_setUTCMinutes, 3),
            ("setUTCMonth", DatePrototype_setUTCMonth, 2),
            ("setUTCSeconds", DatePrototype_setUTCSeconds, 2),
            ("toDateString", DatePrototype_toDateString, 0),
            ("toISOString", DatePrototype_toISOString, 0),
            ("toJSON", DatePrototype_toJSON, 1),
            ("toLocaleDateString", DatePrototype_toLocaleDateString, 0),
            ("toLocaleString", DatePrototype_toLocaleString, 0),
            ("toLocaleTimeString", DatePrototype_toLocaleTimeString, 0),
            ("toString", DatePrototype_toString, 0),
            ("toTimeString", DatePrototype_toTimeString, 0),
            ("toUTCString", DatePrototype_toUTCString, 0),
            ("valueOf", DatePrototype_valueOf, 0),
        ],
    )
    func_obj = CreateBuiltinFunction(DatePrototype_toPrimitive, [], realm)
    DefinePropertyOrThrow(
        func_obj, "length", PropertyDescriptor(value=1, writable=False, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        func_obj,
        "name",
        PropertyDescriptor(value="[Symbol.toPrimitive]", writable=False, enumerable=False, configurable=False),
    )
    CreateMethodPropertyOrThrow(date_prototype, wks_to_primitive, func_obj)
    return date_prototype


def DateLocalHelper(this_value, func):
    t = thisTimeValue(this_value)
    if math.isnan(t):
        return t
    return func(LocalTime(t))


# 20.3.4.2 Date.prototype.getDate ( )
def DatePrototype_getDate(this_value, new_target, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. If t is NaN, return NaN.
    #   3. Return DateFromTime(LocalTime(t)).
    return DateLocalHelper(this_value, DateFromTime)


# 20.3.4.3 Date.prototype.getDay ( )
def DatePrototype_getDay(this_value, new_target, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. If t is NaN, return NaN.
    #   3. Return WeekDay(LocalTime(t)).
    return DateLocalHelper(this_value, WeekDay)


def DatePrototype_getFullYear(this_value, new_target, *_):
    return DateLocalHelper(this_value, YearFromTime)


def DatePrototype_getHours(this_value, new_target, *_):
    return DateLocalHelper(this_value, HourFromTime)


def DatePrototype_getMilliseconds(this_value, new_target, *_):
    return DateLocalHelper(this_value, msFromTime)


def DatePrototype_getMinutes(this_value, new_target, *_):
    return DateLocalHelper(this_value, MinFromTime)


def DatePrototype_getMonth(this_value, new_target, *_):
    return DateLocalHelper(this_value, MonthFromTime)


def DatePrototype_getSeconds(this_value, new_target, *_):
    return DateLocalHelper(this_value, SecFromTime)


def DatePrototype_getTime(this_value, new_target, *_):
    return thisTimeValue(this_value)


# 20.3.4.11 Date.prototype.getTimezoneOffset ( )
def DatePrototype_getTimezoneOffset(this_value, new_target, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. If t is NaN, return NaN.
    #   3. Return (t - LocalTime(t)) / msPerMinute.
    t = thisTimeValue(this_value)
    if math.isnan(t):
        return t
    return (t - LocalTime(t)) / msPerMinute


def DateUTCHelper(this_value, func):
    t = thisTimeValue(this_value)
    if math.isnan(t):
        return t
    return func(t)


def DatePrototype_getUTCDate(this_value, new_target, *_):
    return DateUTCHelper(this_value, DateFromTime)


def DatePrototype_getUTCDay(this_value, new_target, *_):
    return DateUTCHelper(this_value, WeekDay)


def DatePrototype_getUTCFullYear(this_value, new_target, *_):
    return DateUTCHelper(this_value, YearFromTime)


def DatePrototype_getUTCHours(this_value, new_target, *_):
    return DateUTCHelper(this_value, HourFromTime)


def DatePrototype_getUTCMilliseconds(this_value, new_target, *_):
    return DateUTCHelper(this_value, msFromTime)


def DatePrototype_getUTCMinutes(this_value, new_target, *_):
    return DateUTCHelper(this_value, MinFromTime)


def DatePrototype_getUTCMonth(this_value, new_target, *_):
    return DateUTCHelper(this_value, MonthFromTime)


def DatePrototype_getUTCSeconds(this_value, new_target, *_):
    return DateUTCHelper(this_value, SecFromTime)


# 20.3.4.20 Date.prototype.setDate ( date )
def DatePrototype_setDate(this_value, new_target, date=None, *_):
    # The following steps are performed:
    #
    #   1. Let t be LocalTime(? thisTimeValue(this value)).
    #   2. Let dt be ? ToNumber(date).
    #   3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).
    #   4. Let u be TimeClip(UTC(newDate)).
    #   5. Set the [[DateValue]] internal slot of this Date object to u.
    #   6. Return u.
    t = LocalTime(thisTimeValue(this_value))
    dt = ToNumber(date)
    newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t))
    u = TimeClip(UTC(newDate))
    this_value.DateValue = u
    return u


# 20.3.4.21 Date.prototype.setFullYear ( year [ , month [ , date ] ] )
def DatePrototype_setFullYear(this_value, new_target, year=None, month=EMPTY, date=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. If t is NaN, let t be +0; otherwise, let t be LocalTime(t).
    #   3. Let y be ? ToNumber(year).
    #   4. If month is not present, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).
    #   5. If date is not present, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).
    #   6. Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).
    #   7. Let u be TimeClip(UTC(newDate)).
    #   8. Set the [[DateValue]] internal slot of this Date object to u.
    #   9. Return u.
    t = thisTimeValue(this_value)
    if math.isnan(t):
        t = 0
    else:
        t = LocalTime(t)
    y = ToNumber(year)
    if month == EMPTY:
        m = MonthFromTime(t)
    else:
        m = ToNumber(month)
    if date == EMPTY:
        dt = DateFromTime(t)
    else:
        dt = ToNumber(date)
    newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t))
    u = TimeClip(UTC(newDate))
    this_value.DateValue = u
    return u
    # The length property of the setFullYear method is 3.
    # NOTE
    # If month is not present, this method behaves as if month was present with the value getMonth(). If date is not
    # present, it behaves as if date was present with the value getDate().


# 20.3.4.22 Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )
def DatePrototype_setHours(this_value, new_target, hour=None, min=EMPTY, sec=EMPTY, ms=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be LocalTime(? thisTimeValue(this value)).
    #   2. Let h be ? ToNumber(hour).
    #   3. If min is not present, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).
    #   4. If sec is not present, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).
    #   5. If ms is not present, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    #   6. Let date be MakeDate(Day(t), MakeTime(h, m, s, milli)).
    #   7. Let u be TimeClip(UTC(date)).
    #   8. Set the [[DateValue]] internal slot of this Date object to u.
    #   9. Return u.
    t = LocalTime(thisTimeValue(this_value))
    h = ToNumber(hour)
    if min == EMPTY:
        m = MinFromTime(t)
    else:
        m = ToNumber(min)
    if sec == EMPTY:
        s = SecFromTime(t)
    else:
        s = ToNumber(sec)
    if ms == EMPTY:
        milli = msFromTime(t)
    else:
        milli = ToNumber(ms)
    date = MakeDate(Day(t), MakeTime(h, m, s, milli))
    u = TimeClip(UTC(date))
    this_value.DateValue = u
    return u
    # The length property of the setHours method is 4.
    #
    # NOTE
    # If min is not present, this method behaves as if min was present with the value getMinutes(). If sec is not
    # present, it behaves as if sec was present with the value getSeconds(). If ms is not present, it behaves as if ms
    # was present with the value getMilliseconds().


# 20.3.4.23 Date.prototype.setMilliseconds ( ms )
def DatePrototype_setMilliseconds(this_value, new_target, ms=None, *_):
    # The following steps are performed:
    #
    #   1. Let t be LocalTime(? thisTimeValue(this value)).
    #   2. Let ms be ? ToNumber(ms).
    #   3. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms).
    #   4. Let u be TimeClip(UTC(MakeDate(Day(t), time))).
    #   5. Set the [[DateValue]] internal slot of this Date object to u.
    #   6. Return u.
    t = LocalTime(thisTimeValue(this_value))
    ms = ToNumber(ms)
    time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms)
    u = TimeClip(UTC(MakeDate(Day(t), time)))
    this_value.DateValue = u
    return u


# 20.3.4.24 Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )
def DatePrototype_setMinutes(this_value, new_target, min=None, sec=EMPTY, ms=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be LocalTime(? thisTimeValue(this value)).
    #   2. Let m be ? ToNumber(min).
    #   3. If sec is not present, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).
    #   4. If ms is not present, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    #   5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).
    #   6. Let u be TimeClip(UTC(date)).
    #   7. Set the [[DateValue]] internal slot of this Date object to u.
    #   8. Return u.
    t = LocalTime(thisTimeValue(this_value))
    m = ToNumber(min)
    if sec == EMPTY:
        s = SecFromTime(t)
    else:
        s = ToNumber(sec)
    if ms == EMPTY:
        milli = msFromTime(t)
    else:
        milli = ToNumber(ms)
    date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli))
    u = TimeClip(UTC(date))
    this_value.DateValue = u
    return u
    # The length property of the setMinutes method is 3.
    #
    # NOTE
    # If sec is not present, this method behaves as if sec was present with the value getSeconds(). If ms is not
    # present, this behaves as if ms was present with the value getMilliseconds().


# 20.3.4.25 Date.prototype.setMonth ( month [ , date ] )
def DatePrototype_setMonth(this_value, new_target, month=None, date=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be LocalTime(? thisTimeValue(this value)).
    #   2. Let m be ? ToNumber(month).
    #   3. If date is not present, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).
    #   4. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).
    #   5. Let u be TimeClip(UTC(newDate)).
    #   6. Set the [[DateValue]] internal slot of this Date object to u.
    #   7. Return u.
    t = LocalTime(thisTimeValue(this_value))
    m = ToNumber(month)
    if date == EMPTY:
        dt = DateFromTime(t)
    else:
        dt = ToNumber(date)
    newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t))
    u = TimeClip(UTC(newDate))
    this_value.DateValue = u
    return u
    # The length property of the setMonth method is 2.
    #
    # NOTE
    # If date is not present, this method behaves as if date was present with the value getDate().


# 20.3.4.26 Date.prototype.setSeconds ( sec [ , ms ] )
def DatePrototype_setSeconds(this_value, new_target, sec=None, ms=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be LocalTime(? thisTimeValue(this value)).
    #   2. Let s be ? ToNumber(sec).
    #   3. If ms is not present, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    #   4. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).
    #   5. Let u be TimeClip(UTC(date)).
    #   6. Set the [[DateValue]] internal slot of this Date object to u.
    #   7. Return u.
    t = LocalTime(thisTimeValue(this_value))
    s = ToNumber(sec)
    if ms == EMPTY:
        milli = msFromTime(t)
    else:
        milli = ToNumber(ms)
    date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli))
    u = TimeClip(UTC(date))
    this_value.DateValue = u
    return u
    # The length property of the setSeconds method is 2.
    #
    # NOTE
    # If ms is not present, this method behaves as if ms was present with the value getMilliseconds().


# 20.3.4.27 Date.prototype.setTime ( time )
def DatePrototype_setTime(this_value, new_target, time=None, *_):
    # The following steps are performed:
    #
    #   1. Perform ? thisTimeValue(this value).
    #   2. Let t be ? ToNumber(time).
    #   3. Let v be TimeClip(t).
    #   4. Set the [[DateValue]] internal slot of this Date object to v.
    #   5. Return v.
    thisTimeValue(this_value)  # essentially, just to generate an exception for non-date objects
    t = ToNumber(time)
    v = TimeClip(t)
    this_value.DateValue = v
    return v


# 20.3.4.28 Date.prototype.setDate ( date )
def DatePrototype_setUTCDate(this_value, new_target, date=None, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. Let dt be ? ToNumber(date).
    #   3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).
    #   4. Let v be TimeClip(newDate).
    #   5. Set the [[DateValue]] internal slot of this Date object to v.
    #   6. Return v.
    t = thisTimeValue(this_value)
    dt = ToNumber(date)
    newDate = MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t))
    v = TimeClip(newDate)
    this_value.DateValue = v
    return v


# 20.3.4.29 Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )
def DatePrototype_setUTCFullYear(this_value, new_target, year=None, month=EMPTY, date=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. If t is NaN, let t be +0.
    #   3. Let y be ? ToNumber(year).
    #   4. If month is not present, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).
    #   5. If date is not present, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).
    #   6. Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).
    #   7. Let v be TimeClip(newDate).
    #   8. Set the [[DateValue]] internal slot of this Date object to v.
    #   9. Return v.
    t = thisTimeValue(this_value)
    if math.isnan(t):
        t = 0
    y = ToNumber(year)
    if month == EMPTY:
        m = MonthFromTime(t)
    else:
        m = ToNumber(month)
    if date == EMPTY:
        dt = DateFromTime(t)
    else:
        dt = ToNumber(date)
    newDate = MakeDate(MakeDay(y, m, dt), TimeWithinDay(t))
    v = TimeClip(newDate)
    this_value.DateValue = v
    return v
    # The length property of the setUTCFullYear method is 3.
    #
    # NOTE
    # If month is not present, this method behaves as if month was present with the value getUTCMonth(). If date is not
    # present, it behaves as if date was present with the value getUTCDate().


# 20.3.4.30 Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )
def DatePrototype_setUTCHours(this_value, new_target, hour=None, min=EMPTY, sec=EMPTY, ms=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. Let h be ? ToNumber(hour).
    #   3. If min is not present, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).
    #   4. If sec is not present, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).
    #   5. If ms is not present, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).
    #   6. Let newDate be MakeDate(Day(t), MakeTime(h, m, s, milli)).
    #   7. Let v be TimeClip(newDate).
    #   8. Set the [[DateValue]] internal slot of this Date object to v.
    #   9. Return v.
    t = thisTimeValue(this_value)
    h = ToNumber(hour)
    if min == EMPTY:
        m = MinFromTime(t)
    else:
        m = ToNumber(m)
    if sec == EMPTY:
        s = SecFromTime(t)
    else:
        s = ToNumber(sec)
    if ms == EMPTY:
        milli = msFromTime(t)
    else:
        milli = ToNumber(ms)
    newDate = MakeDate(Day(t), MakeTime(h, m, s, milli))
    v = TimeClip(newDate)
    this_value.DateValue = v
    return v
    # The length property of the setUTCHours method is 4.
    #
    # NOTE
    # If min is not present, this method behaves as if min was present with the value getUTCMinutes(). If sec is not
    # present, it behaves as if sec was present with the value getUTCSeconds(). If ms is not present, it behaves as if
    # ms was present with the value getUTCMilliseconds().


# 20.3.4.31 Date.prototype.setUTCMilliseconds ( ms )
def DatePrototype_setUTCMilliseconds(this_value, new_target, ms=None, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. Let milli be ? ToNumber(ms).
    #   3. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli).
    #   4. Let v be TimeClip(MakeDate(Day(t), time)).
    #   5. Set the [[DateValue]] internal slot of this Date object to v.
    #   6. Return v.
    t = thisTimeValue(this_value)
    milli = ToNumber(ms)
    time = MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli)
    v = TimeClip(MakeDate(Day(t), time))
    this_value.DateValue = v
    return v


# 20.3.4.32 Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] )
def DatePrototype_setUTCMinutes(this_value, new_target, min=None, sec=EMPTY, ms=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. Let m be ? ToNumber(min).
    #   3. If sec is not present, let s be SecFromTime(t).
    #   4. Else,
    #       a. Let s be ? ToNumber(sec).
    #   5. If ms is not present, let milli be msFromTime(t).
    #   6. Else,
    #       a. Let milli be ? ToNumber(ms).
    #   7. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).
    #   8. Let v be TimeClip(date).
    #   9. Set the [[DateValue]] internal slot of this Date object to v.
    #   10. Return v.
    t = thisTimeValue(this_value)
    m = ToNumber(min)
    if sec == EMPTY:
        s = SecFromTime(t)
    else:
        s = ToNumber(sec)
    if ms == EMPTY:
        milli = msFromTime(t)
    else:
        milli = ToNumber(ms)
    date = MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli))
    v = TimeClip(date)
    this_value.DateValue = v
    return v
    # The length property of the setUTCMinutes method is 3.
    #
    # NOTE
    # If sec is not present, this method behaves as if sec was present with the value getUTCSeconds(). If ms is not
    # present, it function behaves as if ms was present with the value return by getUTCMilliseconds().


# 20.3.4.33 Date.prototype.setUTCMonth ( month [ , date ] )
def DatePrototype_setUTCMonth(this_value, new_target, month=None, date=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. Let m be ? ToNumber(month).
    #   3. If date is not present, let dt be DateFromTime(t).
    #   4. Else,
    #       a. Let dt be ? ToNumber(date).
    #   5. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).
    #   6. Let v be TimeClip(newDate).
    #   7. Set the [[DateValue]] internal slot of this Date object to v.
    #   8. Return v.
    t = thisTimeValue(this_value)
    m = ToNumber(month)
    if date == EMPTY:
        dt = DateFromTime(t)
    else:
        dt = ToNumber(date)
    newDate = MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t))
    v = TimeClip(newDate)
    this_value.DateValue = v
    return v
    # The length property of the setUTCMonth method is 2.
    #
    # NOTE
    # If date is not present, this method behaves as if date was present with the value getUTCDate().


# 20.3.4.34 Date.prototype.setUTCSeconds ( sec [ , ms ] )
def DatePrototype_setUTCSeconds(this_value, new_target, sec=None, ms=EMPTY, *_):
    # The following steps are performed:
    #
    #   1. Let t be ? thisTimeValue(this value).
    #   2. Let s be ? ToNumber(sec).
    #   3. If ms is not present, let milli be msFromTime(t).
    #   4. Else,
    #       a. Let milli be ? ToNumber(ms).
    #   5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).
    #   6. Let v be TimeClip(date).
    #   7. Set the [[DateValue]] internal slot of this Date object to v.
    #   8. Return v.
    t = thisTimeValue(this_value)
    s = ToNumber(sec)
    if ms == EMPTY:
        milli = msFromTime(t)
    else:
        milli = ToNumber(ms)
    date = MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli))
    v = TimeClip(date)
    this_value.DateValue = v
    return v
    # The length property of the setUTCSeconds method is 2.
    #
    # NOTE
    # If ms is not present, this method behaves as if ms was present with the value getUTCMilliseconds().


# 20.3.4.35 Date.prototype.toDateString ( )
def DatePrototype_toDateString(this_value, new_target, *_):
    # The following steps are performed:
    #
    #   1. Let O be this Date object.
    #   2. Let tv be ? thisTimeValue(O).
    #   3. If tv is NaN, return "Invalid Date".
    #   4. Let t be LocalTime(tv).
    #   5. Return DateString(t).
    tv = thisTimeValue(this_value)
    if math.isnan(tv):
        return "Invalid Date"
    return DateString(LocalTime(tv))


# 20.3.4.36 Date.prototype.toISOString ( )
def DatePrototype_toISOString(this_value, new_target, *_):
    # This function returns a String value representing the instance in time corresponding to this time value. The
    # format of the String is the Date Time string format defined in 20.3.1.15. All fields are present in the String.
    # The time zone is always UTC, denoted by the suffix Z. If this time value is not a finite Number or if the year
    # is not a value that can be represented in that format (if necessary using extended year format), a RangeError
    # exception is thrown.
    tv = thisTimeValue(this_value)
    if math.isnan(tv) or abs(YearFromTime(tv)) >= 1000000:
        raise ESRangeError("Invalid time value")
    year = YearFromTime(tv)
    month = MonthFromTime(tv) + 1
    day = DateFromTime(tv)
    time = TimeWithinDay(tv)
    hours = HourFromTime(time)
    minutes = MinFromTime(time)
    secs = SecFromTime(time)
    ms = msFromTime(time)
    if year >= 0 and year <= 9999:
        year_str = f"{year:04d}"
    else:
        year_str = f"{('-','+')[year >= 0]}{year:06d}"
    return f"{year_str}-{month:02d}-{day:02d}T{hours:02d}:{minutes:02d}:{secs:02d}.{ms:03d}Z"


# 20.3.4.37 Date.prototype.toJSON ( key )
def DatePrototype_toJSON(this_value, new_target, key=None, *_):
    # This function provides a String representation of a Date object for use by JSON.stringify (24.5.2).
    #
    # When the toJSON method is called with argument key, the following steps are taken:
    #
    #   1. Let O be ? ToObject(this value).
    #   2. Let tv be ? ToPrimitive(O, hint Number).
    #   3. If Type(tv) is Number and tv is not finite, return null.
    #   4. Return ? Invoke(O, "toISOString").
    O = ToObject(this_value)
    tv = ToPrimitive(O, "number")
    if isNumber(tv) and not math.isfinite(tv):
        return JSNull.NULL
    return Invoke(O, "toISOString")
    # NOTE 1
    # The argument is ignored.
    #
    # NOTE 2
    # The toJSON function is intentionally generic; it does not require that its this value be a Date object.
    # Therefore, it can be transferred to other kinds of objects for use as a method. However, it does require that any
    # such object have a toISOString method.


def locale_date(localtime):
    return f"{MonthFromTime(localtime)+1}/{DateFromTime(localtime)}/{YearFromTime(localtime)}"


def locale_time(localtime):
    time = TimeWithinDay(localtime)
    hour = HourFromTime(time)
    display_hour = (12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)[hour]
    ampm = ("AM", "PM")[hour >= 12]
    return f"{display_hour}:{MinFromTime(time):02d}:{SecFromTime(time):02d} {ampm}"


# 20.3.4.38 Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )
def DatePrototype_toLocaleDateString(this_value, new_target, reserved1=EMPTY, reserved2=EMPTY, *_):
    # An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the
    # Date.prototype.toLocaleDateString method as specified in the ECMA-402 specification. If an ECMAScript
    # implementation does not include the ECMA-402 API the following specification of the toLocaleDateString method is
    # used.
    #
    # This function returns a String value. The contents of the String are implementation-dependent, but are intended
    # to represent the “date” portion of the Date in the current time zone in a convenient, human-readable form that
    # corresponds to the conventions of the host environment's current locale.
    #
    # The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations
    # that do not include ECMA-402 support must not use those parameter positions for anything else.
    tv = thisTimeValue(this_value)
    if math.isnan(tv):
        return "Invalid Date"
    return locale_date(LocalTime(tv))


DatePrototype_toLocaleDateString.length = 0
DatePrototype_toLocaleDateString.name = "toLocaleDateString"

# 20.3.4.39 Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
def DatePrototype_toLocaleString(this_value, new_target, reserved1=EMPTY, reserved2=EMPTY, *_):
    # An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the
    # Date.prototype.toLocaleString method as specified in the ECMA-402 specification. If an ECMAScript implementation
    # does not include the ECMA-402 API the following specification of the toLocaleString method is used.
    #
    # This function returns a String value. The contents of the String are implementation-dependent, but are intended
    # to represent the Date in the current time zone in a convenient, human-readable form that corresponds to the
    # conventions of the host environment's current locale.
    #
    # The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations
    # that do not include ECMA-402 support must not use those parameter positions for anything else.
    tv = thisTimeValue(this_value)
    if math.isnan(tv):
        return "Invalid Date"
    lt = LocalTime(tv)
    return f"{locale_date(lt)}, {locale_time(lt)}"


DatePrototype_toLocaleString.length = 0
DatePrototype_toLocaleString.name = "toLocaleDateString"


# 20.3.4.40 Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )
def DatePrototype_toLocaleTimeString(this_value, new_target, reserved1=EMPTY, reserved2=EMPTY, *_):
    # An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the
    # Date.prototype.toLocaleTimeString method as specified in the ECMA-402 specification. If an ECMAScript
    # implementation does not include the ECMA-402 API the following specification of the toLocaleTimeString method is
    # used.
    #
    # This function returns a String value. The contents of the String are implementation-dependent, but are intended
    # to represent the “time” portion of the Date in the current time zone in a convenient, human-readable form that
    # corresponds to the conventions of the host environment's current locale.
    #
    # The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations
    # that do not include ECMA-402 support must not use those parameter positions for anything else.
    tv = thisTimeValue(this_value)
    if math.isnan(tv):
        return "Invalid Date"
    return locale_time(LocalTime(tv))


DatePrototype_toLocaleTimeString.length = 0
DatePrototype_toLocaleTimeString.name = "toLocaleTimeString"

# 20.3.4.41 Date.prototype.toString ( )
def DatePrototype_toString(this_value, new_target, *_):
    # The following steps are performed:
    #
    #   1. Let tv be ? thisTimeValue(this value).
    #   2. Return ToDateString(tv).
    return ToDateString(thisTimeValue(this_value))
    # NOTE 1
    # For any Date object d whose milliseconds amount is zero, the result of Date.parse(d.toString()) is equal to
    # d.valueOf(). See 20.3.3.2.
    #
    # NOTE 2
    # The toString function is intentionally generic; it does not require that its this value be a Date object.
    # Therefore, it can be transferred to other kinds of objects for use as a method.


# 20.3.4.42 Date.prototype.toTimeString ( )
def DatePrototype_toTimeString(this_value, nt, *_):
    # The following steps are performed:
    #
    #   1. Let O be this Date object.
    #   2. Let tv be ? thisTimeValue(O).
    #   3. If tv is NaN, return "Invalid Date".
    #   4. Let t be LocalTime(tv).
    #   5. Return the string-concatenation of TimeString(t) and TimeZoneString(tv).
    tv = thisTimeValue(this_value)
    if math.isnan(tv):
        return "Invalid Date"
    return f"{TimeString(LocalTime(tv))}{TimeZoneString(tv)}"


# 20.3.4.43 Date.prototype.toUTCString ( )
def DatePrototype_toUTCString(this_value, new_target, *_):
    # The following steps are performed:
    #
    #   1. Let O be this Date object.
    #   2. Let tv be ? thisTimeValue(O).
    #   3. If tv is NaN, return "Invalid Date".
    #   4. Let weekday be the Name of the entry in Table 46 with the Number WeekDay(tv).
    #   5. Let month be the Name of the entry in Table 47 with the Number MonthFromTime(tv).
    #   6. Let day be the String representation of DateFromTime(tv), formatted as a two-digit decimal number, padded to
    #      the left with a zero if necessary.
    #   7. Let year be the String representation of YearFromTime(tv), formatted as a decimal number of at least four
    #      digits, padded to the left with zeroes if necessary.
    #   8. Return the string-concatenation of weekday, ",", the code unit 0x0020 (SPACE), day, the code unit 0x0020
    #      (SPACE), month, the code unit 0x0020 (SPACE), year, the code unit 0x0020 (SPACE), and TimeString(tv).
    tv = thisTimeValue(this_value)
    if math.isnan(tv):
        return "Invalid Date"
    weekday = weekday_names[WeekDay(tv)]
    month = month_names[MonthFromTime(tv)]
    day = f"{DateFromTime(tv):02d}"
    year = f"{YearFromTime(tv):04d}"
    return f"{weekday}, {day} {month} {year} {TimeString(tv)}"


# 20.3.4.44 Date.prototype.valueOf ( )
def DatePrototype_valueOf(this_value, new_target, *_):
    # The following steps are performed:
    #
    #   1. Return ? thisTimeValue(this value).
    return thisTimeValue(this_value)


# 20.3.4.45 Date.prototype [ @@toPrimitive ] ( hint )
def DatePrototype_toPrimitive(this_value, new_target, hint=None, *_):
    # This function is called by ECMAScript language operators to convert a Date object to a primitive value. The
    # allowed values for hint are  "default", "number", and "string". Date objects, are unique among built-in
    # ECMAScript object in that they treat "default" as being equivalent to "string", All other built-in ECMAScript
    # objects treat "default" as being equivalent to "number".
    #
    # When the @@toPrimitive method is called with argument hint, the following steps are taken:
    #
    #   1. Let O be the this value.
    #   2. If Type(O) is not Object, throw a TypeError exception.
    #   3. If hint is the String value "string" or the String value "default", then
    #       a. Let tryFirst be "string".
    #   4. Else if hint is the String value "number", then
    #       a. Let tryFirst be "number".
    #   5. Else, throw a TypeError exception.
    #   6. Return ? OrdinaryToPrimitive(O, tryFirst).
    if not isObject(this_value):
        raise ESTypeError("toPrimitive needs an object")
    if hint in ["string", "default"]:
        tryFirst = "string"
    elif hint == "number":
        tryFirst = "number"
    else:
        raise ESTypeError("bad hint for toPrimitive")
    return OrdinaryToPrimitive(this_value, tryFirst)
    # The value of the name property of this function is "[Symbol.toPrimitive]".
    #
    # This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.


def DateFixups(realm):
    date_constructor = realm.intrinsics["%Date%"]
    date_prototype = realm.intrinsics["%DatePrototype%"]
    proto_desc = PropertyDescriptor(value=date_prototype, writable=False, enumerable=False, configurable=False)
    DefinePropertyOrThrow(date_constructor, "prototype", proto_desc)
    DefinePropertyOrThrow(date_prototype, "constructor", PropertyDescriptor(value=date_constructor))
    return None


# ------------------------------------ 𝟐𝟏 𝑻𝒆𝒙𝒕 𝑷𝒓𝒐𝒄𝒆𝒔𝒔𝒊𝒏𝒈 ------------------------------------
# ------------------------------------ 𝟐𝟏.𝟏 𝑺𝒕𝒓𝒊𝒏𝒈 𝑶𝒃𝒋𝒆𝒄𝒕𝒔 ------------------------------------
#######################################################################################################################################################
#
#  .d8888b.   d888        d888        .d8888b.  888            d8b                        .d88888b.  888         d8b                   888
# d88P  Y88b d8888       d8888       d88P  Y88b 888            Y8P                       d88P" "Y88b 888         Y8P                   888
#        888   888         888       Y88b.      888                                      888     888 888                               888
#      .d88P   888         888        "Y888b.   888888 888d888 888 88888b.   .d88b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  .od888P"    888         888           "Y88b. 888    888P"   888 888 "88b d88P"88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# d88P"        888         888             "888 888    888     888 888  888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
# 888"         888   d8b   888       Y88b  d88P Y88b.  888     888 888  888 Y88b 888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888888888  8888888 Y8P 8888888      "Y8888P"   "Y888 888     888 888  888  "Y88888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                888                             888
#                                                                           Y8b d88P                            d88P
#                                                                            "Y88P"                           888P"
#
#######################################################################################################################################################
# ------------------------------------ 𝟐𝟏.𝟏.𝟏 𝑻𝒉𝒆 𝑺𝒕𝒓𝒊𝒏𝒈 𝑪𝒐𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒐𝒓 ------------------------------------
# 21.1.1 The String Constructor
# The String constructor:
#
#   * is the intrinsic object %String%.
#   * is the initial value of the String property of the global object.
#   * creates and initializes a new String object when called as a constructor.
#   * performs a type conversion when called as a function rather than as a constructor.
#   * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#     constructors that intend to inherit the specified String behaviour must include a super call to the String
#     constructor to create and initialize the subclass instance with a [[StringData]] internal slot.
#
def CreateStringConstructor(realm):
    obj = CreateBuiltinFunction(StringFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "String")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    BindBuiltinFunctions(
        realm,
        obj,
        [
            ("fromCharCode", String_fromCharCode, 1),
            ("fromCodePoint", String_fromCodePoint, 1),
            ("raw", String_raw, None),
        ],
    )
    return obj


# ------------------------------------ 𝟐𝟏.𝟏.𝟏.𝟏 𝑺𝒕𝒓𝒊𝒏𝒈 ( 𝒗𝒂𝒍𝒖𝒆 ) ------------------------------------
def StringFunction(this_value, new_target, value=MISSING, *_):
    # When String is called with argument value, the following steps are taken:
    #
    # 1. If no arguments were passed to this function invocation, let s be "".
    # 2. Else,
    #    a. If NewTarget is undefined and Type(value) is Symbol, return SymbolDescriptiveString(value).
    #    b. Let s be ? ToString(value).
    # 3. If NewTarget is undefined, return s.
    # 4. Return ? StringCreate(s, ? GetPrototypeFromConstructor(NewTarget, "%StringPrototype%")).
    if value == MISSING:
        s = ""
    else:
        if new_target is None and isSymbol(value):
            return SymbolDescriptiveString(value)
        s = ToString(value)
    if new_target is None:
        return s
    proto = GetPrototypeFromConstructor(new_target, "%StringPrototype%")
    return StringCreate(s, proto)


# ------------------------------------ 𝟐𝟏.𝟏.𝟐 𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒊𝒆𝒔 𝒐𝒇 𝒕𝒉𝒆 𝑺𝒕𝒓𝒊𝒏𝒈 𝑪𝒐𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒐𝒓 ------------------------------------
# 21.1.2 Properties of the String Constructor
#
# The String constructor:
#
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.
#   * has the following properties:

# ------------------------------------ 𝟐𝟏.𝟏.𝟐.𝟏 𝑺𝒕𝒓𝒊𝒏𝒈.𝒇𝒓𝒐𝒎𝑪𝒉𝒂𝒓𝑪𝒐𝒅𝒆 ( ...𝒄𝒐𝒅𝒆𝑼𝒏𝒊𝒕𝒔 ) ------------------------------------
# 21.1.2.1 String.fromCharCode ( ...codeUnits )
def String_fromCharCode(this_value, new_target, *codeUnits):
    # The String.fromCharCode function may be called with any number of arguments which form the rest parameter
    # codeUnits. The following steps are taken:
    #
    # 1. Let codeUnits be a List containing the arguments passed to this function.
    # 2. Let length be the number of elements in codeUnits.
    # 3. Let elements be a new empty List.
    # 4. Let nextIndex be 0.
    # 5. Repeat, while nextIndex < length
    #    a. Let next be codeUnits[nextIndex].
    #    b. Let nextCU be ? ToUint16(next).
    #    c. Append nextCU to the end of elements.
    #    d. Let nextIndex be nextIndex + 1.
    # 6. Return the String value whose elements are, in order, the elements in the List elements. If length is 0, the
    #    empty string is returned.
    elements = []
    for next in codeUnits:
        codevalue = ToUint16(next)
        elements.append(codevalue)
    return "".join(chr(x) for x in elements)
    # The length property of the fromCharCode function is 1.


String_fromCharCode.length = 1
String_fromCharCode.name = "fromCharCode"

# ------------------------------------ 𝟐𝟏.𝟏.𝟐.𝟐 𝑺𝒕𝒓𝒊𝒏𝒈.𝒇𝒓𝒐𝒎𝑪𝒐𝒅𝒆𝑷𝒐𝒊𝒏𝒕 ( ...𝒄𝒐𝒅𝒆𝑷𝒐𝒊𝒏𝒕𝒔 ) ------------------------------------
# 21.1.2.2 String.fromCodePoint ( ...codePoints )
def String_fromCodePoint(this_value, new_target, *codePoints):
    # The String.fromCodePoint function may be called with any number of arguments which form the rest parameter
    # codePoints. The following steps are taken:
    #
    # 1. Let codePoints be a List containing the arguments passed to this function.
    # 2. Let length be the number of elements in codePoints.
    # 3. Let elements be a new empty List.
    # 4. Let nextIndex be 0.
    # 5. Repeat, while nextIndex < length
    #    a. Let next be codePoints[nextIndex].
    #    b. Let nextCP be ? ToNumber(next).
    #    c. If SameValue(nextCP, ToInteger(nextCP)) is false, throw a RangeError exception.
    #    d. If nextCP < 0 or nextCP > 0x10FFFF, throw a RangeError exception.
    #    e. Append the elements of the UTF16Encoding of nextCP to the end of elements.
    #    f. Let nextIndex be nextIndex + 1.
    # 6. Return the String value whose elements are, in order, the elements in the List elements. If length is 0, the
    #    empty string is returned.
    elements = []
    for next in codePoints:
        nextCP = ToNumber(next)
        if not SameValue(nextCP, ToInteger(nextCP)):
            raise ESRangeError("code points must be integers")
        if nextCP < 0 or nextCP > 0x10FFFF:
            raise ESRangeError("code points must be in the range 0x0..0x10ffff")
        elements.extend(utf_16_encode(chr(nextCP)))
    return "".join(elements)
    # The length property of the fromCodePoint function is 1.


String_fromCodePoint.length = 1
String_fromCodePoint.name = "fromCodePoint"

# 21.1.2.4 String.raw ( template, ...substitutions )
def String_raw(this_value, new_target, template=None, *substitutions):
    # The String.raw function may be called with a variable number of arguments. The first argument is template and the
    # remainder of the arguments form the List substitutions. The following steps are taken:
    #
    #   1. Let substitutions be a List consisting of all of the arguments passed to this function, starting with the
    #      second argument. If fewer than two arguments were passed, the List is empty.
    #   2. Let numberOfSubstitutions be the number of elements in substitutions.
    #   3. Let cooked be ? ToObject(template).
    #   4. Let raw be ? ToObject(? Get(cooked, "raw")).
    #   5. Let literalSegments be ? ToLength(? Get(raw, "length")).
    #   6. If literalSegments ≤ 0, return the empty string.
    #   7. Let stringElements be a new empty List.
    #   8. Let nextIndex be 0.
    #   9. Repeat,
    #       a. Let nextKey be ! ToString(nextIndex).
    #       b. Let nextSeg be ? ToString(? Get(raw, nextKey)).
    #       c. Append in order the code unit elements of nextSeg to the end of stringElements.
    #       d. If nextIndex + 1 = literalSegments, then
    #           i. Return the String value whose code units are, in order, the elements in the List stringElements. If
    #              stringElements has no elements, the empty string is returned.
    #       e. If nextIndex < numberOfSubstitutions, let next be substitutions[nextIndex].
    #       f. Else, let next be the empty String.
    #       g. Let nextSub be ? ToString(next).
    #       h. Append in order the code unit elements of nextSub to the end of stringElements.
    #       i. Increase nextIndex by 1.
    # NOTE  | String.raw is intended for use as a tag function of a Tagged Template (12.3.7). When called as such, the
    #       | first argument will be a well formed template object and the rest parameter will contain the substitution
    #       | values.
    numberOfSubstitutions = len(substitutions)
    cooked = ToObject(template)
    raw = ToObject(Get(cooked, "raw"))
    literalSegments = ToLength(Get(raw, "length"))
    if literalSegments <= 0:
        return ""
    stringElements = ""
    nextIndex = 0
    while 1:
        nextKey = ToString(nextIndex)
        nextSeg = ToString(Get(raw, nextKey))
        stringElements = stringElements + nextSeg
        if nextIndex + 1 == literalSegments:
            return stringElements
        if nextIndex < numberOfSubstitutions:
            next = substitutions[nextIndex]
        else:
            next = ""
        nextSub = ToString(next)
        stringElements = stringElements + nextSub
        nextIndex += 1


String_raw.length = 1
String_raw.name = "raw"


# ------------------------------------ 𝟐𝟏.𝟏.𝟑 𝑷𝒓𝒐𝒑𝒆𝒓𝒕𝒊𝒆𝒔 𝒐𝒇 𝒕𝒉𝒆 𝑺𝒕𝒓𝒊𝒏𝒈 𝑷𝒓𝒐𝒕𝒐𝒕𝒚𝒑𝒆 𝑶𝒃𝒋𝒆𝒄𝒕 ------------------------------------
# 21.1.3 Properties of the String Prototype Object
# The String prototype object:
#
#   * is the intrinsic object %StringPrototype%.
#   * is a String exotic object and has the internal methods specified for such objects.
#   * has a [[StringData]] internal slot whose value is the empty String.
#   * has a length property whose initial value is 0 and whose attributes are { [[Writable]]: false,
#     [[Enumerable]]: false, [[Configurable]]: false }.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
#
# Unless explicitly stated otherwise, the methods of the String prototype object defined below are not generic and the
# this value passed to them must be either a String value or an object that has a [[StringData]] internal slot that has
# been initialized to a String value.
def CreateStringPrototype(realm):
    string_prototype = StringCreate("", realm.intrinsics["%ObjectPrototype%"])
    BindBuiltinFunctions(
        realm,
        string_prototype,
        (
            ("indexOf", StringPrototype_indexOf, None),
            ("slice", StringPrototype_slice, None),
            ("toString", StringPrototype_toString, None),
            ("valueOf", StringPrototype_valueOf, None),
        ),
    )
    return string_prototype


def thisStringValue(value):
    # The abstract operation thisStringValue(value) performs the following steps:
    #
    # 1. If Type(value) is String, return value.
    # 2. If Type(value) is Object and value has a [[StringData]] internal slot, then
    #    a. Assert: value.[[StringData]] is a String value.
    #    b. Return value.[[StringData]].
    # 3. Throw a TypeError exception.
    if isString(value):
        return value
    if isObject(value) and hasattr(value, "StringData"):
        assert isString(value.StringData)
        return value.StringData
    raise ESTypeError("Not a string value")


# 21.1.3.8 String.prototype.indexOf ( searchString [ , position ] )
def StringPrototype_indexOf(this_value, new_target, searchString=None, position=None, *_):
    # NOTE 1    | If searchString appears as a substring of the result of converting this object to a String, at one
    #           | or more indices that are greater than or equal to position, then the smallest such index is
    #           | returned; otherwise, -1 is returned. If position is undefined, 0 is assumed, so as to search all
    #           | of the String.
    #
    # The indexOf method takes two arguments, searchString and position, and performs the following steps:
    #   1. Let O be ? RequireObjectCoercible(this value).
    #   2. Let S be ? ToString(O).
    #   3. Let searchStr be ? ToString(searchString).
    #   4. Let pos be ? ToInteger(position).
    #   5. Assert: If position is undefined, then pos is 0.
    #   6. Let len be the length of S.
    #   7. Let start be min(max(pos, 0), len).
    #   8. Let searchLen be the length of searchStr.
    #   9. Return the smallest possible integer k not smaller than start such that k + searchLen is not greater than
    #      len, and for all nonnegative integers j less than searchLen, the code unit at index k + j within S is the
    #      same as the code unit at index j within searchStr; but if there is no such integer k, return the value
    #      -1.
    # NOTE 2    | The indexOf function is intentionally generic; it does not require that its this value be a String
    #           | object. Therefore, it can be transferred to other kinds of objects for use as a method.
    S = ToString(RequireObjectCoercible(this_value))
    searchStr = ToString(searchString)
    pos = ToInteger(position)
    start = min(max(pos, 0), len(S))
    try:
        return S.index(searchStr, start)
    except ValueError:
        return -1


StringPrototype_indexOf.length = 1
StringPrototype_indexOf.name = "indexOf"

# 21.1.3.18 String.prototype.slice ( start, end )
def StringPrototype_slice(this_value, new_target, start=None, end=None, *_):
    # The slice method takes two arguments, start and end, and returns a substring of the result of converting this
    # object to a String, starting from index start and running to, but not including, index end (or through the end
    # of the String if end is undefined). If start is negative, it is treated as sourceLength + start where
    # sourceLength is the length of the String. If end is negative, it is treated as sourceLength + end where
    # sourceLength is the length of the String. The result is a String value, not a String object. The following
    # steps are taken:
    #   1. Let O be ? RequireObjectCoercible(this value).
    #   2. Let S be ? ToString(O).
    #   3. Let len be the length of S.
    #   4. Let intStart be ? ToInteger(start).
    #   5. If end is undefined, let intEnd be len; else let intEnd be ? ToInteger(end).
    #   6. If intStart < 0, let from be max(len + intStart, 0); otherwise let from be min(intStart, len).
    #   7. If intEnd < 0, let to be max(len + intEnd, 0); otherwise let to be min(intEnd, len).
    #   8. Let span be max(to - from, 0).
    #   9. Return the String value containing span consecutive code units from S beginning with the code unit at
    #      index from.
    # NOTE  | The slice function is intentionally generic; it does not require that its this value be a String
    #       | object. Therefore it can be transferred to other kinds of objects for use as a method.
    O = RequireObjectCoercible(this_value)
    S = ToString(O)
    length = len(S)
    intStart = ToInteger(start)
    intEnd = length if end is None else ToInteger(end)
    from_ = int(max(length + intStart, 0) if intStart < 0 else min(intStart, length))
    to = int(max(length + intEnd, 0) if intEnd < 0 else min(intEnd, length))
    span = max(to - from_, 0)
    return S[from_ : from_ + span]


StringPrototype_slice.length = 2
StringPrototype_slice.name = "slice"

# ------------------------------------ 𝟐𝟏.𝟏.𝟑.𝟐𝟓 𝑺𝒕𝒓𝒊𝒏𝒈.𝒑𝒓𝒐𝒕𝒐𝒕𝒚𝒑𝒆.𝒕𝒐𝑺𝒕𝒓𝒊𝒏𝒈 ( ) ------------------------------------
# 21.1.3.25 String.prototype.toString ( )
def StringPrototype_toString(this_value, new_target, *_):
    # When the toString method is called, the following steps are taken:
    #
    # 1. Return ? thisStringValue(this value).
    # NOTE
    # For a String object, the toString method happens to return the same thing as the valueOf method.
    return thisStringValue(this_value)


StringPrototype_toString.length = 0
StringPrototype_toString.name = "toString"

# ------------------------------------ 𝟐𝟏.𝟏.𝟑.𝟐𝟖 𝑺𝒕𝒓𝒊𝒏𝒈.𝒑𝒓𝒐𝒕𝒐𝒕𝒚𝒑𝒆.𝒗𝒂𝒍𝒖𝒆𝑶𝒇 ( ) ------------------------------------
# 21.1.3.28 String.prototype.valueOf ( )
def StringPrototype_valueOf(this_value, new_target, *_):
    # When the valueOf method is called, the following steps are taken:
    #
    # 1. Return ? thisStringValue(this value).
    return thisStringValue(this_value)


StringPrototype_valueOf.length = 0
StringPrototype_valueOf.name = "valueOf"


def StringFixups(realm):
    string_constructor = realm.intrinsics["%String%"]
    string_prototype = realm.intrinsics["%StringPrototype%"]
    proto_desc = PropertyDescriptor(value=string_prototype, writable=False, enumerable=False, configurable=False)
    DefinePropertyOrThrow(string_constructor, "prototype", proto_desc)
    const_desc = PropertyDescriptor(value=string_constructor, writable=True, enumerable=False, configurable=True)
    DefinePropertyOrThrow(string_prototype, "constructor", const_desc)
    return None


#######################################################################################################################
#
#  .d8888b.   d888        .d8888b.      8888888b.                    8888888888
# d88P  Y88b d8888       d88P  Y88b     888   Y88b                   888
#        888   888              888     888    888                   888
#      .d88P   888            .d88P     888   d88P  .d88b.   .d88b.  8888888    888  888 88888b.
#  .od888P"    888        .od888P"      8888888P"  d8P  Y8b d88P"88b 888        `Y8bd8P' 888 "88b
# d88P"        888       d88P"          888 T88b   88888888 888  888 888          X88K   888  888
# 888"         888   d8b 888"           888  T88b  Y8b.     Y88b 888 888        .d8""8b. 888 d88P
# 888888888  8888888 Y8P 888888888      888   T88b  "Y8888   "Y88888 8888888888 888  888 88888P"
#                                                                888                     888
#                                                           Y8b d88P                     888
#                                                            "Y88P"                      888
#   .d88 8888888b.                             888
#  d88P" 888   Y88b                            888
# d88P   888    888                            888
# 888    888   d88P  .d88b.   .d88b.  888  888 888  8888b.  888d888
# 888    8888888P"  d8P  Y8b d88P"88b 888  888 888     "88b 888P"
# Y88b   888 T88b   88888888 888  888 888  888 888 .d888888 888
#  Y88b. 888  T88b  Y8b.     Y88b 888 Y88b 888 888 888  888 888
#   "Y88 888   T88b  "Y8888   "Y88888  "Y88888 888 "Y888888 888
#                                 888
#                            Y8b d88P
#                             "Y88P"
# 8888888888                                                      d8b                   88b.
# 888                                                             Y8P                   "Y88b
# 888                                                                                     Y88b
# 8888888    888  888 88888b.  888d888  .d88b.  .d8888b  .d8888b  888  .d88b.  88888b.     888
# 888        `Y8bd8P' 888 "88b 888P"   d8P  Y8b 88K      88K      888 d88""88b 888 "88b    888
# 888          X88K   888  888 888     88888888 "Y8888b. "Y8888b. 888 888  888 888  888   d88P
# 888        .d8""8b. 888 d88P 888     Y8b.          X88      X88 888 Y88..88P 888  888 .d88P
# 8888888888 888  888 88888P"  888      "Y8888   88888P'  88888P' 888  "Y88P"  888  888 88P"
#                     888
#                     888
#                     888
#  .d88888b.  888         d8b                   888
# d88P" "Y88b 888         Y8P                   888
# 888     888 888                               888
# 888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
# 888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# 888     888 888  888    888 88888888 888      888    "Y8888b.
# Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
#  "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                         888
#                        d88P
#                      888P"
#
#######################################################################################################################
# 21.2 RegExp (Regular Expression) Objects
# 21.2.1 Patterns
# 21.2.2 Pattern Semantics
# 21.2.3 The RegExp Constructor
# 21.2.3.1 RegExp ( pattern, flags )
# 21.2.3.2 Abstract Operations for the RegExp Constructor
# 21.2.3.2.1 RS: RegExpAlloc ( newTarget )
# 21.2.3.2.2 RS: RegExpInitialize ( obj, pattern, flags )
# 21.2.3.2.3 RS: RegExpCreate ( P, F )
# 21.2.3.2.4 RS: EscapeRegExpPattern ( P, F )
# 21.2.4 Properties of the RegExp Constructor
# 21.2.4.1 RegExp.prototype
# 21.2.4.2 get RegExp [ @@species ]
# 21.2.5 Properties of the RegExp Prototype Object
# 21.2.5.1 RegExp.prototype.constructor
# 21.2.5.2 RegExp.prototype.exec ( string )
# 21.2.5.2.1 RS: RegExpExec ( R, S )
# 21.2.5.2.2 RS: RegExpBuiltinExec ( R, S )
# 21.2.5.2.3 AdvanceStringIndex ( S, index, unicode )
# 21.2.5.3 get RegExp.prototype.dotAll
# 21.2.5.4 get RegExp.prototype.flags
# 21.2.5.5 get RegExp.prototype.global
# 21.2.5.6 get RegExp.prototype.ignoreCase
# 21.2.5.7 RegExp.prototype [ @@match ] ( string )
# 21.2.5.8 get RegExp.prototype.multiline
# 21.2.5.9 RegExp.prototype [ @@replace ] ( string, replaceValue )
# 21.2.5.10 RegExp.prototype [ @@search ] ( string )
# 21.2.5.11 get RegExp.prototype.source
# 21.2.5.12 RegExp.prototype [ @@split ] ( string, limit )
# 21.2.5.13 get RegExp.prototype.sticky
# 21.2.5.14 RegExp.prototype.test ( S )
# 21.2.5.15 RegExp.prototype.toString ( )
# 21.2.5.16 get RegExp.prototype.unicode
# 21.2.6 Properties of RegExp Instances
# 21.2.6.1 lastIndex
#######################################################################################################################

# 21.2.3 The RegExp Constructor
# The RegExp constructor:
#
#   * is the intrinsic object %RegExp%.
#   * is the initial value of the RegExp property of the global object.
#   * creates and initializes a new RegExp object when called as a function rather than as a constructor. Thus the
#     function call RegExp(…) is equivalent to the object creation expression new RegExp(…) with the same arguments.
#   * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#     constructors that intend to inherit the specified RegExp behaviour must include a super call to the RegExp
#     constructor to create and initialize subclass instances with the necessary internal slots.
def CreateRegexConstructor(realm: Realm) -> JSObject:
    obj = CreateBuiltinFunction(RegexpFunction, ["Construct"], realm=realm)
    for key, value in (("length", 2), ("name", "RegExp")):
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    BindBuiltinAccessors(realm, obj, [(wks_species, RegExp_species, None)])
    return obj


# 21.2.3.1 RegExp ( pattern, flags )
def RegexpFunction(this_value, new_target, pattern=None, flags=None, *_):
    # The following steps are taken:
    #
    #   1. Let patternIsRegExp be ? IsRegExp(pattern).
    #   2. If NewTarget is undefined, then
    #       a. Let newTarget be the active function object.
    #       b. If patternIsRegExp is true and flags is undefined, then
    #           i. Let patternConstructor be ? Get(pattern, "constructor").
    #           ii. If SameValue(newTarget, patternConstructor) is true, return pattern.
    #   3. Else, let newTarget be NewTarget.
    #   4. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then
    #       a. Let P be pattern.[[OriginalSource]].
    #       b. If flags is undefined, let F be pattern.[[OriginalFlags]].
    #       c. Else, let F be flags.
    #   5. Else if patternIsRegExp is true, then
    #       a. Let P be ? Get(pattern, "source").
    #       b. If flags is undefined, then
    #           i. Let F be ? Get(pattern, "flags").
    #       c. Else, let F be flags.
    #   6. Else,
    #       a. Let P be pattern.
    #       b. Let F be flags.
    #   7. Let O be ? RegExpAlloc(newTarget).
    #   8. Return ? RegExpInitialize(O, P, F).
    patternIsRegExp = IsRegExp(pattern)
    if new_target is None:
        newTarget = surrounding_agent.running_ec.function
        if patternIsRegExp and flags is None:
            patternConstructor = Get(pattern, "constructor")
            if SameValue(newTarget, patternConstructor):
                return pattern
    else:
        newTarget = new_target
    if isObject(pattern) and hasattr(pattern, "RegExpMatcher"):
        P = pattern.OriginalSource
        if flags is None:
            F = pattern.OriginalFlags
        else:
            F = flags
    elif patternIsRegExp:
        P = Get(pattern, "source")
        if flags is None:
            F = Get(pattern, "flags")
        else:
            F = flags
    else:
        P = pattern
        F = flags
    O = RegExpAlloc(newTarget)
    return RegExpInitialize(O, P, F)
    # NOTE  | If pattern is supplied using a StringLiteral, the usual escape sequence substitutions are performed
    #       | before the String is processed by RegExp. If pattern must contain an escape sequence to be recognized by
    #       | RegExp, any U+005C (REVERSE SOLIDUS) code points must be escaped within the StringLiteral to prevent them
    #       | being removed when the contents of the StringLiteral are formed.


# 21.2.3.2.1 Runtime Semantics: RegExpAlloc ( newTarget )
def RegExpAlloc(newTarget):
    # When the abstract operation RegExpAlloc with argument newTarget is called, the following steps are taken:
    #   1. Let obj be ? OrdinaryCreateFromConstructor(newTarget, "%RegExpPrototype%", « [[RegExpMatcher]],
    #      [[OriginalSource]], [[OriginalFlags]] »).
    #   2. Perform ! DefinePropertyOrThrow(obj, "lastIndex", PropertyDescriptor { [[Writable]]: true,
    #      [[Enumerable]]: false, [[Configurable]]: false }).
    #   3. Return obj.
    obj = OrdinaryCreateFromConstructor(
        newTarget, "%RegExpPrototype%", ["RegExpMatcher", "OriginalSource", "OriginalFlags"]
    )
    DefinePropertyOrThrow(obj, "lastIndex", PropertyDescriptor(writable=True, enumerable=False, configurable=False))
    return obj


# 21.2.3.2.2 Runtime Semantics: RegExpInitialize ( obj, pattern, flags )
def RegExpInitialize(obj, pattern, flags):
    # When the abstract operation RegExpInitialize with arguments obj, pattern, and flags is called, the following
    # steps are taken:
    #   1. If pattern is undefined, let P be the empty String.
    #   2. Else, let P be ? ToString(pattern).
    #   3. If flags is undefined, let F be the empty String.
    #   4. Else, let F be ? ToString(flags).
    #   5. If F contains any code unit other than "g", "i", "m", "s", "u", or "y" or if it contains the same code unit
    #      more than once, throw a SyntaxError exception.
    #   6. If F contains "u", let BMP be false; else let BMP be true.
    #   7. If BMP is true, then
    #       a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP code
    #          point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is Pattern[~U, ~N].
    #          If the result of parsing contains a GroupName, reparse with the goal symbol Pattern[~U, +N] and use this
    #          result instead. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P
    #          were not matched by the parse, or if any Early Error conditions exist.
    #       b. Let patternCharacters be a List whose elements are the code unit elements of P.
    #   8. Else,
    #       a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points (6.1.4).
    #          The goal symbol for the parse is Pattern[+U, +N]. Throw a SyntaxError exception if P did not conform to
    #          the grammar, if any elements of P were not matched by the parse, or if any Early Error conditions exist.
    #       b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16
    #          decoding to P's sequence of elements.
    #   9. Set obj.[[OriginalSource]] to P.
    #   10. Set obj.[[OriginalFlags]] to F.
    #   11. Set obj.[[RegExpMatcher]] to the internal procedure that evaluates the above parse of P by applying the
    #       semantics provided in 21.2.2 using patternCharacters as the pattern's List of SourceCharacter values and F
    #       as the flag parameters.
    #   12. Perform ? Set(obj, "lastIndex", 0, true).
    #   13. Return obj.
    P = "" if pattern is None else ToString(pattern)
    F = "" if flags is None else ToString(flags)
    if bad_regex_flag_match.search(F) or len(F) != len(set(F)):
        raise ESSyntaxError(f"Bad flags for regex: {F}")
    BMP = "u" not in F
    if BMP:
        pat = e262_regexp.parse_Pattern(P, 0, False, False)
        if pat and pat.group_names:
            pat = e262_regexp.parse_Pattern(P, 0, False, True)
        if not pat or pat.span.after != len(P):
            raise ESSyntaxError(f"Bad Regex: {P}")
        patternCharacters = P
    else:
        pat = e262_regexp.parse_Pattern(P, 0, True, True)
        if not pat or pat.span.after != len(pat):
            raise ESSyntaxError(f"Bad Regex: {P}")
        patternCharacters = utf_16_decode(P, throw=True, syntax_error_ctor=ESSyntaxError)
    if pat.earlyerrors:
        raise ESSyntaxError("\n".join(chain((f"Bad Regex: {P}",), pat.earlyerrors)))

    obj.OriginalSource = P
    obj.OriginalFlags = F
    obj.RegExpMatcher = e262_regexp.matcher(pat, patternCharacters, F)
    obj.capture_map = pat.capture_map
    Set(obj, "lastIndex", 0, True)
    return obj


# 21.2.3.2.3 Runtime Semantics: RegExpCreate ( P, F )
def RegExpCreate(P, F):
    # When the abstract operation RegExpCreate with arguments P and F is called, the following steps are taken:
    #   1. Let obj be ? RegExpAlloc(%RegExp%).
    #   2. Return ? RegExpInitialize(obj, P, F).
    obj = RegExpAlloc(surrounding_agent.running_ec.realm.intrinsics["%RegExp%"])
    return RegExpInitialize(obj, P, F)


# 21.2.3.2.4 Runtime Semantics: EscapeRegExpPattern ( P, F )
def EscapeRegExpPattern(P, F):
    # When the abstract operation EscapeRegExpPattern with arguments P and F is called, the following occurs:
    #   1. Let S be a String in the form of a Pattern[~U] (Pattern[+U] if F contains "u") equivalent to P interpreted
    #      as UTF-16 encoded Unicode code points (6.1.4), in which certain code points are escaped as described below.
    #      S may or may not be identical to P; however, the internal procedure that would result from evaluating S as a
    #      Pattern[~U] (Pattern[+U] if F contains "u") must behave identically to the internal procedure given by the
    #      constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the
    #      same values for P and F must produce identical results.
    #   2. The code points / or any LineTerminator occurring in the pattern shall be escaped in S as necessary to
    #      ensure that the string-concatenation of "/", S, "/", and F can be parsed (in an appropriate lexical context)
    #      as a RegularExpressionLiteral that behaves identically to the constructed regular expression. For example,
    #      if P is "/", then S could be "\/" or "\u002F", among other possibilities, but not "/", because /// followed
    #      by F would be parsed as a SingleLineComment rather than a RegularExpressionLiteral. If P is the empty
    #      String, this specification can be met by letting S be "(?:)".
    #   3. Return S.
    if any(ch in P for ch in "/\n\r\u2028\u2029"):
        raise NotImplementedError()
    return P


# 21.2.4 Properties of the RegExp Constructor
# The RegExp constructor:
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.


def RegExpFixups(realm: Realm) -> None:
    regexp_constructor = realm.intrinsics["%RegExp%"]
    regexp_prototype = realm.intrinsics["%RegExpPrototype%"]
    # 21.2.4.1 RegExp.prototype
    # The initial value of RegExp.prototype is the intrinsic object %RegExpPrototype%.
    # This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.
    proto_desc = PropertyDescriptor(value=regexp_prototype, writable=False, enumerable=False, Configurable=False)
    DefinePropertyOrThrow(regexp_constructor, "prototype", proto_desc)
    # 21.2.5.1 RegExp.prototype.constructor
    # The initial value of RegExp.prototype.constructor is the intrinsic object %RegExp%.
    constructor_desc = PropertyDescriptor(
        value=regexp_constructor, writable=True, enumerable=False, Configurable=True
    )
    DefinePropertyOrThrow(regexp_prototype, "constructor", constructor_desc)


# 21.2.4.2 get RegExp [ @@species ]
def RegExp_species(this_value, new_target, *_):
    # RegExp[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function
    # performs the following steps:
    #   1. Return the this value.
    return this_value
    # The value of the name property of this function is "get [Symbol.species]".
    # NOTE  | RegExp prototype methods normally use their this object's constructor to create a derived object.
    #       | However, a subclass constructor may over-ride that default behaviour by redefining its @@species
    #       | property.


RegExp_species.length = 0
RegExp_species.name = "get [Symbol.species]"

# 21.2.5 Properties of the RegExp Prototype Object
# The RegExp prototype object:
#   * is the intrinsic object %RegExpPrototype%.
#   * is an ordinary object.
#   * is not a RegExp instance and does not have a [[RegExpMatcher]] internal slot or any of the other internal slots
#     of RegExp instance objects.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
# NOTE  | The RegExp prototype object does not have a valueOf property of its own; however, it inherits the valueOf
#       | property from the Object prototype object.
def CreateRegExpPrototype(realm: Realm) -> JSObject:
    obj = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    BindBuiltinFunctions(
        realm,
        obj,
        [
            ("exec", RegExpPrototype_exec, None),
            (wks_match, RegExpPrototype_match, None),
            (wks_replace, RegExpPrototype_replace, None),
            (wks_search, RegExpPrototype_search, None),
            (wks_split, RegExpPrototype_split, None),
            ("test", RegExpPrototype_test, None),
            ("toString", RegExpPrototype_toString, None),
        ],
    )
    BindBuiltinAccessors(
        realm,
        obj,
        [
            ("dotAll", RegExpPrototype_getDotAll, None),
            ("flags", RegExpPrototype_getFlags, None),
            ("global", RegExpPrototype_getGlobal, None),
            ("ignoreCase", RegExpPrototype_getIgnoreCase, None),
            ("multiline", RegExpPrototype_getMultiline, None),
            ("source", RegExpPrototype_getSource, None),
            ("sticky", RegExpPrototype_getSticky, None),
            ("unicode", RegExpPrototype_getUnicode, None),
        ],
    )
    return obj


# 21.2.5.2 RegExp.prototype.exec ( string )
def RegExpPrototype_exec(this_value, new_target, string=None, *_):
    # Performs a regular expression match of string against the regular expression and returns an Array object
    # containing the results of the match, or null if string did not match.
    #
    # The String ToString(string) is searched for an occurrence of the regular expression pattern as follows:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.
    #   4. Let S be ? ToString(string).
    #   5. Return ? RegExpBuiltinExec(R, S).
    R = this_value
    if not isObject(R) or not hasattr(R, "RegExpMatcher"):
        raise ESTypeError(f"RegExp.prototype.exec called on incompatible receiver {ToString(R)}")
    S = ToString(string)
    return RegExpBuiltinExec(R, S)


RegExpPrototype_exec.length = 1
RegExpPrototype_exec.name = "exec"

# 21.2.5.2.1 Runtime Semantics: RegExpExec ( R, S )
def RegExpExec(R, S):
    # The abstract operation RegExpExec with arguments R and S performs the following steps:
    #   1. Assert: Type(R) is Object.
    #   2. Assert: Type(S) is String.
    #   3. Let exec be ? Get(R, "exec").
    #   4. If IsCallable(exec) is true, then
    #       a. Let result be ? Call(exec, R, « S »).
    #       b. If Type(result) is neither Object or Null, throw a TypeError exception.
    #       c. Return result.
    #   5. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.
    #   6. Return ? RegExpBuiltinExec(R, S).
    # NOTE  | If a callable exec property is not found this algorithm falls back to attempting to use the built-in
    #       | RegExp matching algorithm. This provides compatible behaviour for code written for prior editions where
    #       | most built-in algorithms that use regular expressions did not perform a dynamic property lookup of exec.
    assert isObject(R)
    assert isString(S)
    exec = Get(R, "exec")
    if IsCallable(exec):
        result = Call(exec, R, [S])
        if not isObject(R) and not isNull(R):
            raise ESTypeError(f'Invalid result from RegExp "exec" call: {ToString(R)}')
        return result
    if not hasattr(R, "RegExpMatcher"):
        raise ESTypeError(f"RegExp exec called with invalid reciever {ToString(R)}")
    return RegExpBuiltinExec(R, S)


# 21.2.5.2.2 Runtime Semantics: RegExpBuiltinExec ( R, S )
def RegExpBuiltinExec(R, S):
    # The abstract operation RegExpBuiltinExec with arguments R and S performs the following steps:
    #   1. Assert: R is an initialized RegExp instance.
    #   2. Assert: Type(S) is String.
    #   3. Let length be the number of code units in S.
    #   4. Let lastIndex be ? ToLength(? Get(R, "lastIndex")).
    #   5. Let flags be R.[[OriginalFlags]].
    #   6. If flags contains "g", let global be true, else let global be false.
    #   7. If flags contains "y", let sticky be true, else let sticky be false.
    #   8. If global is false and sticky is false, set lastIndex to 0.
    #   9. Let matcher be R.[[RegExpMatcher]].
    #   10. If flags contains "u", let fullUnicode be true, else let fullUnicode be false.
    #   11. Let matchSucceeded be false.
    #   12. Repeat, while matchSucceeded is false
    #       a. If lastIndex > length, then
    #           i. If global is true or sticky is true, then
    #               1. Perform ? Set(R, "lastIndex", 0, true).
    #           ii. Return null.
    #       b. Let r be matcher(S, lastIndex).
    #       c. If r is failure, then
    #           i. If sticky is true, then
    #               1. Perform ? Set(R, "lastIndex", 0, true).
    #               2. Return null.
    #           ii. Set lastIndex to AdvanceStringIndex(S, lastIndex, fullUnicode).
    #       d. Else,
    #           i. Assert: r is a State.
    #           ii. Set matchSucceeded to true.
    #   13. Let e be r's endIndex value.
    #   14. If fullUnicode is true, then
    #       a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the
    #          smallest index into S that corresponds to the character at element e of Input. If e is greater than or
    #          equal to the number of elements in Input, then eUTF is the number of code units in S.
    #       b. Set e to eUTF.
    #   15. If global is true or sticky is true, then
    #       a. Perform ? Set(R, "lastIndex", e, true).
    #   16. Let n be the number of elements in r's captures List. (This is the same value as 21.2.2.1's
    #       NcapturingParens.)
    #   17. Assert: n < 2^32 - 1.
    #   18. Let A be ! ArrayCreate(n + 1).
    #   19. Assert: The value of A's "length" property is n + 1.
    #   20. Perform ! CreateDataProperty(A, "index", lastIndex).
    #   21. Perform ! CreateDataProperty(A, "input", S).
    #   22. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and
    #       offset e exclusive).
    #   23. Perform ! CreateDataProperty(A, "0", matchedSubstr).
    #   24. If R contains any GroupName, then
    #       a. Let groups be ObjectCreate(null).
    #   25. Else,
    #       a. Let groups be undefined.
    #   26. Perform ! CreateDataProperty(A, "groups", groups).
    #   27. For each integer i such that i > 0 and i ≤ n, do
    #       a. Let captureI be ith element of r's captures List.
    #       b. If captureI is undefined, let capturedValue be undefined.
    #       c. Else if fullUnicode is true, then
    #           i. Assert: captureI is a List of code points.
    #           ii. Let capturedValue be the String value whose code units are the UTF16Encoding of the code points of
    #               captureI.
    #       d. Else fullUnicode is false,
    #           i. Assert: captureI is a List of code units.
    #           ii. Let capturedValue be the String value consisting of the code units of captureI.
    #       e. Perform ! CreateDataProperty(A, ! ToString(i), capturedValue).
    #       f. If the ith capture of R was defined with a GroupName, then
    #           i. Let s be the StringValue of the corresponding RegExpIdentifierName.
    #           ii. Perform ! CreateDataProperty(groups, s, capturedValue).
    #   28. Return A.
    assert all(getattr(R, attr, None) is not None for attr in ("RegExpMatcher", "OriginalSource", "OriginalFlags"))
    assert isString(S)
    length = len(S)
    lastIndex = ToLength(Get(R, "lastIndex"))
    flags = R.OriginalFlags
    global_ = "g" in flags
    sticky = "y" in flags
    if not global_ and not sticky:
        lastIndex = 0
    matcher = R.RegExpMatcher
    fullUnicode = "u" in flags
    matchSucceeded = False
    while not matchSucceeded:
        if lastIndex > length:
            if global_ or sticky:
                Set(R, "lastIndex", 0, True)
            return JSNull.NULL
        r = matcher(S, lastIndex)
        if r == FAILURE:
            if sticky:
                Set(R, "lastIndex", 0, True)
                return JSNull.NULL
            lastIndex = AdvanceStringIndex(S, lastIndex, fullUnicode)
        else:
            assert isinstance(r, e262_regexp.State)
            matchSucceeded = True
    e = r.endIndex
    if fullUnicode:
        # The matcher counts code points, not code units. We need the code units, though, which is what the paragraph
        # in the steps, above, is really saying. Essentially, we need to count unicode _characters_ in S until we've
        # counted e of them, and then eUTF is the index we're sitting at. Essentially: eUTF = e + number of high/low
        # surrogate pairs in the first e characters.
        idx = 0
        charsleft = e
        while charsleft > 0:
            if idx < len(S) - 1 and 0xD800 <= ord(S[idx]) <= 0xDBFF and 0xDC00 <= ord(S[idx + 1]) <= 0xDFFF:
                idx += 2
            else:
                idx += 1
            charsleft -= 1
        e = idx
    if global_ or sticky:
        Set(R, "lastIndex", e, True)
    n = len(r.captures)
    assert n < 2 ** 32 - 1
    A = ArrayCreate(n + 1)
    assert Get(A, "length") == n + 1
    CreateDataProperty(A, "index", lastIndex)
    CreateDataProperty(A, "input", S)
    matchedSubstr = S[lastIndex:e]
    CreateDataProperty(A, "0", matchedSubstr)
    if len(R.capture_map) > 0:
        groups = ObjectCreate(JSNull.NULL)
    else:
        groups = None
    CreateDataProperty(A, "groups", groups)
    for i in range(1, n + 1):
        captureI = r.captures[i - 1]
        if captureI is None:
            capturedValue = None
        elif fullUnicode:
            capturedValue = utf_16_encode(captureI)
        else:
            capturedValue = captureI
        CreateDataProperty(A, ToString(i), capturedValue)
        if i - 1 in R.capture_map:
            s = R.capture_map[i - 1]
            CreateDataProperty(groups, s, capturedValue)
    return A


# 21.2.5.2.3 AdvanceStringIndex ( S, index, unicode )
def AdvanceStringIndex(S, index, unicode):
    # The abstract operation AdvanceStringIndex with arguments S, index, and unicode performs the following steps:
    #   1. Assert: Type(S) is String.
    #   2. Assert: index is an integer such that 0 ≤ index ≤ 2^53 - 1.
    #   3. Assert: Type(unicode) is Boolean.
    #   4. If unicode is false, return index + 1.
    #   5. Let length be the number of code units in S.
    #   6. If index + 1 ≥ length, return index + 1.
    #   7. Let first be the numeric value of the code unit at index index within S.
    #   8. If first < 0xD800 or first > 0xDBFF, return index + 1.
    #   9. Let second be the numeric value of the code unit at index index + 1 within S.
    #   10. If second < 0xDC00 or second > 0xDFFF, return index + 1.
    #   11. Return index + 2.
    assert isString(S)
    assert IsInteger(index) and 0 <= index <= 2 ** 53 - 1
    assert isBoolean(unicode)

    if not unicode:
        return index + 1
    length = len(S)
    if index + 1 >= length:
        return index + 1
    first = ord(S[index])
    if first < 0xD800 or first > 0xDBFF:
        return index + 1
    second = ord(S[index + 1])
    if second < 0xDC00 or second > 0xDFFF:
        return index + 1
    return index + 2


def regexp_object_validator(obj, callername):
    err = lambda name, obj: ESTypeError(f"{name} called with bad receiver {ToString(obj)}")
    if not isObject(obj):
        raise err(callername, obj)
    if not hasattr(obj, "OriginalFlags"):
        if SameValue(obj, surrounding_agent.running_ec.realm.intrinsics["%RegExpPrototype%"]):
            return False
        raise err(callername, obj)
    return True


def regexp_flag_checker(obj, name, ch):
    if not regexp_object_validator(obj, name):
        return None
    return ch in obj.OriginalFlags


# 21.2.5.3 get RegExp.prototype.dotAll
def RegExpPrototype_getDotAll(this_value, new_target, *_):
    # RegExp.prototype.dotAll is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have an [[OriginalFlags]] internal slot, then
    #       a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    #       b. Otherwise, throw a TypeError exception.
    #   4. Let flags be R.[[OriginalFlags]].
    #   5. If flags contains the code unit 0x0073 (LATIN SMALL LETTER S), return true.
    #   6. Return false.
    return regexp_flag_checker(this_value, "RegExp.prototype.dotAll", "s")


RegExpPrototype_getDotAll.length = 0
RegExpPrototype_getDotAll.name = "get dotAll"

# 21.2.5.4 get RegExp.prototype.flags
def RegExpPrototype_getFlags(this_value, new_target, *_):
    # RegExp.prototype.flags is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. Let result be the empty String.
    #   4. Let global be ToBoolean(? Get(R, "global")).
    #   5. If global is true, append the code unit 0x0067 (LATIN SMALL LETTER G) as the last code unit of result.
    #   6. Let ignoreCase be ToBoolean(? Get(R, "ignoreCase")).
    #   7. If ignoreCase is true, append the code unit 0x0069 (LATIN SMALL LETTER I) as the last code unit of result.
    #   8. Let multiline be ToBoolean(? Get(R, "multiline")).
    #   9. If multiline is true, append the code unit 0x006D (LATIN SMALL LETTER M) as the last code unit of result.
    #   10. Let dotAll be ToBoolean(? Get(R, "dotAll")).
    #   11. If dotAll is true, append the code unit 0x0073 (LATIN SMALL LETTER S) as the last code unit of result.
    #   12. Let unicode be ToBoolean(? Get(R, "unicode")).
    #   13. If unicode is true, append the code unit 0x0075 (LATIN SMALL LETTER U) as the last code unit of result.
    #   14. Let sticky be ToBoolean(? Get(R, "sticky")).
    #   15. If sticky is true, append the code unit 0x0079 (LATIN SMALL LETTER Y) as the last code unit of result.
    #   16. Return result.
    if not isObject(this_value):
        raise ESTypeError(f"RegExp.prototype.flags called with invalid receiver {ToString(this_value)}")
    return "".join(
        ch
        for key, ch in (
            ("global", "g"),
            ("ignoreCase", "i"),
            ("multiline", "m"),
            ("dotAll", "s"),
            ("unicode", "u"),
            ("sticky", "y"),
        )
        if ToBoolean(Get(this_value, key))
    )


RegExpPrototype_getFlags.length = 0
RegExpPrototype_getFlags.name = "get flags"

# 21.2.5.5 get RegExp.prototype.global
def RegExpPrototype_getGlobal(this_value, new_target, *_):
    # RegExp.prototype.global is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have an [[OriginalFlags]] internal slot, then
    #       a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    #       b. Otherwise, throw a TypeError exception.
    #   4. Let flags be R.[[OriginalFlags]].
    #   5. If flags contains the code unit 0x0067 (LATIN SMALL LETTER G), return true.
    #   6. Return false.
    return regexp_flag_checker(this_value, "RegExp.prototype.global", "g")


RegExpPrototype_getGlobal.length = 0
RegExpPrototype_getGlobal.name = "get global"

# 21.2.5.6 get RegExp.prototype.ignoreCase
def RegExpPrototype_getIgnoreCase(this_value, new_target, *_):
    # RegExp.prototype.ignoreCase is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have an [[OriginalFlags]] internal slot, then
    #       a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    #       b. Otherwise, throw a TypeError exception.
    #   4. Let flags be R.[[OriginalFlags]].
    #   5. If flags contains the code unit 0x0069 (LATIN SMALL LETTER I), return true.
    #   6. Return false.
    return regexp_flag_checker(this_value, "RegExp.prototype.ignoreCase", "i")


RegExpPrototype_getIgnoreCase.length = 0
RegExpPrototype_getIgnoreCase.name = "get ignoreCase"

# 21.2.5.7 RegExp.prototype [ @@match ] ( string )
def RegExpPrototype_match(this_value, new_target, string=None, *_):
    # When the @@match method is called with argument string, the following steps are taken:
    #   1. Let rx be the this value.
    #   2. If Type(rx) is not Object, throw a TypeError exception.
    #   3. Let S be ? ToString(string).
    #   4. Let global be ToBoolean(? Get(rx, "global")).
    #   5. If global is false, then
    #       a. Return ? RegExpExec(rx, S).
    #   6. Else global is true,
    #       a. Let fullUnicode be ToBoolean(? Get(rx, "unicode")).
    #       b. Perform ? Set(rx, "lastIndex", 0, true).
    #       c. Let A be ! ArrayCreate(0).
    #       d. Let n be 0.
    #       e. Repeat,
    #           i. Let result be ? RegExpExec(rx, S).
    #           ii. If result is null, then
    #               1. If n = 0, return null.
    #               2. Return A.
    #           iii. Else result is not null,
    #               1. Let matchStr be ? ToString(? Get(result, "0")).
    #               2. Let status be CreateDataProperty(A, ! ToString(n), matchStr).
    #               3. Assert: status is true.
    #               4. If matchStr is the empty String, then
    #                   a. Let thisIndex be ? ToLength(? Get(rx, "lastIndex")).
    #                   b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).
    #                   c. Perform ? Set(rx, "lastIndex", nextIndex, true).
    #               5. Increment n.
    if not isObject(this_value):
        raise ESTypeError(f"RegExp.prototype.@@match called with invalid receiver {ToString(this_value)}")
    S = ToString(string)
    if not ToBoolean(Get(this_value, "global")):
        return RegExpExec(this_value, S)
    fullUnicode = ToBoolean(Get(this_value, "unicode"))
    Set(this_value, "lastIndex", 0, True)
    A = ArrayCreate(0)
    n = 0
    while 1:
        result = RegExpExec(this_value, S)
        if isNull(result):
            return A if n != 0 else JSNull.NULL
        matchStr = ToString(Get(result, "0"))
        status = CreateDataProperty(A, ToString(n), matchStr)
        assert status
        if matchStr == "":
            thisIndex = ToLength(Get(this_value, "lastIndex"))
            nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode)
            Set(this_value, "lastIndex", nextIndex, True)
        n += 1


# The value of the name property of this function is "[Symbol.match]".
RegExpPrototype_match.length = 1
RegExpPrototype_match.name = "[Symbol.match]"
# NOTE  | The @@match property is used by the IsRegExp abstract operation to identify objects that have the basic
#       | behaviour of regular expressions. The absence of a @@match property or the existence of such a property
#       | whose value does not Boolean coerce to true indicates that the object is not intended to be used as a
#       | regular expression object.

# 21.2.5.8 get RegExp.prototype.multiline
def RegExpPrototype_getMultiline(this_value, new_target, *_):
    # RegExp.prototype.multiline is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have an [[OriginalFlags]] internal slot, then
    #       a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    #       b. Otherwise, throw a TypeError exception.
    #   4. Let flags be R.[[OriginalFlags]].
    #   5. If flags contains the code unit 0x006D (LATIN SMALL LETTER M), return true.
    #   6. Return false.
    return regexp_flag_checker(this_value, "RegExp.prototype.multiline", "m")


RegExpPrototype_getMultiline.length = 0
RegExpPrototype_getMultiline.name = "get multiline"

# 21.2.5.9 RegExp.prototype [ @@replace ] ( string, replaceValue )
def RegExpPrototype_replace(this_value, new_target, string=None, replaceValue=None, *_):
    # When the @@replace method is called with arguments string and replaceValue, the following steps are taken:
    #   1. Let rx be the this value.
    #   2. If Type(rx) is not Object, throw a TypeError exception.
    #   3. Let S be ? ToString(string).
    #   4. Let lengthS be the number of code unit elements in S.
    #   5. Let functionalReplace be IsCallable(replaceValue).
    #   6. If functionalReplace is false, then
    #   a. Set replaceValue to ? ToString(replaceValue).
    #   7. Let global be ToBoolean(? Get(rx, "global")).
    #   8. If global is true, then
    #       a. Let fullUnicode be ToBoolean(? Get(rx, "unicode")).
    #       b. Perform ? Set(rx, "lastIndex", 0, true).
    #   9. Let results be a new empty List.
    #   10. Let done be false.
    #   11. Repeat, while done is false
    #       a. Let result be ? RegExpExec(rx, S).
    #       b. If result is null, set done to true.
    #       c. Else result is not null,
    #           i. Append result to the end of results.
    #           ii. If global is false, set done to true.
    #           iii. Else,
    #               1. Let matchStr be ? ToString(? Get(result, "0")).
    #               2. If matchStr is the empty String, then
    #                   a. Let thisIndex be ? ToLength(? Get(rx, "lastIndex")).
    #                   b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).
    #                   c. Perform ? Set(rx, "lastIndex", nextIndex, true).
    #   12. Let accumulatedResult be the empty String value.
    #   13. Let nextSourcePosition be 0.
    #   14. For each result in results, do
    #       a. Let nCaptures be ? ToLength(? Get(result, "length")).
    #       b. Set nCaptures to max(nCaptures - 1, 0).
    #       c. Let matched be ? ToString(? Get(result, "0")).
    #       d. Let matchLength be the number of code units in matched.
    #       e. Let position be ? ToInteger(? Get(result, "index")).
    #       f. Set position to max(min(position, lengthS), 0).
    #       g. Let n be 1.
    #       h. Let captures be a new empty List.
    #       i. Repeat, while n ≤ nCaptures
    #           i. Let capN be ? Get(result, ! ToString(n)).
    #           ii. If capN is not undefined, then
    #               1. Set capN to ? ToString(capN).
    #           iii. Append capN as the last element of captures.
    #           iv. Increase n by 1.
    #       j. Let namedCaptures be ? Get(result, "groups").
    #       k. If functionalReplace is true, then
    #           i. Let replacerArgs be « matched ».
    #           ii. Append in list order the elements of captures to the end of the List replacerArgs.
    #           iii. Append position and S to replacerArgs.
    #           iv. If namedCaptures is not undefined, then
    #               1. Append namedCaptures as the last element of replacerArgs.
    #           v. Let replValue be ? Call(replaceValue, undefined, replacerArgs).
    #           vi. Let replacement be ? ToString(replValue).
    #       l. Else,
    #           i. Let replacement be GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue).
    #       m. If position ≥ nextSourcePosition, then
    #           i. NOTE: position should not normally move backwards. If it does, it is an indication of an ill-behaving
    #              RegExp subclass or use of an access triggered side-effect to change the global flag or other
    #              characteristics of rx. In such cases, the corresponding substitution is ignored.
    #           ii. Set accumulatedResult to the string-concatenation of the current value of accumulatedResult, the
    #               substring of S consisting of the code units from nextSourcePosition (inclusive) up to position
    #               (exclusive), and replacement.
    #           iii. Set nextSourcePosition to position + matchLength.
    #   15. If nextSourcePosition ≥ lengthS, return accumulatedResult.
    #   16. Return the string-concatenation of accumulatedResult and the substring of S consisting of the code units
    #       from nextSourcePosition (inclusive) up through the final code unit of S (inclusive).
    if not isObject(this_value):
        raise ESTypeError(f"RegExp.prototype.@@replace called with invalid receiver {ToString(this_value)}")
    S = ToString(string)
    lengthS = len(S)
    functionalReplace = IsCallable(replaceValue)
    if not functionalReplace:
        replaceValue = ToString(replaceValue)
    global_ = ToBoolean(Get(this_value, "global"))
    if global_:
        fullUnicode = ToBoolean(Get(this_value, "unicode"))
        Set(this_value, "lastIndex", 0, True)
    results = []
    done = False
    while not done:
        result = RegExpExec(this_value, S)
        if isNull(result):
            done = True
        else:
            results.append(result)
            if not global_:
                done = True
            else:
                matchStr = ToString(Get(result, "0"))
                if matchStr == "":
                    thisIndex = ToLength(Get(this_value, "lastIndex"))
                    nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode)
                    Set(this_value, "lastIndex", nextIndex, True)
    accumulatedResult = ""
    nextSourcePosition = 0
    for result in results:
        nCaptures = ToLength(Get(result, "length"))
        nCaptures = max(nCaptures - 1, 0)
        matched = ToString(Get(result, "0"))
        matchLength = len(matched)
        position = ToInteger(Get(result, "index"))
        position = max(min(position, lengthS), 0)
        n = 1
        captures = []
        while n <= nCaptures:
            capN = Get(result, ToString(n))
            if capN is not None:
                capN = ToString(capN)
            captures.append(capN)
            n += 1
        namedCaptures = Get(result, "groups")
        if functionalReplace:
            replacerArgs = [matched]
            replacerArgs.extend(captures)
            replacerArgs.append(position)
            replacerArgs.append(S)
            if namedCaptures is not None:
                replacerArgs.append(namedCaptures)
            replValue = Call(replaceValue, None, replacerArgs)
            replacement = ToString(replValue)
        else:
            replacement = GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue)
        if position >= nextSourcePosition:
            accumulatedResult = f"{accumulatedResult}{S[nextSourcePosition:position]}{replacement}"
            nextSourcePosition = position + matchLength
    if nextSourcePosition >= lengthS:
        return accumulatedResult
    return f"{accumulatedResult}{S[nextSourcePosition:]}"
    # The value of the name property of this function is "[Symbol.replace]".


RegExpPrototype_replace.length = 2
RegExpPrototype_replace.name = "[Symbol.replace]"

# 21.2.5.10 RegExp.prototype [ @@search ] ( string )
def RegExpPrototype_search(this_value, new_target, string=None, *_):
    # When the @@search method is called with argument string, the following steps are taken:
    #
    #   1. Let rx be the this value.
    #   2. If Type(rx) is not Object, throw a TypeError exception.
    #   3. Let S be ? ToString(string).
    #   4. Let previousLastIndex be ? Get(rx, "lastIndex").
    #   5. If SameValue(previousLastIndex, 0) is false, then
    #       a. Perform ? Set(rx, "lastIndex", 0, true).
    #   6. Let result be ? RegExpExec(rx, S).
    #   7. Let currentLastIndex be ? Get(rx, "lastIndex").
    #   8. If SameValue(currentLastIndex, previousLastIndex) is false, then
    #       a. Perform ? Set(rx, "lastIndex", previousLastIndex, true).
    #   9. If result is null, return -1.
    #   10. Return ? Get(result, "index").
    #
    # NOTE  | The lastIndex and global properties of this RegExp object are ignored when performing the search. The
    #       | lastIndex property is left unchanged.
    if not isObject(this_value):
        raise ESTypeError(f"RegExp.prototype.@@search called with invalid receiver {ToString(this_value)}")
    S = ToString(string)
    previousLastIndex = Get(this_value, "lastIndex")
    if not SameValue(previousLastIndex, 0):
        Set(this_value, "lastIndex", 0, True)
    result = RegExpExec(this_value, S)
    currentLastIndex = Get(this_value, "lastIndex")
    if not SameValue(currentLastIndex, previousLastIndex):
        Set(this_value, "lastIndex", previousLastIndex, True)
    if isNull(result):
        return -1
    return Get(result, "index")


# The value of the name property of this function is "[Symbol.search]".
RegExpPrototype_search.length = 1
RegExpPrototype_search.name = "[Symbol.search]"

# 21.2.5.11 get RegExp.prototype.source
def RegExpPrototype_getSource(this_value, new_target, *_):
    # RegExp.prototype.source is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have an [[OriginalSource]] internal slot, then
    #       a. If SameValue(R, %RegExpPrototype%) is true, return "(?:)".
    #       b. Otherwise, throw a TypeError exception.
    #   4. Assert: R has an [[OriginalFlags]] internal slot.
    #   5. Let src be R.[[OriginalSource]].
    #   6. Let flags be R.[[OriginalFlags]].
    #   7. Return EscapeRegExpPattern(src, flags).
    if not regexp_object_validator(this_value, "RegExp.source"):
        return "(?:)"
    return EscapeRegExpPattern(this_value.OriginalSource, this_value.OriginalFlags)


RegExpPrototype_getSource.length = 0
RegExpPrototype_getSource.name = "get source"

# 21.2.5.12 RegExp.prototype [ @@split ] ( string, limit )
def RegExpPrototype_split(this_value, new_target, string=None, limit=None, *_):
    # NOTE 1    | Returns an Array object into which substrings of the result of converting string to a String have
    #           | been stored. The substrings are determined by searching from left to right for matches of the this
    #           | value regular expression; these occurrences are not part of any substring in the returned array, but
    #           | serve to divide up the String value.
    #           |
    #           | The this value may be an empty regular expression or a regular expression that can match an empty
    #           | String. In this case, the regular expression does not match the empty substring at the beginning or
    #           | end of the input String, nor does it match the empty substring at the end of the previous separator
    #           | match. (For example, if the regular expression matches the empty String, the String is split up into
    #           | individual code unit elements; the length of the result array equals the length of the String, and
    #           | each substring contains one code unit.) Only the first match at a given index of the String is
    #           | considered, even if backtracking could yield a non-empty-substring match at that index. (For example,
    #           | /a*?/[Symbol.split]("ab") evaluates to the array ["a", "b"], while /a*/[Symbol.split]("ab") evaluates
    #           | to the array ["","b"].)
    #           |
    #           | If the string is (or converts to) the empty String, the result depends on whether the regular
    #           | expression can match the empty String. If it can, the result array contains no elements. Otherwise,
    #           | the result array contains one element, which is the empty String.
    #           |
    #           | If the regular expression contains capturing parentheses, then each time separator is matched the
    #           | results (including any undefined results) of the capturing parentheses are spliced into the output
    #           | array. For example,
    #           |
    #           |   /<(\/)?([^<>]+)>/[Symbol.split]("A<B>bold</B>and<CODE>coded</CODE>")
    #           |
    #           | evaluates to the array
    #           |
    #           |   ["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]
    #           |
    #           | If limit is not undefined, then the output array is truncated so that it contains no more than limit
    #           | elements.
    #
    # When the @@split method is called, the following steps are taken:
    #
    #   1. Let rx be the this value.
    #   2. If Type(rx) is not Object, throw a TypeError exception.
    #   3. Let S be ? ToString(string).
    #   4. Let C be ? SpeciesConstructor(rx, %RegExp%).
    #   5. Let flags be ? ToString(? Get(rx, "flags")).
    #   6. If flags contains "u", let unicodeMatching be true.
    #   7. Else, let unicodeMatching be false.
    #   8. If flags contains "y", let newFlags be flags.
    #   9. Else, let newFlags be the string-concatenation of flags and "y".
    #   10. Let splitter be ? Construct(C, « rx, newFlags »).
    #   11. Let A be ! ArrayCreate(0).
    #   12. Let lengthA be 0.
    #   13. If limit is undefined, let lim be 2^32 - 1; else let lim be ? ToUint32(limit).
    #   14. Let size be the length of S.
    #   15. Let p be 0.
    #   16. If lim = 0, return A.
    #   17. If size = 0, then
    #       a. Let z be ? RegExpExec(splitter, S).
    #       b. If z is not null, return A.
    #       c. Perform ! CreateDataProperty(A, "0", S).
    #       d. Return A.
    #   18. Let q be p.
    #   19. Repeat, while q < size
    #       a. Perform ? Set(splitter, "lastIndex", q, true).
    #       b. Let z be ? RegExpExec(splitter, S).
    #       c. If z is null, set q to AdvanceStringIndex(S, q, unicodeMatching).
    #       d. Else z is not null,
    #           i. Let e be ? ToLength(? Get(splitter, "lastIndex")).
    #           ii. Set e to min(e, size).
    #           iii. If e = p, set q to AdvanceStringIndex(S, q, unicodeMatching).
    #           iv. Else e ≠ p,
    #               1. Let T be the String value equal to the substring of S consisting of the code units at indices p
    #                  (inclusive) through q (exclusive).
    #               2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
    #               3. Increase lengthA by 1.
    #               4. If lengthA = lim, return A.
    #               5. Set p to e.
    #               6. Let numberOfCaptures be ? ToLength(? Get(z, "length")).
    #               7. Set numberOfCaptures to max(numberOfCaptures - 1, 0).
    #               8. Let i be 1.
    #               9. Repeat, while i ≤ numberOfCaptures,
    #                   a. Let nextCapture be ? Get(z, ! ToString(i)).
    #                   b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
    #                   c. Increase i by 1.
    #                   d. Increase lengthA by 1.
    #                   e. If lengthA = lim, return A.
    #               10. Set q to p.
    #   20. Let T be the String value equal to the substring of S consisting of the code units at indices p (inclusive)
    #       through size (exclusive).
    #   21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
    #   22. Return A.
    #
    # NOTE 2
    # The @@split method ignores the value of the global and sticky properties of this RegExp object.
    if not isObject(this_value):
        raise ESTypeError(f"RegExp.prototype.@@split called with invalid receiver {ToString(this_value)}")
    S = ToString(string)
    C = SpeciesConstructor(this_value, surrounding_agent.running_ec.realm.intrinsics["%RegExp%"])
    flags = ToString(Get(this_value, "flags"))
    unicodeMatching = "u" in flags
    newFlags = flags if "y" in flags else flags + "y"
    splitter = Construct(C, [this_value, newFlags])
    A = ArrayCreate(0)
    lengthA = 0
    if limit is None:
        lim = 2 ** 32 - 1
    else:
        lim = ToUint32(limit)
    if lim == 0:
        return A
    size = len(S)
    if size == 0:
        z = RegExpExec(splitter, S)
        if not isNull(z):
            return A
        CreateDataProperty(A, "0", S)
        return A
    p = 0
    q = 0
    while q < size:
        Set(splitter, "lastIndex", q, True)
        z = RegExpExec(splitter, S)
        if isNull(z):
            q = AdvanceStringIndex(S, q, unicodeMatching)
        else:
            e = ToLength(Get(splitter, "lastIndex"))
            e = min(e, size)
            if e == p:
                q = AdvanceStringIndex(S, q, unicodeMatching)
            else:
                T = S[p:q]
                CreateDataProperty(A, ToString(lengthA), T)
                lengthA += 1
                if lengthA == lim:
                    return A
                p = e
                numberOfCaptures = ToLength(Get(z, "length"))
                numberOfCaptures = max(numberOfCaptures - 1, 0)
                i = 1
                while i <= numberOfCaptures:
                    nextCapture = Get(z, ToString(i))
                    CreateDataProperty(A, ToString(lengthA), nextCapture)
                    i += 1
                    lengthA += 1
                    if lengthA == lim:
                        return A
                q = p
    T = S[p:]
    CreateDataProperty(A, ToString(lengthA), T)
    return A


# The value of the name property of this function is "[Symbol.split]".
RegExpPrototype_split.length = 2
RegExpPrototype_split.name = "[Symbol.split]"

# 21.2.5.13 get RegExp.prototype.sticky
def RegExpPrototype_getSticky(this_value, new_target, *_):
    # RegExp.prototype.sticky is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have an [[OriginalFlags]] internal slot, then
    #       a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    #       b. Otherwise, throw a TypeError exception.
    #   4. Let flags be R.[[OriginalFlags]].
    #   5. If flags contains the code unit 0x0079 (LATIN SMALL LETTER Y), return true.
    #   6. Return false.
    return regexp_flag_checker(this_value, "RegExp.prototype.sticky", "y")


RegExpPrototype_getSticky.length = 0
RegExpPrototype_getSticky.name = "get sticky"

# 21.2.5.14 RegExp.prototype.test ( S )
def RegExpPrototype_test(this_value, new_target, S=None, *_):
    # The following steps are taken:
    #
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. Let string be ? ToString(S).
    #   4. Let match be ? RegExpExec(R, string).
    #   5. If match is not null, return true; else return false.
    if not isObject(this_value):
        raise ESTypeError(f"RegExp.prototype.test called with invalid receiver {ToObject(this_value)}")
    string = ToString(S)
    match = RegExpExec(this_value, string)
    return not isNull(match)


RegExpPrototype_test.length = 1
RegExpPrototype_test.name = "test"

# 21.2.5.15 RegExp.prototype.toString ( )
def RegExpPrototype_toString(this_value, new_target, *_):
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. Let pattern be ? ToString(? Get(R, "source")).
    #   4. Let flags be ? ToString(? Get(R, "flags")).
    #   5. Let result be the string-concatenation of "/", pattern, "/", and flags.
    #   6. Return result.
    # NOTE  | The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object
    #       | with the same behaviour as this object.
    if not isObject(this_value):
        raise ESTypeError(f"RegExp.prototype.toString called with invalid receiver {ToString(this_value)}")
    pattern = ToString(Get(this_value, "source"))
    flags = ToString(Get(this_value, "flags"))
    return f"/{pattern}/{flags}"


RegExpPrototype_toString.length = 0
RegExpPrototype_toString.name = "toString"

# 21.2.5.16 get RegExp.prototype.unicode
def RegExpPrototype_getUnicode(this_value, new_target, *_):
    # RegExp.prototype.unicode is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps:
    #   1. Let R be the this value.
    #   2. If Type(R) is not Object, throw a TypeError exception.
    #   3. If R does not have an [[OriginalFlags]] internal slot, then
    #       a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    #       b. Otherwise, throw a TypeError exception.
    #   4. Let flags be R.[[OriginalFlags]].
    #   5. If flags contains the code unit 0x0075 (LATIN SMALL LETTER U), return true.
    #   6. Return false.
    return regexp_flag_checker(this_value, "RegExp.prototype.unicode", "u")


RegExpPrototype_getUnicode.length = 0
RegExpPrototype_getUnicode.name = "get unicode"

# ------------------------------------ 𝟐𝟐 𝑰𝒏𝒅𝒆𝒙𝒆𝒅 𝑪𝒐𝒍𝒍𝒆𝒄𝒕𝒊𝒐𝒏𝒔 ------------------------------------
# ------------------------------------ 𝟐𝟐.𝟏 𝑨𝒓𝒓𝒂𝒚 𝑶𝒃𝒋𝒆𝒄𝒕𝒔 ------------------------------------
########################################################################################################################################################
#
#  .d8888b.   .d8888b.       d888              d8888                                        .d88888b.  888         d8b                   888
# d88P  Y88b d88P  Y88b     d8888             d88888                                       d88P" "Y88b 888         Y8P                   888
#        888        888       888            d88P888                                       888     888 888                               888
#      .d88P      .d88P       888           d88P 888 888d888 888d888  8888b.  888  888     888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  .od888P"   .od888P"        888          d88P  888 888P"   888P"       "88b 888  888     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# d88P"      d88P"            888         d88P   888 888     888     .d888888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
# 888"       888"       d8b   888        d8888888888 888     888     888  888 Y88b 888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888888888  888888888  Y8P 8888888     d88P     888 888     888     "Y888888  "Y88888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                  888                             888
#                                                                             Y8b d88P                            d88P
#                                                                              "Y88P"                           888P"
#
########################################################################################################################################################
# Array objects are exotic objects that give special treatment to a certain class of property names. See 9.4.2 for a
# definition of this special treatment.
# ------------------------------------ 𝟐𝟐.𝟏.𝟏 𝑻𝒉𝒆 𝑨𝒓𝒓𝒂𝒚 𝑪𝒐𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒐𝒓 ------------------------------------
# 22.1.1 The Array Constructor
# The Array constructor:
#
#   * is the intrinsic object %Array%.
#   * is the initial value of the Array property of the global object.
#   * creates and initializes a new Array exotic object when called as a constructor.
#   * also creates and initializes a new Array object when called as a function rather than as a constructor. Thus the
#     function call Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.
#   * is a single function whose behaviour is overloaded based upon the number and types of its arguments.
#   * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#     constructors that intend to inherit the exotic Array behaviour must include a super call to the Array constructor
#     to initialize subclass instances that are Array exotic objects. However, most of the Array.prototype methods are
#     generic methods that are not dependent upon their this value being an Array exotic object.
#   * has a length property whose value is 1.
#
def CreateArrayConstructor(realm):
    obj = CreateBuiltinFunction(ArrayFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "Array")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    BindBuiltinFunctions(
        realm, obj, [("from", Array_from, None), ("isArray", Array_isArray, None), ("of", Array_of, None),],
    )

    def get_species(this_value, new_target, *_):
        return this_value

    get_species.length = 0
    get_species.name = "get [Symbol.species]"

    fcn_obj = CreateAnnotatedFunctionObject(realm, get_species, [])
    DefinePropertyOrThrow(obj, wks_species, PropertyDescriptor(Get=fcn_obj, enumerable=False, configurable=True))

    return obj


# ------------------------------------ 𝟐𝟐.𝟏.𝟏.𝟏 𝑨𝒓𝒓𝒂𝒚 ( ) ------------------------------------
# 22.1.1.1 Array ( )
def ArrayFunction_no_args(this_value, new_target):
    # This description applies if and only if the Array constructor is called with no arguments.
    #
    #   1. Let numberOfArgs be the number of arguments passed to this function call.
    #   2. Assert: numberOfArgs = 0.
    #   3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
    #   4. Let proto be ? GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%").
    #   5. Return ! ArrayCreate(0, proto).
    newTarget = new_target or GetActiveFunction()
    proto = GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%")
    return ArrayCreate(0, proto)


# ------------------------------------ 𝟐𝟐.𝟏.𝟏.𝟐 𝑨𝒓𝒓𝒂𝒚 ( 𝒍𝒆𝒏 ) ------------------------------------
# 22.1.1.2 Array ( len )
def ArrayFunction_one_arg(this_value, new_target, length):
    # This description applies if and only if the Array constructor is called with exactly one argument.
    #
    #   1. Let numberOfArgs be the number of arguments passed to this function call.
    #   2. Assert: numberOfArgs = 1.
    #   3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
    #   4. Let proto be ? GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%").
    #   5. Let array be ! ArrayCreate(0, proto).
    #   6. If Type(len) is not Number, then
    #       a. Let defineStatus be CreateDataProperty(array, "0", len).
    #       b. Assert: defineStatus is true.
    #       c. Let intLen be 1.
    #   7. Else,
    #       a. Let intLen be ToUint32(len).
    #       b. If intLen ≠ len, throw a RangeError exception.
    #   8. Perform ! Set(array, "length", intLen, true).
    #   9. Return array.
    newTarget = new_target or GetActiveFunction()
    proto = GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%")
    array = ArrayCreate(0, proto)
    if not isNumber(length):
        defineStatus = CreateDataProperty(array, "0", length)
        assert defineStatus
        intLen = 1
    else:
        intLen = ToUint32(length)
        if intLen != length:
            raise ESRangeError(f"Invalid array length: {length}")
    Set(array, "length", intLen, True)
    return array


# ------------------------------------ 𝟐𝟐.𝟏.𝟏.𝟑 𝑨𝒓𝒓𝒂𝒚 ( ...𝒊𝒕𝒆𝒎𝒔 ) ------------------------------------
# 22.1.1.3 Array ( ...items )
def ArrayFunction(this_value, new_target, *items):
    # This description applies if and only if the Array constructor is called with at least two arguments.
    #
    # When the Array function is called, the following steps are taken:
    #
    #   1. Let numberOfArgs be the number of arguments passed to this function call.
    #   2. Assert: numberOfArgs ≥ 2.
    #   3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
    #   4. Let proto be ? GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%").
    #   5. Let array be ? ArrayCreate(numberOfArgs, proto).
    #   6. Let k be 0.
    #   7. Let items be a zero-origined List containing the argument items in order.
    #   8. Repeat, while k < numberOfArgs
    #       a. Let Pk be ! ToString(k).
    #       b. Let itemK be items[k].
    #       c. Let defineStatus be CreateDataProperty(array, Pk, itemK).
    #       d. Assert: defineStatus is true.
    #       e. Increase k by 1.
    #   9. Assert: The value of array's length property is numberOfArgs.
    #   10. Return array.
    numberOfArgs = len(items)
    if numberOfArgs == 0:
        return ArrayFunction_no_args(this_value, new_target)
    if numberOfArgs == 1:
        return ArrayFunction_one_arg(this_value, new_target, items[0])
    newTarget = new_target or GetActiveFunction()
    proto = GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%")
    array = ArrayCreate(numberOfArgs, proto)
    for k, itemK in enumerate(items):
        Pk = ToString(k)
        defineStatus = CreateDataProperty(array, Pk, itemK)
        assert defineStatus
    assert Get(array, "length") == numberOfArgs
    return array


# 22.1.2 Properties of the Array Constructor
# The Array constructor:
#
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.
#   * has the following properties:

# ------------------------------------ 𝟐𝟐.𝟏.𝟐.𝟏 𝑨𝒓𝒓𝒂𝒚.𝒇𝒓𝒐𝒎 ( 𝒊𝒕𝒆𝒎𝒔 [ , 𝒎𝒂𝒑𝒇𝒏 [ , 𝒕𝒉𝒊𝒔𝑨𝒓𝒈 ] ] ) ------------------------------------
# 22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] )
def Array_from(this_value, new_target, items=None, mapfn=None, thisArg=None, *_):
    # When the from method is called with argument items and optional arguments mapfn and thisArg, the following steps
    # are taken:
    #
    #   1. Let C be the this value.
    #   2. If mapfn is undefined, let mapping be false.
    #   3. Else,
    #       a. If IsCallable(mapfn) is false, throw a TypeError exception.
    #       b. If thisArg is present, let T be thisArg; else let T be undefined.
    #       c. Let mapping be true.
    #   4. Let usingIterator be ? GetMethod(items, @@iterator).
    #   5. If usingIterator is not undefined, then
    #       a. If IsConstructor(C) is true, then
    #           i. Let A be ? Construct(C).
    #       b. Else,
    #           i. Let A be ! ArrayCreate(0).
    #       c. Let iteratorRecord be ? GetIterator(items, sync, usingIterator).
    #       d. Let k be 0.
    #       e. Repeat,
    #           i. If k ≥ 2^53-1, then
    #               1. Let error be ThrowCompletion(a newly created TypeError object).
    #               2. Return ? IteratorClose(iteratorRecord, error).
    #           ii. Let Pk be ! ToString(k).
    #           iii. Let next be ? IteratorStep(iteratorRecord).
    #           iv. If next is false, then
    #               1. Perform ? Set(A, "length", k, true).
    #               2. Return A.
    #           v. Let nextValue be ? IteratorValue(next).
    #           vi. If mapping is true, then
    #               1. Let mappedValue be Call(mapfn, T, « nextValue, k »).
    #               2. If mappedValue is an abrupt completion, return ? IteratorClose(iteratorRecord, mappedValue).
    #               3. Let mappedValue be mappedValue.[[Value]].
    #           vii. Else, let mappedValue be nextValue.
    #           viii. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).
    #           ix. If defineStatus is an abrupt completion, return ? IteratorClose(iteratorRecord, defineStatus).
    #           x. Increase k by 1.
    #   6. NOTE: items is not an Iterable so assume it is an array-like object.
    #   7. Let arrayLike be ! ToObject(items).
    #   8. Let len be ? ToLength(? Get(arrayLike, "length")).
    #   9. If IsConstructor(C) is true, then
    #       a. Let A be ? Construct(C, « len »).
    #   10. Else,
    #       a. Let A be ? ArrayCreate(len).
    #   11. Let k be 0.
    #   12. Repeat, while k < len
    #       a. Let Pk be ! ToString(k).
    #       b. Let kValue be ? Get(arrayLike, Pk).
    #       c. If mapping is true, then
    #           i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).
    #       d. Else, let mappedValue be kValue.
    #       e. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).
    #       f. Increase k by 1.
    #   13. Perform ? Set(A, "length", len, true).
    #   14. Return A.
    # NOTE
    # The from function is an intentionally generic factory method; it does not require that its this value be the
    # Array constructor. Therefore it can be transferred to or inherited by any other constructors that may be called
    # with a single numeric argument.
    raise NotImplementedError  # This wants iterators. @@@ I'm not there yet.


Array_from.length = 1
Array_from.name = "from"

# 22.1.2.2 Array.isArray ( arg )
def Array_isArray(this_value, new_target, arg=None, *_):
    # The isArray function takes one argument arg, and performs the following steps:
    #   1. Return ? IsArray(arg).
    return IsArray(arg)


Array_isArray.length = 1
Array_isArray.name = "isArray"

# 22.1.2.3 Array.of ( ...items )
def Array_of(this_value, new_target, *items):
    # When the of method is called with any number of arguments, the following steps are taken:
    #   1. Let len be the actual number of arguments passed to this function.
    #   2. Let items be the List of arguments passed to this function.
    #   3. Let C be the this value.
    #   4. If IsConstructor(C) is true, then
    #       a. Let A be ? Construct(C, « len »).
    #   5. Else,
    #       a. Let A be ? ArrayCreate(len).
    #   6. Let k be 0.
    #   7. Repeat, while k < len
    #       a. Let kValue be items[k].
    #       b. Let Pk be ! ToString(k).
    #       c. Perform ? CreateDataPropertyOrThrow(A, Pk, kValue).
    #       d. Increase k by 1.
    #   8. Perform ? Set(A, "length", len, true).
    #   9. Return A.
    # NOTE 1    | The items argument is assumed to be a well-formed rest argument value.
    # NOTE 2    | The of function is an intentionally generic factory method; it does not require that its this
    #           | value be the Array constructor. Therefore it can be transferred to or inherited by other
    #           | constructors that may be called with a single numeric argument.
    if IsConstructor(this_value):
        A = Construct(this_value, [len(items)])
    else:
        A = ArrayCreate(len(items))
    for k, kValue in enumerate(items):
        Pk = ToString(k)
        CreateDataPropertyOrThrow(A, Pk, kValue)
    Set(A, "length", len(items), True)
    return A


Array_of.length = 0
Array_of.name = "of"


# 22.1.3 Properties of the Array Prototype Object
# The Array prototype object:
#
#   * is the intrinsic object %ArrayPrototype%.
#   * is an Array exotic object and has the internal methods specified for such objects.
#   * has a length property whose initial value is 0 and whose attributes are
#     { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
# NOTE
# The Array prototype object is specified to be an Array exotic object to ensure compatibility with ECMAScript code
# that was created prior to the ECMAScript 2015 specification.


def CreateArrayPrototype(realm):
    proto = ArrayCreate(0, realm.intrinsics["%ObjectPrototype%"])
    BindBuiltinFunctions(
        realm,
        proto,
        [
            ("forEach", ArrayPrototype_forEach, None),
            ("join", ArrayPrototype_join, None),
            ("map", ArrayPrototype_map, None),
            ("push", ArrayPrototype_push, None),
            ("slice", ArrayPrototype_slice, None),
            ("toString", ArrayPrototype_toString, 0),
            ("values", ArrayPrototype_values, 0),
        ],
    )
    DefinePropertyOrThrow(
        proto,
        wks_iterator,
        PropertyDescriptor(value=Get(proto, "values"), writable=True, enumerable=False, configurable=True),
    )
    return proto


# 22.1.3.12 Array.prototype.forEach ( callbackfn [ , thisArg ] )
def ArrayPrototype_forEach(this_value, new_target, callbackfn=None, thisArg=None, *_):
    # NOTE 1    | callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each
    #           | element present in the array, in ascending order. callbackfn is called only for elements of the array
    #           | which actually exist; it is not called for missing elements of the array.
    #           |
    #           | If a thisArg parameter is provided, it will be used as the this value for each invocation of
    #           | callbackfn. If it is not provided, undefined is used instead.
    #           |
    #           | callbackfn is called with three arguments: the value of the element, the index of the element, and
    #           | the object being traversed.
    #           |
    #           | forEach does not directly mutate the object on which it is called but the object may be mutated by
    #           | the calls to callbackfn.
    #
    # When the forEach method is called with one or two arguments, the following steps are taken:
    #   1. Let O be ? ToObject(this value).
    #   2. Let len be ? ToLength(? Get(O, "length")).
    #   3. If IsCallable(callbackfn) is false, throw a TypeError exception.
    #   4. If thisArg is present, let T be thisArg; else let T be undefined.
    #   5. Let k be 0.
    #   6. Repeat, while k < len
    #       a. Let Pk be ! ToString(k).
    #       b. Let kPresent be ? HasProperty(O, Pk).
    #       c. If kPresent is true, then
    #           i. Let kValue be ? Get(O, Pk).
    #           ii. Perform ? Call(callbackfn, T, « kValue, k, O »).
    #       d. Increase k by 1.
    #   7. Return undefined.
    # This function is the %ArrayProto_forEach% intrinsic object.
    #
    # NOTE 2    | The forEach function is intentionally generic; it does not require that its this value be an Array
    #           | object. Therefore it can be transferred to other kinds of objects for use as a method.
    O = ToObject(this_value)
    length = ToLength(Get(O, "length"))
    if not IsCallable(callbackfn):
        raise ESTypeError("Array.prototype.forEach called with invalid receiver")
    for k in range(length):
        Pk = ToString(k)
        if HasProperty(O, Pk):
            Call(callbackfn, thisArg, [Get(O, Pk), k, O])
    return None


ArrayPrototype_forEach.length = 1
ArrayPrototype_forEach.name = "forEach"

# 22.1.3.15 Array.prototype.join ( separator )
def ArrayPrototype_join(this_value, new_target, separator=",", *_):
    # NOTE 1
    # The elements of the array are converted to Strings, and these Strings are then concatenated, separated by
    # occurrences of the separator. If no separator is provided, a single comma is used as the separator.
    #
    # The join method takes one argument, separator, and performs the following steps:
    #
    #   1. Let O be ? ToObject(this value).
    #   2. Let len be ? ToLength(? Get(O, "length")).
    #   3. If separator is undefined, let sep be the single-element String ",".
    #   4. Else, let sep be ? ToString(separator).
    #   5. Let R be the empty String.
    #   6. Let k be 0.
    #   7. Repeat, while k < len
    #       a. If k > 0, let R be the string-concatenation of R and sep.
    #       b. Let element be ? Get(O, ! ToString(k)).
    #       c. If element is undefined or null, let next be the empty String; otherwise, let next be
    #          ? ToString(element).
    #       d. Set R to the string-concatenation of R and next.
    #       e. Increase k by 1.
    #   8. Return R.
    # NOTE 2
    # The join function is intentionally generic; it does not require that its this value be an Array object.
    # Therefore, it can be transferred to other kinds of objects for use as a method.
    O = ToObject(this_value)
    length = ToLength(Get(O, "length"))
    sep = ToString(separator)
    return sep.join(
        ToString(element) if not (isUndefined(element) or isNull(element)) else ""
        for element in (Get(O, ToString(k)) for k in range(length))
    )


ArrayPrototype_join.length = 1
ArrayPrototype_join.name = "join"

# 22.1.3.18 Array.prototype.map ( callbackfn [ , thisArg ] )
def ArrayPrototype_map(this_value, new_target, callbackfn=None, T=None, *_):
    # NOTE 1    | callbackfn should be a function that accepts three arguments. map calls callbackfn once for each
    #           | element in the array, in ascending order, and constructs a new Array from the results. callbackfn
    #           | is called only for elements of the array which actually exist; it is not called for missing
    #           | elements of the array.
    #           |
    #           | If a thisArg parameter is provided, it will be used as the this value for each invocation of
    #           | callbackfn. If it is not provided, undefined is used instead.
    #           |
    #           | callbackfn is called with three arguments: the value of the element, the index of the element, and
    #           | the object being traversed.
    #           |
    #           | map does not directly mutate the object on which it is called but the object may be mutated by the
    #           | calls to callbackfn.
    #           |
    #           | The range of elements processed by map is set before the first call to callbackfn. Elements which
    #           | are appended to the array after the call to map begins will not be visited by callbackfn. If
    #           | existing elements of the array are changed, their value as passed to callbackfn will be the value
    #           | at the time map visits them; elements that are deleted after the call to map begins and before
    #           | being visited are not visited.
    #
    # When the map method is called with one or two arguments, the following steps are taken:
    #   1. Let O be ? ToObject(this value).
    #   2. Let len be ? ToLength(? Get(O, "length")).
    #   3. If IsCallable(callbackfn) is false, throw a TypeError exception.
    #   4. If thisArg is present, let T be thisArg; else let T be undefined.
    #   5. Let A be ? ArraySpeciesCreate(O, len).
    #   6. Let k be 0.
    #   7. Repeat, while k < len
    #       a. Let Pk be ! ToString(k).
    #       b. Let kPresent be ? HasProperty(O, Pk).
    #       c. If kPresent is true, then
    #           i. Let kValue be ? Get(O, Pk).
    #           ii. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).
    #           iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).
    #       d. Increase k by 1.
    #   8. Return A.
    # NOTE 2    | The map function is intentionally generic; it does not require that its this value be an Array
    #           | object. Therefore it can be transferred to other kinds of objects for use as a method.
    O = ToObject(this_value)
    length = ToLength(Get(O, "length"))
    if not IsCallable(callbackfn):
        raise ESTypeError("In Array.prototype.map, callback must be a function")
    A = ArraySpeciesCreate(O, length)
    for k in range(length):
        Pk = ToString(k)
        if HasProperty(O, Pk):
            mappedValue = Call(callbackfn, T, [Get(O, Pk), k, O])
            CreateDataPropertyOrThrow(A, Pk, mappedValue)
    return A


ArrayPrototype_map.length = 1
ArrayPrototype_map.name = "map"

# 22.1.3.20 Array.prototype.push ( ...items )
def ArrayPrototype_push(this_value, new_target, *items):
    # NOTE 1    | The arguments are appended to the end of the array, in the order in which they appear. The new length
    #           | of the array is returned as the result of the call.
    #
    # When the push method is called with zero or more arguments, the following steps are taken:
    #   1. Let O be ? ToObject(this value).
    #   2. Let len be ? ToLength(? Get(O, "length")).
    #   3. Let items be a List whose elements are, in left to right order, the arguments that were passed to this
    #      function invocation.
    #   4. Let argCount be the number of elements in items.
    #   5. If len + argCount > 2^53 - 1, throw a TypeError exception.
    #   6. Repeat, while items is not empty
    #       a. Remove the first element from items and let E be the value of the element.
    #       b. Perform ? Set(O, ! ToString(len), E, true).
    #       c. Increase len by 1.
    #   7. Perform ? Set(O, "length", len, true).
    #   8. Return len.
    # The "length" property of the push method is 1.
    # NOTE 2    | The push function is intentionally generic; it does not require that its this value be an Array
    #           | object. Therefore it can be transferred to other kinds of objects for use as a method.
    obj = ToObject(this_value)
    length = ToLength(Get(obj, "length"))
    argCount = len(items)
    if length + argCount > 2 ** 53 - 1:
        raise ESTypeError("Array too large")
    for idx, item in enumerate(items):
        Set(obj, ToString(idx + length), item, True)
    Set(obj, "length", length + argCount, True)
    return length + argCount


ArrayPrototype_push.length = 1
ArrayPrototype_push.name = "push"

# 22.1.3.25 Array.prototype.slice ( start, end )
def ArrayPrototype_slice(this_value, new_target, start=None, end=None, *_):
    # NOTE 1    | The slice method takes two arguments, start and end, and returns an array containing the elements
    #           | of the array from element start up to, but not including, element end (or through the end of the
    #           | array if end is undefined). If start is negative, it is treated as length + start where length is
    #           | the length of the array. If end is negative, it is treated as length + end where length is the
    #           | length of the array.
    #
    # The following steps are taken:
    #   1. Let O be ? ToObject(this value).
    #   2. Let len be ? ToLength(? Get(O, "length")).
    #   3. Let relativeStart be ? ToInteger(start).
    #   4. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).
    #   5. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    #   6. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    #   7. Let count be max(final - k, 0).
    #   8. Let A be ? ArraySpeciesCreate(O, count).
    #   9. Let n be 0.
    #   10. Repeat, while k < final
    #       a. Let Pk be ! ToString(k).
    #       b. Let kPresent be ? HasProperty(O, Pk).
    #       c. If kPresent is true, then
    #           i. Let kValue be ? Get(O, Pk).
    #           ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), kValue).
    #       d. Increase k by 1.
    #       e. Increase n by 1.
    #   11. Perform ? Set(A, "length", n, true).
    #   12. Return A.
    # NOTE 2    | The explicit setting of the "length" property of the result Array in step 11 was necessary in
    #           | previous editions of ECMAScript to ensure that its length was correct in situations where the
    #           | trailing elements of the result Array were not present. Setting "length" became unnecessary
    #           | starting in ES2015 when the result Array was initialized to its proper length rather than an empty
    #           | Array but is carried forward to preserve backward compatibility.
    # NOTE 3    | The slice function is intentionally generic; it does not require that its this value be an Array
    #           | object. Therefore it can be transferred to other kinds of objects for use as a method.
    O = ToObject(this_value)
    length = ToLength(Get(O, "length"))
    relativeStart = ToInteger(start)
    if relativeStart < 0:
        k = max(length + relativeStart, 0)
    else:
        k = min(relativeStart, length)
    if end is None:
        relativeEnd = length
    else:
        relativeEnd = ToInteger(end)
    if relativeEnd < 0:
        final = max(length + relativeEnd, 0)
    else:
        final = min(relativeEnd, length)
    count = max(final - k, 0)
    A = ArraySpeciesCreate(O, count)
    n = 0
    while k < final:
        Pk = ToString(k)
        kPresent = HasProperty(O, Pk)
        if kPresent:
            kValue = Get(O, Pk)
            CreateDataPropertyOrThrow(A, ToString(n), kValue)
        k += 1
        n += 1
    Set(A, "length", n, True)
    return A


ArrayPrototype_slice.length = 2
ArrayPrototype_slice.name = "slice"

# 22.1.3.30 Array.prototype.toString ( )
def ArrayPrototype_toString(this_value, new_target, *_):
    # When the toString method is called, the following steps are taken:
    #
    #   1. Let array be ? ToObject(this value).
    #   2. Let func be ? Get(array, "join").
    #   3. If IsCallable(func) is false, let func be the intrinsic function %ObjProto_toString%.
    #   4. Return ? Call(func, array).
    # NOTE
    # The toString function is intentionally generic; it does not require that its this value be an Array object.
    # Therefore it can be transferred to other kinds of objects for use as a method.
    array = ToObject(this_value)
    func = Get(array, "join")
    if not IsCallable(func):
        func = surrounding_agent.running_ec.realm.intrinsics["%ObjProto_toString%"]
    return Call(func, array)


# 22.1.3.32 Array.prototype.values ( )
def ArrayPrototype_values(this_value, new_target, *_):
    # The following steps are taken:
    #
    #   1. Let O be ? ToObject(this value).
    #   2. Return CreateArrayIterator(O, "value").
    O = ToObject(this_value)
    return CreateArrayIterator(O, "value")
    # This function is the %ArrayProto_values% intrinsic object.


def ArrayFixups(realm):
    array_constructor = realm.intrinsics["%Array%"]
    array_prototype = realm.intrinsics["%ArrayPrototype%"]
    proto_desc = PropertyDescriptor(value=array_prototype, writable=False, enumerable=False, configurable=False)
    DefinePropertyOrThrow(array_constructor, "prototype", proto_desc)
    const_desc = PropertyDescriptor(value=array_constructor, writable=True, enumerable=False, configurable=True)
    DefinePropertyOrThrow(array_prototype, "constructor", const_desc)
    realm.intrinsics["%ArrayProto_values%"] = Get(array_prototype, "values")


# 22.1.5 Array Iterator Objects
# An Array Iterator is an object, that represents a specific iteration over some specific Array instance object. There
# is not a named constructor for Array Iterator objects. Instead, Array iterator objects are created by calling certain
# methods of Array instance objects.

# 22.1.5.1 CreateArrayIterator ( array, kind )
def CreateArrayIterator(array, kind):
    # Several methods of Array objects return Iterator objects. The abstract operation CreateArrayIterator with
    # arguments array and kind is used to create such iterator objects. It performs the following steps:
    #
    #   1. Assert: Type(array) is Object.
    #   2. Let iterator be ObjectCreate(%ArrayIteratorPrototype%, « [[IteratedObject]],
    #      [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] »).
    #   3. Set iterator.[[IteratedObject]] to array.
    #   4. Set iterator.[[ArrayIteratorNextIndex]] to 0.
    #   5. Set iterator.[[ArrayIterationKind]] to kind.
    #   6. Return iterator.
    assert isObject(array)
    iterator = ObjectCreate(
        surrounding_agent.running_ec.realm.intrinsics["%ArrayIteratorPrototype%"],
        ["IteratedObject", "ArrayIteratorNextIndex", "ArrayIterationKind"],
    )
    iterator.IteratedObject = array
    iterator.ArrayIteratorNextIndex = 0
    iterator.ArrayIterationKind = kind
    return iterator


# 22.1.5.2 The %ArrayIteratorPrototype% Object
# The %ArrayIteratorPrototype% object:
#
#   * has properties that are inherited by all Array Iterator Objects.
#   * is an ordinary object.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.
#   * has the following properties:


def CreateArrayIteratorPrototype(realm):
    proto = ObjectCreate(realm.intrinsics["%IteratorPrototype%"])
    BindBuiltinFunctions(realm, proto, [("next", ArrayIteratorPrototype_next, 0)])
    # 22.1.5.2.2 %ArrayIteratorPrototype% [ @@toStringTag ]
    # The initial value of the @@toStringTag property is the String value "Array Iterator".
    # This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.
    pdesc = PropertyDescriptor(value="Array Iterator", writable=False, enumerable=False, configurable=True)
    DefinePropertyOrThrow(proto, wks_to_string_tag, pdesc)
    return proto


# 22.1.5.2.1 %ArrayIteratorPrototype%.next ( )
def ArrayIteratorPrototype_next(this_value, new_target, *_):
    #   1. Let O be the this value.
    #   2. If Type(O) is not Object, throw a TypeError exception.
    #   3. If O does not have all of the internal slots of an Array Iterator Instance (22.1.5.3), throw a TypeError exception.
    #   4. Let a be O.[[IteratedObject]].
    #   5. If a is undefined, return CreateIterResultObject(undefined, true).
    #   6. Let index be O.[[ArrayIteratorNextIndex]].
    #   7. Let itemKind be O.[[ArrayIterationKind]].
    #   8. If a has a [[TypedArrayName]] internal slot, then
    #       a. If IsDetachedBuffer(a.[[ViewedArrayBuffer]]) is true, throw a TypeError exception.
    #       b. Let len be a.[[ArrayLength]].
    #   9. Else,
    #       a. Let len be ? ToLength(? Get(a, "length")).
    #   10. If index ≥ len, then
    #       a. Set O.[[IteratedObject]] to undefined.
    #       b. Return CreateIterResultObject(undefined, true).
    #   11. Set O.[[ArrayIteratorNextIndex]] to index+1.
    #   12. If itemKind is "key", return CreateIterResultObject(index, false).
    #   13. Let elementKey be ! ToString(index).
    #   14. Let elementValue be ? Get(a, elementKey).
    #   15. If itemKind is "value", let result be elementValue.
    #   16. Else,
    #       a. Assert: itemKind is "key+value".
    #       b. Let result be CreateArrayFromList(« index, elementValue »).
    #   17. Return CreateIterResultObject(result, false).
    O = this_value
    if not isObject(O):
        raise ESTypeError("next must be called as a method")
    if any(not hasattr(O, attr) for attr in ["IteratedObject", "ArrayIteratorNextIndex", "ArrayIterationKind"]):
        raise ESTypeError("next must be a method of an array iterator object")
    a = O.IteratedObject
    if not a:
        return CreateIterResultObject(None, True)
    index = O.ArrayIteratorNextIndex
    itemKind = O.ArrayIterationKind
    if hasattr(a, "TypedArrayName"):
        if IsDetachedBuffer(a.ViewedArrayBuffer):
            raise ESTypeError("next can't handle detached buffers")
        length = a.ArrayLength
    else:
        length = ToLength(Get(a, "length"))
    if index >= length:
        O.IteratedObject = None
        return CreateIterResultObject(None, True)
    O.ArrayIteratorNextIndex = index + 1
    if itemKind == "key":
        return CreateIterResultObject(index, False)
    elementKey = ToString(index)
    elementValue = Get(a, elementKey)
    if itemKind == "value":
        result = elementValue
    else:
        assert itemKind == "key+value"
        result = CreateArrayFromList([index, elementValue])
    return CreateIterResultObject(result, False)


#### 22.2 TypedArray Objects #######################################################################################
#
#  .d8888b.   .d8888b.       .d8888b.
# d88P  Y88b d88P  Y88b     d88P  Y88b
#        888        888            888
#      .d88P      .d88P          .d88P
#  .od888P"   .od888P"       .od888P"
# d88P"      d88P"          d88P"
# 888"       888"       d8b 888"
# 888888888  888888888  Y8P 888888888
#
#
#
#  88888888888                                 888        d8888
#      888                                     888       d88888
#      888                                     888      d88P888
#      888     888  888 88888b.   .d88b.   .d88888     d88P 888 888d888 888d888  8888b.  888  888
#      888     888  888 888 "88b d8P  Y8b d88" 888    d88P  888 888P"   888P"       "88b 888  888
#      888     888  888 888  888 88888888 888  888   d88P   888 888     888     .d888888 888  888
#      888     Y88b 888 888 d88P Y8b.     Y88b 888  d8888888888 888     888     888  888 Y88b 888
#      888      "Y88888 88888P"   "Y8888   "Y88888 d88P     888 888     888     "Y888888  "Y88888
#                   888 888                                                                   888
#              Y8b d88P 888                                                              Y8b d88P
#               "Y88P"  888                                                               "Y88P"
#
#  .d88888b.  888         d8b                   888
# d88P" "Y88b 888         Y8P                   888
# 888     888 888                               888
# 888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
# 888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# 888     888 888  888    888 88888888 888      888    "Y8888b.
# Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
#  "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                         888
#                        d88P
#                      888P"
#
####################################################################################################################
# 22.2 TypedArray Objects
# 22.2.1 The %TypedArray% Intrinsic Object
# 22.2.1.1 %TypedArray% ( )
# 22.2.2 Properties of the %TypedArray% Intrinsic Object
# 22.2.2.1 %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )
# 22.2.2.1.1 RS: IterableToList ( items, method )
# 22.2.2.2 %TypedArray%.of ( ...items )
# 22.2.2.3 %TypedArray%.prototype
# 22.2.2.4 get %TypedArray% [ @@species ]
# 22.2.3 Properties of the %TypedArrayPrototype% Object
# 22.2.3.1 get %TypedArray%.prototype.buffer
# 22.2.3.2 get %TypedArray%.prototype.byteLength
# 22.2.3.3 get %TypedArray%.prototype.byteOffset
# 22.2.3.4 %TypedArray%.prototype.constructor
# 22.2.3.5 %TypedArray%.prototype.copyWithin ( target, start [ , end ] )
# 22.2.3.5.1 RS: ValidateTypedArray ( O )
# 22.2.3.6 %TypedArray%.prototype.entries ( )
# 22.2.3.7 %TypedArray%.prototype.every ( callbackfn [ , thisArg ] )
# 22.2.3.8 %TypedArray%.prototype.fill ( value [ , start [ , end ] ] )
# 22.2.3.9 %TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )
# 22.2.3.10 %TypedArray%.prototype.find ( predicate [ , thisArg ] )
# 22.2.3.11 %TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )
# 22.2.3.12 %TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] )
# 22.2.3.13 %TypedArray%.prototype.includes ( searchElement [ , fromIndex ] )
# 22.2.3.14 %TypedArray%.prototype.indexOf ( searchElement [ , fromIndex ] )
# 22.2.3.15 %TypedArray%.prototype.join ( separator )
# 22.2.3.16 %TypedArray%.prototype.keys ( )
# 22.2.3.17 %TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )
# 22.2.3.18 get %TypedArray%.prototype.length
# 22.2.3.19 %TypedArray%.prototype.map ( callbackfn [ , thisArg ] )
# 22.2.3.20 %TypedArray%.prototype.reduce ( callbackfn [ , initialValue ] )
# 22.2.3.21 %TypedArray%.prototype.reduceRight ( callbackfn [ , initialValue ] )
# 22.2.3.22 %TypedArray%.prototype.reverse ( )
# 22.2.3.23 %TypedArray%.prototype.set ( overloaded [ , offset ] )
# 22.2.3.23.1 %TypedArray%.prototype.set ( array [ , offset ] )
# 22.2.3.23.2 %TypedArray%.prototype.set ( typedArray [ , offset ] )
# 22.2.3.24 %TypedArray%.prototype.slice ( start, end )
# 22.2.3.25 %TypedArray%.prototype.some ( callbackfn [ , thisArg ] )
# 22.2.3.26 %TypedArray%.prototype.sort ( comparefn )
# 22.2.3.27 %TypedArray%.prototype.subarray ( begin, end )
# 22.2.3.28 %TypedArray%.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
# 22.2.3.29 %TypedArray%.prototype.toString ( )
# 22.2.3.30 %TypedArray%.prototype.values ( )
# 22.2.3.31 %TypedArray%.prototype [ @@iterator ] ( )
# 22.2.3.32 get %TypedArray%.prototype [ @@toStringTag ]
# 22.2.4 The TypedArray Constructors
# 22.2.4.1 TypedArray ( )
# 22.2.4.2 TypedArray ( length )
# 22.2.4.2.1 RS: AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] )
# 22.2.4.2.2 RS: AllocateTypedArrayBuffer ( O, length )
# 22.2.4.3 TypedArray ( typedArray )
# 22.2.4.4 TypedArray ( object )
# 22.2.4.5 TypedArray ( buffer [ , byteOffset [ , length ] ] )
# 22.2.4.6 TypedArrayCreate ( constructor, argumentList )
# 22.2.4.7 TypedArraySpeciesCreate ( exemplar, argumentList )
# 22.2.5 Properties of the TypedArray Constructors
# 22.2.5.1 TypedArray.BYTES_PER_ELEMENT
# 22.2.5.2 TypedArray.prototype
# 22.2.6 Properties of the TypedArray Prototype Objects
# 22.2.6.1 TypedArray.prototype.BYTES_PER_ELEMENT
# 22.2.6.2 TypedArray.prototype.constructor
# 22.2.7 Properties of TypedArray Instances
####################################################################################################################

# TypedArray objects present an array-like view of an underlying binary data buffer (24.1). Each element of a
# TypedArray instance has the same underlying binary scalar data type. There is a distinct TypedArray constructor,
# listed in Table 56, for each of the nine supported element types. Each constructor in Table 56 has a corresponding
# distinct prototype object.

# Table 59: The TypedArray Constructors
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Constructor Name    | Element Type | Element | Conversion   | Description            | Equivalent C Type
# |   and Intrinsic     |              | Size    | Operation    |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Int8Array           | Int8         | 1       | ToInt8       | 8-bit 2's complement   | signed char
# | %Int8Array%         |              |         |              | signed integer
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Uint8Array          | Uint8        | 1       | ToUint8      | 8-bit unsigned integer | unsigned char
# | %Uint8Array%        |              |         |              |                        |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Uint8ClampedArray   | Uint8C       | 1       | ToUint8Clamp | 8-bit unsigned integer | unsigned char
# | %Uint8ClampedArray% |              |         |              | (clamped conversion)   |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Int16Array          | Int16        | 2       | ToInt16      | 16-bit 2's complement  | short
# | %Int16Array%        |              |         |              | signed integer         |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Uint16Array         | Uint16       | 2       | ToUint16     | 16-bit unsigned        | unsigned short
# | %Uint16Array%       |              |         |              | integer                |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Int32Array          | Int32        | 4       | ToInt32      | 32-bit 2's complement  | int
# | %Int32Array%        |              |         |              | signed integer         |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Uint32Array         | Uint32       | 4       | ToUint32     | 32-bit unsigned        | unsigned int
# | %Uint32Array%       |              |         |              | integer                |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Float32Array        | Float32      | 4       |              | 32-bit IEEE floating   | float
# | %Float32Array%      |              |         |              | point                  |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
# | Float64Array        | Float64      | 8       |              | 64-bit IEEE floating   | double
# | %Float64Array%      |              |         |              | point                  |
# +---------------------+--------------+---------+--------------+------------------------+--------------------------
TA_ElementSize = {
    "Int8Array": 1,
    "Uint8Array": 1,
    "Uint8ClampedArray": 1,
    "Int16Array": 2,
    "Uint16Array": 2,
    "Int32Array": 4,
    "Uint32Array": 4,
    "Float32Array": 4,
    "Float64Array": 8,
}
TA_ElementTypeName = {
    "Int8Array": "Int8",
    "Uint8Array": "Uint8",
    "Uint8ClampedArray": "Uint8C",
    "Int16Array": "Int16",
    "Uint16Array": "Uint16",
    "Int32Array": "Int32",
    "Uint32Array": "Uint32",
    "Float32Array": "Float32",
    "Float64Array": "Float64",
}

# In the definitions below, references to 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 should be replaced with the appropriate constructor name from
# the above table. The phrase “the element size in bytes” refers to the value in the Element Size column of the
# table in the row corresponding to the constructor. The phrase “element Type” refers to the value in the Element
# Type column for that row.

# 22.2.1 The %TypedArray% Intrinsic Object
# The %TypedArray% intrinsic object:
#
#   * is a constructor function object that all of the 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 constructor objects inherit from.
#   * along with its corresponding prototype object, provides common properties that are inherited by all 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦
#     constructors and their instances.
#   * does not have a global name or appear as a property of the global object.
#   * acts as the abstract superclass of the various 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 constructors.
#   * will throw an error when invoked, because it is an abstract class constructor. The 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 constructors do
#     not perform a super call to it.


def CreateTypedArrayIntrinsicObject(realm: Realm):
    obj = CreateAnnotatedFunctionObject(realm, TypedArrayFunction, ["Construct"])
    BindBuiltinFunctions(realm, obj, (("from", TypedArray_from, None), ("of", TypedArray_of, None),))
    BindBuiltinAccessors(realm, obj, ((wks_species, TypedArray_getSpecies, None),))
    return obj


# 22.2.1.1 %TypedArray% ( )
# The %TypedArray% constructor performs the following steps:
#   1. Throw a TypeError exception.
# The "length" property of the %TypedArray% constructor function is 0.
def TypedArrayFunction(this_value, new_target, *_):
    raise ESTypeError("Abstract class TypedArray not directly constructable")


TypedArrayFunction.name = "TypedArray"
TypedArrayFunction.length = 0

# 22.2.2 Properties of the %TypedArray% Intrinsic Object
# The %TypedArray% intrinsic object:
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.
#   * has a name property whose value is "TypedArray".
#   * has the following properties:

# 22.2.2.1 %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )
def TypedArray_from(this_value, new_target, source=None, mapfn=None, thisArg=None, *_):
    # When the from method is called with argument source, and optional arguments mapfn and thisArg, the following
    # steps are taken:
    #   1. Let C be the this value.
    #   2. If IsConstructor(C) is false, throw a TypeError exception.
    #   3. If mapfn is present and mapfn is not undefined, then
    #       a. If IsCallable(mapfn) is false, throw a TypeError exception.
    #       b. Let mapping be true.
    #   4. Else, let mapping be false.
    #   5. If thisArg is present, let T be thisArg; else let T be undefined.
    #   6. Let usingIterator be ? GetMethod(source, @@iterator).
    #   7. If usingIterator is not undefined, then
    #       a. Let values be ? IterableToList(source, usingIterator).
    #       b. Let len be the number of elements in values.
    #       c. Let targetObj be ? TypedArrayCreate(C, « len »).
    #       d. Let k be 0.
    #       e. Repeat, while k < len
    #           i. Let Pk be ! ToString(k).
    #           ii. Let kValue be the first element of values and remove that element from values.
    #           iii. If mapping is true, then
    #               1. Let mappedValue be ? Call(mapfn, T, « kValue, k »).
    #           iv. Else, let mappedValue be kValue.
    #           v. Perform ? Set(targetObj, Pk, mappedValue, true).
    #           vi. Increase k by 1.
    #       f. Assert: values is now an empty List.
    #       g. Return targetObj.
    #   8. NOTE: source is not an Iterable so assume it is already an array-like object.
    #   9. Let arrayLike be ! ToObject(source).
    #   10. Let len be ? ToLength(? Get(arrayLike, "length")).
    #   11. Let targetObj be ? TypedArrayCreate(C, « len »).
    #   12. Let k be 0.
    #   13. Repeat, while k < len
    #       a. Let Pk be ! ToString(k).
    #       b. Let kValue be ? Get(arrayLike, Pk).
    #       c. If mapping is true, then
    #           i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).
    #       d. Else, let mappedValue be kValue.
    #       e. Perform ? Set(targetObj, Pk, mappedValue, true).
    #       f. Increase k by 1.
    #   14. Return targetObj.
    C = this_value
    if not IsConstructor(C):
        raise ESTypeError(f"%TypedArray%.from called with incompatible receiver {ToString(C)}")
    if mapfn is not None:
        if not IsCallable(mapfn):
            raise ESTypeError(f"%TypedArray%.from called with bad mapping function {ToString(mapfn)}")
        mapping = True
    else:
        mapping = False
    T = thisArg
    usingIterator = GetMethod(source, wks_iterator)
    if usingIterator is not None:
        values = IterableToList(source, usingIterator)
        targetObj = TypedArrayCreate(C, [len(values)])
        for k, kValue in enumerate(values):
            Pk = ToString(k)
            if mapping:
                mappedValue = Call(mapfn, T, [kValue, k])
            else:
                mappedValue = kValue
            Set(targetObj, Pk, mappedValue, True)
        return targetObj
    arrayLike = ToObject(source)
    len_ = ToLength(Get(arrayLike, "length"))
    targetObj = TypedArrayCreate(C, [len_])
    for k in range(len_):
        Pk = ToString(k)
        kValue = Get(arrayLike, Pk)
        if mapping:
            mappedValue = Call(mapfn, T, [kValue, k])
        else:
            mappedValue = kValue
        Set(targetObj, Pk, mappedValue, True)
    return targetObj


TypedArray_from.name = "from"
TypedArray_from.length = 1

# 22.2.2.1.1 Runtime Semantics: IterableToList ( items, method )
def IterableToList(items, method):
    # The abstract operation IterableToList performs the following steps:
    #   1. Let iteratorRecord be ? GetIterator(items, sync, method).
    #   2. Let values be a new empty List.
    #   3. Let next be true.
    #   4. Repeat, while next is not false
    #       a. Set next to ? IteratorStep(iteratorRecord).
    #       b. If next is not false, then
    #           i. Let nextValue be ? IteratorValue(next).
    #           ii. Append nextValue to the end of the List values.
    #   5. Return values.
    iteratorRecord = GetIterator(items, SYNC, method)
    values = []
    next_ = True
    while next_:
        next_ = IteratorStep(iteratorRecord)
        if next_:
            nextValue = IteratorValue(next_)
            values.append(nextValue)
    return values


# 22.2.2.2 %TypedArray%.of ( ...items )
def TypedArray_of(this_value, new_target, *items):
    # When the of method is called with any number of arguments, the following steps are taken:
    #   1. Let len be the actual number of arguments passed to this function.
    #   2. Let items be the List of arguments passed to this function.
    #   3. Let C be the this value.
    #   4. If IsConstructor(C) is false, throw a TypeError exception.
    #   5. Let newObj be ? TypedArrayCreate(C, « len »).
    #   6. Let k be 0.
    #   7. Repeat, while k < len
    #       a. Let kValue be items[k].
    #       b. Let Pk be ! ToString(k).
    #       c. Perform ? Set(newObj, Pk, kValue, true).
    #       d. Increase k by 1.
    #   8. Return newObj.
    # NOTE  | The items argument is assumed to be a well-formed rest argument value.
    len_ = len(items)
    C = this_value
    if not IsConstructor(C):
        raise ESTypeError(f"%TypeError%.of called with invalid receiver {ToString(C)}")
    newObj = TypedArrayCreate(C, [len_])
    for k, kValue in enumerate(items):
        Set(newObj, ToString(k), kValue, True)
    return newObj


TypedArray_of.name = "of"
TypedArray_of.length = 0

# 22.2.2.3 %TypedArray%.prototype
# The initial value of %TypedArray%.prototype is the %TypedArrayPrototype% intrinsic object.
# This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.

# 22.2.3.4 %TypedArray%.prototype.constructor
# The initial value of %TypedArray%.prototype.constructor is the %TypedArray% intrinsic object.
def TypedArrayFixups(realm: Realm) -> None:
    proto = realm.intrinsics["%TypedArrayPrototype%"]
    cstr = realm.intrinsics["%TypedArray%"]
    DefinePropertyOrThrow(
        proto, "constructor", PropertyDescriptor(value=proto, writable=True, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        cstr, "prototype", PropertyDescriptor(value=cstr, writable=False, enumerable=False, configurable=False)
    )


# 22.2.2.4 get %TypedArray% [ @@species ]
def TypedArray_getSpecies(this_value, new_target, *_):
    # %TypedArray%[@@species] is an accessor property whose set accessor function is undefined. Its get accessor
    # function performs the following steps:
    #   1. Return the this value.
    # The value of the name property of this function is "get [Symbol.species]".
    # NOTE  | %TypedArrayPrototype% methods normally use their this object's constructor to create a derived object.
    #       | However, a subclass constructor may over-ride that default behaviour by redefining its @@species
    #       | property.
    return this_value


TypedArray_getSpecies.name = "get [Symbol.species]"
TypedArray_getSpecies.length = 0

# 22.2.3 Properties of the %TypedArrayPrototype% Object
# The %TypedArrayPrototype% object:
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
#   * is an ordinary object.
#   * does not have a [[ViewedArrayBuffer]] or any other of the internal slots that are specific to TypedArray
#     instance objects.


def CreateTypedArrayPrototype(realm: Realm) -> JSObject:
    obj = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    BindBuiltinAccessors(
        realm,
        obj,
        (
            ("buffer", TypedArrayPrototype_getBuffer, None),
            ("byteLength", TypedArrayPrototype_getByteLength, None),
            ("byteOffset", TypedArrayPrototype_getByteOffset, None),
        ),
    )
    BindBuiltinFunctions(
        realm,
        obj,
        (
            ("copyWithin", TypedArrayPrototype_copyWithin, None),
            ("entries", TypedArrayPrototype_entries, None),
            ("every", TypedArrayPrototype_every, None),
            ("fill", TypedArrayPrototype_fill, None),
            ("filter", TypedArrayPrototype_filter, None),
            ("find", TypedArrayPrototype_find, None),
            ("slice", TypedArrayPrototype_slice, None),
        ),
    )
    return obj


# 22.2.3.1 get %TypedArray%.prototype.buffer
def TypedArrayPrototype_getBuffer(this_value, new_target, *_):
    # %TypedArray%.prototype.buffer is an accessor property whose set accessor function is undefined. Its get
    # accessor function performs the following steps:
    #   1. Let O be the this value.
    #   2. If Type(O) is not Object, throw a TypeError exception.
    #   3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    #   4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    #   5. Let buffer be O.[[ViewedArrayBuffer]].
    #   6. Return buffer.
    O = this_value
    if not isObject(O) or not hasattr(O, "TypedArrayName"):
        raise ESTypeError(f"get %TypedArray%.prototype.buffer called with invalid receiver {ToString(O)}")
    assert hasattr(O, "ViewedArrayBuffer")
    return O.ViewedArrayBuffer


TypedArrayPrototype_getBuffer.length = 0
TypedArrayPrototype_getBuffer.name = "get buffer"

# 22.2.3.2 get %TypedArray%.prototype.byteLength
def TypedArrayPrototype_getByteLength(this_value, new_target, *_):
    # %TypedArray%.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get
    # accessor function performs the following steps:
    #   1. Let O be the this value.
    #   2. If Type(O) is not Object, throw a TypeError exception.
    #   3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    #   4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    #   5. Let buffer be O.[[ViewedArrayBuffer]].
    #   6. If IsDetachedBuffer(buffer) is true, return 0.
    #   7. Let size be O.[[ByteLength]].
    #   8. Return size.
    O = this_value
    if not isObject(O) or not hasattr(O, "TypedArrayName"):
        raise ESTypeError(f"get %TypedArray%.prototype.byteLength called with invalid receiver {ToString(O)}")
    assert hasattr(O, "ViewedArrayBuffer")
    buffer = O.ViewedArrayBuffer
    if IsDetachedBuffer(buffer):
        return 0
    return O.ByteLength


TypedArrayPrototype_getByteLength.length = 0
TypedArrayPrototype_getByteLength.name = "get byteLength"

# 22.2.3.3 get %TypedArray%.prototype.byteOffset
def TypedArrayPrototype_getByteOffset(this_value, new_target, *_):
    # %TypedArray%.prototype.byteOffset is an accessor property whose set accessor function is undefined. Its get
    # accessor function performs the following steps:
    #   1. Let O be the this value.
    #   2. If Type(O) is not Object, throw a TypeError exception.
    #   3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    #   4. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    #   5. Let buffer be O.[[ViewedArrayBuffer]].
    #   6. If IsDetachedBuffer(buffer) is true, return 0.
    #   7. Let offset be O.[[ByteOffset]].
    #   8. Return offset.
    O = this_value
    if not isObject(O) or not hasattr(O, "TypedArrayName"):
        raise ESTypeError(f"get %TypedArray%.prototype.byteOffset called with invalid receiver {ToString(O)}")
    assert hasattr(O, "ViewedArrayBuffer")
    buffer = O.ViewedArrayBuffer
    return O.ByteOffset if not IsDetachedBuffer(buffer) else 0


TypedArrayPrototype_getByteOffset.length = 0
TypedArrayPrototype_getByteOffset.name = "get byteOffset"

# 22.2.3.5 %TypedArray%.prototype.copyWithin ( target, start [ , end ] )
def TypedArrayPrototype_copyWithin(this_value, new_target, target=None, start=None, end=None, *_):
    # The interpretation and use of the arguments of %TypedArray%.prototype.copyWithin are the same as for
    # Array.prototype.copyWithin as defined in 22.1.3.3.
    #
    # The following steps are taken:
    #   1. Let O be this value.
    #   2. Perform ? ValidateTypedArray(O).
    #   3. Let len be O.[[ArrayLength]].
    #   4. Let relativeTarget be ? ToInteger(target).
    #   5. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).
    #   6. Let relativeStart be ? ToInteger(start).
    #   7. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be
    #      min(relativeStart, len).
    #   8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    #   9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    #   10. Let count be min(final - from, len - to).
    #   11. If count > 0, then
    #       a. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source
    #          data.
    #       b. Let buffer be O.[[ViewedArrayBuffer]].
    #       c. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    #       d. Let typedArrayName be the String value of O.[[TypedArrayName]].
    #       e. Let elementSize be the Number value of the Element Size value specified in Table 59 for
    #          typedArrayName.
    #       f. Let byteOffset be O.[[ByteOffset]].
    #       g. Let toByteIndex be to × elementSize + byteOffset.
    #       h. Let fromByteIndex be from × elementSize + byteOffset.
    #       i. Let countBytes be count × elementSize.
    #       j. If fromByteIndex < toByteIndex and toByteIndex < fromByteIndex + countBytes, then
    #           i. Let direction be -1.
    #           ii. Set fromByteIndex to fromByteIndex + countBytes - 1.
    #           iii. Set toByteIndex to toByteIndex + countBytes - 1.
    #       k. Else,
    #           i. Let direction be 1.
    #       l. Repeat, while countBytes > 0
    #           i. Let value be GetValueFromBuffer(buffer, fromByteIndex, "Uint8", true, "Unordered").
    #           ii. Perform SetValueInBuffer(buffer, toByteIndex, "Uint8", value, true, "Unordered").
    #           iii. Set fromByteIndex to fromByteIndex + direction.
    #           iv. Set toByteIndex to toByteIndex + direction.
    #           v. Decrease countBytes by 1.
    #   12. Return O.
    O = this_value
    ValidateTypedArray(O, "%TypedArray%.prototype.copyWithin")
    len_ = O.ArrayLength
    relativeTarget = ToInteger(target)
    if relativeTarget < 0:
        to = max(len_ + relativeTarget, 0)
    else:
        to = min(relativeTarget, len_)
    relativeStart = ToInteger(start)
    if relativeStart < 0:
        from_ = max(len_ + relativeStart, 0)
    else:
        from_ = min(relativeStart, len_)
    relativeEnd = ToInteger(end) if end is not None else len_
    if relativeEnd < 0:
        final = max(len_ + relativeEnd, 0)
    else:
        final = min(relativeEnd, len_)
    count = min(final - from_, len_ - to)
    if count > 0:
        buffer = O.ViewedArrayBuffer
        if IsDetachedBuffer(buffer):
            raise ESTypeError("Buffer detached; cannot copyWithin")
        typedArrayName = O.TypedArrayName
        elementSize = TA_ElementSize[typedArrayName]
        byteOffset = O.ByteOffset
        toByteIndex = to * elementSize + byteOffset
        fromByteIndex = from_ * elementSize + byteOffset
        countBytes = count * elementSize
        if fromByteIndex < toByteIndex and toByteIndex < fromByteIndex + countBytes:
            direction = -1
            fromByteIndex = fromByteIndex + countBytes - 1
            toByteIndex = toByteIndex + countBytes - 1
        else:
            direction = 1
        while countBytes > 0:
            value = GetValueFromBuffer(buffer, fromByteIndex, "Uint8", True, "Unordered")
            SetValueInBuffer(buffer, toByteIndex, "Uint8", value, True, "Unordered")
            fromByteIndex += direction
            toByteIndex += direction
            countBytes -= 1
        return O


TypedArrayPrototype_copyWithin.length = 2
TypedArrayPrototype_copyWithin.name = "copyWithin"

# 22.2.3.5.1 Runtime Semantics: ValidateTypedArray ( O )
def ValidateTypedArray(O: JSValue, whoami: str):
    # When called with argument O, the following steps are taken:
    #   1. If Type(O) is not Object, throw a TypeError exception.
    #   2. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.
    #   3. Assert: O has a [[ViewedArrayBuffer]] internal slot.
    #   4. Let buffer be O.[[ViewedArrayBuffer]].
    #   5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    #   6. Return buffer.
    if not isObject(O) or not hasattr(O, "TypedArrayName"):
        raise ESTypeError(f"{whoami} called with invalid receiver {ToString(O)}")
    assert hasattr(O, "ViewedArrayBuffer")
    buffer = O.ViewedArrayBuffer
    if IsDetachedBuffer(buffer):
        raise ESTypeError(f"{whoami} called with unattached buffer")
    return buffer


# 22.2.3.6 %TypedArray%.prototype.entries ( )
def TypedArrayPrototype_entries(this_value, new_target, *_):
    # The following steps are taken:
    #
    #   1. Let O be the this value.
    #   2. Perform ? ValidateTypedArray(O).
    #   3. Return CreateArrayIterator(O, "key+value").
    O = this_value
    ValidateTypedArray(O, "%TypedArray%.prototype.entries")
    return CreateArrayIterator(O, "key+value")


TypedArrayPrototype_entries.length = 0
TypedArrayPrototype_entries.name = "entries"

# 22.2.3.7 %TypedArray%.prototype.every ( callbackfn [ , thisArg ] )
def TypedArrayPrototype_every(this_value, new_target, callbackfn=None, thisArg=None, *_):
    # %TypedArray%.prototype.every is a distinct function that implements the same algorithm as
    # Array.prototype.every as defined in 22.1.3.5 except that the this object's [[ArrayLength]] internal slot is
    # accessed in place of performing a [[Get]] of "length". The implementation of the algorithm may be optimized
    # with the knowledge that the this value is an object that has a fixed length and whose integer-indexed
    # properties are not sparse. However, such optimization must not introduce any observable changes in the
    # specified behaviour of the algorithm and must take into account the possibility that calls to callbackfn may
    # cause the this value to become detached.
    #
    # This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the
    # algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.
    ValidateTypedArray(this_value, "%TypedArray%.prototype.every")
    len_ = this_value.ArrayLength
    if not IsCallable(callbackfn):
        raise ESTypeError(f"%TypedArray%.prototype.every called with non-function {ToString(callbackfn)}")
    for value, index in ((Get(this_value, ToString(k)), k) for k in range(len_)):
        testResult = Call(callbackfn, thisArg, [value, index, this_value])
        if not testResult:
            return False
    return True


TypedArrayPrototype_every.length = 1
TypedArrayPrototype_every.name = "every"

# 22.2.3.8 %TypedArray%.prototype.fill ( value [ , start [ , end ] ] )
def TypedArrayPrototype_fill(this_value, new_target, value=None, start=None, end=None, *_):
    # The interpretation and use of the arguments of %TypedArray%.prototype.fill are the same as for
    # Array.prototype.fill as defined in 22.1.3.6.
    #
    # The following steps are taken:
    #   1. Let O be the this value.
    #   2. Perform ? ValidateTypedArray(O).
    #   3. Let len be O.[[ArrayLength]].
    #   4. Set value to ? ToNumber(value).
    #   5. Let relativeStart be ? ToInteger(start).
    #   6. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).
    #   7. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    #   8. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    #   9. If IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is true, throw a TypeError exception.
    #   10. Repeat, while k < final
    #       a. Let Pk be ! ToString(k).
    #       b. Perform ! Set(O, Pk, value, true).
    #       c. Increase k by 1.
    #   11. Return O.
    O = this_value
    ValidateTypedArray(O, "%TypedArray%.prototype.fill")
    len_ = O.ArrayLength
    value = ToNumber(value)
    relativeStart = ToInteger(start)
    if relativeStart < 0:
        k = max(len_ + relativeStart, 0)
    else:
        k = min(relativeStart, len_)
    if end is None:
        relativeEnd = len_
    else:
        relativeEnd = ToInteger(end)
    if relativeEnd < 0:
        final = max(len_ + relativeEnd, 0)
    else:
        final = min(relativeEnd, len_)
    if IsDetachedBuffer(O.ViewedArrayBuffer):
        raise ESTypeError("%TypedArray%.prototype.fill called with detached buffer")
    while k < final:
        Set(O, ToString(k), value, True)
        k += 1
    return O


TypedArrayPrototype_fill.length = 1
TypedArrayPrototype_fill.name = "fill"

# 22.2.3.9% TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )
def TypedArrayPrototype_filter(O, new_target, callbackfn=None, T=None, *_):
    # The interpretation and use of the arguments of %TypedArray%.prototype.filter are the same as for
    # Array.prototype.filter as defined in 22.1.3.7.
    #
    # When the filter method is called with one or two arguments, the following steps are taken:
    #   1. Let O be the this value.
    #   2. Perform ? ValidateTypedArray(O).
    #   3. Let len be O.[[ArrayLength]].
    #   4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    #   5. If thisArg is present, let T be thisArg; else let T be undefined.
    #   6. Let kept be a new empty List.
    #   7. Let k be 0.
    #   8. Let captured be 0.
    #   9. Repeat, while k < len
    #       a. Let Pk be ! ToString(k).
    #       b. Let kValue be ? Get(O, Pk).
    #       c. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).
    #       d. If selected is true, then
    #           i. Append kValue to the end of kept.
    #           ii. Increase captured by 1.
    #       e. Increase k by 1.
    #   10. Let A be ? TypedArraySpeciesCreate(O, « captured »).
    #   11. Let n be 0.
    #   12. For each element e of kept, do
    #       a. Perform ! Set(A, ! ToString(n), e, true).
    #       b. Increment n by 1.
    #   13. Return A.
    # This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot.
    ValidateTypedArray(O, "%TypedArray%.prototype.filter")
    if not IsCallable(callbackfn):
        raise ESTypeError(f"%TypedArray%.prototype.filter callback must be callable")
    kept = [val for k in range(O.ArrayLength) if ToBoolean(Call(callbackfn, T, [val := Get(O, ToString(k)), k, O]))]
    A = TypedArraySpeciesCreate(O, [len(kept)])
    for n, e in enumerate(kept):
        Set(A, ToString(n), e, True)
    return A


TypedArrayPrototype_filter.length = 1
TypedArrayPrototype_filter.name = "filter"

# 22.2.3.10 %TypedArray%.prototype.find ( predicate [ , thisArg ] )
def TypedArrayPrototype_find(O, new_target, predicate=None, T=None, *_):
    # %TypedArray%.prototype.find is a distinct function that implements the same algorithm as Array.prototype.find
    # as defined in 22.1.3.8 except that the this object's [[ArrayLength]] internal slot is accessed in place of
    # performing a [[Get]] of "length". The implementation of the algorithm may be optimized with the knowledge that
    # the this value is an object that has a fixed length and whose integer-indexed properties are not sparse.
    # However, such optimization must not introduce any observable changes in the specified behaviour of the
    # algorithm and must take into account the possibility that calls to predicate may cause the this value to
    # become detached.
    #
    # This function is not generic. ValidateTypedArray is applied to the this value prior to evaluating the
    # algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.
    ValidateTypedArray(O, "%TypedArray%.prototype.find")
    if not IsCallable(predicate):
        raise ESTypeError("%TypedArray%.prototype.find needs a callable predicate")
    for k in range(O.ArrayLength):
        kValue = Get(O, ToString(k))
        if ToBoolean(Call(predicate, T, [kValue, k, O])):
            return kValue
    return None


TypedArrayPrototype_find.length = 1
TypedArrayPrototype_find.name = "find"

# 22.2.3.24 %TypedArray%.prototype.slice ( start, end )
def TypedArrayPrototype_slice(this_value, new_target, start=None, end=None, *_):
    # The interpretation and use of the arguments of %TypedArray%.prototype.slice are the same as for
    # Array.prototype.slice as defined in 22.1.3.25. The following steps are taken:
    #   1. Let O be the this value.
    #   2. Perform ? ValidateTypedArray(O).
    #   3. Let len be O.[[ArrayLength]].
    #   4. Let relativeStart be ? ToInteger(start).
    #   5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).
    #   6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    #   7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    #   8. Let count be max(final - k, 0).
    #   9. Let A be ? TypedArraySpeciesCreate(O, « count »).
    #   10. Let srcName be the String value of O.[[TypedArrayName]].
    #   11. Let srcType be the String value of the Element Type value in Table 59 for srcName.
    #   12. Let targetName be the String value of A.[[TypedArrayName]].
    #   13. Let targetType be the String value of the Element Type value in Table 59 for targetName.
    #   14. If SameValue(srcType, targetType) is false, then
    #       a. Let n be 0.
    #       b. Repeat, while k < final
    #           i. Let Pk be ! ToString(k).
    #           ii. Let kValue be ? Get(O, Pk).
    #           iii. Perform ! Set(A, ! ToString(n), kValue, true).
    #           iv. Increase k by 1.
    #           v. Increase n by 1.
    #   15. Else if count > 0, then
    #       a. Let srcBuffer be O.[[ViewedArrayBuffer]].
    #       b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.
    #       c. Let targetBuffer be A.[[ViewedArrayBuffer]].
    #       d. Let elementSize be the Number value of the Element Size value specified in Table 59 for srcType.
    #       e. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
    #       f. Let srcByteOffet be O.[[ByteOffset]].
    #       g. Let targetByteIndex be A.[[ByteOffset]].
    #       h. Let srcByteIndex be (k × elementSize) + srcByteOffet.
    #       i. Let limit be targetByteIndex + count × elementSize.
    #       j. Repeat, while targetByteIndex < limit
    #           i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, "Uint8", true, "Unordered").
    #           ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, "Uint8", value, true, "Unordered").
    #           iii. Increase srcByteIndex by 1.
    #           iv. Increase targetByteIndex by 1.
    #   16. Return A.
    # This function is not generic. The this value must be an object with a [[TypedArrayName]] internal slot.
    O = this_value
    ValidateTypedArray(O, "%TypedArray%.prototype.slice")
    length = O.ArrayLength
    relativeStart = ToInteger(start)
    k = max(length + relativeStart, 0) if relativeStart < 0 else min(relativeStart, length)
    relativeEnd = length if end is None else ToInteger(end)
    final = max(length + relativeEnd, 0) if relativeEnd < 0 else min(relativeEnd, length)
    count = max(final - k, 0)
    A = TypedArraySpeciesCreate(O, [count])
    srcName = O.TypedArrayName
    srcType = TA_ElementTypeName[srcName]
    targetName = A.TypedArrayName
    targetType = TA_ElementTypeName[targetName]
    if not SameValue(srcType, targetType):
        n = 0
        while k < final:
            Pk = ToString(k)
            kValue = Get(O, Pk)
            Set(A, ToString(n), kValue, True)
            k += 1
            n += 1
    elif count > 0:
        srcBuffer = O.ViewedArrayBuffer
        if IsDetachedBuffer(srcBuffer):
            raise ESTypeError("slice on detached buffer")
        targetBuffer = A.ViewedArrayBuffer
        elementSize = TA_ElementSize[srcName]
        srcByteOffset = O.ByteOffset
        targetByteIndex = A.ByteOffset
        srcByteIndex = k * elementSize + srcByteOffset
        limit = targetByteIndex + count * elementSize
        while targetByteIndex < limit:
            value = GetValueFromBuffer(srcBuffer, srcByteIndex, "Uint8", True, "Unordered")
            SetValueInBuffer(targetBuffer, targetByteIndex, "Uint8", value, True, "Unordered")
            srcByteIndex += 1
            targetByteIndex += 1
    return A


TypedArrayPrototype_slice.length = 2
TypedArrayPrototype_slice.name = "slice"

# 22.2.4 The 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 Constructors
# Each 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 constructor:
#
#   * is an intrinsic object that has the structure described below, differing only in the name used as the
#     constructor name instead of 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦, in Table 59.
#   * is a single function whose behaviour is overloaded based upon the number and types of its arguments. The
#     actual behaviour of a call of 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 depends upon the number and kind of arguments that are passed to it.
#   * is not intended to be called as a function and will throw an exception when called in that manner.
#   * is designed to be subclassable. It may be used as the value of an extends clause of a class definition.
#     Subclass constructors that intend to inherit the specified 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 behaviour must include a super call to
#     the 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 constructor to create and initialize the subclass instance with the internal state necessary to
#     support the %TypedArray%.prototype built-in methods.
#   * has a "length" property whose value is 3.


def CreateSpecificTypedArrayConstructor(realm: Realm, name: str) -> JSObject:
    obj = CreateAnnotatedFunctionObject(realm, CreateSpecificTypedArrayFunction(name), ["Construct"])
    # BindBuiltinFunctions(realm, obj, (("from", TypedArray_from, None), ("of", TypedArray_of, None),))
    # BindBuiltinAccessors(realm, obj, ((wks_species, TypedArray_getSpecies, None),))
    DefinePropertyOrThrow(
        obj,
        "BYTES_PER_ELEMENT",
        PropertyDescriptor(value=TA_ElementSize[name], writable=False, enumerable=False, configurable=False),
    )
    return obj


def CreateSpecificTypedArrayFunction(name: str):
    def SpecificTypedArray(this_value, new_target, arg1=..., byteOffset=None, length=None, *_):
        if arg1 is Ellipsis:
            # 22.2.4.1 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 ( )
            # This description applies only if the 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 function is called with no arguments.
            #   1. If NewTarget is undefined, throw a TypeError exception.
            #   2. Let constructorName be the String value of the Constructor Name value specified in Table 59 for
            #      this 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 constructor.
            #   3. Return ? AllocateTypedArray(constructorName, NewTarget, "%𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦Prototype%", 0).
            if new_target is None:
                raise ESTypeError(f"{name}() must be used with the 'new' operator")
            return AllocateTypedArray(name, new_target, f"%{name}Prototype%", 0)
        if not isObject(arg1):
            # 22.2.4.2 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 ( length )
            # This description applies only if the 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 function is called with at least one argument and the
            # Type of the first argument is not Object.
            #
            # 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 called with argument length performs the following steps:
            #   1. Assert: Type(length) is not Object.
            #   2. If NewTarget is undefined, throw a TypeError exception.
            #   3. Let elementLength be ? ToIndex(length).
            #   4. Let constructorName be the String value of the Constructor Name value specified in Table 59 for
            #      this 𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦 constructor.
            #   5. Return ? AllocateTypedArray(constructorName, NewTarget, "%𝑇𝑦𝑝𝑒𝑑𝐴𝑟𝑟𝑎𝑦Prototype%", elementLength).
            if new_target is None:
                raise ESTypeError(f"{name}() must be used with the 'new' operator")
            return AllocateTypedArray(name, new_target, f"%{name}Prototype%", ToIndex(arg1))
        if hasattr(arg1, "TypedArrayName"):
            # 22.2.4.3 TypedArray ( typedArray )
            # This description applies only if the TypedArray function is called with at least one argument and the
            # Type of the first argument is Object and that object has a [[TypedArrayName]] internal slot.
            #
            # TypedArray called with argument typedArray performs the following steps:
            #   1. Assert: Type(typedArray) is Object and typedArray has a [[TypedArrayName]] internal slot.
            #   2. If NewTarget is undefined, throw a TypeError exception.
            #   3. Let constructorName be the String value of the Constructor Name value specified in Table 59 for
            #      this TypedArray constructor.
            #   4. Let O be ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%").
            #   5. Let srcArray be typedArray.
            #   6. Let srcData be srcArray.[[ViewedArrayBuffer]].
            #   7. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.
            #   8. Let elementType be the String value of the Element Type value in Table 59 for constructorName.
            #   9. Let elementLength be srcArray.[[ArrayLength]].
            #   10. Let srcName be the String value of srcArray.[[TypedArrayName]].
            #   11. Let srcType be the String value of the Element Type value in Table 59 for srcName.
            #   12. Let srcElementSize be the Element Size value in Table 59 for srcName.
            #   13. Let srcByteOffset be srcArray.[[ByteOffset]].
            #   14. Let elementSize be the Element Size value in Table 59 for constructorName.
            #   15. Let byteLength be elementSize × elementLength.
            #   16. If IsSharedArrayBuffer(srcData) is false, then
            #       a. Let bufferConstructor be ? SpeciesConstructor(srcData, %ArrayBuffer%).
            #   17. Else,
            #       a. Let bufferConstructor be %ArrayBuffer%.
            #   18. If SameValue(elementType, srcType) is true, then
            #       a. Let data be ? CloneArrayBuffer(srcData, srcByteOffset, byteLength, bufferConstructor).
            #   19. Else,
            #       a. Let data be ? AllocateArrayBuffer(bufferConstructor, byteLength).
            #       b. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.
            #       c. Let srcByteIndex be srcByteOffset.
            #       d. Let targetByteIndex be 0.
            #       e. Let count be elementLength.
            #       f. Repeat, while count > 0
            #           i. Let value be GetValueFromBuffer(srcData, srcByteIndex, srcType, true, "Unordered").
            #           ii. Perform SetValueInBuffer(data, targetByteIndex, elementType, value, true, "Unordered").
            #           iii. Set srcByteIndex to srcByteIndex + srcElementSize.
            #           iv. Set targetByteIndex to targetByteIndex + elementSize.
            #           v. Decrement count by 1.
            #   20. Set O.[[ViewedArrayBuffer]] to data.
            #   21. Set O.[[ByteLength]] to byteLength.
            #   22. Set O.[[ByteOffset]] to 0.
            #   23. Set O.[[ArrayLength]] to elementLength.
            #   24. Return O.
            if new_target is None:
                raise ESTypeError(f"{name}() must be used with the 'new' operator")
            O = AllocateTypedArray(name, new_target, f"%{name}Prototype%")
            srcArray = arg1
            srcData = srcArray.ViewedArrayBuffer
            if IsDetachedBuffer(srcData):
                raise ESTypeError(f"source data buffer is detached in {name} initialization")
            elementType = TA_ElementTypeName[name]
            elementLength = srcArray.ArrayLength
            srcName = srcArray.TypedArrayName
            srcType = TA_ElementTypeName[srcName]
            srcElementSize = TA_ElementSize[srcName]
            srcByteOffset = srcArray.ByteOffset
            elementSize = TA_ElementSize[name]
            byteLength = elementSize * elementLength
            if not IsSharedArrayBuffer(srcData):
                bufferConstructor = SpeciesConstructor(
                    srcData, surrounding_agent.running_ec.realm.intrinsics["%ArrayBuffer%"]
                )
            else:
                bufferConstructor = surrounding_agent.running_ec.realm.intrinsics["%ArrayBuffer%"]
            if SameValue(elementType, srcType):
                data = CloneArrayBuffer(srcData, srcByteOffset, byteLength, bufferConstructor)
            else:
                data = AllocateArrayBuffer(bufferConstructor, byteLength)
                if IsDetachedBuffer(srcData):
                    raise ESTypeError(f"source data buffer is detached in {name} initialization")
                srcByteIndex = srcByteOffset
                targetByteIndex = 0
                count = elementLength
                while count > 0:
                    value = GetValueFromBuffer(srcData, srcByteIndex, srcType, True, "Unordered")
                    SetValueInBuffer(data, targetByteIndex, elementType, value, True, "Unordered")
                    srcByteIndex += srcElementSize
                    targetByteIndex += elementSize
                    count -= 1
            O.ViewedArrayBuffer = data
            O.ByteLength = byteLength
            O.ByteOffset = 0
            O.ArrayLength = elementLength
            return O
        if not hasattr(arg1, "ArrayBufferData"):
            # 22.2.4.4 TypedArray ( object )
            # This description applies only if the TypedArray function is called with at least one argument and the
            # Type of the first argument is Object and that object does not have either a [[TypedArrayName]] or an
            # [[ArrayBufferData]] internal slot.
            #
            # TypedArray called with argument object performs the following steps:
            #   1. Assert: Type(object) is Object and object does not have either a [[TypedArrayName]] or an
            #      [[ArrayBufferData]] internal slot.
            #   2. If NewTarget is undefined, throw a TypeError exception.
            #   3. Let constructorName be the String value of the Constructor Name value specified in Table 59 for
            #      this TypedArray constructor.
            #   4. Let O be ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%").
            #   5. Let usingIterator be ? GetMethod(object, @@iterator).
            #   6. If usingIterator is not undefined, then
            #       a. Let values be ? IterableToList(object, usingIterator).
            #       b. Let len be the number of elements in values.
            #       c. Perform ? AllocateTypedArrayBuffer(O, len).
            #       d. Let k be 0.
            #       e. Repeat, while k < len
            #           i. Let Pk be ! ToString(k).
            #           ii. Let kValue be the first element of values and remove that element from values.
            #           iii. Perform ? Set(O, Pk, kValue, true).
            #           iv. Increase k by 1.
            #       f. Assert: values is now an empty List.
            #       g. Return O.
            #   7. NOTE: object is not an Iterable so assume it is already an array-like object.
            #   8. Let arrayLike be object.
            #   9. Let len be ? ToLength(? Get(arrayLike, "length")).
            #   10. Perform ? AllocateTypedArrayBuffer(O, len).
            #   11. Let k be 0.
            #   12. Repeat, while k < len
            #       a. Let Pk be ! ToString(k).
            #       b. Let kValue be ? Get(arrayLike, Pk).
            #       c. Perform ? Set(O, Pk, kValue, true).
            #       d. Increase k by 1.
            #   13. Return O.
            assert isObject(arg1) and not hasattr(arg1, "ArrayBufferData") and not hasattr(arg1, "TypedArrayName")
            if new_target is None:
                raise ESTypeError(f"{name}() must be used with the 'new' operator")
            constructorName = name
            O = AllocateTypedArray(constructorName, new_target, f"%{name}prototype%")
            usingIterator = GetMethod(arg1, wks_iterator)
            if usingIterator is not None:
                values = IterableToList(arg1, usingIterator)
                AllocateTypedArrayBuffer(O, len(values))
                for k, kValue in enumerate(values):
                    Set(O, ToString(k), kValue, True)
                return O
            arrayLike = arg1
            len_ = ToLength(Get(arrayLike, "length"))
            AllocateTypedArrayBuffer(O, len_)
            for Pk in (ToString(k) for k in range(len_)):
                kValue = Get(arrayLike, Pk)
                Set(O, Pk, kValue, True)
            return O

        # 22.2.4.5 TypedArray ( buffer [ , byteOffset [ , length ] ] )
        # This description applies only if the TypedArray function is called with at least one argument and the Type
        # of the first argument is Object and that object has an [[ArrayBufferData]] internal slot.
        #
        # TypedArray called with at least one argument buffer performs the following steps:
        #   1. Assert: Type(buffer) is Object and buffer has an [[ArrayBufferData]] internal slot.
        #   2. If NewTarget is undefined, throw a TypeError exception.
        #   3. Let constructorName be the String value of the Constructor Name value specified in Table 59 for this
        #      TypedArray constructor.
        #   4. Let O be ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%").
        #   5. Let elementSize be the Number value of the Element Size value in Table 59 for constructorName.
        #   6. Let offset be ? ToIndex(byteOffset).
        #   7. If offset modulo elementSize ≠ 0, throw a RangeError exception.
        #   8. If length is present and length is not undefined, then
        #       a. Let newLength be ? ToIndex(length).
        #   9. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
        #   10. Let bufferByteLength be buffer.[[ArrayBufferByteLength]].
        #   11. If length is either not present or undefined, then
        #       a. If bufferByteLength modulo elementSize ≠ 0, throw a RangeError exception.
        #       b. Let newByteLength be bufferByteLength - offset.
        #       c. If newByteLength < 0, throw a RangeError exception.
        #   12. Else,
        #       a. Let newByteLength be newLength × elementSize.
        #       b. If offset + newByteLength > bufferByteLength, throw a RangeError exception.
        #   13. Set O.[[ViewedArrayBuffer]] to buffer.
        #   14. Set O.[[ByteLength]] to newByteLength.
        #   15. Set O.[[ByteOffset]] to offset.
        #   16. Set O.[[ArrayLength]] to newByteLength / elementSize.
        #   17. Return O.
        assert isObject(arg1) and hasattr(arg1, "ArrayBufferData")
        if new_target is None:
            raise ESTypeError(f"{name}() must be used with the 'new' operator")
        O = AllocateTypedArray(name, new_target, f"%{name}Prototype%")
        elementSize = TA_ElementSize[name]
        offset = ToIndex(byteOffset)
        if offset % elementSize != 0:
            raise ESRangeError(f"Bad offset in {name} constructor: {offset} not a modulo of {elementSize}")
        if length is not None:
            newLength = ToIndex(length)
        if IsDetachedBuffer(arg1):
            raise ESTypeError(f"Can't make a new {name} with a detached buffer")
        bufferByteLength = arg1.ArrayBufferByteLength
        if length is None:
            if bufferByteLength % elementSize != 0:
                raise ESRangeError(
                    f"Can't make a new {name}: buffer byte length ({bufferByteLength}) isn't a multiple of the element size ({elementSize})"
                )
            newByteLength = bufferByteLength - offset
            if newByteLength < 0:
                raise ESRangeError(
                    f"Can't make a new {name}: offset ({offset}) greater than source size ({bufferByteLength})"
                )
        else:
            newByteLength = newLength * elementSize
            if offset + newByteLength > bufferByteLength:
                raise ESRangeError(f"Can't make a new {name}: off the end")
        O.ViewedArrayBuffer = arg1
        O.ByteLength = newByteLength
        O.ByteOffset = offset
        O.ArrayLength = newByteLength / elementSize
        return O

    SpecificTypedArray.length = 3
    SpecificTypedArray.name = name
    return SpecificTypedArray


# 22.2.4.2.1 Runtime Semantics: AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] )
def AllocateTypedArray(constructorName, newTarget, defaultProto, length=...):
    # The abstract operation AllocateTypedArray with arguments constructorName, newTarget, defaultProto and optional
    # argument length is used to validate and create an instance of a TypedArray constructor. constructorName is
    # required to be the name of a TypedArray constructor in Table 59. If the length argument is passed, an
    # ArrayBuffer of that length is also allocated and associated with the new TypedArray instance.
    # AllocateTypedArray provides common semantics that is used by all of the TypedArray overloads.
    # AllocateTypedArray performs the following steps:
    #   1. Let proto be ? GetPrototypeFromConstructor(newTarget, defaultProto).
    #   2. Let obj be IntegerIndexedObjectCreate(proto, « [[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]],
    #      [[ByteOffset]], [[ArrayLength]] »).
    #   3. Assert: obj.[[ViewedArrayBuffer]] is undefined.
    #   4. Set obj.[[TypedArrayName]] to constructorName.
    #   5. If length is not present, then
    #       a. Set obj.[[ByteLength]] to 0.
    #       b. Set obj.[[ByteOffset]] to 0.
    #       c. Set obj.[[ArrayLength]] to 0.
    #   6. Else,
    #       a. Perform ? AllocateTypedArrayBuffer(obj, length).
    #   7. Return obj.
    proto = GetPrototypeFromConstructor(newTarget, defaultProto)
    obj = IntegerIndexedObjectCreate(
        proto, ["ViewedArrayBuffer", "TypedArrayName", "ByteLength", "ByteOffset", "ArrayLength"]
    )
    assert obj.ViewedArrayBuffer is None
    obj.TypedArrayName = constructorName
    if length is Ellipsis:
        obj.ByteLength = 0
        obj.ByteOffset = 0
        obj.ArrayLength = 0
    else:
        AllocateTypedArrayBuffer(obj, length)
    return obj


# 22.2.4.2.2 Runtime Semantics: AllocateTypedArrayBuffer ( O, length )
def AllocateTypedArrayBuffer(O, length):
    # The abstract operation AllocateTypedArrayBuffer with arguments O and length allocates and associates an
    # ArrayBuffer with the TypedArray instance O. It performs the following steps:
    #   1. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
    #   2. Assert: O.[[ViewedArrayBuffer]] is undefined.
    #   3. Assert: length ≥ 0.
    #   4. Let constructorName be the String value of O.[[TypedArrayName]].
    #   5. Let elementSize be the Element Size value in Table 59 for constructorName.
    #   6. Let byteLength be elementSize × length.
    #   7. Let data be ? AllocateArrayBuffer(%ArrayBuffer%, byteLength).
    #   8. Set O.[[ViewedArrayBuffer]] to data.
    #   9. Set O.[[ByteLength]] to byteLength.
    #   10. Set O.[[ByteOffset]] to 0.
    #   11. Set O.[[ArrayLength]] to length.
    #   12. Return O.
    assert isObject(O) and hasattr(O, "ViewedArrayBuffer")
    assert O.ViewedArrayBuffer is None
    assert length >= 0
    constructorName = O.TypedArrayName
    elementSize = TA_ElementSize[constructorName]
    byteLength = elementSize * length
    data = AllocateArrayBuffer(surrounding_agent.running_ec.realm.intrinsics["%ArrayBuffer%"], byteLength)
    O.ViewedArrayBuffer = data
    O.ByteLength = byteLength
    O.ByteOffset = 0
    O.ArrayLength = length
    return O


# 22.2.4.6 TypedArrayCreate ( constructor, argumentList )
def TypedArrayCreate(constructor, argumentList):
    # The abstract operation TypedArrayCreate with arguments constructor and argumentList is used to specify the
    # creation of a new TypedArray object using a constructor function. It performs the following steps:
    #   1. Let newTypedArray be ? Construct(constructor, argumentList).
    #   2. Perform ? ValidateTypedArray(newTypedArray).
    #   3. If argumentList is a List of a single Number, then
    #       a. If newTypedArray.[[ArrayLength]] < argumentList[0], throw a TypeError exception.
    #   4. Return newTypedArray.
    newTypedArray = Construct(constructor, argumentList)
    ValidateTypedArray(newTypedArray, "TypedArrayCreate")
    if len(argumentList) == 1 and isNumber(argumentList[0]) and newTypedArray.ArrayLength < argumentList[0]:
        raise ESTypeError("Bad size in TypedArrayCreate")
    return newTypedArray


# 22.2.4.7 TypedArraySpeciesCreate ( exemplar, argumentList )
def TypedArraySpeciesCreate(exemplar, argumentList):
    # The abstract operation TypedArraySpeciesCreate with arguments exemplar and argumentList is used to specify
    # the creation of a new TypedArray object using a constructor function that is derived from exemplar. It
    # performs the following steps:
    #   1. Assert: exemplar is an Object that has a [[TypedArrayName]] internal slot.
    #   2. Let defaultConstructor be the intrinsic object listed in column one of Table 59 for
    #      exemplar.[[TypedArrayName]].
    #   3. Let constructor be ? SpeciesConstructor(exemplar, defaultConstructor).
    #   4. Return ? TypedArrayCreate(constructor, argumentList).
    assert isObject(exemplar) and hasattr(exemplar, "TypedArrayName")
    defaultConstructor = surrounding_agent.running_ec.realm.intrinsics[f"%{exemplar.TypedArrayName}%"]
    constructor = SpeciesConstructor(exemplar, defaultConstructor)
    return TypedArrayCreate(constructor, argumentList)


def CreateSpecificTypedArrayPrototype(realm: Realm, name: str):
    proto = ObjectCreate(realm.intrinsics["%TypedArrayPrototype%"])
    DefinePropertyOrThrow(
        proto,
        "BYTES_PER_ELEMENT",
        PropertyDescriptor(value=TA_ElementSize[name], writable=False, enumerable=False, configurable=False),
    )
    return proto


def SpecificTypedArrayFixups(realm: Realm, name: str):
    proto = realm.intrinsics[f"%{name}Prototype%"]
    cstr = realm.intrinsics[f"%{name}%"]
    DefinePropertyOrThrow(proto, "constructor", PropertyDescriptor(value=cstr))
    DefinePropertyOrThrow(
        cstr, "prototype", PropertyDescriptor(value=proto, writable=False, enumerable=False, configurable=False)
    )


######################################################################################################################
# 24 Structured Data
######################################################################################################################

############################################################################################################################################################################################################
#
#  .d8888b.      d8888       d888              d8888                                   888888b.             .d888  .d888                       .d88888b.  888         d8b                   888
# d88P  Y88b    d8P888      d8888             d88888                                   888  "88b           d88P"  d88P"                       d88P" "Y88b 888         Y8P                   888
#        888   d8P 888        888            d88P888                                   888  .88P           888    888                         888     888 888                               888
#      .d88P  d8P  888        888           d88P 888 888d888 888d888  8888b.  888  888 8888888K.  888  888 888888 888888  .d88b.  888d888     888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  .od888P"  d88   888        888          d88P  888 888P"   888P"       "88b 888  888 888  "Y88b 888  888 888    888    d8P  Y8b 888P"       888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# d88P"      8888888888       888         d88P   888 888     888     .d888888 888  888 888    888 888  888 888    888    88888888 888         888     888 888  888    888 88888888 888      888    "Y8888b.
# 888"             888  d8b   888        d8888888888 888     888     888  888 Y88b 888 888   d88P Y88b 888 888    888    Y8b.     888         Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888888888        888  Y8P 8888888     d88P     888 888     888     "Y888888  "Y88888 8888888P"   "Y88888 888    888     "Y8888  888          "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                  888                                                                                888
#                                                                             Y8b d88P                                                                               d88P
#                                                                              "Y88P"                                                                              888P"
#
############################################################################################################################################################################################################
# 24.1 ArrayBuffer Objects

# 24.1.1 Abstract Operations For ArrayBuffer Objects

# 24.1.1.1 AllocateArrayBuffer ( constructor, byteLength )
def AllocateArrayBuffer(constructor, byteLength):
    # The abstract operation AllocateArrayBuffer with arguments constructor and byteLength is used to create an
    # ArrayBuffer object. It performs the following steps:
    #
    #   1. Let obj be ? OrdinaryCreateFromConstructor(constructor, "%ArrayBufferPrototype%", « [[ArrayBufferData]],
    #      [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »).
    #   2. Assert: byteLength is an integer value ≥ 0.
    #   3. Let block be ? CreateByteDataBlock(byteLength).
    #   4. Set obj.[[ArrayBufferData]] to block.
    #   5. Set obj.[[ArrayBufferByteLength]] to byteLength.
    #   6. Return obj.
    obj = OrdinaryCreateFromConstructor(
        constructor, "%ArrayBufferPrototype%", ["ArrayBufferData", "ArrayBufferByteLength", "ArrayBufferDetachKey"]
    )
    assert IsInteger(byteLength) and byteLength >= 0
    block = CreateByteDataBlock(byteLength)
    obj.ArrayBufferData = block
    obj.ArrayBufferByteLength = byteLength
    return obj


# 24.1.1.2 IsDetachedBuffer ( arrayBuffer )
def IsDetachedBuffer(arrayBuffer):
    # The abstract operation IsDetachedBuffer with argument arrayBuffer performs the following steps:
    #
    #   1. Assert: Type(arrayBuffer) is Object and it has an [[ArrayBufferData]] internal slot.
    #   2. If arrayBuffer.[[ArrayBufferData]] is null, return true.
    #   3. Return false.
    assert isObject(arrayBuffer) and hasattr(arrayBuffer, "ArrayBufferData")
    return isNull(arrayBuffer.ArrayBufferData)


# 24.1.1.3 DetachArrayBuffer ( arrayBuffer [ , key ] )
def DetachArrayBuffer(arrayBuffer, key=None):
    # The abstract operation DetachArrayBuffer with argument arrayBuffer and optional argument key performs the
    # following steps:
    #
    #   1. Assert: Type(arrayBuffer) is Object and it has [[ArrayBufferData]], [[ArrayBufferByteLength]], and
    #      [[ArrayBufferDetachKey]] internal slots.
    #   2. Assert: IsSharedArrayBuffer(arrayBuffer) is false.
    #   3. If key is not present, set key to undefined.
    #   4. If SameValue(arrayBuffer.[[ArrayBufferDetachKey]], key) is false, throw a TypeError exception.
    #   5. Set arrayBuffer.[[ArrayBufferData]] to null.
    #   6. Set arrayBuffer.[[ArrayBufferByteLength]] to 0.
    #   7. Return NormalCompletion(null).
    assert isObject(arrayBuffer) and all(
        hasattr(arrayBuffer, x) for x in ("ArrayBufferData", "ArrayBufferByteLength", "ArrayBufferDetachKey")
    )
    assert not IsSharedArrayBuffer(arrayBuffer)
    if not SameValue(arrayBuffer.ArrayBufferDetachKey, key):
        raise ESTypeError("Bad key for arraybuffer detach")
    arrayBuffer.ArrayBufferData = JSNull.NULL
    arrayBuffer.ArrayBufferByteLength = 0
    return JSNull.NULL
    # NOTE
    # Detaching an ArrayBuffer instance disassociates the Data Block used as its backing store from the instance and
    # sets the byte length of the buffer to 0. No operations defined by this specification use the DetachArrayBuffer
    # abstract operation. However, an ECMAScript implementation or host environment may define such operations.


# 24.1.1.4 CloneArrayBuffer ( srcBuffer, srcByteOffset, srcLength, cloneConstructor )
def CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor):
    # The abstract operation CloneArrayBuffer takes four parameters, an ArrayBuffer srcBuffer, an integer offset
    # srcByteOffset, an integer length srcLength, and a constructor function cloneConstructor. It creates a new
    # ArrayBuffer whose data is a copy of srcBuffer's data over the range starting at srcByteOffset and continuing for
    # srcLength bytes. This operation performs the following steps:
    #
    #   1. Assert: Type(srcBuffer) is Object and it has an [[ArrayBufferData]] internal slot.
    #   2. Assert: IsConstructor(cloneConstructor) is true.
    #   3. Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).
    #   4. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.
    #   5. Let srcBlock be srcBuffer.[[ArrayBufferData]].
    #   6. Let targetBlock be targetBuffer.[[ArrayBufferData]].
    #   7. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength).
    #   8. Return targetBuffer.
    assert isObject(srcBuffer) and hasattr(srcBuffer, "ArrayBufferData")
    assert IsConstructor(cloneConstructor)
    targetBuffer = AllocateArrayBuffer(cloneConstructor, srcLength)
    if IsDetachedBuffer(srcBuffer):
        raise ESTypeError("Cannot clone a detached buffer")
    srcBlock = srcBuffer.ArrayBufferData
    targetBlock = targetBuffer.ArrayBufferData
    CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength)
    return targetBuffer


type_sizes = {
    "Int8": 1,
    "Uint8": 1,
    "Uint8C": 1,
    "Int16": 2,
    "Uint16": 2,
    "Int32": 4,
    "Uint32": 4,
    "Float32": 4,
    "Float64": 8,
}
conversion_ops = {
    "Int8": ToInt8,
    "Uint8": ToUint8,
    "Uint8C": ToUint8Clamp,
    "Int16": ToInt16,
    "Uint16": ToUint16,
    "Int32": ToInt32,
    "Uint32": ToUint32,
}

# 24.1.1.5 RawBytesToNumber ( type, rawBytes, isLittleEndian )
def RawBytesToNumber(type, rawBytes, isLittleEndian):
    # The abstract operation RawBytesToNumber takes three parameters, a String type, a List rawBytes, and a Boolean
    # isLittleEndian. This operation performs the following steps:
    #
    #   1. Let elementSize be the Number value of the Element Size value specified in Table 56 for Element Type type.
    #   2. If isLittleEndian is false, reverse the order of the elements of rawBytes.
    #   3. If type is "Float32", then
    #       a. Let value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string
    #          encoding of an IEEE 754-2008 binary32 value.
    #       b. If value is an IEEE 754-2008 binary32 NaN value, return the NaN Number value.
    #       c. Return the Number value that corresponds to value.
    #   4. If type is "Float64", then
    #       a. Let value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string
    #          encoding of an IEEE 754-2008 binary64 value.
    #       b. If value is an IEEE 754-2008 binary64 NaN value, return the NaN Number value.
    #       c. Return the Number value that corresponds to value.
    #   5. If the first code unit of type is the code unit 0x0055 (LATIN CAPITAL LETTER U), then
    #       a. Let intValue be the byte elements of rawBytes concatenated and interpreted as a bit string encoding of
    #          an unsigned little-endian binary number.
    #   6. Else,
    #       a. Let intValue be the byte elements of rawBytes concatenated and interpreted as a bit string encoding of
    #          a binary little-endian 2's complement number of bit length elementSize × 8.
    #   7. Return the Number value that corresponds to intValue.
    elementSize = type_sizes.get(type, 1)
    if type.startswith("Float"):
        fmt = (">f", "<f", ">d", "<d")[int(isLittleEndian) + 2 * int(type == "Float64")]
    else:
        fmt = (">B", "<B", ">b", "<b", ">H", "<H", ">h", "<h", ">L", "<L", ">l", "<l")[
            int(isLittleEndian) + 2 * (type.startswith("I")) + 2 * (elementSize & 6)
        ]
    value = struct.unpack(fmt, bytearray(rawBytes))
    return value[0]


# 24.1.1.6 GetValueFromBuffer ( arrayBuffer, byteIndex, type, isTypedArray, order [ , isLittleEndian ] )
def GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order, isLittleEndian=EMPTY):
    # The abstract operation GetValueFromBuffer takes six parameters, an ArrayBuffer or SharedArrayBuffer arrayBuffer,
    # an integer byteIndex, a String type, a Boolean isTypedArray, a String order, and optionally a Boolean
    # isLittleEndian. This operation performs the following steps:
    #
    #   1. Assert: IsDetachedBuffer(arrayBuffer) is false.
    #   2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.
    #   3. Assert: byteIndex is an integer value ≥ 0.
    #   4. Let block be arrayBuffer.[[ArrayBufferData]].
    #   5. Let elementSize be the Number value of the Element Size value specified in Table 56 for Element Type type.
    #   6. If IsSharedArrayBuffer(arrayBuffer) is true, then
    #       a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
    #       b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose
    #          [[AgentSignifier]] is AgentSignifier().
    #       c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear
    #          be true; otherwise let noTear be false.
    #       d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
    #       e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the
    #          underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe
    #          observable behaviour of hardware with weak consistency.
    #       f. Let readEvent be ReadSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block,
    #          [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
    #       g. Append readEvent to eventList.
    #       h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to
    #          execution.[[ChosenValues]].
    #   7. Else, let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting
    #      with block[byteIndex].
    #   8. If isLittleEndian is not present, set isLittleEndian to the value of the [[LittleEndian]] field of the
    #      surrounding agent's Agent Record.
    #   9. Return RawBytesToNumber(type, rawValue, isLittleEndian).
    assert not IsDetachedBuffer(arrayBuffer)
    assert IsInteger(byteIndex) and byteIndex >= 0
    byteIndex = int(byteIndex)
    elementSize = type_sizes.get(type, 1)
    block = arrayBuffer.ArrayBufferData
    assert byteIndex + elementSize <= block.nbytes
    if IsSharedArrayBuffer(arrayBuffer):
        raise NotImplementedError("Need shared buffer support")
    else:
        rawValue = block[byteIndex : byteIndex + elementSize]
    if isLittleEndian == EMPTY:
        isLittleEndian = surrounding_agent.agent_record.little_endian
    return RawBytesToNumber(type, rawValue, isLittleEndian)


# 24.1.1.7 NumberToRawBytes ( type, value, isLittleEndian )
def NumberToRawBytes(type, value, isLittleEndian):
    # The abstract operation NumberToRawBytes takes three parameters, a String type, a Number value, and a Boolean
    # isLittleEndian. This operation performs the following steps:
    #
    #   1. If type is "Float32", then
    #       a. Let rawBytes be a List containing the 4 bytes that are the result of converting value to IEEE 754-2008
    #          binary32 format using “Round to nearest, ties to even” rounding mode. If isLittleEndian is false, the
    #          bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If
    #          value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2008 binary32 format
    #          Not-a-Number encoding. An implementation must always choose the same encoding for each implementation
    #          distinguishable NaN value.
    #   2. Else if type is "Float64", then
    #       a. Let rawBytes be a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of
    #          value. If isLittleEndian is false, the bytes are arranged in big endian order. Otherwise, the bytes are
    #          arranged in little endian order. If value is NaN, rawBytes may be set to any implementation chosen IEEE
    #          754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding
    #          for each implementation distinguishable NaN value.
    #   3. Else,
    #       a. Let n be the Number value of the Element Size specified in Table 56 for Element Type type.
    #       b. Let convOp be the abstract operation named in the Conversion Operation column in Table 56 for Element
    #          Type type.
    #       c. Let intValue be convOp(value).
    #       d. If intValue ≥ 0, then
    #           i. Let rawBytes be a List containing the n-byte binary encoding of intValue. If isLittleEndian is
    #              false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian
    #              order.
    #       e. Else,
    #           i. Let rawBytes be a List containing the n-byte binary 2's complement encoding of intValue. If
    #              isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered
    #              in little endian order.
    #   4. Return rawBytes.
    if type.startswith("F"):
        fmt = (">f", "<f", ">d", "<d")[int(isLittleEndian) + 2 * int(type == "Float64")]
        return struct.pack(fmt, value)
    intValue = conversion_ops[type](value)
    elementSize = type_sizes[type]
    fmt = (">b", "<b", ">B", "<B", ">h", "<h", ">H", "<H", ">l", "<l", ">L", "<L")[
        int(isLittleEndian) + 2 * int(type.startswith("U")) + 2 * (elementSize & 6)
    ]
    return struct.pack(fmt, intValue)


# 24.1.1.8 SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isTypedArray, order [ , isLittleEndian ] )
def SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order, isLittleEndian=EMPTY):
    # The abstract operation SetValueInBuffer takes seven parameters, an ArrayBuffer or SharedArrayBuffer arrayBuffer,
    # an integer byteIndex, a String type, a Number value, a Boolean isTypedArray, a String order, and optionally a
    # Boolean isLittleEndian. This operation performs the following steps:
    #
    #   1. Assert: IsDetachedBuffer(arrayBuffer) is false.
    #   2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.
    #   3. Assert: byteIndex is an integer value ≥ 0.
    #   4. Assert: Type(value) is Number.
    #   5. Let block be arrayBuffer.[[ArrayBufferData]].
    #   6. Let elementSize be the Number value of the Element Size value specified in Table 56 for Element Type type.
    #   7. If isLittleEndian is not present, set isLittleEndian to the value of the [[LittleEndian]] field of the
    #      surrounding agent's Agent Record.
    #   8. Let rawBytes be NumberToRawBytes(type, value, isLittleEndian).
    #   9. If IsSharedArrayBuffer(arrayBuffer) is true, then
    #       a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
    #       b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose
    #          [[AgentSignifier]] is AgentSignifier().
    #       c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear
    #          be true; otherwise let noTear be false.
    #       d. Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block,
    #          [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
    #   10. Else, store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
    #   11. Return NormalCompletion(undefined).
    assert not IsDetachedBuffer(arrayBuffer)
    assert IsInteger(byteIndex) and byteIndex >= 0
    byteIndex = int(byteIndex)
    elementSize = type_sizes[type]
    block = arrayBuffer.ArrayBufferData
    assert byteIndex + elementSize <= block.nbytes
    assert isNumber(value)
    if isLittleEndian == EMPTY:
        isLittleEndian = surrounding_agent.agent_record.little_endian
    rawBytes = NumberToRawBytes(type, value, isLittleEndian)
    if IsSharedArrayBuffer(arrayBuffer):
        raise NotImplementedError("Shared Array Data support required")
    else:
        block[byteIndex : byteIndex + elementSize] = bytearray(rawBytes)


# 24.1.2 The ArrayBuffer Constructor
# The ArrayBuffer constructor:
#
# * is the intrinsic object %ArrayBuffer%.
# * is the initial value of the ArrayBuffer property of the global object.
# * creates and initializes a new ArrayBuffer object when called as a constructor.
# * is not intended to be called as a function and will throw an exception when called in that manner.
# * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#   constructors that intend to inherit the specified ArrayBuffer behaviour must include a super call to the
#   ArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support
#   the ArrayBuffer.prototype built-in methods.


def CreateArrayBufferConstructor(realm):
    obj = CreateBuiltinFunction(ArrayBufferFunction, ["Construct"], realm=realm)
    for key, value in [("length", 1), ("name", "ArrayBuffer")]:
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    BindBuiltinFunctions(realm, obj, [("isView", ArrayBuffer_isView, 1)])
    # 24.1.3.3 get ArrayBuffer [ @@species ]
    # ArrayBuffer[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function
    # performs the following steps:
    #
    #   1. Return the this value.
    #
    # The value of the name property of this function is "get [Symbol.species]".
    #
    # NOTE
    # ArrayBuffer prototype methods normally use their this object's constructor to create a derived object. However, a
    # subclass constructor may over-ride that default behaviour by redefining its @@species property.
    def get_species(this_value, new_target, *_):
        return this_value

    fcn_obj = CreateBuiltinFunction(get_species, [], realm)
    DefinePropertyOrThrow(
        fcn_obj, "length", PropertyDescriptor(value=0, writable=False, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        fcn_obj,
        "name",
        PropertyDescriptor(value="get [Symbol.species]", writable=False, enumerable=False, configurable=True),
    )
    DefinePropertyOrThrow(obj, wks_species, PropertyDescriptor(Get=fcn_obj, enumerable=False, configurable=True))
    return obj


# 24.1.2.1 ArrayBuffer ( length )
def ArrayBufferFunction(this_value, new_target, length=None, *_):
    # When the ArrayBuffer function is called with argument length, the following steps are taken:
    #
    # If NewTarget is undefined, throw a TypeError exception.
    # Let byteLength be ? ToIndex(length).
    # Return ? AllocateArrayBuffer(NewTarget, byteLength).
    if new_target is None:
        raise ESTypeError("The ArrayBuffer constructor may not be called as a function")
    return AllocateArrayBuffer(new_target, ToIndex(length))


# 24.1.3.1 ArrayBuffer.isView ( arg )
def ArrayBuffer_isView(this_value, new_target, arg=None, *_):
    # The isView function takes one argument arg, and performs, the following steps are taken:
    #
    #   1. If Type(arg) is not Object, return false.
    #   2. If arg has a [[ViewedArrayBuffer]] internal slot, return true.
    #   3. Return false.
    return isObject(arg) and hasattr(arg, "ViewedArrayBuffer")


# 24.1.4 Properties of the ArrayBuffer Prototype Object
# The ArrayBuffer prototype object:
#
# * is the intrinsic object %ArrayBufferPrototype%.
# * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
# * is an ordinary object.
# * does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.


def CreateArrayBufferPrototype(realm):
    proto = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    BindBuiltinFunctions(realm, proto, [("slice", ArrayBufferPrototype_slice, 2)])
    byteLength = CreateBuiltinFunction(get_ArrayBufferPrototype_byteLength, [], realm)
    DefinePropertyOrThrow(
        byteLength, "length", PropertyDescriptor(value=0, writable=False, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        byteLength,
        "name",
        PropertyDescriptor(value="get byteLength", writable=False, enumerable=False, configurable=True),
    )
    DefinePropertyOrThrow(
        proto, "byteLength", PropertyDescriptor(Get=byteLength, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        proto,
        wks_to_string_tag,
        PropertyDescriptor(value="ArrayBuffer", writable=False, enumerable=False, configurable=True),
    )
    return proto


# 24.1.4.1 get ArrayBuffer.prototype.byteLength
def get_ArrayBufferPrototype_byteLength(this_value, new_target, *_):
    # ArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is undefined. Its get
    # accessor function performs the following steps:
    #
    #   1. Let O be the this value.
    #   2. If Type(O) is not Object, throw a TypeError exception.
    #   3. If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.
    #   4. If IsSharedArrayBuffer(O) is true, throw a TypeError exception.
    #   5. If IsDetachedBuffer(O) is true, throw a TypeError exception.
    #   6. Let length be O.[[ArrayBufferByteLength]].
    #   7. Return length.
    if not isObject(this_value) or not hasattr(this_value, "ArrayBufferData"):
        raise ESTypeError("byteLength called with bad object")
    if IsSharedArrayBuffer(this_value):
        raise ESTypeError("byteLength not allowed on shared buffers")
    if IsDetachedBuffer(this_value):
        raise ESTypeError("byteLength not allowed on detached buffers")
    return this_value.ArrayBufferByteLength


# 24.1.4.3 ArrayBuffer.prototype.slice ( start, end )
def ArrayBufferPrototype_slice(this_value, new_target, start=None, end=None, *_):
    # The following steps are taken:
    #
    #   1. Let O be the this value.
    #   2. If Type(O) is not Object, throw a TypeError exception.
    #   3. If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.
    #   4. If IsSharedArrayBuffer(O) is true, throw a TypeError exception.
    #   5. If IsDetachedBuffer(O) is true, throw a TypeError exception.
    #   6. Let len be O.[[ArrayBufferByteLength]].
    #   7. Let relativeStart be ? ToInteger(start).
    #   8. If relativeStart < 0, let first be max((len + relativeStart), 0); else let first be min(relativeStart, len).
    #   9. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).
    #   10. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).
    #   11. Let newLen be max(final-first, 0).
    #   12. Let ctor be ? SpeciesConstructor(O, %ArrayBuffer%).
    #   13. Let new be ? Construct(ctor, « newLen »).
    #   14. If new does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.
    #   15. If IsSharedArrayBuffer(new) is true, throw a TypeError exception.
    #   16. If IsDetachedBuffer(new) is true, throw a TypeError exception.
    #   17. If SameValue(new, O) is true, throw a TypeError exception.
    #   18. If new.[[ArrayBufferByteLength]] < newLen, throw a TypeError exception.
    #   19. NOTE: Side-effects of the above steps may have detached O.
    #   20. If IsDetachedBuffer(O) is true, throw a TypeError exception.
    #   21. Let fromBuf be O.[[ArrayBufferData]].
    #   22. Let toBuf be new.[[ArrayBufferData]].
    #   23. Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen).
    #   24. Return new.
    if (
        not isObject(this_value)
        or not hasattr(this_value, "ArrayBufferData")
        or IsSharedArrayBuffer(this_value)
        or IsDetachedBuffer(this_value)
    ):
        raise ESTypeError("Improper object for slice")
    length = this_value.ArrayBufferByteLength
    relativeStart = ToInteger(start)
    if relativeStart < 0:
        first = max(length + relativeStart, 0)
    else:
        first = min(relativeStart, length)
    if end is None:
        relativeEnd = length
    else:
        relativeEnd = ToInteger(end)
    if relativeEnd < 0:
        final = max(len + relativeEnd, 0)
    else:
        final = min(relativeEnd, length)
    newLen = max(final - first, 0)
    ctor = SpeciesConstructor(this_value, surrounding_agent.running_ec.realm.intrinsics["%ArrayBuffer%"])
    newobj = Construct(ctor, [newLen])
    if (
        not hasattr(newobj, "ArrayBufferData")
        or IsSharedArrayBuffer(newobj)
        or IsDetachedBuffer(newobj)
        or SameValue(newobj, this_value)
        or newobj.ArrayBufferByteLength < newLen
        or IsDetachedBuffer(this_value)
    ):
        raise ESTypeError("Bad ArrayBuffer constructor")
    fromBuf = this_value.ArrayBufferData
    toBuf = newobj.ArrayBufferData
    CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen)
    return newobj


def ArrayBufferFixups(realm):
    constructor = realm.intrinsics["%ArrayBuffer%"]
    prototype = realm.intrinsics["%ArrayBufferPrototype%"]
    DefinePropertyOrThrow(
        constructor,
        "prototype",
        PropertyDescriptor(value=prototype, writable=False, enumerable=False, configurable=False),
    )
    DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor(value=constructor))


######################################################################################################################################################################################################################################################################
#
#  .d8888b.      d8888       .d8888b.       .d8888b.  888                                     888        d8888                                   888888b.             .d888  .d888                       .d88888b.  888         d8b                   888
# d88P  Y88b    d8P888      d88P  Y88b     d88P  Y88b 888                                     888       d88888                                   888  "88b           d88P"  d88P"                       d88P" "Y88b 888         Y8P                   888
#        888   d8P 888             888     Y88b.      888                                     888      d88P888                                   888  .88P           888    888                         888     888 888                               888
#      .d88P  d8P  888           .d88P      "Y888b.   88888b.   8888b.  888d888  .d88b.   .d88888     d88P 888 888d888 888d888  8888b.  888  888 8888888K.  888  888 888888 888888  .d88b.  888d888     888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  .od888P"  d88   888       .od888P"          "Y88b. 888 "88b     "88b 888P"   d8P  Y8b d88" 888    d88P  888 888P"   888P"       "88b 888  888 888  "Y88b 888  888 888    888    d8P  Y8b 888P"       888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# d88P"      8888888888     d88P"                "888 888  888 .d888888 888     88888888 888  888   d88P   888 888     888     .d888888 888  888 888    888 888  888 888    888    88888888 888         888     888 888  888    888 88888888 888      888    "Y8888b.
# 888"             888  d8b 888"           Y88b  d88P 888  888 888  888 888     Y8b.     Y88b 888  d8888888888 888     888     888  888 Y88b 888 888   d88P Y88b 888 888    888    Y8b.     888         Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888888888        888  Y8P 888888888       "Y8888P"  888  888 "Y888888 888      "Y8888   "Y88888 d88P     888 888     888     "Y888888  "Y88888 8888888P"   "Y88888 888    888     "Y8888  888          "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                                                            888                                                                                888
#                                                                                                                                       Y8b d88P                                                                               d88P
#                                                                                                                                        "Y88P"                                                                              888P"
#
######################################################################################################################################################################################################################################################################
# 24.2 SharedArrayBuffer Objects

# 24.2.1.2 IsSharedArrayBuffer ( obj )
def IsSharedArrayBuffer(obj):
    # IsSharedArrayBuffer tests whether an object is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either. It
    # performs the following steps:
    #
    #   1. Assert: Type(obj) is Object and it has an [[ArrayBufferData]] internal slot.
    #   2. Let bufferData be obj.[[ArrayBufferData]].
    #   3. If bufferData is null, return false.
    #   4. If bufferData is a Data Block, return false.
    #   5. Assert: bufferData is a Shared Data Block.
    #   6. Return true.
    assert isObject(obj) and hasattr(obj, "ArrayBufferData")
    bufferData = obj.ArrayBufferData
    if isNull(bufferData):
        return False
    if isinstance(bufferData, memoryview):
        return False
    assert "bufferData is a Shared Data Block"
    return True


"""
 .d8888b.  888888888       d888       8888888 888                              888    d8b
d88P  Y88b 888            d8888         888   888                              888    Y8P
       888 888              888         888   888                              888
     .d88P 8888888b.        888         888   888888  .d88b.  888d888  8888b.  888888 888  .d88b.  88888b.
 .od888P"       "Y88b       888         888   888    d8P  Y8b 888P"       "88b 888    888 d88""88b 888 "88b
d88P"             888       888         888   888    88888888 888     .d888888 888    888 888  888 888  888
888"       Y88b  d88P d8b   888         888   Y88b.  Y8b.     888     888  888 Y88b.  888 Y88..88P 888  888
888888888   "Y8888P"  Y8P 8888888     8888888  "Y888  "Y8888  888     "Y888888  "Y888 888  "Y88P"  888  888



25.1 Iteration
25.1.1 Common Iteration Interfaces
25.1.2 The %IteratorPrototype% Object
25.1.3 The %AsyncIteratorPrototype% Object
25.1.4 Async-from-Sync Iterator Objects
"""

# 25.1.1 Common Iteration Interfaces
#
# An interface is a set of property keys whose associated values match a specific specification. Any object that
# provides all the properties as described by an interface's specification conforms to that interface. An interface is
# not represented by a distinct object. There may be many separately implemented objects that conform to any interface.
# An individual object may conform to multiple interfaces.
#
# 25.1.1.1 The Iterable Interface
#
# The Iterable interface includes the property described in Table 63:
#
# Table 63: Iterable Interface Required Properties
# +-------------+----------------------------+-------------------------------------------------------------+
# | Property    | Value                      | Requirements                                                |
# +-------------+----------------------------+-------------------------------------------------------------+
# | @@iterator  | A function that returns an | The returned object must conform to the Iterator interface. |
# |             | Iterator object.           |                                                             |
# +-------------+----------------------------+-------------------------------------------------------------+
#
# 25.1.1.2 The Iterator Interface
# An object that implements the Iterator interface must include the property in Table 64. Such objects may also
# implement the properties in Table 65.
#
# Table 64: Iterator Interface Required Properties
# +----------+----------------------------+------------------------------------------------------------------------+
# | Property | Value                      | Requirements                                                           |
# +----------+----------------------------+------------------------------------------------------------------------+
# | next     | A function that returns an | The returned object must conform to the IteratorResult interface. If a |
# |          | IteratorResult object.     | previous call to the next method of an Iterator has returned an        |
# |          |                            | IteratorResult object whose done property is true, then all subsequent |
# |          |                            | calls to the next method of that object should also return an          |
# |          |                            | IteratorResult object whose done property is true. However, this       |
# |          |                            | requirement is not enforced.                                           |
# +----------+----------------------------+------------------------------------------------------------------------+
# NOTE 1
# Arguments may be passed to the next function but their interpretation and validity is dependent upon the target
# Iterator. The for-of statement and other common users of Iterators do not pass any arguments, so Iterator objects
# that expect to be used in such a manner must be prepared to deal with being called with no arguments.
#
# Table 65: Iterator Interface Optional Properties
# +----------+----------------------------+------------------------------------------------------------------------+
# | Property | Value                      | Requirements                                                           |
# +----------+----------------------------+------------------------------------------------------------------------+
# | return   | A function that returns an | The returned object must conform to the IteratorResult interface.      |
# |          | IteratorResult object.     | Invoking this method notifies the Iterator object that the caller does |
# |          |                            | not intend to make any more next method calls to the Iterator. The     |
# |          |                            | returned IteratorResult object will typically have a done property     |
# |          |                            | whose value is true, and a value property with the value passed as the |
# |          |                            | argument of the return method. However, this requirement is not        |
# |          |                            | enforced.                                                              |
# +----------+----------------------------+------------------------------------------------------------------------+
# | throw    | A function that returns an | The returned object must conform to the IteratorResult interface.      |
# |          | IteratorResult object.     | Invoking this method notifies the Iterator object that the caller has  |
# |          |                            | detected an error condition. The argument may be used to identify the  |
# |          |                            | error condition and typically will be an exception object. A typical   |
# |          |                            | response is to throw the value passed as the argument. If the method   |
# |          |                            | does not throw, the returned IteratorResult object will typically have |
# |          |                            | a done property whose value is true.                                   |
# +----------+----------------------------+------------------------------------------------------------------------+
# NOTE 2
# Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language
# features including for-of, yield*, and array destructuring call these methods after performing an existence check.
# Most ECMAScript library functions that accept Iterable objects as arguments also conditionally call them.
#
# 25.1.1.3 The AsyncIterable Interface
#
# The AsyncIterable interface includes the properties described in Table 66:
#
# Table 66: AsyncIterable Interface Required Properties
# +-----------------+--------------------------+------------------------------------------------------------------+
# | Property        | Value                    | Requirements                                                     |
# +-----------------+--------------------------+------------------------------------------------------------------+
# | @@asyncIterator | A function that returns  | The returned object must conform to the AsyncIterator interface. |
# |                 | an AsyncIterator object. |                                                                  |
# +-----------------+--------------------------+------------------------------------------------------------------+
#
# 25.1.1.4 The AsyncIterator Interface
#
# An object that implements the AsyncIterator interface must include the properties in Table 67. Such objects may also
# implement the properties in Table 68.
#
# Table 67: AsyncIterator Interface Required Properties
# +----------+-------------------------+------------------------------------------------------------------------------+
# | Property | Value                   | Requirements
# +----------+-------------------------+------------------------------------------------------------------------------+
# | next     | A function that returns | The returned promise, when fulfilled, must fulfill with an object which      |
# |          | a promise for an        | conforms to the IteratorResult interface. If a previous call to the next     |
# |          | IteratorResult object.  | method of an AsyncIterator has returned a promise for an IteratorResult      |
# |          |                         | object whose done property is true, then all subsequent calls to the next    |
# |          |                         | method of that object should also return a promise for an IteratorResult     |
# |          |                         | object whose done property is true. However, this requirement is not         |
# |          |                         | enforced.                                                                    |
# |          |                         |                                                                              |
# |          |                         | Additionally, the IteratorResult object that serves as a fulfillment value   |
# |          |                         | should have a value property whose value is not a promise (or "thenable").   |
# |          |                         | However, this requirement is also not enforced.                              |
# +----------+-------------------------+------------------------------------------------------------------------------+
# NOTE 1
# Arguments may be passed to the next function but their interpretation and validity is dependent upon the target
# AsyncIterator. The for-await-of statement and other common users of AsyncIterators do not pass any arguments, so
# AsyncIterator objects that expect to be used in such a manner must be prepared to deal with being called with no
# arguments.
#
# Table 68: AsyncIterator Interface Optional Properties
# +----------+----------------+---------------------------------------------------------------------------------------+
# | Property | Value          | Requirements                                                                          |
# +----------+----------------+---------------------------------------------------------------------------------------+
# | return   | A function     | The returned promise, when fulfilled, must fulfill with an object which conforms to   |
# |          | that returns   | the IteratorResult interface. Invoking this method notifies the AsyncIterator object  |
# |          | a promise      | that the caller does not intend to make any more next method calls to the             |
# |          | for an         | AsyncIterator. The returned promise will fulfill with an IteratorResult object which  |
# |          | IteratorResult | will typically have a done property whose value is true, and a value property with    |
# |          | object.        | the value passed as the argument of the return method. However, this requirement is   |
# |          |                | not enforced.                                                                         |
# |          |                |                                                                                       |
# |          |                | Additionally, the IteratorResult object that serves as a fulfillment value should     |
# |          |                | have a value property whose value is not a promise (or "thenable"). If the argument   |
# |          |                | value is used in the typical manner, then if it is a rejected promise, a promise      |
# |          |                | rejected with the same reason should be returned; if it is a fulfilled promise, then  |
# |          |                | its fulfillment value should be used as the value property of the returned promise's  |
# |          |                | IteratorResult object fulfillment value. However, these requirements are also not     |
# |          |                | enforced.                                                                             |
# +----------+----------------+---------------------------------------------------------------------------------------+
# | throw    | A function     | The returned promise, when fulfilled, must fulfill with an object which conforms to   |
# |          | that returns a | the IteratorResult interface. Invoking this method notifies the AsyncIterator object  |
# |          | promise for an | that the caller has detected an error condition. The argument may be used to identify |
# |          | IteratorResult | the error condition and typically will be an exception object. A typical response is  |
# |          | object.        | to return a rejected promise which rejects with the value passed as the argument.     |
# |          |                |                                                                                       |
# |          |                | If the returned promise is fulfilled, the IteratorResult fulfillment value will       |
# |          |                | typically have a done property whose value is true. Additionally, it should have a    |
# |          |                | value property whose value is not a promise (or "thenable"), but this requirement is  |
# |          |                | not enforced.                                                                         |
# +----------+----------------+---------------------------------------------------------------------------------------+
# NOTE 2
# Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language
# features including for-await-of and yield* call these methods after performing an existence check.
#
# 25.1.1.5 The IteratorResult Interface
#
# The IteratorResult interface includes the properties listed in Table 69:
#
# Table 69: IteratorResult Interface Properties
# +----------+----------------+---------------------------------------------------------------------------------------+
# | Property | Value          | Requirements                                                                          |
# +----------+----------------+---------------------------------------------------------------------------------------+
# | done     | Either true or | This is the result status of an iterator next method call. If the end of the iterator |
# |          | false.         | was reached done is true. If the end was not reached done is false and a value is     |
# |          |                | available. If a done property (either own or inherited) does not exist, it is         |
# |          |                | consider to have the value false.                                                     |
# +----------+----------------+---------------------------------------------------------------------------------------+
# | value    | Any ECMAScript | If done is false, this is the current iteration element value. If done is true, this  |
# |          | language       | is the return value of the iterator, if it supplied one. If the iterator does not     |
# |          | value.         | have a return value, value is undefined. In that case, the value property may be      |
# |          |                | absent from the conforming object if it does not inherit an explicit value property.  |
# +----------+----------------+---------------------------------------------------------------------------------------+

# 25.1.2 The %IteratorPrototype% Object
# The %IteratorPrototype% object:
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
#   * is an ordinary object.
def CreateIteratorPrototype(realm):
    proto = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    func_obj = CreateBuiltinFunction(IteratorPrototype_iterator, [], realm)
    DefinePropertyOrThrow(
        func_obj, "length", PropertyDescriptor(value=0, writable=False, enumerable=False, configurable=True)
    )
    DefinePropertyOrThrow(
        func_obj,
        "name",
        PropertyDescriptor(value="[Symbol.iterator]", writable=False, enumerable=False, configurable=False),
    )
    CreateMethodPropertyOrThrow(proto, wks_iterator, func_obj)
    return proto


# 25.1.2.1 %IteratorPrototype% [ @@iterator ] ( )
def IteratorPrototype_iterator(this_value, new_target):
    return this_value


# 25.1.4 Async-from-Sync Iterator Objects
# 25.1.4.1 CreateAsyncFromSyncIterator ( syncIteratorRecord )
def CreateAsyncFromSyncIterator(syncIteratorRecord):
    raise NotImplementedError("Async not yet supported")


###############################################################################################################################################################################################################################################################
#
#  .d8888b.  888888888       .d8888b.       .d8888b.                                              888                     8888888888                            888    d8b                        .d88888b.  888         d8b                   888
# d88P  Y88b 888            d88P  Y88b     d88P  Y88b                                             888                     888                                   888    Y8P                       d88P" "Y88b 888         Y8P                   888
#        888 888                   888     888    888                                             888                     888                                   888                              888     888 888                               888
#      .d88P 8888888b.           .d88P     888         .d88b.  88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888 8888888    888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.      888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  .od888P"       "Y88b      .od888P"      888  88888 d8P  Y8b 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"   888        888  888 888 "88b d88P"    888    888 d88""88b 888 "88b     888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# d88P"             888     d88P"          888    888 88888888 888  888 88888888 888     .d888888 888    888  888 888     888        888  888 888  888 888      888    888 888  888 888  888     888     888 888  888    888 88888888 888      888    "Y8888b.
# 888"       Y88b  d88P d8b 888"           Y88b  d88P Y8b.     888  888 Y8b.     888     888  888 Y88b.  Y88..88P 888     888        Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888     Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888888888   "Y8888P"  Y8P 888888888       "Y8888P88  "Y8888  888  888  "Y8888  888     "Y888888  "Y888  "Y88P"  888     888         "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888      "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                                                                                                                                        888
#                                                                                                                                                                                                                       d88P
#
###############################################################################################################################################################################################################################################################                                                                                                                                                                                                                    888P"
# 25.2 GeneratorFunction Objects
#
# GeneratorFunction objects are functions that are usually created by evaluating GeneratorDeclarations,
# GeneratorExpressions, and GeneratorMethods. They may also be created by calling the %GeneratorFunction% intrinsic.

# 25.2.1 The GeneratorFunction Constructor
# The GeneratorFunction constructor:
#
# * is the intrinsic object %GeneratorFunction%.
# * creates and initializes a new GeneratorFunction object when called as a function rather than as a constructor. Thus
#   the function call GeneratorFunction (…) is equivalent to the object creation expression new GeneratorFunction (…)
#   with the same arguments.
# * is designed to be subclassable. It may be used as the value of an extends clause of a class definition. Subclass
#   constructors that intend to inherit the specified GeneratorFunction behaviour must include a super call to the
#   GeneratorFunction constructor to create and initialize subclass instances with the internal slots necessary for
#   built-in GeneratorFunction behaviour. All ECMAScript syntactic forms for defining generator function objects create
#   direct instances of GeneratorFunction. There is no syntactic means to create instances of GeneratorFunction
#   subclasses.

# 25.2.1.1 GeneratorFunction ( p1, p2, … , pn, body )
def GeneratorFunctionFunction(this_value, new_target, *args):
    # The last argument specifies the body (executable code) of a generator function; any preceding arguments specify
    # formal parameters.
    #
    # When the GeneratorFunction function is called with some arguments p1, p2, … , pn, body (where n might be 0, that
    # is, there are no “p” arguments, and where body might also not be provided), the following steps are taken:
    #
    #   1. Let C be the active function object.
    #   2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
    #   3. Return ? CreateDynamicFunction(C, NewTarget, "generator", args).
    return CreateDynamicFunction(this_value, new_target, "generator", args)
    # NOTE
    # See NOTE for 19.2.1.1.


# 25.2.2 Properties of the GeneratorFunction Constructor
# The GeneratorFunction constructor:
#
# * is a standard built-in function object that inherits from the Function constructor.
# * has a [[Prototype]] internal slot whose value is the intrinsic object %Function%.
# * has a name property whose value is "GeneratorFunction".
# * has the following properties:

# 25.2.2.1 GeneratorFunction.length
# This is a data property with a value of 1. This property has the attributes { [[Writable]]: false,
# [[Enumerable]]: false, [[Configurable]]: true }.
def CreateGeneratorFunctionConstructor(realm):
    obj = CreateBuiltinFunction(GeneratorFunctionFunction, ["Construct"], realm=realm)
    for key, value in (("length", 1), ("name", "GeneratorFunction")):
        desc = PropertyDescriptor(value=value, writable=False, enumerable=False, configurable=True)
        DefinePropertyOrThrow(obj, key, desc)
    return obj


# 25.2.3 Properties of the GeneratorFunction Prototype Object
# The GeneratorFunction prototype object:
#
# * is an ordinary object.
# * is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots
#   listed in Table 27 or Table 68.
# * is the value of the prototype property of the intrinsic object %GeneratorFunction%.
# * is the intrinsic object %Generator% (see Figure 2).
# * has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%.
def CreateGeneratorFunctionPrototype(realm):
    obj = ObjectCreate(realm.intrinsics["%FunctionPrototype%"], [])
    DefinePropertyOrThrow(
        obj,
        wks_to_string_tag,
        PropertyDescriptor(value="GeneratorFunction", writable=False, enumerable=False, configurable=True),
    )
    return obj


############################################################################################################################################################################################
#
#  .d8888b.  888888888          d8888       .d8888b.                                              888                          .d88888b.  888         d8b                   888
# d88P  Y88b 888               d8P888      d88P  Y88b                                             888                         d88P" "Y88b 888         Y8P                   888
#        888 888              d8P 888      888    888                                             888                         888     888 888                               888
#      .d88P 8888888b.       d8P  888      888         .d88b.  88888b.   .d88b.  888d888  8888b.  888888  .d88b.  888d888     888     888 88888b.    8888  .d88b.   .d8888b 888888 .d8888b
#  .od888P"       "Y88b     d88   888      888  88888 d8P  Y8b 888 "88b d8P  Y8b 888P"       "88b 888    d88""88b 888P"       888     888 888 "88b   "888 d8P  Y8b d88P"    888    88K
# d88P"             888     8888888888     888    888 88888888 888  888 88888888 888     .d888888 888    888  888 888         888     888 888  888    888 88888888 888      888    "Y8888b.
# 888"       Y88b  d88P d8b       888      Y88b  d88P Y8b.     888  888 Y8b.     888     888  888 Y88b.  Y88..88P 888         Y88b. .d88P 888 d88P    888 Y8b.     Y88b.    Y88b.       X88
# 888888888   "Y8888P"  Y8P       888       "Y8888P88  "Y8888  888  888  "Y8888  888     "Y888888  "Y888  "Y88P"  888          "Y88888P"  88888P"     888  "Y8888   "Y8888P  "Y888  88888P'
#                                                                                                                                                     888
#                                                                                                                                                    d88P
#                                                                                                                                                  888P"
#
############################################################################################################################################################################################
# 25.4 Generator Objects
# A Generator object is an instance of a generator function and conforms to both the Iterator and Iterable interfaces.
#
# Generator instances directly inherit properties from the object that is the value of the prototype property of the
# Generator function that created the instance. Generator instances indirectly inherit properties from the Generator
# Prototype intrinsic, %GeneratorPrototype%.

# 25.4.1 Properties of the Generator Prototype Object
# The Generator prototype object:
#
# * is the intrinsic object %GeneratorPrototype%.
# * is the initial value of the prototype property of the intrinsic object %Generator% (the
#   GeneratorFunction.prototype).
# * is an ordinary object.
# * is not a Generator instance and does not have a [[GeneratorState]] internal slot.
# * has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.
# * has properties that are indirectly inherited by all Generator instances.


def CreateGeneratorPrototype(realm):
    obj = ObjectCreate(realm.intrinsics["%IteratorPrototype%"])
    BindBuiltinFunctions(
        realm,
        obj,
        [
            ("next", GeneratorPrototype_next, 1),
            ("return", GeneratorPrototype_return, 1),
            ("throw", GeneratorPrototype_throw, 1),
        ],
    )
    DefinePropertyOrThrow(
        obj,
        wks_to_string_tag,
        PropertyDescriptor(value="Generator", writable=False, enumerable=False, configurable=True),
    )

    return obj


# 25.4.1.2 Generator.prototype.next ( value )
def GeneratorPrototype_next(this_value, new_target, value=None, *_):
    # The next method performs the following steps:
    #
    #   1. Let g be the this value.
    #   2. Return ? GeneratorResume(g, value).
    return GeneratorResume(this_value, value)


# 25.4.1.3 Generator.prototype.return ( value )
def GeneratorPrototype_return(this_value, new_target, value=None, *_):
    # The return method performs the following steps:
    #
    #   1. Let g be the this value.
    #   2. Let C be Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
    #   3. Return ? GeneratorResumeAbrupt(g, C).
    return GeneratorResumeAbrupt(this_value, Completion(CompletionType.RETURN, value, EMPTY))


# 25.4.1.4 Generator.prototype.throw ( exception )
def GeneratorPrototype_throw(this_value, new_target, exception=None, *_):
    # The throw method performs the following steps:
    #
    #   1. Let g be the this value.
    #   2. Let C be ThrowCompletion(exception).
    #   3. Return ? GeneratorResumeAbrupt(g, C).
    return GeneratorResumeAbrupt(this_value, Completion(CompletionType.THROW, exception, EMPTY))


def GeneratorFixups(realm):
    generator_prototype = realm.intrinsics["%GeneratorPrototype%"]
    generator = realm.intrinsics["%Generator%"]
    generator_function = realm.intrinsics["%GeneratorFunction%"]
    DefinePropertyOrThrow(
        generator_prototype,
        "constructor",
        PropertyDescriptor(value=generator, writable=False, enumerable=False, configurable=True),
    )
    DefinePropertyOrThrow(
        generator,
        "prototype",
        PropertyDescriptor(value=generator_prototype, writable=False, enumerable=False, configurable=True),
    )
    DefinePropertyOrThrow(
        generator,
        "constructor",
        PropertyDescriptor(value=generator_function, writable=False, enumerable=False, configurable=True),
    )
    DefinePropertyOrThrow(
        generator_function,
        "prototype",
        PropertyDescriptor(value=generator, writable=False, enumerable=False, configurable=True),
    )


# 25.4.3 Generator Abstract Operations
# 25.4.3.1 GeneratorStart ( generator, generatorBody )
def GeneratorStart(generator, generatorBody):
    raise NotImplementedError("Generators don't work.")
    # The abstract operation GeneratorStart with arguments generator and generatorBody performs the following steps:
    #
    #   1. Assert: The value of generator.[[GeneratorState]] is undefined.
    #   2. Let genContext be the running execution context.
    #   3. Set the Generator component of genContext to generator.
    #   4. Set the code evaluation state of genContext such that when evaluation is resumed for that execution context
    #      the following steps will be performed:
    #       a. Let result be the result of evaluating generatorBody.
    #       b. Assert: If we return here, the generator either threw an exception or performed either an implicit or
    #          explicit return.
    #       c. Remove genContext from the execution context stack and restore the execution context that is at the top
    #          of the execution context stack as the running execution context.
    #       d. Set generator.[[GeneratorState]] to "completed".
    #       e. Once a generator enters the "completed" state it never leaves it and its associated execution context is
    #          never resumed. Any execution state associated with generator can be discarded at this point.
    #       f. If result.[[Type]] is normal, let resultValue be undefined.
    #       g. Else if result.[[Type]] is return, let resultValue be result.[[Value]].
    #       h. Else,
    #           i. Assert: result.[[Type]] is throw.
    #           ii. Return Completion(result).
    #       i. Return CreateIterResultObject(resultValue, true).
    #   5. Set generator.[[GeneratorContext]] to genContext.
    #   6. Set generator.[[GeneratorState]] to "suspendedStart".
    #   7. Return NormalCompletion(undefined).

    # assert generator.GeneratorState is None
    # genContext = surrounding_agent.running_ec
    # genContext.generator = generator

    # def generator_resumption(*_):
    #     yield None
    #     try:
    #         yield from generatorBody.evaluate()
    #         resultValue = None
    #     except ESAbrupt as abrupt:
    #         resultValue = abrupt.completion.value
    #         assert abrupt.completion.ctype == CompletionType.RETURN
    #     finally:
    #         surrounding_agent.ec_stack.pop()
    #         surrounding_agent.running_ec = surrounding_agent.ec_stack[-1]
    #         surrounding_agent.running_ec.resume()
    #         generator.GeneratorState = "completed"
    #     return CreateIterResultObject(resultValue, True)

    # genContext.coroutine = generator_resumption()  # Make a co-routine
    # next(genContext.coroutine)  # prime the co-routine
    # generator.GeneratorContext = genContext
    # generator.GeneratorState = "suspendedStart"


# 25.4.3.2 GeneratorValidate ( generator )
def GeneratorValidate(generator):
    # The abstract operation GeneratorValidate with argument generator performs the following steps:
    #
    #   1. If Type(generator) is not Object, throw a TypeError exception.
    #   2. If generator does not have a [[GeneratorState]] internal slot, throw a TypeError exception.
    #   3. Assert: generator also has a [[GeneratorContext]] internal slot.
    #   4. Let state be generator.[[GeneratorState]].
    #   5. If state is "executing", throw a TypeError exception.
    #   6. Return state.
    if not isObject(generator) or not hasattr(generator, "GeneratorState"):
        raise ESTypeError(f"Not a generator object: {ToString(generator)}")
    assert hasattr(generator, "GeneratorContext")
    state = generator.GeneratorState
    if state == "executing":
        raise ESTypeError("GeneratorValidate called on executing Generator")
    return state


# 25.4.3.3 GeneratorResume ( generator, value )
def GeneratorResume(generator, value):
    # The abstract operation GeneratorResume with arguments generator and value performs the following steps:
    #
    #   1. Let state be ? GeneratorValidate(generator).
    #   2. If state is "completed", return CreateIterResultObject(undefined, true).
    #   3. Assert: state is either "suspendedStart" or "suspendedYield".
    #   4. Let genContext be generator.[[GeneratorContext]].
    #   5. Let methodContext be the running execution context.
    #   6. Suspend methodContext.
    #   7. Set generator.[[GeneratorState]] to "executing".
    #   8. Push genContext onto the execution context stack; genContext is now the running execution context.
    #   9. Resume the suspended evaluation of genContext using NormalCompletion(value) as the result of the operation
    #      that suspended it. Let result be the value returned by the resumed computation.
    #   10. Assert: When we return here, genContext has already been removed from the execution context stack and
    #       methodContext is the currently running execution context.
    #   11. Return Completion(result).
    state = GeneratorValidate(generator)
    if state == "completed":
        return CreateIterResultObject(None, True)
    assert state in ("suspendedStart", "suspendedYield")
    genContext = generator.GeneratorContext
    methodContext = surrounding_agent.running_ec
    methodContext.suspend()
    generator.GeneratorState = "executing"
    surrounding_agent.ec_stack.append(genContext)
    surrounding_agent.running_ec = surrounding_agent.ec_stack[-1]
    surrounding_agent.running_ec.resume()
    result = genContext.coroutine.send(value)

    assert surrounding_agent.running_ec == methodContext
    return result


# 25.4.3.4 GeneratorResumeAbrupt ( generator, abruptCompletion )
def GeneratorResumeAbrupt(generator, abruptCompletion):
    # The abstract operation GeneratorResumeAbrupt with arguments generator and abruptCompletion performs the following
    # steps:
    #
    #   1. Let state be ? GeneratorValidate(generator).
    #   2. If state is "suspendedStart", then
    #       a. Set generator.[[GeneratorState]] to "completed".
    #       b. Once a generator enters the "completed" state it never leaves it and its associated execution context is
    #          never resumed. Any execution state associated with generator can be discarded at this point.
    #       c. Set state to "completed".
    #   3. If state is "completed", then
    #       a. If abruptCompletion.[[Type]] is return, then
    #           i. Return CreateIterResultObject(abruptCompletion.[[Value]], true).
    #       b. Return Completion(abruptCompletion).
    #   4. Assert: state is "suspendedYield".
    #   5. Let genContext be generator.[[GeneratorContext]].
    #   6. Let methodContext be the running execution context.
    #   7. Suspend methodContext.
    #   8. Set generator.[[GeneratorState]] to "executing".
    #   9. Push genContext onto the execution context stack; genContext is now the running execution context.
    #   10. Resume the suspended evaluation of genContext using abruptCompletion as the result of the operation that
    #       suspended it. Let result be the completion record returned by the resumed computation.
    #   11. Assert: When we return here, genContext has already been removed from the execution context stack and
    #       methodContext is the currently running execution context.
    #   12. Return Completion(result).
    state = GeneratorValidate(generator)
    if state == "suspendedStart":
        generator.GeneratorState = "completed"
        state = "completed"
    if state == "completed":
        if abruptCompletion.ctype == CompletionType.RETURN:
            return CreateIterResultObject(abruptCompletion.value, True)
        assert abruptCompletion.ctype == CompletionType.THROW
        raise ESError(abruptCompletion.value)
    assert state == "suspendedYield"
    genContext = generator.GeneratorContext
    methodContext = surrounding_agent.running_ec
    methodContext.suspend()
    generator.GeneratorState = "executing"
    surrounding_agent.ec_stack.append(genContext)
    surrounding_agent.running_ec = surrounding_agent.ec_stack[-1]
    surrounding_agent.running_ec.resume()
    result = genContext.coroutine.send(abruptCompletion)
    assert surrounding_agent.running_ec == methodContext
    return result


# 25.4.3.5 GetGeneratorKind ( )
def GetGeneratorKind():
    #   1. Let genContext be the running execution context.
    #   2. If genContext does not have a Generator component, return non-generator.
    #   3. Let generator be the Generator component of genContext.
    #   4. If generator has an [[AsyncGeneratorState]] internal slot, return async.
    #   5. Else, return sync.
    genContext = surrounding_agent.running_ec
    if genContext.generator:
        return ASYNC if hasattr(genContext.generator, "AsyncGeneratorState") else SYNC
    return NON_GENERATOR


# 25.4.3.6 GeneratorYield ( iterNextObj )
def GeneratorYield(iterNextObj):
    # The abstract operation GeneratorYield with argument iterNextObj performs the following steps:
    #
    #   1. Assert: iterNextObj is an Object that implements the IteratorResult interface.
    #   2. Let genContext be the running execution context.
    #   3. Assert: genContext is the execution context of a generator.
    #   4. Let generator be the value of the Generator component of genContext.
    #   5. Assert: GetGeneratorKind() is sync.
    #   6. Set generator.[[GeneratorState]] to "suspendedYield".
    #   7. Remove genContext from the execution context stack and restore the execution context that is at the top of
    #      the execution context stack as the running execution context.
    #   8. Set the code evaluation state of genContext such that when evaluation is resumed with a Completion
    #      resumptionValue the following steps will be performed:
    #       a. Return resumptionValue.
    #       b. NOTE: This returns to the evaluation of the YieldExpression that originally called this abstract
    #          operation.
    #   9. Return NormalCompletion(iterNextObj).
    #   10. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of
    #       genContext.
    genContext = surrounding_agent.running_ec
    generator = genContext.generator
    assert GetGeneratorKind() == SYNC
    generator.GeneratorState = "suspendedYield"
    surrounding_agent.ec_stack.pop()
    surrounding_agent.running_ec = surrounding_agent.ec_stack[-1]
    surrounding_agent.running_ec.resume()
    resumptionValue = yield iterNextObj
    return resumptionValue


# 25.5 AsyncGenerator Objects
# 25.5.3 AsyncGenerator Abstract Operations
# 25.5.3.7 AsyncGeneratorYield ( value )
def AsyncGeneratorYield(value):
    raise NotImplementedError("Async not implmemented")


# 26 Reflection
# 26.1 The Reflect Object

# The Reflect object:
#
#   * is the intrinsic object %Reflect%.
#   * is the initial value of the Reflect property of the global object.
#   * is an ordinary object.
#   * has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%.
#   * is not a function object.
#   * does not have a [[Construct]] internal method; it cannot be used as a constructor with the new operator.
#   * does not have a [[Call]] internal method; it cannot be invoked as a function.
def CreateReflectObject(realm):
    obj = ObjectCreate(realm.intrinsics["%ObjectPrototype%"])
    BindBuiltinFunctions(
        realm,
        obj,
        (
            ("apply", Reflect_apply, 3),
            ("construct", Reflect_construct, 2),
            ("defineProperty", Reflect_defineProperty, 3),
            ("deleteProperty", Reflect_deleteProperty, 2),
            ("get", Reflect_get, 2),
            ("getOwnPropertyDescriptor", Reflect_getOwnPropertyDescriptor, 2),
            ("getPrototypeOf", Reflect_getPrototypeOf, 1),
            ("has", Reflect_has, 2),
            ("isExtensible", Reflect_isExtensible, 1),
            ("ownKeys", Reflect_ownKeys, 1),
            ("preventExtensions", Reflect_preventExtensions, 1),
            ("set", Reflect_set, 3),
            ("setPrototypeOf", Reflect_setPrototypeOf, 2),
        ),
    )
    return obj


# 26.1.1 Reflect.apply ( target, thisArgument, argumentsList )
def Reflect_apply(this_value, new_target, target=None, thisArgument=None, argumentsList=None, *_):
    # When the apply function is called with arguments target, thisArgument, and argumentsList, the following steps are
    # taken:
    #   1. If IsCallable(target) is false, throw a TypeError exception.
    #   2. Let args be ? CreateListFromArrayLike(argumentsList).
    #   3. Perform PrepareForTailCall().
    #   4. Return ? Call(target, thisArgument, args).
    if not IsCallable(target):
        raise ESTypeError("Reflect.apply was called on a non-callable")
    args = CreateListFromArrayLike(argumentsList)
    PrepareForTailCall()
    return Call(target, thisArgument, args)


# 26.1.2 Reflect.construct ( target, argumentsList [ , newTarget ] )
def Reflect_construct(this_value, new_target, target=None, argumentsList=None, newTarget=EMPTY, *_):
    # When the construct function is called with arguments target, argumentsList, and newTarget, the following steps
    # are taken:
    #   1. If IsConstructor(target) is false, throw a TypeError exception.
    #   2. If newTarget is not present, set newTarget to target.
    #   3. Else if IsConstructor(newTarget) is false, throw a TypeError exception.
    #   4. Let args be ? CreateListFromArrayLike(argumentsList).
    #   5. Return ? Construct(target, args, newTarget).
    if not IsConstructor(target):
        raise ESTypeError("Reflect.construct was called on a non-constructor")
    if newTarget == EMPTY:
        newTarget = target
    elif not IsConstructor(newTarget):
        raise ESTypeError("newTarget was not a constructor in Reflect.construct")
    args = CreateListFromArrayLike(argumentsList)
    return Construct(target, args, newTarget)


Reflect_construct.length = 2
Reflect_construct.name = "construct"

# 26.1.3 Reflect.defineProperty ( target, propertyKey, attributes )
def Reflect_defineProperty(this_value, new_target, target=None, propertyKey=None, attributes=None, *_):
    # When the defineProperty function is called with arguments target, propertyKey, and attributes, the following
    # steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let key be ? ToPropertyKey(propertyKey).
    #   3. Let desc be ? ToPropertyDescriptor(attributes).
    #   4. Return ? target.[[DefineOwnProperty]](key, desc).
    if not isObject(target):
        raise ESTypeError("Reflect.defineProperty called with non-object target")
    key = ToPropertyKey(propertyKey)
    desc = ToPropertyDescriptor(attributes)
    return target.DefineOwnProperty(key, desc)


# 26.1.4 Reflect.deleteProperty ( target, propertyKey )
def Reflect_deleteProperty(this_value, new_target, target=None, propertyKey=None, *_):
    # When the deleteProperty function is called with arguments target and propertyKey, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let key be ? ToPropertyKey(propertyKey).
    #   3. Return ? target.[[Delete]](key).
    if not isObject(target):
        raise ESTypeError("Refect.deleteProperty called with non-object target")
    key = ToPropertyKey(propertyKey)
    return target.Delete(key)


# 26.1.5 Reflect.get ( target, propertyKey [ , receiver ] )
def Reflect_get(this_value, new_target, target=None, propertyKey=None, receiver=EMPTY, *_):
    # When the get function is called with arguments target, propertyKey, and receiver, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let key be ? ToPropertyKey(propertyKey).
    #   3. If receiver is not present, then
    #       a. Set receiver to target.
    #   4. Return ? target.[[Get]](key, receiver).
    if not isObject(target):
        raise ESTypeError("Reflect.get called with non-object target")
    key = ToPropertyKey(propertyKey)
    if receiver == EMPTY:
        receiver = target
    return target.Get(key, receiver)


Reflect_get.length = 2
Reflect_get.name = "get"

# 26.1.6 Reflect.getOwnPropertyDescriptor ( target, propertyKey )
def Reflect_getOwnPropertyDescriptor(this_value, new_target, target=None, propertyKey=None, *_):
    # When the getOwnPropertyDescriptor function is called with arguments target and propertyKey, the following steps
    # are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let key be ? ToPropertyKey(propertyKey).
    #   3. Let desc be ? target.[[GetOwnProperty]](key).
    #   4. Return FromPropertyDescriptor(desc).
    if not isObject(target):
        raise ESTypeError("Reflect.getOwnPropertyDescriptor called with non-object target")
    key = ToPropertyKey(propertyKey)
    desc = target.GetOwnProperty(key)
    return FromPropertyDescriptor(desc)


# 26.1.7 Reflect.getPrototypeOf ( target )
def Reflect_getPrototypeOf(this_value, new_target, target=None, *_):
    # When the getPrototypeOf function is called with argument target, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Return ? target.[[GetPrototypeOf]]().
    if not isObject(target):
        raise ESTypeError("Reflect.getPrototypeOf called with non-object target")
    return target.GetPrototypeOf()


# 26.1.8 Reflect.has ( target, propertyKey )
def Reflect_has(this_value, new_target, target=None, propertyKey=None, *_):
    # When the has function is called with arguments target and propertyKey, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let key be ? ToPropertyKey(propertyKey).
    #   3. Return ? target.[[HasProperty]](key).
    if not isObject(target):
        raise ESTypeError("Reflect.has called with non-object target")
    return target.HasProperty(ToPropertyKey(propertyKey))


# 26.1.9 Reflect.isExtensible ( target )
def Reflect_isExtensible(this_value, new_target, target=None, *_):
    # When the isExtensible function is called with argument target, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Return ? target.[[IsExtensible]]().
    if not isObject(target):
        raise ESTypeError("Reflect.isExtensible called with non-object target")
    return target.IsExtensible()


# 26.1.10 Reflect.ownKeys ( target )
def Reflect_ownKeys(this_value, new_target, target=None, *_):
    # When the ownKeys function is called with argument target, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let keys be ? target.[[OwnPropertyKeys]]().
    #   3. Return CreateArrayFromList(keys).
    if not isObject(target):
        raise ESTypeError("Reflect.ownKeys called with non-object target")
    return CreateArrayFromList(target.OwnPropertyKeys())


# 26.1.11 Reflect.preventExtensions ( target )
def Reflect_preventExtensions(this_value, new_target, target=None, *_):
    # When the preventExtensions function is called with argument target, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Return ? target.[[PreventExtensions]]().
    if not isObject(target):
        raise ESTypeError("Reflect.preventExtensions called with non-object target")
    return target.PreventExtensions()


# 26.1.12 Reflect.set ( target, propertyKey, V [ , receiver ] )
def Reflect_set(this_value, new_target, target=None, propertyKey=None, V=None, receiver=EMPTY, *_):
    # When the set function is called with arguments target, V, propertyKey, and receiver, the following steps are
    # taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. Let key be ? ToPropertyKey(propertyKey).
    #   3. If receiver is not present, then
    #       a. Set receiver to target.
    #   4. Return ? target.[[Set]](key, V, receiver).
    if not isObject(target):
        raise ESTypeError("Reflect.set called with non-object target")
    return target.Set(ToPropertyKey(propertyKey), V, receiver if receiver != EMPTY else target)


Reflect_set.length = 3
Reflect_set.name = "set"

# 26.1.13 Reflect.setPrototypeOf ( target, proto )
def Reflect_setPrototypeOf(this_value, new_target, target=None, proto=None, *_):
    # When the setPrototypeOf function is called with arguments target and proto, the following steps are taken:
    #   1. If Type(target) is not Object, throw a TypeError exception.
    #   2. If Type(proto) is not Object and proto is not null, throw a TypeError exception.
    #   3. Return ? target.[[SetPrototypeOf]](proto).
    err = lambda name: ESTypeError(f"Reflect.setPrototypeOf called with non-object {name}")
    if not isObject(target):
        raise err("target")
    if not isObject(proto) and not isNull(proto):
        raise err("proto")
    return target.SetPrototypeOf(proto)


#######################################################################################################################################################
if __name__ == "__main__":
    try:
        script_verysimple = "3/1;"
        rv = RunJobs(scripts=[script_verysimple])
    except ESError as err:
        InitializeHostDefinedRealm()
        print(err)
    else:
        InitializeHostDefinedRealm()
        print("Script returned %s" % ToString(rv))
    surrounding_agent.ec_stack.pop()
    surrounding_agent.running_ec = None

# Banners produced using font "Colossal" on https://www.messletters.com/en/big-text/
